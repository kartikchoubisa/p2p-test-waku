// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};

// node_modules/waku-tss/public/multiaddr.min.js
var require_multiaddr_min = __commonJS((exports, module) => {
  (function(root, factory) {
    typeof module === "object" && exports ? module.exports = factory() : root.MultiformatsMultiaddr = factory();
  })(typeof self !== "undefined" ? self : exports, function() {
    var MultiformatsMultiaddr = (() => {
      var dr = Object.create;
      var ae = Object.defineProperty;
      var lr = Object.getOwnPropertyDescriptor;
      var ur = Object.getOwnPropertyNames;
      var pr = Object.getPrototypeOf, hr = Object.prototype.hasOwnProperty;
      var ce = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports), b = (r, e) => {
        for (var t in e)
          ae(r, t, { get: e[t], enumerable: true });
      }, dt = (r, e, t, n) => {
        if (e && typeof e == "object" || typeof e == "function")
          for (let o of ur(e))
            !hr.call(r, o) && o !== t && ae(r, o, { get: () => e[o], enumerable: !(n = lr(e, o)) || n.enumerable });
        return r;
      };
      var Ee = (r, e, t) => (t = r != null ? dr(pr(r)) : {}, dt(e || !r || !r.__esModule ? ae(t, "default", { value: r, enumerable: true }) : t, r)), mr = (r) => dt(ae({}, "__esModule", { value: true }), r);
      var Lt = ce((us, $t) => {
        $t.exports = Xe;
        var Vt = 128, Nn = 127, Bn = ~Nn, zn = Math.pow(2, 31);
        function Xe(r, e, t) {
          if (Number.MAX_SAFE_INTEGER && r > Number.MAX_SAFE_INTEGER)
            throw Xe.bytes = 0, new RangeError("Could not encode varint");
          e = e || [], t = t || 0;
          for (var n = t;r >= zn; )
            e[t++] = r & 255 | Vt, r /= 128;
          for (;r & Bn; )
            e[t++] = r & 255 | Vt, r >>>= 7;
          return e[t] = r | 0, Xe.bytes = t - n + 1, e;
        }
      });
      var Rt = ce((ps, Dt) => {
        Dt.exports = Qe;
        var Mn = 128, Ot = 127;
        function Qe(r, n) {
          var t = 0, n = n || 0, o = 0, s = n, i, a = r.length;
          do {
            if (s >= a || o > 49)
              throw Qe.bytes = 0, new RangeError("Could not decode varint");
            i = r[s++], t += o < 28 ? (i & Ot) << o : (i & Ot) * Math.pow(2, o), o += 7;
          } while (i >= Mn);
          return Qe.bytes = s - n, t;
        }
      });
      var qt = ce((hs, jt) => {
        var kn = Math.pow(2, 7), Fn = Math.pow(2, 14), Vn = Math.pow(2, 21), $n = Math.pow(2, 28), Ln = Math.pow(2, 35), On = Math.pow(2, 42), Dn = Math.pow(2, 49), Rn = Math.pow(2, 56), jn = Math.pow(2, 63);
        jt.exports = function(r) {
          return r < kn ? 1 : r < Fn ? 2 : r < Vn ? 3 : r < $n ? 4 : r < Ln ? 5 : r < On ? 6 : r < Dn ? 7 : r < Rn ? 8 : r < jn ? 9 : 10;
        };
      });
      var be = ce((ms, Gt) => {
        Gt.exports = { encode: Lt(), decode: Rt(), encodingLength: qt() };
      });
      var uo = {};
      b(uo, { MultiaddrFilter: () => Se, fromNodeAddress: () => fo, isMultiaddr: () => ft, isName: () => lo, multiaddr: () => Ae, protocols: () => f, resolvers: () => cr });
      var fe = class {
        constructor() {
          this.index = 0;
          this.input = "";
        }
        new(e) {
          return this.index = 0, this.input = e, this;
        }
        readAtomically(e) {
          let t = this.index, n = e();
          return n === undefined && (this.index = t), n;
        }
        parseWith(e) {
          let t = e();
          if (this.index === this.input.length)
            return t;
        }
        peekChar() {
          if (!(this.index >= this.input.length))
            return this.input[this.index];
        }
        readChar() {
          if (!(this.index >= this.input.length))
            return this.input[this.index++];
        }
        readGivenChar(e) {
          return this.readAtomically(() => {
            let t = this.readChar();
            if (t === e)
              return t;
          });
        }
        readSeparator(e, t, n) {
          return this.readAtomically(() => {
            if (!(t > 0 && this.readGivenChar(e) === undefined))
              return n();
          });
        }
        readNumber(e, t, n, o) {
          return this.readAtomically(() => {
            let s = 0, i = 0, a = this.peekChar();
            if (a === undefined)
              return;
            let u = a === "0", y = 2 ** (8 * o) - 1;
            for (;; ) {
              let p = this.readAtomically(() => {
                let v = this.readChar();
                if (v === undefined)
                  return;
                let M = Number.parseInt(v, e);
                if (!Number.isNaN(M))
                  return M;
              });
              if (p === undefined)
                break;
              if (s *= e, s += p, s > y || (i += 1, t !== undefined && i > t))
                return;
            }
            if (i !== 0)
              return !n && u && i > 1 ? undefined : s;
          });
        }
        readIPv4Addr() {
          return this.readAtomically(() => {
            let e = new Uint8Array(4);
            for (let t = 0;t < e.length; t++) {
              let n = this.readSeparator(".", t, () => this.readNumber(10, 3, false, 1));
              if (n === undefined)
                return;
              e[t] = n;
            }
            return e;
          });
        }
        readIPv6Addr() {
          let e = (t) => {
            for (let n = 0;n < t.length / 2; n++) {
              let o = n * 2;
              if (n < t.length - 3) {
                let i = this.readSeparator(":", n, () => this.readIPv4Addr());
                if (i !== undefined)
                  return t[o] = i[0], t[o + 1] = i[1], t[o + 2] = i[2], t[o + 3] = i[3], [o + 4, true];
              }
              let s = this.readSeparator(":", n, () => this.readNumber(16, 4, true, 2));
              if (s === undefined)
                return [o, false];
              t[o] = s >> 8, t[o + 1] = s & 255;
            }
            return [t.length, false];
          };
          return this.readAtomically(() => {
            let t = new Uint8Array(16), [n, o] = e(t);
            if (n === 16)
              return t;
            if (o || this.readGivenChar(":") === undefined || this.readGivenChar(":") === undefined)
              return;
            let s = new Uint8Array(14), i = 16 - (n + 2), [a] = e(s.subarray(0, i));
            return t.set(s.subarray(0, a), 16 - a), t;
          });
        }
        readIPAddr() {
          return this.readIPv4Addr() ?? this.readIPv6Addr();
        }
      };
      var lt = 45, wr = 15, R = new fe;
      function de(r) {
        if (!(r.length > wr))
          return R.new(r).parseWith(() => R.readIPv4Addr());
      }
      function le(r) {
        if (!(r.length > lt))
          return R.new(r).parseWith(() => R.readIPv6Addr());
      }
      function $(r) {
        if (!(r.length > lt))
          return R.new(r).parseWith(() => R.readIPAddr());
      }
      function ut(r) {
        return !!de(r);
      }
      function pt(r) {
        return !!le(r);
      }
      function ue(r) {
        return !!$(r);
      }
      var Ue = {};
      b(Ue, { identity: () => Sr });
      function br(r, e) {
        if (r.length >= 255)
          throw new TypeError("Alphabet too long");
        for (var t = new Uint8Array(256), n = 0;n < t.length; n++)
          t[n] = 255;
        for (var o = 0;o < r.length; o++) {
          var s = r.charAt(o), i = s.charCodeAt(0);
          if (t[i] !== 255)
            throw new TypeError(s + " is ambiguous");
          t[i] = o;
        }
        var a = r.length, u = r.charAt(0), y = Math.log(a) / Math.log(256), p = Math.log(256) / Math.log(a);
        function v(c) {
          if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          if (c.length === 0)
            return "";
          for (var h = 0, V = 0, S = 0, E = c.length;S !== E && c[S] === 0; )
            S++, h++;
          for (var I = (E - S) * p + 1 >>> 0, x = new Uint8Array(I);S !== E; ) {
            for (var T = c[S], k = 0, A = I - 1;(T !== 0 || k < V) && A !== -1; A--, k++)
              T += 256 * x[A] >>> 0, x[A] = T % a >>> 0, T = T / a >>> 0;
            if (T !== 0)
              throw new Error("Non-zero carry");
            V = k, S++;
          }
          for (var U = I - V;U !== I && x[U] === 0; )
            U++;
          for (var ie = u.repeat(h);U < I; ++U)
            ie += r.charAt(x[U]);
          return ie;
        }
        function M(c) {
          if (typeof c != "string")
            throw new TypeError("Expected String");
          if (c.length === 0)
            return new Uint8Array;
          var h = 0;
          if (c[h] !== " ") {
            for (var V = 0, S = 0;c[h] === u; )
              V++, h++;
            for (var E = (c.length - h) * y + 1 >>> 0, I = new Uint8Array(E);c[h]; ) {
              var x = t[c.charCodeAt(h)];
              if (x === 255)
                return;
              for (var T = 0, k = E - 1;(x !== 0 || T < S) && k !== -1; k--, T++)
                x += a * I[k] >>> 0, I[k] = x % 256 >>> 0, x = x / 256 >>> 0;
              if (x !== 0)
                throw new Error("Non-zero carry");
              S = T, h++;
            }
            if (c[h] !== " ") {
              for (var A = E - S;A !== E && I[A] === 0; )
                A++;
              for (var U = new Uint8Array(V + (E - A)), ie = V;A !== E; )
                U[ie++] = I[A++];
              return U;
            }
          }
        }
        function g(c) {
          var h = M(c);
          if (h)
            return h;
          throw new Error(`Non-${e} character`);
        }
        return { encode: v, decodeUnsafe: M, decode: g };
      }
      var gr = br, xr = gr, ht = xr;
      var yo = new Uint8Array(0);
      var mt = (r, e) => {
        if (r === e)
          return true;
        if (r.byteLength !== e.byteLength)
          return false;
        for (let t = 0;t < r.byteLength; t++)
          if (r[t] !== e[t])
            return false;
        return true;
      }, N = (r) => {
        if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
          return r;
        if (r instanceof ArrayBuffer)
          return new Uint8Array(r);
        if (ArrayBuffer.isView(r))
          return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
        throw new Error("Unknown type, must be binary type");
      };
      var wt = (r) => new TextEncoder().encode(r), bt = (r) => new TextDecoder().decode(r);
      var Ie = class {
        constructor(e, t, n) {
          this.name = e, this.prefix = t, this.baseEncode = n;
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }, Te = class {
        constructor(e, t, n) {
          if (this.name = e, this.prefix = t, t.codePointAt(0) === undefined)
            throw new Error("Invalid prefix character");
          this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
        }
        decode(e) {
          if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length));
          } else
            throw Error("Can only multibase decode strings");
        }
        or(e) {
          return xt(this, e);
        }
      }, Pe = class {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return xt(this, e);
        }
        decode(e) {
          let t = e[0], n = this.decoders[t];
          if (n)
            return n.decode(e);
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }, xt = (r, e) => new Pe({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } }), Ce = class {
        constructor(e, t, n, o) {
          this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = o, this.encoder = new Ie(e, t, n), this.decoder = new Te(e, t, o);
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }, j = ({ name: r, prefix: e, encode: t, decode: n }) => new Ce(r, e, t, n), F = ({ prefix: r, name: e, alphabet: t }) => {
        let { encode: n, decode: o } = ht(t, e);
        return j({ prefix: r, name: e, encode: n, decode: (s) => N(o(s)) });
      }, yr = (r, e, t, n) => {
        let o = {};
        for (let p = 0;p < e.length; ++p)
          o[e[p]] = p;
        let s = r.length;
        for (;r[s - 1] === "="; )
          --s;
        let i = new Uint8Array(s * t / 8 | 0), a = 0, u = 0, y = 0;
        for (let p = 0;p < s; ++p) {
          let v = o[r[p]];
          if (v === undefined)
            throw new SyntaxError(`Non-${n} character`);
          u = u << t | v, a += t, a >= 8 && (a -= 8, i[y++] = 255 & u >> a);
        }
        if (a >= t || 255 & u << 8 - a)
          throw new SyntaxError("Unexpected end of data");
        return i;
      }, vr = (r, e, t) => {
        let n = e[e.length - 1] === "=", o = (1 << t) - 1, s = "", i = 0, a = 0;
        for (let u = 0;u < r.length; ++u)
          for (a = a << 8 | r[u], i += 8;i > t; )
            i -= t, s += e[o & a >> i];
        if (i && (s += e[o & a << t - i]), n)
          for (;s.length * t & 7; )
            s += "=";
        return s;
      }, l = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => j({ prefix: e, name: r, encode(o) {
        return vr(o, n, t);
      }, decode(o) {
        return yr(o, n, t, r);
      } });
      var Sr = j({ prefix: "\0", name: "identity", encode: (r) => bt(r), decode: (r) => wt(r) });
      var Ne = {};
      b(Ne, { base2: () => Ar });
      var Ar = l({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
      var Be = {};
      b(Be, { base8: () => Er });
      var Er = l({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
      var ze = {};
      b(ze, { base10: () => Ir });
      var Ir = F({ prefix: "9", name: "base10", alphabet: "0123456789" });
      var Me = {};
      b(Me, { base16: () => Tr, base16upper: () => Pr });
      var Tr = l({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Pr = l({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
      var ke = {};
      b(ke, { base32: () => B, base32hex: () => Br, base32hexpad: () => Mr, base32hexpadupper: () => kr, base32hexupper: () => zr, base32pad: () => Ur, base32padupper: () => Nr, base32upper: () => Cr, base32z: () => Fr });
      var B = l({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Cr = l({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Ur = l({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Nr = l({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Br = l({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), zr = l({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Mr = l({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), kr = l({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Fr = l({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
      var Fe = {};
      b(Fe, { base36: () => Vr, base36upper: () => $r });
      var Vr = F({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), $r = F({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
      var Ve = {};
      b(Ve, { base58btc: () => m, base58flickr: () => Lr });
      var m = F({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), Lr = F({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
      var $e = {};
      b($e, { base64: () => Or, base64pad: () => Dr, base64url: () => Rr, base64urlpad: () => jr });
      var Or = l({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Dr = l({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), Rr = l({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), jr = l({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
      var Le = {};
      b(Le, { base256emoji: () => Wr });
      var yt = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"), qr = yt.reduce((r, e, t) => (r[t] = e, r), []), Gr = yt.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
      function _r(r) {
        return r.reduce((e, t) => (e += qr[t], e), "");
      }
      function Jr(r) {
        let e = [];
        for (let t of r) {
          let n = Gr[t.codePointAt(0)];
          if (n === undefined)
            throw new Error(`Non-base256emoji character: ${t}`);
          e.push(n);
        }
        return new Uint8Array(e);
      }
      var Wr = j({ prefix: "\uD83D\uDE80", name: "base256emoji", encode: _r, decode: Jr });
      var je = {};
      b(je, { sha256: () => pn, sha512: () => hn });
      var Xr = At, vt = 128, Qr = 127, Hr = ~Qr, Kr = Math.pow(2, 31);
      function At(r, e, t) {
        e = e || [], t = t || 0;
        for (var n = t;r >= Kr; )
          e[t++] = r & 255 | vt, r /= 128;
        for (;r & Hr; )
          e[t++] = r & 255 | vt, r >>>= 7;
        return e[t] = r | 0, At.bytes = t - n + 1, e;
      }
      var Zr = Oe, Yr = 128, St = 127;
      function Oe(r, n) {
        var t = 0, n = n || 0, o = 0, s = n, i, a = r.length;
        do {
          if (s >= a)
            throw Oe.bytes = 0, new RangeError("Could not decode varint");
          i = r[s++], t += o < 28 ? (i & St) << o : (i & St) * Math.pow(2, o), o += 7;
        } while (i >= Yr);
        return Oe.bytes = s - n, t;
      }
      var en = Math.pow(2, 7), tn = Math.pow(2, 14), rn = Math.pow(2, 21), nn = Math.pow(2, 28), on = Math.pow(2, 35), sn = Math.pow(2, 42), an = Math.pow(2, 49), cn = Math.pow(2, 56), fn = Math.pow(2, 63), dn = function(r) {
        return r < en ? 1 : r < tn ? 2 : r < rn ? 3 : r < nn ? 4 : r < on ? 5 : r < sn ? 6 : r < an ? 7 : r < cn ? 8 : r < fn ? 9 : 10;
      }, ln = { encode: Xr, decode: Zr, encodingLength: dn }, un = ln, K = un;
      var Z = (r, e = 0) => [K.decode(r, e), K.decode.bytes], q = (r, e, t = 0) => (K.encode(r, e, t), e), G = (r) => K.encodingLength(r);
      var L = (r, e) => {
        let t = e.byteLength, n = G(r), o = n + G(t), s = new Uint8Array(o + t);
        return q(r, s, 0), q(t, s, n), s.set(e, o), new _(r, t, e, s);
      }, he = (r) => {
        let e = N(r), [t, n] = Z(e), [o, s] = Z(e.subarray(n)), i = e.subarray(n + s);
        if (i.byteLength !== o)
          throw new Error("Incorrect length");
        return new _(t, o, i, e);
      }, Et = (r, e) => {
        if (r === e)
          return true;
        {
          let t = e;
          return r.code === t.code && r.size === t.size && t.bytes instanceof Uint8Array && mt(r.bytes, t.bytes);
        }
      }, _ = class {
        constructor(e, t, n, o) {
          this.code = e, this.size = t, this.digest = n, this.bytes = o;
        }
      };
      var Re = ({ name: r, code: e, encode: t }) => new De(r, e, t), De = class {
        constructor(e, t, n) {
          this.name = e, this.code = t, this.encode = n;
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array ? L(this.code, t) : t.then((n) => L(this.code, n));
          } else
            throw Error("Unknown type, must be binary type");
        }
      };
      var Tt = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e)), pn = Re({ name: "sha2-256", code: 18, encode: Tt("SHA-256") }), hn = Re({ name: "sha2-512", code: 19, encode: Tt("SHA-512") });
      var qe = {};
      b(qe, { identity: () => bn });
      var Pt = 0, mn = "identity", Ct = N, wn = (r) => L(Pt, Ct(r)), bn = { code: Pt, name: mn, encode: Ct, digest: wn };
      var Ro = new TextEncoder, jo = new TextDecoder;
      var Ut = (r, e) => {
        let { bytes: t, version: n } = r;
        switch (n) {
          case 0:
            return vn(t, Ge(r), e || m.encoder);
          default:
            return Sn(t, Ge(r), e || B.encoder);
        }
      };
      var Nt = new WeakMap, Ge = (r) => {
        let e = Nt.get(r);
        if (e == null) {
          let t = new Map;
          return Nt.set(r, t), t;
        }
        return e;
      }, d = class {
        constructor(e, t, n, o) {
          this.code = t, this.version = e, this.multihash = n, this.bytes = o, this["/"] = o;
        }
        get asCID() {
          return this;
        }
        get byteOffset() {
          return this.bytes.byteOffset;
        }
        get byteLength() {
          return this.bytes.byteLength;
        }
        toV0() {
          switch (this.version) {
            case 0:
              return this;
            case 1: {
              let { code: e, multihash: t } = this;
              if (e !== Y)
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              if (t.code !== An)
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              return d.createV0(t);
            }
            default:
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              let { code: e, digest: t } = this.multihash, n = L(e, t);
              return d.createV1(this.code, n);
            }
            case 1:
              return this;
            default:
              throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
          }
        }
        equals(e) {
          return d.equals(this, e);
        }
        static equals(e, t) {
          let n = t;
          return n && e.code === n.code && e.version === n.version && Et(e.multihash, n.multihash);
        }
        toString(e) {
          return Ut(this, e);
        }
        toJSON() {
          return { "/": Ut(this) };
        }
        link() {
          return this;
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return `CID(${this.toString()})`;
        }
        static asCID(e) {
          if (e == null)
            return null;
          let t = e;
          if (t instanceof d)
            return t;
          if (t["/"] != null && t["/"] === t.bytes || t.asCID === t) {
            let { version: n, code: o, multihash: s, bytes: i } = t;
            return new d(n, o, s, i || Bt(n, o, s.bytes));
          } else if (t[En] === true) {
            let { version: n, multihash: o, code: s } = t, i = he(o);
            return d.create(n, s, i);
          } else
            return null;
        }
        static create(e, t, n) {
          if (typeof t != "number")
            throw new Error("String codecs are no longer supported");
          if (!(n.bytes instanceof Uint8Array))
            throw new Error("Invalid digest");
          switch (e) {
            case 0: {
              if (t !== Y)
                throw new Error(`Version 0 CID must use dag-pb (code: ${Y}) block encoding`);
              return new d(e, t, n, n.bytes);
            }
            case 1: {
              let o = Bt(e, t, n.bytes);
              return new d(e, t, n, o);
            }
            default:
              throw new Error("Invalid version");
          }
        }
        static createV0(e) {
          return d.create(0, Y, e);
        }
        static createV1(e, t) {
          return d.create(1, e, t);
        }
        static decode(e) {
          let [t, n] = d.decodeFirst(e);
          if (n.length)
            throw new Error("Incorrect length");
          return t;
        }
        static decodeFirst(e) {
          let t = d.inspectBytes(e), n = t.size - t.multihashSize, o = N(e.subarray(n, n + t.multihashSize));
          if (o.byteLength !== t.multihashSize)
            throw new Error("Incorrect length");
          let s = o.subarray(t.multihashSize - t.digestSize), i = new _(t.multihashCode, t.digestSize, s, o);
          return [t.version === 0 ? d.createV0(i) : d.createV1(t.codec, i), e.subarray(t.size)];
        }
        static inspectBytes(e) {
          let t = 0, n = () => {
            let [v, M] = Z(e.subarray(t));
            return t += M, v;
          }, o = n(), s = Y;
          if (o === 18 ? (o = 0, t = 0) : s = n(), o !== 0 && o !== 1)
            throw new RangeError(`Invalid CID version ${o}`);
          let i = t, a = n(), u = n(), y = t + u, p = y - i;
          return { version: o, codec: s, multihashCode: a, digestSize: u, multihashSize: p, size: y };
        }
        static parse(e, t) {
          let [n, o] = yn(e, t), s = d.decode(o);
          if (s.version === 0 && e[0] !== "Q")
            throw Error("Version 0 CID string must not include multibase prefix");
          return Ge(s).set(n, e), s;
        }
      }, yn = (r, e) => {
        switch (r[0]) {
          case "Q": {
            let t = e || m;
            return [m.prefix, t.decode(`${m.prefix}${r}`)];
          }
          case m.prefix: {
            let t = e || m;
            return [m.prefix, t.decode(r)];
          }
          case B.prefix: {
            let t = e || B;
            return [B.prefix, t.decode(r)];
          }
          default: {
            if (e == null)
              throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            return [r[0], e.decode(r)];
          }
        }
      }, vn = (r, e, t) => {
        let { prefix: n } = t;
        if (n !== m.prefix)
          throw Error(`Cannot string encode V0 in ${t.name} encoding`);
        let o = e.get(n);
        if (o == null) {
          let s = t.encode(r).slice(1);
          return e.set(n, s), s;
        } else
          return o;
      }, Sn = (r, e, t) => {
        let { prefix: n } = t, o = e.get(n);
        if (o == null) {
          let s = t.encode(r);
          return e.set(n, s), s;
        } else
          return o;
      }, Y = 112, An = 18, Bt = (r, e, t) => {
        let n = G(r), o = n + G(e), s = new Uint8Array(o + t.byteLength);
        return q(r, s, 0), q(e, s, n), s.set(t, o), s;
      }, En = Symbol.for("@ipld/js-cid/CID");
      var ee = { ...Ue, ...Ne, ...Be, ...ze, ...Me, ...ke, ...Fe, ...Ve, ...$e, ...Le }, Zo = { ...je, ...qe };
      function W(r) {
        return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
      }
      function me(r = 0) {
        return globalThis.Buffer?.allocUnsafe != null ? W(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
      }
      function Mt(r, e, t, n) {
        return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: n } };
      }
      var zt = Mt("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1))), _e = Mt("ascii", "a", (r) => {
        let e = "a";
        for (let t = 0;t < r.length; t++)
          e += String.fromCharCode(r[t]);
        return e;
      }, (r) => {
        r = r.substring(1);
        let e = me(r.length);
        for (let t = 0;t < r.length; t++)
          e[t] = r.charCodeAt(t);
        return e;
      }), In = { utf8: zt, "utf-8": zt, hex: ee.base16, latin1: _e, ascii: _e, binary: _e, ...ee }, we = In;
      function w(r, e = "utf8") {
        let t = we[e];
        if (t == null)
          throw new Error(`Unsupported encoding "${e}"`);
        return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1);
      }
      var kt = ut, Tn = pt, Je = function(r) {
        let e = 0;
        if (r = r.toString().trim(), kt(r)) {
          let t = new Uint8Array(e + 4);
          return r.split(/\./g).forEach((n) => {
            t[e++] = parseInt(n, 10) & 255;
          }), t;
        }
        if (Tn(r)) {
          let t = r.split(":", 8), n;
          for (n = 0;n < t.length; n++) {
            let s = kt(t[n]), i;
            s && (i = Je(t[n]), t[n] = w(i.slice(0, 2), "base16")), i != null && ++n < 8 && t.splice(n, 0, w(i.slice(2, 4), "base16"));
          }
          if (t[0] === "")
            for (;t.length < 8; )
              t.unshift("0");
          else if (t[t.length - 1] === "")
            for (;t.length < 8; )
              t.push("0");
          else if (t.length < 8) {
            for (n = 0;n < t.length && t[n] !== ""; n++)
              ;
            let s = [n, 1];
            for (n = 9 - t.length;n > 0; n--)
              s.push("0");
            t.splice.apply(t, s);
          }
          let o = new Uint8Array(e + 16);
          for (n = 0;n < t.length; n++) {
            let s = parseInt(t[n], 16);
            o[e++] = s >> 8 & 255, o[e++] = s & 255;
          }
          return o;
        }
        throw new Error("invalid ip address");
      }, Ft = function(r, e = 0, t) {
        e = ~~e, t = t ?? r.length - e;
        let n = new DataView(r.buffer);
        if (t === 4) {
          let o = [];
          for (let s = 0;s < t; s++)
            o.push(r[e + s]);
          return o.join(".");
        }
        if (t === 16) {
          let o = [];
          for (let s = 0;s < t; s += 2)
            o.push(n.getUint16(e + s).toString(16));
          return o.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
        }
        return "";
      };
      var te = {}, We = {}, Cn = [[4, 32, "ip4"], [6, 16, "tcp"], [33, 16, "dccp"], [41, 128, "ip6"], [42, -1, "ip6zone"], [43, 8, "ipcidr"], [53, -1, "dns", true], [54, -1, "dns4", true], [55, -1, "dns6", true], [56, -1, "dnsaddr", true], [132, 16, "sctp"], [273, 16, "udp"], [275, 0, "p2p-webrtc-star"], [276, 0, "p2p-webrtc-direct"], [277, 0, "p2p-stardust"], [280, 0, "webrtc-direct"], [281, 0, "webrtc"], [290, 0, "p2p-circuit"], [301, 0, "udt"], [302, 0, "utp"], [400, -1, "unix", false, true], [421, -1, "ipfs"], [421, -1, "p2p"], [443, 0, "https"], [444, 96, "onion"], [445, 296, "onion3"], [446, -1, "garlic64"], [448, 0, "tls"], [449, -1, "sni"], [460, 0, "quic"], [461, 0, "quic-v1"], [465, 0, "webtransport"], [466, -1, "certhash"], [477, 0, "ws"], [478, 0, "wss"], [479, 0, "p2p-websocket-star"], [480, 0, "http"], [777, -1, "memory"]];
      Cn.forEach((r) => {
        let e = Un(...r);
        We[e.code] = e, te[e.name] = e;
      });
      function Un(r, e, t, n, o) {
        return { code: r, size: e, name: t, resolvable: !!n, path: !!o };
      }
      function f(r) {
        if (typeof r == "number") {
          if (We[r] != null)
            return We[r];
          throw new Error(`no protocol with code: ${r}`);
        } else if (typeof r == "string") {
          if (te[r] != null)
            return te[r];
          throw new Error(`no protocol with name: ${r}`);
        }
        throw new Error(`invalid protocol id type: ${typeof r}`);
      }
      var P = Ee(be(), 1);
      function He(r, e = "utf8") {
        let t = we[e];
        if (t == null)
          throw new Error(`Unsupported encoding "${e}"`);
        return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? W(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
      }
      function z(r, e) {
        e == null && (e = r.reduce((o, s) => o + s.length, 0));
        let t = me(e), n = 0;
        for (let o of r)
          t.set(o, n), n += o.length;
        return W(t);
      }
      function _t(r, e, t) {
        let n = 0;
        for (let o of r)
          if (!(n < e)) {
            if (n > t)
              break;
            if (o !== 255)
              return false;
            n++;
          }
        return true;
      }
      function Jt(r, e, t, n) {
        let o = 0;
        for (let s of r)
          if (!(o < t)) {
            if (o > n)
              break;
            if (s !== e[o])
              return false;
            o++;
          }
        return true;
      }
      function Ke(r) {
        switch (r.length) {
          case O:
            return r.join(".");
          case D: {
            let e = [];
            for (let t = 0;t < r.length; t++)
              t % 2 === 0 && e.push(r[t].toString(16).padStart(2, "0") + r[t + 1].toString(16).padStart(2, "0"));
            return e.join(":");
          }
          default:
            throw new Error("Invalid ip length");
        }
      }
      function Wt(r) {
        let e = 0;
        for (let [t, n] of r.entries()) {
          if (n === 255) {
            e += 8;
            continue;
          }
          for (;n & 128; )
            e++, n = n << 1;
          if (n & 128)
            return -1;
          for (let o = t + 1;o < r.length; o++)
            if (r[o] != 0)
              return -1;
          break;
        }
        return e;
      }
      function Xt(r) {
        let e = "0x";
        for (let t of r)
          e += (t >> 4).toString(16) + (t & 15).toString(16);
        return e;
      }
      var O = 4, D = 16, Ts = parseInt("0xFFFF", 16), qn = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255]);
      function re(r, e) {
        e.length === D && r.length === O && _t(e, 0, 11) && (e = e.slice(12)), e.length === O && r.length === D && Jt(r, qn, 0, 11) && (r = r.slice(12));
        let t = r.length;
        if (t != e.length)
          throw new Error("Failed to mask ip");
        let n = new Uint8Array(t);
        for (let o = 0;o < t; o++)
          n[o] = r[o] & e[o];
        return n;
      }
      function Qt(r, e) {
        if (typeof e == "string" && (e = $(e)), e == null)
          throw new Error("Invalid ip");
        if (e.length !== r.network.length)
          return false;
        for (let t = 0;t < e.length; t++)
          if ((r.network[t] & r.mask[t]) !== (e[t] & r.mask[t]))
            return false;
        return true;
      }
      function Ze(r) {
        let [e, t] = r.split("/");
        if (!e || !t)
          throw new Error("Failed to parse given CIDR: " + r);
        let n = O, o = de(e);
        if (o == null && (n = D, o = le(e), o == null))
          throw new Error("Failed to parse given CIDR: " + r);
        let s = parseInt(t, 10);
        if (Number.isNaN(s) || String(s).length !== t.length || s < 0 || s > n * 8)
          throw new Error("Failed to parse given CIDR: " + r);
        let i = Ye(s, 8 * n);
        return { network: re(o, i), mask: i };
      }
      function Ye(r, e) {
        if (e !== 8 * O && e !== 8 * D)
          throw new Error("Invalid CIDR mask");
        if (r < 0 || r > e)
          throw new Error("Invalid CIDR mask");
        let t = e / 8, n = new Uint8Array(t);
        for (let o = 0;o < t; o++) {
          if (r >= 8) {
            n[o] = 255, r -= 8;
            continue;
          }
          n[o] = 255 - (255 >> r), r = 0;
        }
        return n;
      }
      var X = class {
        constructor(e, t) {
          if (t == null)
            ({ network: this.network, mask: this.mask } = Ze(e));
          else {
            let n = $(e);
            if (n == null)
              throw new Error("Failed to parse network");
            t = String(t);
            let o = parseInt(t, 10);
            if (Number.isNaN(o) || String(o).length !== t.length || o < 0 || o > n.length * 8) {
              let s = $(t);
              if (s == null)
                throw new Error("Failed to parse mask");
              this.mask = s;
            } else
              this.mask = Ye(o, 8 * n.length);
            this.network = re(n, this.mask);
          }
        }
        contains(e) {
          return Qt({ network: this.network, mask: this.mask }, e);
        }
        toString() {
          let e = Wt(this.mask), t = e !== -1 ? String(e) : Xt(this.mask);
          return Ke(this.network) + "/" + t;
        }
      };
      var Gn = f("ip4"), _n = f("ip6"), Jn = f("ipcidr");
      function er(r, e) {
        switch (f(r).code) {
          case 4:
          case 41:
            return Xn(e);
          case 42:
            return Zt(e);
          case 6:
          case 273:
          case 33:
          case 132:
            return nr(e).toString();
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 449:
          case 777:
            return Zt(e);
          case 421:
            return Zn(e);
          case 444:
            return Yt(e);
          case 445:
            return Yt(e);
          case 466:
            return Kn(e);
          default:
            return w(e, "base16");
        }
      }
      function tr(r, e) {
        switch (f(r).code) {
          case 4:
            return Ht(e);
          case 41:
            return Ht(e);
          case 42:
            return Kt(e);
          case 6:
          case 273:
          case 33:
          case 132:
            return tt(parseInt(e, 10));
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 449:
          case 777:
            return Kt(e);
          case 421:
            return Qn(e);
          case 444:
            return Yn(e);
          case 445:
            return eo(e);
          case 466:
            return Hn(e);
          default:
            return He(e, "base16");
        }
      }
      function rr(r) {
        let e, t;
        if (r.stringTuples().forEach(([n, o]) => {
          (n === Gn.code || n === _n.code) && (t = o), n === Jn.code && (e = o);
        }), e == null || t == null)
          throw new Error("Invalid multiaddr");
        return new X(t, e);
      }
      var et = Object.values(ee).map((r) => r.decoder), Wn = function() {
        let r = et[0].or(et[1]);
        return et.slice(2).forEach((e) => r = r.or(e)), r;
      }();
      function Ht(r) {
        if (!ue(r))
          throw new Error("invalid ip address");
        return Je(r);
      }
      function Xn(r) {
        let e = Ft(r, 0, r.length);
        if (e == null)
          throw new Error("ipBuff is required");
        if (!ue(e))
          throw new Error("invalid ip address");
        return e;
      }
      function tt(r) {
        let e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, r), new Uint8Array(e);
      }
      function nr(r) {
        return new DataView(r.buffer).getUint16(r.byteOffset);
      }
      function Kt(r) {
        let e = He(r), t = Uint8Array.from(P.default.encode(e.length));
        return z([t, e], t.length + e.length);
      }
      function Zt(r) {
        let e = P.default.decode(r);
        if (r = r.slice(P.default.decode.bytes), r.length !== e)
          throw new Error("inconsistent lengths");
        return w(r);
      }
      function Qn(r) {
        let e;
        r[0] === "Q" || r[0] === "1" ? e = he(m.decode(`z${r}`)).bytes : e = d.parse(r).multihash.bytes;
        let t = Uint8Array.from(P.default.encode(e.length));
        return z([t, e], t.length + e.length);
      }
      function Hn(r) {
        let e = Wn.decode(r), t = Uint8Array.from(P.default.encode(e.length));
        return z([t, e], t.length + e.length);
      }
      function Kn(r) {
        let e = P.default.decode(r), t = r.slice(P.default.decode.bytes);
        if (t.length !== e)
          throw new Error("inconsistent lengths");
        return "u" + w(t, "base64url");
      }
      function Zn(r) {
        let e = P.default.decode(r), t = r.slice(P.default.decode.bytes);
        if (t.length !== e)
          throw new Error("inconsistent lengths");
        return w(t, "base58btc");
      }
      function Yn(r) {
        let e = r.split(":");
        if (e.length !== 2)
          throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 16)
          throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
        let t = B.decode("b" + e[0]), n = parseInt(e[1], 10);
        if (n < 1 || n > 65536)
          throw new Error("Port number is not in range(1, 65536)");
        let o = tt(n);
        return z([t, o], t.length + o.length);
      }
      function eo(r) {
        let e = r.split(":");
        if (e.length !== 2)
          throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
        if (e[0].length !== 56)
          throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
        let t = B.decode(`b${e[0]}`), n = parseInt(e[1], 10);
        if (n < 1 || n > 65536)
          throw new Error("Port number is not in range(1, 65536)");
        let o = tt(n);
        return z([t, o], t.length + o.length);
      }
      function Yt(r) {
        let e = r.slice(0, r.length - 2), t = r.slice(r.length - 2), n = w(e, "base32"), o = nr(t);
        return `${n}:${o}`;
      }
      var Q = Ee(be(), 1);
      function to(r) {
        let e = [], t = r.split("/").slice(1);
        if (t.length === 1 && t[0] === "")
          return [];
        for (let n = 0;n < t.length; n++) {
          let o = t[n], s = f(o);
          if (s.size === 0) {
            e.push([o]);
            continue;
          }
          if (n++, n >= t.length)
            throw sr("invalid address: " + r);
          if (s.path === true) {
            e.push([o, it(t.slice(n).join("/"))]);
            break;
          }
          e.push([o, t[n]]);
        }
        return e;
      }
      function ro(r) {
        let e = [];
        return r.map((t) => {
          let n = ye(t);
          return e.push(n.name), t.length > 1 && t[1] != null && e.push(t[1]), null;
        }), it(e.join("/"));
      }
      function no(r) {
        return r.map((e) => {
          Array.isArray(e) || (e = [e]);
          let t = ye(e);
          return e.length > 1 ? [t.code, tr(t.code, e[1])] : [t.code];
        });
      }
      function rt(r) {
        return r.map((e) => {
          let t = ye(e);
          return e[1] != null ? [t.code, er(t.code, e[1])] : [t.code];
        });
      }
      function nt(r) {
        return xe(z(r.map((e) => {
          let t = ye(e), n = Uint8Array.from(Q.default.encode(t.code));
          return e.length > 1 && e[1] != null && (n = z([n, e[1]])), n;
        })));
      }
      function ot(r, e) {
        return r.size > 0 ? r.size / 8 : r.size === 0 ? 0 : Q.default.decode(e) + (Q.default.decode.bytes ?? 0);
      }
      function ge(r) {
        let e = [], t = 0;
        for (;t < r.length; ) {
          let n = Q.default.decode(r, t), o = Q.default.decode.bytes ?? 0, s = f(n), i = ot(s, r.slice(t + o));
          if (i === 0) {
            e.push([n]), t += o;
            continue;
          }
          let a = r.slice(t + o, t + o + i);
          if (t += i + o, t > r.length)
            throw sr("Invalid address Uint8Array: " + w(r, "base16"));
          e.push([n, a]);
        }
        return e;
      }
      function st(r) {
        let e = ge(r), t = rt(e);
        return ro(t);
      }
      function oo(r) {
        r = it(r);
        let e = to(r), t = no(e);
        return nt(t);
      }
      function or(r) {
        return oo(r);
      }
      function xe(r) {
        let e = so(r);
        if (e != null)
          throw e;
        return Uint8Array.from(r);
      }
      function so(r) {
        try {
          ge(r);
        } catch (e) {
          return e;
        }
      }
      function it(r) {
        return "/" + r.trim().split("/").filter((e) => e).join("/");
      }
      function sr(r) {
        return new Error("Error parsing address: " + r);
      }
      function ye(r) {
        return f(r[0]);
      }
      var ct = Ee(be(), 1);
      var ve = class extends Error {
        constructor(e, t, n) {
          super(e), this.code = t, this.name = n?.name ?? "CodeError", this.props = n ?? {};
        }
      };
      function ir(r, e) {
        if (r === e)
          return true;
        if (r.byteLength !== e.byteLength)
          return false;
        for (let t = 0;t < r.byteLength; t++)
          if (r[t] !== e[t])
            return false;
        return true;
      }
      var Se = class {
        constructor(e) {
          this.multiaddr = Ae(e), this.netmask = rr(this.multiaddr);
        }
        contains(e) {
          if (e == null)
            return false;
          let t = Ae(e), n;
          for (let [o, s] of t.stringTuples())
            if (o === 4 || o === 41) {
              n = s;
              break;
            }
          return n === undefined ? false : this.netmask.contains(n);
        }
      };
      var H = function(r, e, t, n) {
        if (t === "a" && !n)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? r !== e || !n : !e.has(r))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
      }, at = function(r, e, t, n, o) {
        if (n === "m")
          throw new TypeError("Private method is not writable");
        if (n === "a" && !o)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? r !== e || !o : !e.has(r))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return n === "a" ? o.call(r, t) : o ? o.value = t : e.set(r, t), t;
      }, ne, oe, se, ar, ao = Symbol.for("nodejs.util.inspect.custom"), co = [f("dns").code, f("dns4").code, f("dns6").code, f("dnsaddr").code], cr = new Map, fr = Symbol.for("@multiformats/js-multiaddr/multiaddr");
      function fo(r, e) {
        if (r == null)
          throw new Error("requires node address object");
        if (e == null)
          throw new Error("requires transport protocol");
        let t, n = r.address;
        switch (r.family) {
          case 4:
            t = "ip4";
            break;
          case 6:
            if (t = "ip6", n.includes("%")) {
              let o = n.split("%");
              if (o.length !== 2)
                throw Error("Multiple ip6 zones in multiaddr");
              n = o[0], t = `/ip6zone/${o[1]}/ip6`;
            }
            break;
          default:
            throw Error("Invalid addr family, should be 4 or 6.");
        }
        return new C("/" + [t, n, e, r.port].join("/"));
      }
      function lo(r) {
        return ft(r) ? r.protos().some((e) => e.resolvable) : false;
      }
      function ft(r) {
        return !!r?.[fr];
      }
      var C = class {
        constructor(e) {
          if (ne.set(this, undefined), oe.set(this, undefined), se.set(this, undefined), this[ar] = true, e == null && (e = ""), e instanceof Uint8Array)
            this.bytes = xe(e);
          else if (typeof e == "string") {
            if (e.length > 0 && e.charAt(0) !== "/")
              throw new Error(`multiaddr "${e}" must start with a "/"`);
            this.bytes = or(e);
          } else if (ft(e))
            this.bytes = xe(e.bytes);
          else
            throw new Error("addr must be a string, Buffer, or another Multiaddr");
        }
        toString() {
          return H(this, ne, "f") == null && at(this, ne, st(this.bytes), "f"), H(this, ne, "f");
        }
        toJSON() {
          return this.toString();
        }
        toOptions() {
          let e, t, n, o, s = "", i = f("tcp"), a = f("udp"), u = f("ip4"), y = f("ip6"), p = f("dns6"), v = f("ip6zone");
          for (let [g, c] of this.stringTuples())
            g === v.code && (s = `%${c ?? ""}`), co.includes(g) && (t = i.name, o = 443, n = `${c ?? ""}${s}`, e = g === p.code ? 6 : 4), (g === i.code || g === a.code) && (t = f(g).name, o = parseInt(c ?? "")), (g === u.code || g === y.code) && (t = f(g).name, n = `${c ?? ""}${s}`, e = g === y.code ? 6 : 4);
          if (e == null || t == null || n == null || o == null)
            throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
          return { family: e, host: n, transport: t, port: o };
        }
        protos() {
          return this.protoCodes().map((e) => Object.assign({}, f(e)));
        }
        protoCodes() {
          let e = [], t = this.bytes, n = 0;
          for (;n < t.length; ) {
            let o = ct.default.decode(t, n), s = ct.default.decode.bytes ?? 0, i = f(o), a = ot(i, t.slice(n + s));
            n += a + s, e.push(o);
          }
          return e;
        }
        protoNames() {
          return this.protos().map((e) => e.name);
        }
        tuples() {
          return H(this, oe, "f") == null && at(this, oe, ge(this.bytes), "f"), H(this, oe, "f");
        }
        stringTuples() {
          return H(this, se, "f") == null && at(this, se, rt(this.tuples()), "f"), H(this, se, "f");
        }
        encapsulate(e) {
          return e = new C(e), new C(this.toString() + e.toString());
        }
        decapsulate(e) {
          let t = e.toString(), n = this.toString(), o = n.lastIndexOf(t);
          if (o < 0)
            throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);
          return new C(n.slice(0, o));
        }
        decapsulateCode(e) {
          let t = this.tuples();
          for (let n = t.length - 1;n >= 0; n--)
            if (t[n][0] === e)
              return new C(nt(t.slice(0, n)));
          return this;
        }
        getPeerId() {
          try {
            let t = this.stringTuples().filter((n) => n[0] === te.ipfs.code).pop();
            if (t?.[1] != null) {
              let n = t[1];
              return n[0] === "Q" || n[0] === "1" ? w(m.decode(`z${n}`), "base58btc") : w(d.parse(n).multihash.bytes, "base58btc");
            }
            return null;
          } catch {
            return null;
          }
        }
        getPath() {
          let e = null;
          try {
            e = this.stringTuples().filter((t) => f(t[0]).path === true)[0][1], e == null && (e = null);
          } catch {
            e = null;
          }
          return e;
        }
        equals(e) {
          return ir(this.bytes, e.bytes);
        }
        async resolve(e) {
          let t = this.protos().find((s) => s.resolvable);
          if (t == null)
            return [this];
          let n = cr.get(t.name);
          if (n == null)
            throw new ve(`no available resolver for ${t.name}`, "ERR_NO_AVAILABLE_RESOLVER");
          return (await n(this, e)).map((s) => new C(s));
        }
        nodeAddress() {
          let e = this.toOptions();
          if (e.transport !== "tcp" && e.transport !== "udp")
            throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
          return { family: e.family, address: e.host, port: e.port };
        }
        isThinWaistAddress(e) {
          let t = (e ?? this).protos();
          return !(t.length !== 2 || t[0].code !== 4 && t[0].code !== 41 || t[1].code !== 6 && t[1].code !== 273);
        }
        [(ne = new WeakMap, oe = new WeakMap, se = new WeakMap, ar = fr, ao)]() {
          return `Multiaddr(${st(this.bytes)})`;
        }
      };
      function Ae(r) {
        return new C(r);
      }
      return mr(uo);
    })();
    globalThis.MultiformatsMultiaddr = MultiformatsMultiaddr;
    return MultiformatsMultiaddr;
  });
});

// node_modules/waku-tss/public/wakusdk.js
var require_wakusdk = __commonJS((exports) => {
  var isPeerId = function(other) {
    return other != null && Boolean(other[symbol$5]);
  };
  var base$f = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$G = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$9) {
      out[offset++] = num & 255 | MSB$c;
      num /= 128;
    }
    while (num & MSBALL$9) {
      out[offset++] = num & 255 | MSB$c;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$G.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$a = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$a.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1$8) << shift : (b & REST$1$8) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1$8);
    read$a.bytes = counter2 - offset;
    return res;
  };
  var equals$4 = function(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0;i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };
  var base$e = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$E = function(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars$3[c];
      return p;
    }, "");
  };
  var decode$y = function(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes$3[char.codePointAt(0)];
      if (byt === undefined) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  };
  var asUint8Array = function(buf) {
    if (globalThis.Buffer != null) {
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
  };
  var alloc$1 = function(size = 0) {
    if (globalThis.Buffer?.alloc != null) {
      return asUint8Array(globalThis.Buffer.alloc(size));
    }
    return new Uint8Array(size);
  };
  var allocUnsafe$2 = function(size = 0) {
    if (globalThis.Buffer?.allocUnsafe != null) {
      return asUint8Array(globalThis.Buffer.allocUnsafe(size));
    }
    return new Uint8Array(size);
  };
  var createCodec$1 = function(name2, prefix, encode3, decode3) {
    return {
      name: name2,
      prefix,
      encoder: {
        name: name2,
        prefix,
        encode: encode3
      },
      decoder: {
        decode: decode3
      }
    };
  };
  var toString$9 = function(array, encoding = "utf8") {
    const base3 = BASES[encoding];
    if (base3 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
    }
    return base3.encoder.encode(array).substring(1);
  };
  var concat$1 = function(arrays, length2) {
    if (length2 == null) {
      length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output2 = allocUnsafe$2(length2);
    let offset = 0;
    for (const arr of arrays) {
      output2.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array(output2);
  };
  var getDefaultExportFromCjs = function(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  };
  var getAugmentedNamespace = function(n) {
    if (n.__esModule)
      return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a() {
        if (this instanceof a) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  };
  var encode$D = function(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode$D.bytes = 0;
      throw new RangeError("Could not encode varint");
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$8) {
      out[offset++] = num & 255 | MSB$b;
      num /= 128;
    }
    while (num & MSBALL$8) {
      out[offset++] = num & 255 | MSB$b;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$D.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$9 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l || shift > 49) {
        read$9.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$a) << shift : (b & REST$a) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$a);
    read$9.bytes = counter2 - offset;
    return res;
  };
  var parseIPv4 = function(input) {
    if (input.length > MAX_IPV4_LENGTH) {
      return;
    }
    return parser2.new(input).parseWith(() => parser2.readIPv4Addr());
  };
  var parseIPv6 = function(input) {
    if (input.includes("%")) {
      input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
      return;
    }
    return parser2.new(input).parseWith(() => parser2.readIPv6Addr());
  };
  var parseIP = function(input) {
    if (input.includes("%")) {
      input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
      return;
    }
    return parser2.new(input).parseWith(() => parser2.readIPAddr());
  };
  var encode$C = function(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars$2[c];
      return p;
    }, "");
  };
  var decode$w = function(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes$2[char.codePointAt(0)];
      if (byt === undefined) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  };
  var fromString$3 = function(string2, encoding = "utf8") {
    const base3 = BASES[encoding];
    if (base3 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
    }
    return base3.decoder.decode(`${base3.prefix}${string2}`);
  };
  var isIPv4 = function(input) {
    return Boolean(parseIPv4(input));
  };
  var isIPv6 = function(input) {
    return Boolean(parseIPv6(input));
  };
  var isIP = function(input) {
    return Boolean(parseIP(input));
  };
  var createProtocol$1 = function(code2, size, name2, resolvable, path) {
    return {
      code: code2,
      size,
      name: name2,
      resolvable: Boolean(resolvable),
      path: Boolean(path)
    };
  };
  var getProtocol$1 = function(proto) {
    if (typeof proto === "number") {
      if (codes$5[proto] != null) {
        return codes$5[proto];
      }
      throw new Error(`no protocol with code: ${proto}`);
    } else if (typeof proto === "string") {
      if (names$1[proto] != null) {
        return names$1[proto];
      }
      throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
  };
  var convertToString$1 = function(proto, buf) {
    const protocol = getProtocol$1(proto);
    switch (protocol.code) {
      case 4:
      case 41:
        return bytes2ip$1(buf);
      case 42:
        return bytes2str$1(buf);
      case 6:
      case 273:
      case 33:
      case 132:
        return bytes2port$1(buf).toString();
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 449:
      case 777:
        return bytes2str$1(buf);
      case 421:
        return bytes2mh$1(buf);
      case 444:
        return bytes2onion$1(buf);
      case 445:
        return bytes2onion$1(buf);
      case 466:
        return bytes2mb$1(buf);
      default:
        return toString$9(buf, "base16");
    }
  };
  var convertToBytes$1 = function(proto, str) {
    const protocol = getProtocol$1(proto);
    switch (protocol.code) {
      case 4:
        return ip2bytes$1(str);
      case 41:
        return ip2bytes$1(str);
      case 42:
        return str2bytes$1(str);
      case 6:
      case 273:
      case 33:
      case 132:
        return port2bytes$1(parseInt(str, 10));
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 449:
      case 777:
        return str2bytes$1(str);
      case 421:
        return mh2bytes$1(str);
      case 444:
        return onion2bytes$1(str);
      case 445:
        return onion32bytes$1(str);
      case 466:
        return mb2bytes$1(str);
      default:
        return fromString$3(str, "base16");
    }
  };
  var ip2bytes$1 = function(ipString) {
    if (!isIP(ipString)) {
      throw new Error("invalid ip address");
    }
    return toBytes$4(ipString);
  };
  var bytes2ip$1 = function(ipBuff) {
    const ipString = toString$8(ipBuff, 0, ipBuff.length);
    if (ipString == null) {
      throw new Error("ipBuff is required");
    }
    if (!isIP(ipString)) {
      throw new Error("invalid ip address");
    }
    return ipString;
  };
  var port2bytes$1 = function(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
  };
  var bytes2port$1 = function(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
  };
  var str2bytes$1 = function(str) {
    const buf = fromString$3(str);
    const size = Uint8Array.from(varint$9.encode(buf.length));
    return concat$1([size, buf], size.length + buf.length);
  };
  var bytes2str$1 = function(buf) {
    const size = varint$9.decode(buf);
    buf = buf.slice(varint$9.decode.bytes);
    if (buf.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return toString$9(buf);
  };
  var mh2bytes$1 = function(hash2) {
    let mh;
    if (hash2[0] === "Q" || hash2[0] === "1") {
      mh = decode$A(base58btc$d.decode(`z${hash2}`)).bytes;
    } else {
      mh = CID$2.parse(hash2).multihash.bytes;
    }
    const size = Uint8Array.from(varint$9.encode(mh.length));
    return concat$1([size, mh], size.length + mh.length);
  };
  var mb2bytes$1 = function(mbstr) {
    const mb = anybaseDecoder$1.decode(mbstr);
    const size = Uint8Array.from(varint$9.encode(mb.length));
    return concat$1([size, mb], size.length + mb.length);
  };
  var bytes2mb$1 = function(buf) {
    const size = varint$9.decode(buf);
    const hash2 = buf.slice(varint$9.decode.bytes);
    if (hash2.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return "u" + toString$9(hash2, "base64url");
  };
  var bytes2mh$1 = function(buf) {
    const size = varint$9.decode(buf);
    const address = buf.slice(varint$9.decode.bytes);
    if (address.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return toString$9(address, "base58btc");
  };
  var onion2bytes$1 = function(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    const buf = base32$g.decode("b" + addr[0]);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes$1(port);
    return concat$1([buf, portBuf], buf.length + portBuf.length);
  };
  var onion32bytes$1 = function(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    const buf = base32$g.decode(`b${addr[0]}`);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes$1(port);
    return concat$1([buf, portBuf], buf.length + portBuf.length);
  };
  var bytes2onion$1 = function(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = toString$9(addrBytes, "base32");
    const port = bytes2port$1(portBytes);
    return `${addr}:${port}`;
  };
  var stringToMultiaddrParts = function(str) {
    str = cleanPath$1(str);
    const tuples = [];
    const stringTuples = [];
    let path = null;
    const parts = str.split("/").slice(1);
    if (parts.length === 1 && parts[0] === "") {
      return {
        bytes: new Uint8Array,
        string: "/",
        tuples: [],
        stringTuples: [],
        path: null
      };
    }
    for (let p = 0;p < parts.length; p++) {
      const part = parts[p];
      const proto = getProtocol$1(part);
      if (proto.size === 0) {
        tuples.push([proto.code]);
        stringTuples.push([proto.code]);
        continue;
      }
      p++;
      if (p >= parts.length) {
        throw ParseError$1("invalid address: " + str);
      }
      if (proto.path === true) {
        path = cleanPath$1(parts.slice(p).join("/"));
        tuples.push([proto.code, convertToBytes$1(proto.code, path)]);
        stringTuples.push([proto.code, path]);
        break;
      }
      const bytes2 = convertToBytes$1(proto.code, parts[p]);
      tuples.push([proto.code, bytes2]);
      stringTuples.push([proto.code, convertToString$1(proto.code, bytes2)]);
    }
    return {
      string: stringTuplesToString$1(stringTuples),
      bytes: tuplesToBytes$1(tuples),
      tuples,
      stringTuples,
      path
    };
  };
  var bytesToMultiaddrParts = function(bytes2) {
    const tuples = [];
    const stringTuples = [];
    let path = null;
    let i = 0;
    while (i < bytes2.length) {
      const code2 = varint$9.decode(bytes2, i);
      const n = varint$9.decode.bytes ?? 0;
      const p = getProtocol$1(code2);
      const size = sizeForAddr$1(p, bytes2.slice(i + n));
      if (size === 0) {
        tuples.push([code2]);
        stringTuples.push([code2]);
        i += n;
        continue;
      }
      const addr = bytes2.slice(i + n, i + n + size);
      i += size + n;
      if (i > bytes2.length) {
        throw ParseError$1("Invalid address Uint8Array: " + toString$9(bytes2, "base16"));
      }
      tuples.push([code2, addr]);
      const stringAddr = convertToString$1(code2, addr);
      stringTuples.push([code2, stringAddr]);
      if (p.path === true) {
        path = stringAddr;
        break;
      }
    }
    return {
      bytes: Uint8Array.from(bytes2),
      string: stringTuplesToString$1(stringTuples),
      tuples,
      stringTuples,
      path
    };
  };
  var stringTuplesToString$1 = function(tuples) {
    const parts = [];
    tuples.map((tup) => {
      const proto = getProtocol$1(tup[0]);
      parts.push(proto.name);
      if (tup.length > 1 && tup[1] != null) {
        parts.push(tup[1]);
      }
      return null;
    });
    return cleanPath$1(parts.join("/"));
  };
  var tuplesToBytes$1 = function(tuples) {
    return concat$1(tuples.map((tup) => {
      const proto = getProtocol$1(tup[0]);
      let buf = Uint8Array.from(varint$9.encode(proto.code));
      if (tup.length > 1 && tup[1] != null) {
        buf = concat$1([buf, tup[1]]);
      }
      return buf;
    }));
  };
  var sizeForAddr$1 = function(p, addr) {
    if (p.size > 0) {
      return p.size / 8;
    } else if (p.size === 0) {
      return 0;
    } else {
      const size = varint$9.decode(addr);
      return size + (varint$9.decode.bytes ?? 0);
    }
  };
  var cleanPath$1 = function(str) {
    return "/" + str.trim().split("/").filter((a) => a).join("/");
  };
  var ParseError$1 = function(str) {
    return new Error("Error parsing address: " + str);
  };
  var isMultiaddr$1 = function(value) {
    return Boolean(value?.[symbol$4]);
  };
  var multiaddr$1 = function(addr) {
    return new DefaultMultiaddr$1(addr);
  };
  var requireMs = function() {
    if (hasRequiredMs)
      return ms;
    hasRequiredMs = 1;
    var s2 = 1000;
    var m = s2 * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
    }
    return ms;
  };
  var setup = function(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(new Date);
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format4) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format4];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split2.length;
      for (i = 0;i < len; i++) {
        if (!split2[i]) {
          continue;
        }
        namespaces = split2[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  var hexToBytes$3 = function(hex) {
    if (typeof hex === "string") {
      const _hex = hex.replace(/^0x/i, "");
      return fromString$3(_hex.toLowerCase(), "base16");
    }
    return hex;
  };
  var concat = function(byteArrays, totalLength) {
    const len = totalLength ?? byteArrays.reduce((acc, curr) => acc + curr.length, 0);
    const res = new Uint8Array(len);
    let offset = 0;
    for (const bytes2 of byteArrays) {
      res.set(bytes2, offset);
      offset += bytes2.length;
    }
    return res;
  };
  var requireAspromise = function() {
    if (hasRequiredAspromise)
      return aspromise;
    hasRequiredAspromise = 1;
    aspromise = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
      while (index2 < arguments.length)
        params[offset++] = arguments[index2++];
      return new Promise(function executor(resolve5, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve5.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
    return aspromise;
  };
  var requireBase64 = function() {
    if (hasRequiredBase64)
      return base64$f;
    hasRequiredBase64 = 1;
    (function(exports2) {
      var base642 = exports2;
      base642.length = function length(string2) {
        var p = string2.length;
        if (!p)
          return 0;
        var n = 0;
        while (--p % 4 > 1 && string2.charAt(p) === "=")
          ++n;
        return Math.ceil(string2.length * 3) / 4 - n;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (var i = 0;i < 64; )
        s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
      base642.encode = function encode(buffer, start, end) {
        var parts = null, chunk = [];
        var i2 = 0, j = 0, t;
        while (start < end) {
          var b = buffer[start++];
          switch (j) {
            case 0:
              chunk[i2++] = b64[b >> 2];
              t = (b & 3) << 4;
              j = 1;
              break;
            case 1:
              chunk[i2++] = b64[t | b >> 4];
              t = (b & 15) << 2;
              j = 2;
              break;
            case 2:
              chunk[i2++] = b64[t | b >> 6];
              chunk[i2++] = b64[b & 63];
              j = 0;
              break;
          }
          if (i2 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i2 = 0;
          }
        }
        if (j) {
          chunk[i2++] = b64[t];
          chunk[i2++] = 61;
          if (j === 1)
            chunk[i2++] = 61;
        }
        if (parts) {
          if (i2)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i2));
      };
      var invalidEncoding = "invalid encoding";
      base642.decode = function decode(string2, buffer, offset) {
        var start = offset;
        var j = 0, t;
        for (var i2 = 0;i2 < string2.length; ) {
          var c = string2.charCodeAt(i2++);
          if (c === 61 && j > 1)
            break;
          if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
          switch (j) {
            case 0:
              t = c;
              j = 1;
              break;
            case 1:
              buffer[offset++] = t << 2 | (c & 48) >> 4;
              t = c;
              j = 2;
              break;
            case 2:
              buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
              t = c;
              j = 3;
              break;
            case 3:
              buffer[offset++] = (t & 3) << 6 | c;
              j = 0;
              break;
          }
        }
        if (j === 1)
          throw Error(invalidEncoding);
        return offset - start;
      };
      base642.test = function test(string2) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
      };
    })(base64$f);
    return base64$f;
  };
  var requireEventemitter = function() {
    if (hasRequiredEventemitter)
      return eventemitter;
    hasRequiredEventemitter = 1;
    eventemitter = EventEmitter2;
    function EventEmitter2() {
      this._listeners = {};
    }
    EventEmitter2.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter2.prototype.off = function off(evt, fn) {
      if (evt === undefined)
        this._listeners = {};
      else {
        if (fn === undefined)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0;i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter2.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (;i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0;i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
    return eventemitter;
  };
  var requireFloat = function() {
    if (hasRequiredFloat)
      return float;
    hasRequiredFloat = 1;
    float = factory(factory);
    function factory(exports2) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports2.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports2.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports2.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports2.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 340282346638528860000000000000000000000)
              writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 0.000000000000000000000000000000000000011754943508222875)
              writeUint((sign2 << 31 | Math.round(val / 0.000000000000000000000000000000000000000000001401298464324817)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 0.000000000000000000000000000000000000000000001401298464324817 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports2.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports2.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports2.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports2.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) {
              writeUint(0, buf, pos + off0);
              writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072014) {
                mantissa = val / 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports2;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
    return float;
  };
  var requireInquire = function() {
    if (hasRequiredInquire)
      return inquire_1;
    hasRequiredInquire = 1;
    inquire_1 = inquire;
    function inquire(moduleName) {
      try {
        var mod2 = (0, eval)("quire".replace(/^/, "re"))(moduleName);
        if (mod2 && (mod2.length || Object.keys(mod2).length))
          return mod2;
      } catch (e) {
      }
      return null;
    }
    return inquire_1;
  };
  var requireUtf8 = function() {
    if (hasRequiredUtf8)
      return utf8$2;
    hasRequiredUtf8 = 1;
    (function(exports2) {
      var utf82 = exports2;
      utf82.length = function utf8_length(string2) {
        var len = 0, c = 0;
        for (var i = 0;i < string2.length; ++i) {
          c = string2.charCodeAt(i);
          if (c < 128)
            len += 1;
          else if (c < 2048)
            len += 2;
          else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {
            ++i;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf82.read = function utf8_read(buffer, start, end) {
        var len = end - start;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i = 0, t;
        while (start < end) {
          t = buffer[start++];
          if (t < 128)
            chunk[i++] = t;
          else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
          else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
            chunk[i++] = 55296 + (t >> 10);
            chunk[i++] = 56320 + (t & 1023);
          } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
          if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
          }
        }
        if (parts) {
          if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i));
      };
      utf82.write = function utf8_write(string2, buffer, offset) {
        var start = offset, c1, c2;
        for (var i = 0;i < string2.length; ++i) {
          c1 = string2.charCodeAt(i);
          if (c1 < 128) {
            buffer[offset++] = c1;
          } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start;
      };
    })(utf8$2);
    return utf8$2;
  };
  var requirePool = function() {
    if (hasRequiredPool)
      return pool_1;
    hasRequiredPool = 1;
    pool_1 = pool;
    function pool(alloc2, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc2(size2);
        if (offset + size2 > SIZE) {
          slab = alloc2(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
    return pool_1;
  };
  var requireLongbits = function() {
    if (hasRequiredLongbits)
      return longbits;
    hasRequiredLongbits = 1;
    longbits = LongBits2;
    var util2 = requireMinimal();
    function LongBits2(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits2.zero = new LongBits2(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits2.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits2(lo, hi);
    };
    LongBits2.from = function from(value) {
      if (typeof value === "number")
        return LongBits2.fromNumber(value);
      if (util2.isString(value)) {
        if (util2.Long)
          value = util2.Long.fromString(value);
        else
          return LongBits2.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits2.prototype.toNumber = function toNumber(unsigned2) {
      if (!unsigned2 && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits2.prototype.toLong = function toLong(unsigned2) {
      return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned2)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned2) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits2.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits2((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
    };
    LongBits2.prototype.toHash = function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    };
    LongBits2.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits2.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
    return longbits;
  };
  var requireMinimal = function() {
    if (hasRequiredMinimal)
      return minimal$1;
    hasRequiredMinimal = 1;
    (function(exports2) {
      var util2 = exports2;
      util2.asPromise = requireAspromise();
      util2.base64 = requireBase64();
      util2.EventEmitter = requireEventemitter();
      util2.float = requireFloat();
      util2.inquire = requireInquire();
      util2.utf8 = requireUtf8();
      util2.pool = requirePool();
      util2.LongBits = requireLongbits();
      util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
      util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
      util2.emptyArray = Object.freeze ? Object.freeze([]) : [];
      util2.emptyObject = Object.freeze ? Object.freeze({}) : {};
      util2.isInteger = Number.isInteger || function isInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util2.isString = function isString(value) {
        return typeof value === "string" || value instanceof String;
      };
      util2.isObject = function isObject(value) {
        return value && typeof value === "object";
      };
      util2.isset = util2.isSet = function isSet(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util2.Buffer = function() {
        try {
          var Buffer2 = util2.inquire("buffer").Buffer;
          return Buffer2.prototype.utf8Write ? Buffer2 : null;
        } catch (e) {
          return null;
        }
      }();
      util2._Buffer_from = null;
      util2._Buffer_allocUnsafe = null;
      util2.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util2.Long = util2.global.dcodeIO && util2.global.dcodeIO.Long || util2.global.Long || util2.inquire("long");
      util2.key2Re = /^true|false|0|1$/;
      util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util2.longToHash = function longToHash(value) {
        return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
      };
      util2.longFromHash = function longFromHash(hash2, unsigned2) {
        var bits2 = util2.LongBits.fromHash(hash2);
        if (util2.Long)
          return util2.Long.fromBits(bits2.lo, bits2.hi, unsigned2);
        return bits2.toNumber(Boolean(unsigned2));
      };
      function merge2(dst, src2, ifNotSet) {
        for (var keys = Object.keys(src2), i = 0;i < keys.length; ++i)
          if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src2[keys[i]];
        return dst;
      }
      util2.merge = merge2;
      util2.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name2) {
        function CustomError(message2, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message2, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message2;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge2(this, properties);
        }
        CustomError.prototype = Object.create(Error.prototype, {
          constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
          },
          name: {
            get: function get() {
              return name2;
            },
            set: undefined,
            enumerable: false,
            configurable: true
          },
          toString: {
            value: function value() {
              return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        return CustomError;
      }
      util2.newError = newError;
      util2.ProtocolError = newError("ProtocolError");
      util2.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i = 0;i < fieldNames.length; ++i)
          fieldMap[fieldNames[i]] = 1;
        return function() {
          for (var keys = Object.keys(this), i2 = keys.length - 1;i2 > -1; --i2)
            if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== undefined && this[keys[i2]] !== null)
              return keys[i2];
        };
      };
      util2.oneOfSetter = function setOneOf(fieldNames) {
        return function(name2) {
          for (var i = 0;i < fieldNames.length; ++i)
            if (fieldNames[i] !== name2)
              delete this[fieldNames[i]];
        };
      };
      util2.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util2._configure = function() {
        var Buffer2 = util2.Buffer;
        if (!Buffer2) {
          util2._Buffer_from = util2._Buffer_allocUnsafe = null;
          return;
        }
        util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
          return new Buffer2(value, encoding);
        };
        util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
          return new Buffer2(size);
        };
      };
    })(minimal$1);
    return minimal$1;
  };
  var indexOutOfRange = function(reader2, writeLength) {
    return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
  };
  var Reader$1 = function(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  };
  var readLongVarint = function() {
    var bits2 = new LongBits$2(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (;i < 4; ++i) {
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
      }
      bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits2;
      i = 0;
    } else {
      for (;i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
      }
      bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits2;
    }
    if (this.len - this.pos > 4) {
      for (;i < 5; ++i) {
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
      }
    } else {
      for (;i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits2;
      }
    }
    throw Error("invalid varint encoding");
  };
  var readFixed32_end = function(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  };
  var readFixed64 = function() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits$2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  };
  var BufferReader = function(buffer) {
    Reader.call(this, buffer);
  };
  var Op = function(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = undefined;
    this.val = val;
  };
  var noop$1 = function() {
  };
  var State = function(writer2) {
    this.head = writer2.head;
    this.tail = writer2.tail;
    this.len = writer2.len;
    this.next = writer2.states;
  };
  var Writer$1 = function() {
    this.len = 0;
    this.head = new Op(noop$1, 0, 0);
    this.tail = this.head;
    this.states = null;
  };
  var writeByte = function(val, buf, pos) {
    buf[pos] = val & 255;
  };
  var writeVarint32 = function(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  };
  var VarintOp = function(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
  };
  var writeVarint64 = function(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  };
  var writeFixed32 = function(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  };
  var BufferWriter = function() {
    Writer.call(this);
  };
  var writeStringBuffer = function(val, buf, pos) {
    if (val.length < 40)
      util$4.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos);
    else
      buf.write(val, pos);
  };
  var configure = function() {
    util$6._configure();
    ReaderClass._configure(ReaderBufferClass);
    WriterClass._configure(WriterBufferClass);
  };
  var patchReader = function(obj) {
    for (const method of methods) {
      if (obj[method] == null) {
        continue;
      }
      const original = obj[method];
      obj[method] = function() {
        return BigInt(original.call(this).toString());
      };
    }
    return obj;
  };
  var reader$1 = function(buf) {
    return patchReader(new ReaderClass(buf));
  };
  var patchWriter = function(obj) {
    for (const method of methods) {
      if (obj[method] == null) {
        continue;
      }
      const original = obj[method];
      obj[method] = function(val) {
        return original.call(this, val.toString());
      };
    }
    return obj;
  };
  var writer = function() {
    return patchWriter(WriterClass.create());
  };
  var decodeMessage$1 = function(buf, codec2) {
    const r = reader$1(buf instanceof Uint8Array ? buf : buf.subarray());
    return codec2.decode(r);
  };
  var encodeMessage = function(message2, codec2) {
    const w = writer();
    codec2.encode(message2, w, {
      lengthDelimited: false
    });
    return w.finish();
  };
  var createCodec = function(name2, type, encode3, decode3) {
    return {
      name: name2,
      type,
      encode: encode3,
      decode: decode3
    };
  };
  var enumeration = function(v) {
    function findValue(val) {
      if (v[val.toString()] == null) {
        throw new Error("Invalid enum value");
      }
      return v[val];
    }
    const encode3 = function enumEncode(val, writer2) {
      const enumValue = findValue(val);
      writer2.int32(enumValue);
    };
    const decode3 = function enumDecode(reader2) {
      const val = reader2.int32();
      return findValue(val);
    };
    return createCodec("enum", CODEC_TYPES.VARINT, encode3, decode3);
  };
  var message$1 = function(encode3, decode3) {
    return createCodec("message", CODEC_TYPES.LENGTH_DELIMITED, encode3, decode3);
  };
  var createEncoder = function({ contentTopic, ephemeral, metaSetter }) {
    return new Encoder$e(contentTopic, ephemeral, metaSetter);
  };
  var createDecoder = function(contentTopic) {
    return new Decoder$e(contentTopic);
  };
  var mapToPeerIdOrMultiaddr = function(peerId) {
    return isPeerId(peerId) ? peerId : multiaddr$1(peerId);
  };
  var isDefined = function(value) {
    return Boolean(value);
  };
  var getPseudoRandomSubset = function(values, wantedNumber) {
    if (values.length <= wantedNumber || values.length <= 1) {
      return values;
    }
    return shuffle$1(values).slice(0, wantedNumber);
  };
  var shuffle$1 = function(arr) {
    if (arr.length <= 1) {
      return arr;
    }
    const randInt = () => {
      return Math.floor(Math.random() * Math.floor(arr.length));
    };
    for (let i = 0;i < arr.length; i++) {
      const j = randInt();
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  };
  var groupByContentTopic = function(values) {
    const groupedDecoders = new Map;
    values.forEach((value) => {
      let decs = groupedDecoders.get(value.contentTopic);
      if (!decs) {
        groupedDecoders.set(value.contentTopic, []);
        decs = groupedDecoders.get(value.contentTopic);
      }
      decs.push(value);
    });
    return groupedDecoders;
  };
  async function toAsyncIterator(receiver, decoder, iteratorOptions) {
    const iteratorDelay = iteratorOptions?.iteratorDelay ?? FRAME_RATE;
    const messages2 = [];
    let unsubscribe;
    unsubscribe = await receiver.subscribe(decoder, (message2) => {
      messages2.push(message2);
    });
    const isWithTimeout = Number.isInteger(iteratorOptions?.timeoutMs);
    const timeoutMs = iteratorOptions?.timeoutMs ?? 0;
    const startTime = Date.now();
    async function* iterator() {
      while (true) {
        if (isWithTimeout && Date.now() - startTime >= timeoutMs) {
          return;
        }
        await wait(iteratorDelay);
        const message2 = messages2.shift();
        if (!unsubscribe && messages2.length === 0) {
          return message2;
        }
        if (!message2 && unsubscribe) {
          continue;
        }
        yield message2;
      }
    }
    return {
      iterator: iterator(),
      async stop() {
        if (unsubscribe) {
          await unsubscribe();
          unsubscribe = undefined;
        }
      }
    };
  }
  var wait = function(ms2) {
    return new Promise((resolve5) => {
      setTimeout(resolve5, ms2);
    });
  };
  var removeItemFromArray = function(arr, value) {
    const index2 = arr.indexOf(value);
    if (index2 > -1) {
      arr.splice(index2, 1);
    }
    return arr;
  };
  var isAsyncIterable$b = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var all$1 = function(source2) {
    if (isAsyncIterable$b(source2)) {
      return (async () => {
        const arr2 = [];
        for await (const entry of source2) {
          arr2.push(entry);
        }
        return arr2;
      })();
    }
    const arr = [];
    for (const entry of source2) {
      arr.push(entry);
    }
    return arr;
  };
  var findBufAndOffset = function(bufs, index2) {
    if (index2 == null || index2 < 0) {
      throw new RangeError("index is out of bounds");
    }
    let offset = 0;
    for (const buf of bufs) {
      const bufEnd = offset + buf.byteLength;
      if (index2 < bufEnd) {
        return {
          buf,
          index: index2 - offset
        };
      }
      offset = bufEnd;
    }
    throw new RangeError("index is out of bounds");
  };
  var isUint8ArrayList = function(value) {
    return Boolean(value?.[symbol$3]);
  };
  var accessor = function(buf) {
    if (buf instanceof Uint8Array) {
      return {
        get(index2) {
          return buf[index2];
        },
        set(index2, value) {
          buf[index2] = value;
        }
      };
    }
    return {
      get(index2) {
        return buf.get(index2);
      },
      set(index2, value) {
        buf.set(index2, value);
      }
    };
  };
  var isAsyncIterable$a = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var encode$B = function(source2, options) {
    options = options ?? {};
    const encodeLength = options.lengthEncoder ?? defaultEncoder;
    function* maybeYield(chunk) {
      const length2 = encodeLength(chunk.byteLength);
      if (length2 instanceof Uint8Array) {
        yield length2;
      } else {
        yield* length2;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
    if (isAsyncIterable$a(source2)) {
      return async function* () {
        for await (const chunk of source2) {
          yield* maybeYield(chunk);
        }
      }();
    }
    return function* () {
      for (const chunk of source2) {
        yield* maybeYield(chunk);
      }
    }();
  };
  var assign = function(obj, props) {
    for (const key in props) {
      Object.defineProperty(obj, key, {
        value: props[key],
        enumerable: true,
        configurable: true
      });
    }
    return obj;
  };
  var createError = function(err, code2, props) {
    if (!err || typeof err === "string") {
      throw new TypeError("Please pass an Error to err-code");
    }
    if (!props) {
      props = {};
    }
    if (typeof code2 === "object") {
      props = code2;
      code2 = "";
    }
    if (code2) {
      props.code = code2;
    }
    try {
      return assign(err, props);
    } catch (_) {
      props.message = err.message;
      props.stack = err.stack;
      const ErrClass = function() {
      };
      ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
      const output2 = assign(new ErrClass, props);
      return output2;
    }
  };
  var decode$v = function(source2, options) {
    const buffer = new Uint8ArrayList;
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;
    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
    function* maybeYield() {
      while (buffer.byteLength > 0) {
        if (mode === ReadMode.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer);
            if (dataLength < 0) {
              throw errCode$1(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
            }
            if (dataLength > maxDataLength) {
              throw errCode$1(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer.consume(dataLengthLength);
            if (options?.onLength != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode.DATA;
          } catch (err) {
            if (err instanceof RangeError) {
              if (buffer.byteLength > maxLengthLength) {
                throw errCode$1(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
              }
              break;
            }
            throw err;
          }
        }
        if (mode === ReadMode.DATA) {
          if (buffer.byteLength < dataLength) {
            break;
          }
          const data = buffer.sublist(0, dataLength);
          buffer.consume(dataLength);
          if (options?.onData != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode.LENGTH;
        }
      }
    }
    if (isAsyncIterable$a(source2)) {
      return async function* () {
        for await (const buf of source2) {
          buffer.append(buf);
          yield* maybeYield();
        }
        if (buffer.byteLength > 0) {
          throw errCode$1(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
        }
      }();
    }
    return function* () {
      for (const buf of source2) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw errCode$1(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
      }
    }();
  };
  var pDefer = function() {
    const deferred = {};
    deferred.promise = new Promise((resolve5, reject) => {
      deferred.resolve = resolve5;
      deferred.reject = reject;
    });
    return deferred;
  };
  var pushable = function(options = {}) {
    const getNext = (buffer) => {
      const next = buffer.shift();
      if (next == null) {
        return { done: true };
      }
      if (next.error != null) {
        throw next.error;
      }
      return {
        done: next.done === true,
        value: next.value
      };
    };
    return _pushable(getNext, options);
  };
  var pushableV = function(options = {}) {
    const getNext = (buffer) => {
      let next;
      const values = [];
      while (!buffer.isEmpty()) {
        next = buffer.shift();
        if (next == null) {
          break;
        }
        if (next.error != null) {
          throw next.error;
        }
        if (next.done === false) {
          values.push(next.value);
        }
      }
      if (next == null) {
        return { done: true };
      }
      return {
        done: next.done === true,
        value: values
      };
    };
    return _pushable(getNext, options);
  };
  var _pushable = function(getNext, options) {
    options = options ?? {};
    let onEnd = options.onEnd;
    let buffer = new FIFO;
    let pushable2;
    let onNext;
    let ended;
    let drain2 = pDefer();
    const waitNext = async () => {
      try {
        if (!buffer.isEmpty()) {
          return getNext(buffer);
        }
        if (ended) {
          return { done: true };
        }
        return await new Promise((resolve5, reject) => {
          onNext = (next) => {
            onNext = null;
            buffer.push(next);
            try {
              resolve5(getNext(buffer));
            } catch (err) {
              reject(err);
            }
            return pushable2;
          };
        });
      } finally {
        if (buffer.isEmpty()) {
          queueMicrotask(() => {
            drain2.resolve();
            drain2 = pDefer();
          });
        }
      }
    };
    const bufferNext = (next) => {
      if (onNext != null) {
        return onNext(next);
      }
      buffer.push(next);
      return pushable2;
    };
    const bufferError = (err) => {
      buffer = new FIFO;
      if (onNext != null) {
        return onNext({ error: err });
      }
      buffer.push({ error: err });
      return pushable2;
    };
    const push = (value) => {
      if (ended) {
        return pushable2;
      }
      if (options?.objectMode !== true && value?.byteLength == null) {
        throw new Error("objectMode was not true but tried to push non-Uint8Array value");
      }
      return bufferNext({ done: false, value });
    };
    const end = (err) => {
      if (ended)
        return pushable2;
      ended = true;
      return err != null ? bufferError(err) : bufferNext({ done: true });
    };
    const _return = () => {
      buffer = new FIFO;
      end();
      return { done: true };
    };
    const _throw = (err) => {
      end(err);
      return { done: true };
    };
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: waitNext,
      return: _return,
      throw: _throw,
      push,
      end,
      get readableLength() {
        return buffer.size;
      },
      onEmpty: async (options2) => {
        const signal = options2?.signal;
        signal?.throwIfAborted();
        if (buffer.isEmpty()) {
          return;
        }
        let cancel;
        let listener;
        if (signal != null) {
          cancel = new Promise((resolve5, reject) => {
            listener = () => {
              reject(new AbortError$7);
            };
            signal.addEventListener("abort", listener);
          });
        }
        try {
          await Promise.race([
            drain2.promise,
            cancel
          ]);
        } finally {
          if (listener != null && signal != null) {
            signal?.removeEventListener("abort", listener);
          }
        }
      }
    };
    if (onEnd == null) {
      return pushable2;
    }
    const _pushable2 = pushable2;
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next() {
        return _pushable2.next();
      },
      throw(err) {
        _pushable2.throw(err);
        if (onEnd != null) {
          onEnd(err);
          onEnd = undefined;
        }
        return { done: true };
      },
      return() {
        _pushable2.return();
        if (onEnd != null) {
          onEnd();
          onEnd = undefined;
        }
        return { done: true };
      },
      push,
      end(err) {
        _pushable2.end(err);
        if (onEnd != null) {
          onEnd(err);
          onEnd = undefined;
        }
        return pushable2;
      },
      get readableLength() {
        return _pushable2.readableLength;
      }
    };
    return pushable2;
  };
  var isAsyncIterable$9 = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var merge$1 = function(...sources) {
    const syncSources = [];
    for (const source2 of sources) {
      if (!isAsyncIterable$9(source2)) {
        syncSources.push(source2);
      }
    }
    if (syncSources.length === sources.length) {
      return function* () {
        for (const source2 of syncSources) {
          yield* source2;
        }
      }();
    }
    return async function* () {
      const output2 = pushable({
        objectMode: true
      });
      Promise.resolve().then(async () => {
        try {
          await Promise.all(sources.map(async (source2) => {
            for await (const item of source2) {
              output2.push(item);
            }
          }));
          output2.end();
        } catch (err) {
          output2.end(err);
        }
      });
      yield* output2;
    }();
  };
  var pipe = function(first2, ...rest) {
    if (first2 == null) {
      throw new Error("Empty pipeline");
    }
    if (isDuplex(first2)) {
      const duplex2 = first2;
      first2 = () => duplex2.source;
    } else if (isIterable(first2) || isAsyncIterable$8(first2)) {
      const source2 = first2;
      first2 = () => source2;
    }
    const fns = [first2, ...rest];
    if (fns.length > 1) {
      if (isDuplex(fns[fns.length - 1])) {
        fns[fns.length - 1] = fns[fns.length - 1].sink;
      }
    }
    if (fns.length > 2) {
      for (let i = 1;i < fns.length - 1; i++) {
        if (isDuplex(fns[i])) {
          fns[i] = duplexPipelineFn(fns[i]);
        }
      }
    }
    return rawPipe(...fns);
  };
  var selectRandomPeer = function(peers) {
    if (peers.length === 0)
      return;
    const index2 = Math.round(Math.random() * (peers.length - 1));
    return peers[index2];
  };
  async function selectLowestLatencyPeer(peerStore, peers) {
    if (peers.length === 0)
      return;
    const results = await Promise.all(peers.map(async (peer) => {
      const pingBytes = (await peerStore.get(peer.id)).metadata.get("ping");
      if (!pingBytes)
        return { peer, ping: Infinity };
      const ping = Number(bytesToUtf8(pingBytes)) ?? Infinity;
      return { peer, ping };
    }));
    const lowestLatencyResult = results.sort((a, b) => a.ping - b.ping)[0];
    if (!lowestLatencyResult) {
      return;
    }
    return lowestLatencyResult.ping !== Infinity ? lowestLatencyResult.peer : undefined;
  }
  async function getPeersForProtocol(peerStore, protocols) {
    const peers = [];
    await peerStore.forEach((peer) => {
      for (let i = 0;i < protocols.length; i++) {
        if (peer.protocols.includes(protocols[i])) {
          peers.push(peer);
          break;
        }
      }
    });
    return peers;
  }
  async function selectPeerForProtocol(peerStore, protocols, peerId) {
    let peer;
    if (peerId) {
      peer = await peerStore.get(peerId);
      if (!peer) {
        throw new Error(`Failed to retrieve connection details for provided peer in peer store: ${peerId.toString()}`);
      }
    } else {
      const peers = await getPeersForProtocol(peerStore, protocols);
      peer = await selectLowestLatencyPeer(peerStore, peers);
      if (!peer) {
        peer = selectRandomPeer(peers);
        if (!peer)
          throw new Error(`Failed to find known peer that registers protocols: ${protocols}`);
      }
    }
    let protocol;
    for (const codec2 of protocols) {
      if (peer.protocols.includes(codec2)) {
        protocol = codec2;
      }
    }
    log$E(`Using codec ${protocol}`);
    if (!protocol) {
      throw new Error(`Peer does not register required protocols (${peer.id.toString()}): ${protocols}`);
    }
    return { peer, protocol };
  }
  var selectConnection = function(connections) {
    if (!connections.length)
      return;
    if (connections.length === 1)
      return connections[0];
    let latestConnection;
    connections.forEach((connection) => {
      if (connection.status === "open") {
        if (!latestConnection) {
          latestConnection = connection;
        } else if (connection.timeline.open > latestConnection.timeline.open) {
          latestConnection = connection;
        }
      }
    });
    return latestConnection;
  };
  async function filterPeers(peers, numPeers, maxBootstrapPeers) {
    const bootstrapPeers = peers.filter((peer) => peer.tags.has(Tags.BOOTSTRAP)).slice(0, maxBootstrapPeers);
    const nonBootstrapPeers = peers.filter((peer) => !peer.tags.has(Tags.BOOTSTRAP));
    if (numPeers === 0) {
      return [...bootstrapPeers, ...nonBootstrapPeers];
    }
    const selectedPeers = [...bootstrapPeers];
    while (selectedPeers.length < numPeers && nonBootstrapPeers.length > 0) {
      const randomIndex = Math.floor(Math.random() * nonBootstrapPeers.length);
      const randomPeer = nonBootstrapPeers.splice(randomIndex, 1)[0];
      selectedPeers.push(randomPeer);
    }
    return selectedPeers;
  }
  var rng = function() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  };
  var unsafeStringify = function(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  };
  var v4$2 = function(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
      return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  };
  var wakuFilter = function(init2 = {}) {
    return (libp2p) => new Filter(libp2p, init2);
  };
  async function pushMessage(subscriptionCallback, pubSubTopic, message2) {
    const { decoders: decoders2, callback } = subscriptionCallback;
    const { contentTopic } = message2;
    if (!contentTopic) {
      log$D("Message has no content topic, skipping");
      return;
    }
    try {
      const decodePromises = decoders2.map((dec) => dec.fromProtoObj(pubSubTopic, message2).then((decoded) => decoded || Promise.reject("Decoding failed")));
      const decodedMessage = await Promise.any(decodePromises);
      await callback(decodedMessage);
    } catch (e) {
      log$D("Error decoding message", e);
    }
  }
  var wakuLightPush = function(init2 = {}) {
    return (libp2p) => new LightPush(libp2p, init2);
  };
  var number$2 = function(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  };
  var bytes$2 = function(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  };
  var hash$3 = function(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number$2(hash2.outputLen);
    number$2(hash2.blockLen);
  };
  var exists$2 = function(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  };
  var output$2 = function(out, instance) {
    bytes$2(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  };
  var utf8ToBytes$3 = function(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  };
  var toBytes$3 = function(data) {
    if (typeof data === "string")
      data = utf8ToBytes$3(data);
    if (!u8a$3(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  };
  var wrapConstructor$1 = function(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes$3(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  };
  var randomBytes$8 = function(bytesLength = 32) {
    if (crypto$7 && typeof crypto$7.getRandomValues === "function") {
      return crypto$7.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  };
  var setBigUint64$2 = function(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  };
  var toProtoMessage = function(wire) {
    return { ...EmptyMessage, ...wire };
  };
  var directionToProto = function(pageDirection) {
    switch (pageDirection) {
      case PageDirection.BACKWARD:
        return PagingInfo.Direction.BACKWARD;
      case PageDirection.FORWARD:
        return PagingInfo.Direction.FORWARD;
      default:
        return PagingInfo.Direction.BACKWARD;
    }
  };
  async function* paginate(streamFactory, queryOpts, decoders2, cursor) {
    if (queryOpts.contentTopics.toString() !== Array.from(decoders2.keys()).toString()) {
      throw new Error("Internal error, the decoders should match the query's content topics");
    }
    let currentCursor = cursor;
    while (true) {
      queryOpts.cursor = currentCursor;
      const historyRpcQuery = HistoryRpc.createQuery(queryOpts);
      log$B("Querying store peer", `for (${queryOpts.pubSubTopic})`, queryOpts.contentTopics);
      const stream = await streamFactory();
      const res = await pipe([historyRpcQuery.encode()], encode$B, stream, decode$v, async (source2) => await all$1(source2));
      const bytes2 = new Uint8ArrayList;
      res.forEach((chunk) => {
        bytes2.append(chunk);
      });
      const reply = historyRpcQuery.decode(bytes2);
      if (!reply.response) {
        log$B("Stopping pagination due to store `response` field missing");
        break;
      }
      const response = reply.response;
      if (response.error && response.error !== HistoryError.NONE) {
        throw "History response contains an Error: " + response.error;
      }
      if (!response.messages || !response.messages.length) {
        log$B("Stopping pagination due to store `response.messages` field missing or empty");
        break;
      }
      log$B(`${response.messages.length} messages retrieved from store`);
      yield response.messages.map((protoMsg) => {
        const contentTopic = protoMsg.contentTopic;
        if (typeof contentTopic !== "undefined") {
          const decoder = decoders2.get(contentTopic);
          if (decoder) {
            return decoder.fromProtoObj(queryOpts.pubSubTopic, toProtoMessage(protoMsg));
          }
        }
        return Promise.resolve(undefined);
      });
      const nextCursor = response.pagingInfo?.cursor;
      if (typeof nextCursor === "undefined") {
        log$B("Stopping pagination due to `response.pagingInfo.cursor` missing from store response");
        break;
      }
      currentCursor = nextCursor;
      const responsePageSize = response.pagingInfo?.pageSize;
      const queryPageSize = historyRpcQuery.query?.pagingInfo?.pageSize;
      if (responsePageSize && queryPageSize && responsePageSize < queryPageSize) {
        break;
      }
    }
  }
  async function createCursor(message2, pubsubTopic = DefaultPubSubTopic) {
    if (!message2 || !message2.timestamp || !message2.payload || !message2.contentTopic) {
      throw new Error("Message is missing required fields");
    }
    const contentTopicBytes = utf8ToBytes$4(message2.contentTopic);
    const digest2 = sha256$a(concat([contentTopicBytes, message2.payload]));
    const messageTime = BigInt(message2.timestamp.getTime()) * BigInt(1e6);
    return {
      digest: digest2,
      pubsubTopic,
      senderTime: messageTime,
      receiverTime: messageTime
    };
  }
  var wakuStore = function(init2 = {}) {
    return (libp2p) => new Store(libp2p, init2);
  };
  var pTimeout$2 = function(promise, milliseconds, fallback, options) {
    let timer;
    const cancelablePromise = new Promise((resolve5, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        resolve5(promise);
        return;
      }
      options = {
        customTimers: { setTimeout, clearTimeout },
        ...options
      };
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason$2(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason$2(signal));
        });
      }
      timer = options.customTimers.setTimeout.call(undefined, () => {
        if (typeof fallback === "function") {
          try {
            resolve5(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError$3(message2);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      (async () => {
        try {
          resolve5(await promise);
        } catch (error) {
          reject(error);
        } finally {
          options.customTimers.clearTimeout.call(undefined, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      clearTimeout(timer);
      timer = undefined;
    };
    return cancelablePromise;
  };
  var pEventMultiple = function(emitter, event, options) {
    let cancel;
    const returnValue = new Promise((resolve5, reject) => {
      options = {
        rejectionEvents: ["error"],
        multiArgs: false,
        resolveImmediately: false,
        ...options
      };
      if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
        throw new TypeError("The `count` option should be at least 0 or more");
      }
      const events2 = [event].flat();
      const items = [];
      const { addListener, removeListener } = normalizeEmitter(emitter);
      const onItem = (...arguments_) => {
        const value = options.multiArgs ? arguments_ : arguments_[0];
        if (options.filter && !options.filter(value)) {
          return;
        }
        items.push(value);
        if (options.count === items.length) {
          cancel();
          resolve5(items);
        }
      };
      const rejectHandler = (error) => {
        cancel();
        reject(error);
      };
      cancel = () => {
        for (const event2 of events2) {
          removeListener(event2, onItem);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          removeListener(rejectionEvent, rejectHandler);
        }
      };
      for (const event2 of events2) {
        addListener(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        addListener(rejectionEvent, rejectHandler);
      }
      if (options.resolveImmediately) {
        resolve5(items);
      }
    });
    returnValue.cancel = cancel;
    if (typeof options.timeout === "number") {
      const timeout = pTimeout$2(returnValue, options.timeout);
      timeout.cancel = cancel;
      return timeout;
    }
    return returnValue;
  };
  var pEvent = function(emitter, event, options) {
    if (typeof options === "function") {
      options = { filter: options };
    }
    options = {
      ...options,
      count: 1,
      resolveImmediately: false
    };
    const arrayPromise = pEventMultiple(emitter, event, options);
    const promise = arrayPromise.then((array) => array[0]);
    promise.cancel = arrayPromise.cancel;
    return promise;
  };
  async function waitForRemotePeer(waku2, protocols, timeoutMs) {
    protocols = protocols ?? getEnabledProtocols(waku2);
    if (!waku2.isStarted())
      return Promise.reject("Waku node is not started");
    const promises = [];
    if (protocols.includes(Protocols.Relay)) {
      if (!waku2.relay)
        throw new Error("Cannot wait for Relay peer: protocol not mounted");
      promises.push(waitForGossipSubPeerInMesh(waku2.relay));
    }
    if (protocols.includes(Protocols.Store)) {
      if (!waku2.store)
        throw new Error("Cannot wait for Store peer: protocol not mounted");
      promises.push(waitForConnectedPeer(waku2.store));
    }
    if (protocols.includes(Protocols.LightPush)) {
      if (!waku2.lightPush)
        throw new Error("Cannot wait for LightPush peer: protocol not mounted");
      promises.push(waitForConnectedPeer(waku2.lightPush));
    }
    if (protocols.includes(Protocols.Filter)) {
      if (!waku2.filter)
        throw new Error("Cannot wait for Filter peer: protocol not mounted");
      promises.push(waitForConnectedPeer(waku2.filter));
    }
    if (timeoutMs) {
      await rejectOnTimeout(Promise.all(promises), timeoutMs, "Timed out waiting for a remote peer.");
    } else {
      await Promise.all(promises);
    }
  }
  async function waitForConnectedPeer(protocol) {
    const codec2 = protocol.multicodec;
    const peers = await protocol.peers();
    if (peers.length) {
      log$A(`${codec2} peer found: `, peers[0].id.toString());
      return;
    }
    await new Promise((resolve5) => {
      const cb = (evt) => {
        if (evt.detail?.protocols?.includes(codec2)) {
          log$A("Resolving for", codec2, evt.detail.protocols);
          protocol.removeLibp2pEventListener("peer:identify", cb);
          resolve5();
        }
      };
      protocol.addLibp2pEventListener("peer:identify", cb);
    });
  }
  async function waitForGossipSubPeerInMesh(waku2) {
    let peers = waku2.getMeshPeers();
    while (peers.length == 0) {
      await pEvent(waku2.gossipSub, "gossipsub:heartbeat");
      peers = waku2.getMeshPeers();
    }
  }
  async function rejectOnTimeout(promise, timeoutMs, rejectReason) {
    await Promise.race([promise, awaitTimeout(timeoutMs, rejectReason)]);
  }
  var getEnabledProtocols = function(waku2) {
    const protocols = [];
    if (waku2.relay) {
      protocols.push(Protocols.Relay);
    }
    if (waku2.filter) {
      protocols.push(Protocols.Filter);
    }
    if (waku2.store) {
      protocols.push(Protocols.Store);
    }
    if (waku2.lightPush) {
      protocols.push(Protocols.LightPush);
    }
    return protocols;
  };
  var byteStream = function(duplex2) {
    const write2 = pushable();
    duplex2.sink(write2).catch((err) => {
      write2.end(err);
    });
    duplex2.sink = async (source3) => {
      for await (const buf of source3) {
        write2.push(buf);
      }
      write2.end();
    };
    let source2 = duplex2.source;
    if (duplex2.source[Symbol.iterator] != null) {
      source2 = duplex2.source[Symbol.iterator]();
    } else if (duplex2.source[Symbol.asyncIterator] != null) {
      source2 = duplex2.source[Symbol.asyncIterator]();
    }
    const readBuffer = new Uint8ArrayList;
    const W = {
      read: async (bytes2, options) => {
        options?.signal?.throwIfAborted();
        let listener;
        const abortPromise = new Promise((resolve5, reject) => {
          listener = () => {
            reject(new AbortError$5("Read aborted"));
          };
          options?.signal?.addEventListener("abort", listener);
        });
        try {
          if (bytes2 == null) {
            const { done, value } = await Promise.race([
              source2.next(),
              abortPromise
            ]);
            if (done === true) {
              return new Uint8ArrayList;
            }
            return value;
          }
          while (readBuffer.byteLength < bytes2) {
            const { value, done } = await Promise.race([
              source2.next(),
              abortPromise
            ]);
            if (done === true) {
              throw new CodeError$2("unexpected end of input", "ERR_UNEXPECTED_EOF");
            }
            readBuffer.append(value);
          }
          const buf = readBuffer.sublist(0, bytes2);
          readBuffer.consume(bytes2);
          return buf;
        } finally {
          if (listener != null) {
            options?.signal?.removeEventListener("abort", listener);
          }
        }
      },
      write: async (data, options) => {
        options?.signal?.throwIfAborted();
        if (data instanceof Uint8Array) {
          write2.push(data);
        } else {
          write2.push(data.subarray());
        }
        await write2.onEmpty(options);
      },
      unwrap: () => {
        const originalStream = duplex2.source;
        duplex2.source = async function* () {
          yield* readBuffer;
          yield* originalStream;
        }();
        return duplex2;
      }
    };
    return W;
  };
  var lpStream = function(duplex2, opts) {
    const bytes2 = byteStream(duplex2);
    const W = {
      read: async (options) => {
        let dataLength = -1;
        const lengthBuffer = new Uint8ArrayList;
        const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder;
        while (true) {
          lengthBuffer.append(await bytes2.read(1, options));
          try {
            dataLength = decodeLength(lengthBuffer);
          } catch (err) {
            if (err instanceof RangeError) {
              continue;
            }
            throw err;
          }
          if (dataLength > -1) {
            break;
          }
          if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
            throw new CodeError$1("message length length too long", "ERR_MSG_LENGTH_TOO_LONG");
          }
        }
        if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
          throw new CodeError$1("message length too long", "ERR_MSG_DATA_TOO_LONG");
        }
        return bytes2.read(dataLength, options);
      },
      write: async (data, options) => {
        await bytes2.write(encode$B.single(data, opts), options);
      },
      unwrap: () => {
        return bytes2.unwrap();
      }
    };
    return W;
  };
  var pair = function() {
    const deferred = pDefer();
    let piped = false;
    return {
      sink: async (source2) => {
        if (piped) {
          throw new Error("already piped");
        }
        piped = true;
        deferred.resolve(source2);
      },
      source: async function* () {
        const source2 = await deferred.promise;
        yield* source2;
      }()
    };
  };
  var duplexPair = function() {
    const a = pair();
    const b = pair();
    return [
      {
        source: a.source,
        sink: b.sink
      },
      {
        source: b.source,
        sink: a.sink
      }
    ];
  };
  var utf8ToBytes$2 = function(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  };
  var toBytes$2 = function(data) {
    if (typeof data === "string")
      data = utf8ToBytes$2(data);
    if (!u8a$2(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  };
  var checkOpts = function(defaults, opts) {
    if (opts !== undefined && (typeof opts !== "object" || !isPlainObject(opts)))
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  };
  var ensureBytes$3 = function(b, len) {
    if (!(b instanceof Uint8Array))
      throw new Error("Uint8Array expected");
    if (typeof len === "number") {
      if (b.length !== len)
        throw new Error(`Uint8Array length ${len} expected`);
    }
  };
  var equalBytes$2 = function(a, b) {
    if (a.length !== b.length)
      throw new Error("equalBytes: Different size of Uint8Arrays");
    let isSame = true;
    for (let i = 0;i < a.length; i++)
      isSame && (isSame = a[i] === b[i]);
    return isSame;
  };
  var setBigUint64$1 = function(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  };
  var number$1 = function(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  };
  var bool$1 = function(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  };
  var bytes$1 = function(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  };
  var hash$2 = function(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number$1(hash2.outputLen);
    number$1(hash2.blockLen);
  };
  var exists$1 = function(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  };
  var output$1 = function(out, instance) {
    bytes$1(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  };
  var wrapConstructorWithKey = function(hashCons) {
    const hashC = (msg, key) => hashCons(key).update(toBytes$2(msg)).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key) => hashCons(key);
    return hashC;
  };
  var chachaCore = function(c, k, n, out, cnt, rounds = 20) {
    let y00 = c[0], y01 = c[1], y02 = c[2], y03 = c[3];
    let y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3];
    let y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7];
    let y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i = 0;i < rounds; i += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  };
  var hchacha = function(c, key, src2, out) {
    const k32 = u32(key);
    const i32 = u32(src2);
    const o32 = u32(out);
    let x00 = c[0], x01 = c[1], x02 = c[2], x03 = c[3];
    let x04 = k32[0], x05 = k32[1], x06 = k32[2], x07 = k32[3];
    let x08 = k32[4], x09 = k32[5], x10 = k32[6], x11 = k32[7];
    let x12 = i32[0], x13 = i32[1], x14 = i32[2], x15 = i32[3];
    for (let i = 0;i < 20; i += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    o32[0] = x00;
    o32[1] = x01;
    o32[2] = x02;
    o32[3] = x03;
    o32[4] = x12;
    o32[5] = x13;
    o32[6] = x14;
    o32[7] = x15;
    return out;
  };
  var number = function(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  };
  var bool = function(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  };
  var bytes = function(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  };
  var hash$1 = function(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  };
  var exists = function(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  };
  var output = function(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  };
  var utf8ToBytes$1 = function(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  };
  var toBytes$1 = function(data) {
    if (typeof data === "string")
      data = utf8ToBytes$1(data);
    if (!u8a$1(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  };
  var concatBytes$3 = function(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a$1(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  };
  var wrapConstructor = function(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  };
  var randomBytes$7 = function(bytesLength = 32) {
    if (crypto$6 && typeof crypto$6.getRandomValues === "function") {
      return crypto$6.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  };
  var setBigUint64 = function(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  };
  var fromBig = function(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  };
  var split = function(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0;i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  };
  var add = function(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  };
  var bytesToHex$2 = function(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < bytes2.length; i++) {
      hex += hexes$2[bytes2[i]];
    }
    return hex;
  };
  var numberToHexUnpadded$1 = function(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  };
  var hexToNumber$1 = function(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  };
  var hexToBytes$2 = function(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  };
  var bytesToNumberBE = function(bytes2) {
    return hexToNumber$1(bytesToHex$2(bytes2));
  };
  var bytesToNumberLE$1 = function(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber$1(bytesToHex$2(Uint8Array.from(bytes2).reverse()));
  };
  var numberToBytesBE = function(n, len) {
    return hexToBytes$2(n.toString(16).padStart(len * 2, "0"));
  };
  var numberToBytesLE = function(n, len) {
    return numberToBytesBE(n, len).reverse();
  };
  var numberToVarBytesBE = function(n) {
    return hexToBytes$2(numberToHexUnpadded$1(n));
  };
  var ensureBytes$2 = function(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes$2(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (u8a(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  };
  var concatBytes$2 = function(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  };
  var equalBytes$1 = function(b1, b2) {
    if (b1.length !== b2.length)
      return false;
    for (let i = 0;i < b1.length; i++)
      if (b1[i] !== b2[i])
        return false;
    return true;
  };
  var utf8ToBytes = function(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  };
  var bitLen = function(n) {
    let len;
    for (len = 0;n > _0n$7; n >>= _1n$9, len += 1)
      ;
    return len;
  };
  var bitGet = function(n, pos) {
    return n >> BigInt(pos) & _1n$9;
  };
  var createHmacDrbg = function(hashLen2, qByteLen, hmacFn) {
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen2);
    let k = u8n(hashLen2);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n()) => {
      k = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8fr([1]), seed);
      v = h();
    };
    const gen = () => {
      if (i++ >= 1000)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes$2(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = undefined;
      while (!(res = pred(gen())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  };
  var validateObject = function(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object[fieldName];
      if (isOptional && val === undefined)
        return;
      if (!checkVal(val, object)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  };
  var mod$2 = function(a, b) {
    const result = a % b;
    return result >= _0n$6 ? result : b + result;
  };
  var pow = function(num, power, modulo) {
    if (modulo <= _0n$6 || power < _0n$6)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n$8)
      return _0n$6;
    let res = _1n$8;
    while (power > _0n$6) {
      if (power & _1n$8)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n$8;
    }
    return res;
  };
  var pow2$2 = function(x, power, modulo) {
    let res = x;
    while (power-- > _0n$6) {
      res *= res;
      res %= modulo;
    }
    return res;
  };
  var invert$2 = function(number2, modulo) {
    if (number2 === _0n$6 || modulo <= _0n$6) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a = mod$2(number2, modulo);
    let b = modulo;
    let x = _0n$6, u = _1n$8;
    while (a !== _0n$6) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      b = a, a = r, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n$8)
      throw new Error("invert: does not exist");
    return mod$2(x, modulo);
  };
  var tonelliShanks = function(P) {
    const legendreC = (P - _1n$8) / _2n$5;
    let Q, S, Z;
    for (Q = P - _1n$8, S = 0;Q % _2n$5 === _0n$6; Q /= _2n$5, S++)
      ;
    for (Z = _2n$5;Z < P && pow(Z, legendreC, P) !== P - _1n$8; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n$8) / _4n;
      return function tonelliFast(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n$8) / _2n$5;
    return function tonelliSlow(Fp2, n) {
      if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
      let x = Fp2.pow(n, Q1div2);
      let b = Fp2.pow(n, Q);
      while (!Fp2.eql(b, Fp2.ONE)) {
        if (Fp2.eql(b, Fp2.ZERO))
          return Fp2.ZERO;
        let m = 1;
        for (let t2 = Fp2.sqr(b);m < r; m++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge = Fp2.pow(g, _1n$8 << BigInt(r - m - 1));
        g = Fp2.sqr(ge);
        x = Fp2.mul(x, ge);
        b = Fp2.mul(b, g);
        r = m;
      }
      return x;
    };
  };
  var FpSqrt = function(P) {
    if (P % _4n === _3n$2) {
      const p1div4 = (P + _1n$8) / _4n;
      return function sqrt3mod4(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n$3 === _5n$1) {
      const c1 = (P - _5n$1) / _8n$3;
      return function sqrt5mod8(Fp2, n) {
        const n2 = Fp2.mul(n, _2n$5);
        const v = Fp2.pow(n2, c1);
        const nv = Fp2.mul(n, v);
        const i = Fp2.mul(Fp2.mul(nv, _2n$5), v);
        const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    return tonelliShanks(P);
  };
  var validateField = function(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map2, val) => {
      map2[val] = "function";
      return map2;
    }, initial);
    return validateObject(field, opts);
  };
  var FpPow = function(f, num, power) {
    if (power < _0n$6)
      throw new Error("Expected power > 0");
    if (power === _0n$6)
      return f.ONE;
    if (power === _1n$8)
      return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n$6) {
      if (power & _1n$8)
        p = f.mul(p, d);
      d = f.sqr(d);
      power >>= _1n$8;
    }
    return p;
  };
  var FpInvertBatch = function(f, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = acc;
      return f.mul(acc, num);
    }, f.ONE);
    const inverted = f.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = f.mul(acc, tmp[i]);
      return f.mul(acc, num);
    }, inverted);
    return tmp;
  };
  var nLength = function(n, nBitLength) {
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  };
  var Field = function(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n$6)
      throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n$6,
      ONE: _1n$8,
      create: (num) => mod$2(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n$6 <= num && num < ORDER;
      },
      is0: (num) => num === _0n$6,
      isOdd: (num) => (num & _1n$8) === _1n$8,
      neg: (num) => mod$2(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod$2(num * num, ORDER),
      add: (lhs, rhs) => mod$2(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod$2(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod$2(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f, num, power),
      div: (lhs, rhs) => mod$2(lhs * invert$2(rhs, ORDER), ORDER),
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert$2(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
      invertBatch: (lst) => FpInvertBatch(f, lst),
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE$1(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f);
  };
  var FpSqrtEven = function(Fp2, elm) {
    if (!Fp2.isOdd)
      throw new Error(`Field doesn't have isOdd`);
    const root = Fp2.sqrt(elm);
    return Fp2.isOdd(root) ? Fp2.neg(root) : root;
  };
  var hashToPrivateScalar = function(hash2, groupOrder, isLE2 = false) {
    hash2 = ensureBytes$2("privateHash", hash2);
    const hashLen2 = hash2.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen2 < minLen || hashLen2 > 1024)
      throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen2}`);
    const num = isLE2 ? bytesToNumberLE$1(hash2) : bytesToNumberBE(hash2);
    return mod$2(num, groupOrder - _1n$8) + _1n$8;
  };
  var wNAF = function(c, bits2) {
    const constTimeNegate2 = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W) => {
      const windows = Math.ceil(bits2 / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate: constTimeNegate2,
      unsafeLadder(elm, n) {
        let p = c.ZERO;
        let d = elm;
        while (n > _0n$5) {
          if (n & _1n$7)
            p = p.add(d);
          d = d.double();
          n >>= _1n$7;
        }
        return p;
      },
      precomputeWindow(elm, W) {
        const { windows, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base3 = p;
        for (let window2 = 0;window2 < windows; window2++) {
          base3 = p;
          points.push(base3);
          for (let i = 1;i < windowSize; i++) {
            base3 = base3.add(p);
            points.push(base3);
          }
          p = base3.double();
        }
        return points;
      },
      wNAF(W, precomputes, n) {
        const { windows, windowSize } = opts(W);
        let p = c.ZERO;
        let f = c.BASE;
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0;window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n$7;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate2(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate2(cond2, precomputes[offset2]));
          }
        }
        return { p, f };
      },
      wNAFCached(P, precomputesMap, n, transform) {
        const W = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n);
      }
    };
  };
  var validateBasic = function(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  };
  var validateOpts$2 = function(curve) {
    const opts = validateBasic(curve);
    validateObject(curve, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  };
  var twistedEdwards = function(curveDef) {
    const CURVE2 = validateOpts$2(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE2;
    const MASK = _2n$4 << BigInt(nByteLength * 8) - _1n$6;
    const modP = Fp2.create;
    const uvRatio2 = CURVE2.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v)) };
      } catch (e) {
        return { isValid: false, value: _0n$4 };
      }
    });
    const adjustScalarBytes2 = CURVE2.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = CURVE2.domain || ((data, ctx, phflag) => {
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    const inBig = (n) => typeof n === "bigint" && _0n$4 < n;
    const inRange = (n, max) => inBig(n) && inBig(max) && n < max;
    const in0MaskRange = (n) => n === _0n$4 || inRange(n, MASK);
    function assertInRange(n, max) {
      if (inRange(n, max))
        return n;
      throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
    }
    function assertGE0(n) {
      return n === _0n$4 ? n : assertInRange(n, CURVE_ORDER);
    }
    const pointPrecomputes2 = new Map;
    function isPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ExtendedPoint expected");
    }

    class Point2 {
      constructor(ex, ey, ez, et) {
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et;
        if (!in0MaskRange(ex))
          throw new Error("x required");
        if (!in0MaskRange(ey))
          throw new Error("y required");
        if (!in0MaskRange(ez))
          throw new Error("z required");
        if (!in0MaskRange(et))
          throw new Error("t required");
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point2)
          throw new Error("extended point not allowed");
        const { x, y } = p || {};
        if (!in0MaskRange(x) || !in0MaskRange(y))
          throw new Error("invalid affine point");
        return new Point2(x, y, _1n$6, modP(x * y));
      }
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p) => p.ez));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes2.delete(this);
      }
      assertValidity() {
        const { a, d } = CURVE2;
        if (this.is0())
          throw new Error("bad point: ZERO");
        const { ex: X, ey: Y, ez: Z, et: T } = this;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left2 = modP(Z2 * modP(aX2 + Y2));
        const right2 = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left2 !== right2)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
      }
      equals(other) {
        isPoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      negate() {
        return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      double() {
        const { a } = CURVE2;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n$4 * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G2 = D + B;
        const F = G2 - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point2(X3, Y3, Z3, T3);
      }
      add(other) {
        isPoint(other);
        const { a, d } = CURVE2;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        if (a === BigInt(-1)) {
          const A2 = modP((Y1 - X1) * (Y2 + X2));
          const B2 = modP((Y1 + X1) * (Y2 - X2));
          const F2 = modP(B2 - A2);
          if (F2 === _0n$4)
            return this.double();
          const C2 = modP(Z1 * _2n$4 * T2);
          const D2 = modP(T1 * _2n$4 * Z2);
          const E2 = D2 + C2;
          const G3 = B2 + A2;
          const H2 = D2 - C2;
          const X32 = modP(E2 * F2);
          const Y32 = modP(G3 * H2);
          const T32 = modP(E2 * H2);
          const Z32 = modP(F2 * G3);
          return new Point2(X32, Y32, Z32, T32);
        }
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G2 = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point2(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes2, n, Point2.normalizeZ);
      }
      multiply(scalar) {
        const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
        return Point2.normalizeZ([p, f])[0];
      }
      multiplyUnsafe(scalar) {
        let n = assertGE0(scalar);
        if (n === _0n$4)
          return I;
        if (this.equals(I) || n === _1n$6)
          return this;
        if (this.equals(G))
          return this.wNAF(n).p;
        return wnaf.unsafeLadder(this, n);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      toAffine(iz) {
        const { ex: x, ey: y, ez: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? _8n$2 : Fp2.inv(z);
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0)
          return { x: _0n$4, y: _1n$6 };
        if (zz !== _1n$6)
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE2;
        if (cofactor2 === _1n$6)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      static fromHex(hex, zip215 = false) {
        const { d, a } = CURVE2;
        const len = Fp2.BYTES;
        hex = ensureBytes$2("pointHex", hex, len);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y = bytesToNumberLE$1(normed);
        if (y === _0n$4)
          ;
        else {
          if (zip215)
            assertInRange(y, MASK);
          else
            assertInRange(y, Fp2.ORDER);
        }
        const y2 = modP(y * y);
        const u = modP(y2 - _1n$6);
        const v = modP(d * y2 - a);
        let { isValid, value: x } = uvRatio2(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n$6) === _1n$6;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n$4 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point2.fromAffine({ x, y });
      }
      static fromPrivateKey(privKey) {
        return getExtendedPublicKey2(privKey).point;
      }
      toRawBytes() {
        const { x, y } = this.toAffine();
        const bytes2 = numberToBytesLE(y, Fp2.BYTES);
        bytes2[bytes2.length - 1] |= x & _1n$6 ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex$2(this.toRawBytes());
      }
    }
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, _1n$6, modP(CURVE2.Gx * CURVE2.Gy));
    Point2.ZERO = new Point2(_0n$4, _1n$6, _1n$6, _0n$4);
    const { BASE: G, ZERO: I } = Point2;
    const wnaf = wNAF(Point2, nByteLength * 8);
    function modN(a) {
      return mod$2(a, CURVE_ORDER);
    }
    function modN_LE(hash2) {
      return modN(bytesToNumberLE$1(hash2));
    }
    function getExtendedPublicKey2(key) {
      const len = nByteLength;
      key = ensureBytes$2("private key", key, len);
      const hashed = ensureBytes$2("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes2(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      const point = G.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey2(privKey) {
      return getExtendedPublicKey2(privKey).pointBytes;
    }
    function hashDomainToScalar(context = new Uint8Array, ...msgs) {
      const msg = concatBytes$2(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes$2("context", context), !!prehash)));
    }
    function sign2(msg, privKey, options = {}) {
      msg = ensureBytes$2("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey2(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R2 = G.multiply(r).toRawBytes();
      const k = hashDomainToScalar(options.context, R2, pointBytes, msg);
      const s2 = modN(r + k * scalar);
      assertGE0(s2);
      const res = concatBytes$2(R2, numberToBytesLE(s2, Fp2.BYTES));
      return ensureBytes$2("result", res, nByteLength * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify2(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp2.BYTES;
      sig = ensureBytes$2("signature", sig, 2 * len);
      msg = ensureBytes$2("message", msg);
      if (prehash)
        msg = prehash(msg);
      const s2 = bytesToNumberLE$1(sig.slice(len, 2 * len));
      let A, R2, SB;
      try {
        A = Point2.fromHex(publicKey, zip215);
        R2 = Point2.fromHex(sig.slice(0, len), zip215);
        SB = G.multiplyUnsafe(s2);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R2.toRawBytes(), A.toRawBytes(), msg);
      const RkA = R2.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);
    }
    G._setWindowSize(8);
    const utils2 = {
      getExtendedPublicKey: getExtendedPublicKey2,
      randomPrivateKey: () => randomBytes2(Fp2.BYTES),
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE: CURVE2,
      getPublicKey: getPublicKey2,
      sign: sign2,
      verify: verify2,
      ExtendedPoint: Point2,
      utils: utils2
    };
  };
  var validateOpts$1 = function(curve) {
    validateObject(curve, {
      a: "bigint"
    }, {
      montgomeryBits: "isSafeInteger",
      nByteLength: "isSafeInteger",
      adjustScalarBytes: "function",
      domain: "function",
      powPminus2: "function",
      Gu: "bigint"
    });
    return Object.freeze({ ...curve });
  };
  var montgomery = function(curveDef) {
    const CURVE2 = validateOpts$1(curveDef);
    const { P } = CURVE2;
    const modP = (n) => mod$2(n, P);
    const montgomeryBits = CURVE2.montgomeryBits;
    const montgomeryBytes = Math.ceil(montgomeryBits / 8);
    const fieldLen2 = CURVE2.nByteLength;
    const adjustScalarBytes2 = CURVE2.adjustScalarBytes || ((bytes2) => bytes2);
    const powPminus2 = CURVE2.powPminus2 || ((x) => pow(x, P - BigInt(2), P));
    function cswap(swap, x_2, x_3) {
      const dummy = modP(swap * (x_2 - x_3));
      x_2 = modP(x_2 - dummy);
      x_3 = modP(x_3 + dummy);
      return [x_2, x_3];
    }
    function assertFieldElement(n) {
      if (typeof n === "bigint" && _0n$3 <= n && n < P)
        return n;
      throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
    }
    const a24 = (CURVE2.a - BigInt(2)) / BigInt(4);
    function montgomeryLadder(pointU, scalar) {
      const u = assertFieldElement(pointU);
      const k = assertFieldElement(scalar);
      const x_1 = u;
      let x_2 = _1n$5;
      let z_2 = _0n$3;
      let x_3 = u;
      let z_3 = _1n$5;
      let swap = _0n$3;
      let sw;
      for (let t = BigInt(montgomeryBits - 1);t >= _0n$3; t--) {
        const k_t = k >> t & _1n$5;
        swap ^= k_t;
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        swap = k_t;
        const A = x_2 + z_2;
        const AA = modP(A * A);
        const B = x_2 - z_2;
        const BB = modP(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = modP(D * A);
        const CB = modP(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = modP(dacb * dacb);
        z_3 = modP(x_1 * modP(da_cb * da_cb));
        x_2 = modP(AA * BB);
        z_2 = modP(E * (AA + modP(a24 * E)));
      }
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      const z2 = powPminus2(z_2);
      return modP(x_2 * z2);
    }
    function encodeUCoordinate(u) {
      return numberToBytesLE(modP(u), montgomeryBytes);
    }
    function decodeUCoordinate(uEnc) {
      const u = ensureBytes$2("u coordinate", uEnc, montgomeryBytes);
      if (fieldLen2 === montgomeryBytes)
        u[fieldLen2 - 1] &= 127;
      return bytesToNumberLE$1(u);
    }
    function decodeScalar(n) {
      const bytes2 = ensureBytes$2("scalar", n);
      if (bytes2.length !== montgomeryBytes && bytes2.length !== fieldLen2)
        throw new Error(`Expected ${montgomeryBytes} or ${fieldLen2} bytes, got ${bytes2.length}`);
      return bytesToNumberLE$1(adjustScalarBytes2(bytes2));
    }
    function scalarMult(scalar, u) {
      const pointU = decodeUCoordinate(u);
      const _scalar = decodeScalar(scalar);
      const pu = montgomeryLadder(pointU, _scalar);
      if (pu === _0n$3)
        throw new Error("Invalid private or public key received");
      return encodeUCoordinate(pu);
    }
    const GuBytes = encodeUCoordinate(CURVE2.Gu);
    function scalarMultBase(scalar) {
      return scalarMult(scalar, GuBytes);
    }
    return {
      scalarMult,
      scalarMultBase,
      getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
      getPublicKey: (privateKey) => scalarMultBase(privateKey),
      utils: { randomPrivateKey: () => CURVE2.randomBytes(CURVE2.nByteLength) },
      GuBytes
    };
  };
  var ed25519_pow_2_252_3 = function(x) {
    const P = ED25519_P;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2$2(b2, _2n$3, P) * b2 % P;
    const b5 = pow2$2(b4, _1n$4, P) * x % P;
    const b10 = pow2$2(b5, _5n, P) * b5 % P;
    const b20 = pow2$2(b10, _10n, P) * b10 % P;
    const b40 = pow2$2(b20, _20n, P) * b20 % P;
    const b80 = pow2$2(b40, _40n, P) * b40 % P;
    const b160 = pow2$2(b80, _80n, P) * b80 % P;
    const b240 = pow2$2(b160, _80n, P) * b80 % P;
    const b250 = pow2$2(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = pow2$2(b250, _2n$3, P) * x % P;
    return { pow_p_5_8, b2 };
  };
  var adjustScalarBytes = function(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  };
  var uvRatio$1 = function(u, v) {
    const P = ED25519_P;
    const v3 = mod$2(v * v * v, P);
    const v7 = mod$2(v3 * v3 * v, P);
    const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod$2(u * v3 * pow3, P);
    const vx2 = mod$2(v * x * x, P);
    const root1 = x;
    const root2 = mod$2(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod$2(-u, P);
    const noRoot = vx2 === mod$2(-u * ED25519_SQRT_M1, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE(x, P))
      x = mod$2(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  };
  var ed25519_domain = function(data, ctx, phflag) {
    if (ctx.length > 255)
      throw new Error("Context is too big");
    return concatBytes$3(utf8ToBytes$1("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
  };
  var extract = function(hash2, ikm, salt) {
    hash$3(hash2);
    if (salt === undefined)
      salt = new Uint8Array(hash2.outputLen);
    return hmac$2(hash2, toBytes$3(salt), toBytes$3(ikm));
  };
  var expand = function(hash2, prk, info, length2 = 32) {
    hash$3(hash2);
    number$2(length2);
    if (length2 > 255 * hash2.outputLen)
      throw new Error("Length should be <= 255*HashLen");
    const blocks = Math.ceil(length2 / hash2.outputLen);
    if (info === undefined)
      info = EMPTY_BUFFER;
    const okm = new Uint8Array(blocks * hash2.outputLen);
    const HMAC2 = hmac$2.create(hash2, prk);
    const HMACTmp = HMAC2._cloneInto();
    const T = new Uint8Array(HMAC2.outputLen);
    for (let counter2 = 0;counter2 < blocks; counter2++) {
      HKDF_COUNTER[0] = counter2 + 1;
      HMACTmp.update(counter2 === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
      okm.set(T, hash2.outputLen * counter2);
      HMAC2._cloneInto(HMACTmp);
    }
    HMAC2.destroy();
    HMACTmp.destroy();
    T.fill(0);
    HKDF_COUNTER.fill(0);
    return okm.slice(0, length2);
  };
  var encode0 = function(message2) {
    return concat$1([message2.ne, message2.ciphertext], message2.ne.length + message2.ciphertext.length);
  };
  var encode1 = function(message2) {
    return concat$1([message2.ne, message2.ns, message2.ciphertext], message2.ne.length + message2.ns.length + message2.ciphertext.length);
  };
  var encode2 = function(message2) {
    return concat$1([message2.ns, message2.ciphertext], message2.ns.length + message2.ciphertext.length);
  };
  var decode0 = function(input) {
    if (input.length < 32) {
      throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
    }
    return {
      ne: input.subarray(0, 32),
      ciphertext: input.subarray(32, input.length),
      ns: new Uint8Array(0)
    };
  };
  var decode1 = function(input) {
    if (input.length < 80) {
      throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
    }
    return {
      ne: input.subarray(0, 32),
      ns: input.subarray(32, 80),
      ciphertext: input.subarray(80, input.length)
    };
  };
  var decode2 = function(input) {
    if (input.length < 48) {
      throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
    }
    return {
      ne: new Uint8Array(0),
      ns: input.subarray(0, 48),
      ciphertext: input.subarray(48, input.length)
    };
  };
  var encryptStream = function(handshake2, metrics) {
    return async function* (source2) {
      for await (const chunk of source2) {
        for (let i = 0;i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
          let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
          if (end > chunk.length) {
            end = chunk.length;
          }
          const data = handshake2.encrypt(chunk.subarray(i, end), handshake2.session);
          metrics?.encryptedPackets.increment();
          yield uint16BEEncode(data.byteLength);
          yield data;
        }
      }
    };
  };
  var decryptStream = function(handshake2, metrics) {
    return async function* (source2) {
      for await (const chunk of source2) {
        for (let i = 0;i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
          let end = i + NOISE_MSG_MAX_LENGTH_BYTES;
          if (end > chunk.length) {
            end = chunk.length;
          }
          if (end - CHACHA_TAG_LENGTH < i) {
            throw new Error("Invalid chunk");
          }
          const encrypted = chunk.subarray(i, end);
          const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);
          const { plaintext: decrypted, valid } = handshake2.decrypt(encrypted, handshake2.session, dst);
          if (!valid) {
            metrics?.decryptErrors.increment();
            throw new Error("Failed to validate decrypted chunk");
          }
          metrics?.decryptedPackets.increment();
          yield decrypted;
        }
      }
    };
  };
  var _encodeWithByteBuffer = function(input, alphabet2) {
    var i = 0;
    var base3 = alphabet2.length;
    var first2 = alphabet2.charAt(0);
    var digits = [0];
    for (i = 0;i < input.length(); ++i) {
      for (var j = 0, carry = input.at(i);j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base3;
        carry = carry / base3 | 0;
      }
      while (carry > 0) {
        digits.push(carry % base3);
        carry = carry / base3 | 0;
      }
    }
    var output2 = "";
    for (i = 0;input.at(i) === 0 && i < input.length() - 1; ++i) {
      output2 += first2;
    }
    for (i = digits.length - 1;i >= 0; --i) {
      output2 += alphabet2[digits[i]];
    }
    return output2;
  };
  var _checkBitsParam = function(n) {
    if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
      throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
    }
  };
  var ByteStringBuffer = function(b) {
    this.data = "";
    this.read = 0;
    if (typeof b === "string") {
      this.data = b;
    } else if (util$2.isArrayBuffer(b) || util$2.isArrayBufferView(b)) {
      if (typeof Buffer !== "undefined" && b instanceof Buffer) {
        this.data = b.toString("binary");
      } else {
        var arr = new Uint8Array(b);
        try {
          this.data = String.fromCharCode.apply(null, arr);
        } catch (e) {
          for (var i = 0;i < arr.length; ++i) {
            this.putByte(arr[i]);
          }
        }
      }
    } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
      this.data = b.data;
      this.read = b.read;
    }
    this._constructedStringLength = 0;
  };
  var DataBuffer = function(b, options) {
    options = options || {};
    this.read = options.readOffset || 0;
    this.growSize = options.growSize || 1024;
    var isArrayBuffer2 = util$2.isArrayBuffer(b);
    var isArrayBufferView = util$2.isArrayBufferView(b);
    if (isArrayBuffer2 || isArrayBufferView) {
      if (isArrayBuffer2) {
        this.data = new DataView(b);
      } else {
        this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
      }
      this.write = ("writeOffset" in options) ? options.writeOffset : this.data.byteLength;
      return;
    }
    this.data = new DataView(new ArrayBuffer(0));
    this.write = 0;
    if (b !== null && b !== undefined) {
      this.putBytes(b);
    }
    if ("writeOffset" in options) {
      this.write = options.writeOffset;
    }
  };
  var _IN = function(id, name2) {
    oids$1[id] = name2;
    oids$1[name2] = id;
  };
  var _I_ = function(id, name2) {
    oids$1[id] = name2;
  };
  var _checkBufferLength = function(bytes2, remaining, n) {
    if (n > remaining) {
      var error = new Error("Too few bytes to parse DER.");
      error.available = bytes2.length();
      error.remaining = remaining;
      error.requested = n;
      throw error;
    }
  };
  var _fromDer = function(bytes2, remaining, depth, options) {
    var start;
    _checkBufferLength(bytes2, remaining, 2);
    var b1 = bytes2.getByte();
    remaining--;
    var tagClass = b1 & 192;
    var type = b1 & 31;
    start = bytes2.length();
    var length2 = _getValueLength(bytes2, remaining);
    remaining -= start - bytes2.length();
    if (length2 !== undefined && length2 > remaining) {
      if (options.strict) {
        var error = new Error("Too few bytes to read ASN.1 value.");
        error.available = bytes2.length();
        error.remaining = remaining;
        error.requested = length2;
        throw error;
      }
      length2 = remaining;
    }
    var value;
    var bitStringContents;
    var constructed = (b1 & 32) === 32;
    if (constructed) {
      value = [];
      if (length2 === undefined) {
        for (;; ) {
          _checkBufferLength(bytes2, remaining, 2);
          if (bytes2.bytes(2) === String.fromCharCode(0, 0)) {
            bytes2.getBytes(2);
            remaining -= 2;
            break;
          }
          start = bytes2.length();
          value.push(_fromDer(bytes2, remaining, depth + 1, options));
          remaining -= start - bytes2.length();
        }
      } else {
        while (length2 > 0) {
          start = bytes2.length();
          value.push(_fromDer(bytes2, length2, depth + 1, options));
          remaining -= start - bytes2.length();
          length2 -= start - bytes2.length();
        }
      }
    }
    if (value === undefined && tagClass === asn1$2.Class.UNIVERSAL && type === asn1$2.Type.BITSTRING) {
      bitStringContents = bytes2.bytes(length2);
    }
    if (value === undefined && options.decodeBitStrings && tagClass === asn1$2.Class.UNIVERSAL && type === asn1$2.Type.BITSTRING && length2 > 1) {
      var savedRead = bytes2.read;
      var savedRemaining = remaining;
      var unused = 0;
      if (type === asn1$2.Type.BITSTRING) {
        _checkBufferLength(bytes2, remaining, 1);
        unused = bytes2.getByte();
        remaining--;
      }
      if (unused === 0) {
        try {
          start = bytes2.length();
          var subOptions = {
            strict: true,
            decodeBitStrings: true
          };
          var composed = _fromDer(bytes2, remaining, depth + 1, subOptions);
          var used = start - bytes2.length();
          remaining -= used;
          if (type == asn1$2.Type.BITSTRING) {
            used++;
          }
          var tc = composed.tagClass;
          if (used === length2 && (tc === asn1$2.Class.UNIVERSAL || tc === asn1$2.Class.CONTEXT_SPECIFIC)) {
            value = [composed];
          }
        } catch (ex) {
        }
      }
      if (value === undefined) {
        bytes2.read = savedRead;
        remaining = savedRemaining;
      }
    }
    if (value === undefined) {
      if (length2 === undefined) {
        if (options.strict) {
          throw new Error("Non-constructed ASN.1 object of indefinite length.");
        }
        length2 = remaining;
      }
      if (type === asn1$2.Type.BMPSTRING) {
        value = "";
        for (;length2 > 0; length2 -= 2) {
          _checkBufferLength(bytes2, remaining, 2);
          value += String.fromCharCode(bytes2.getInt16());
          remaining -= 2;
        }
      } else {
        value = bytes2.getBytes(length2);
        remaining -= length2;
      }
    }
    var asn1Options = bitStringContents === undefined ? null : {
      bitStringContents
    };
    return asn1$2.create(tagClass, type, constructed, value, asn1Options);
  };
  var transformIV = function(iv, blockSize) {
    if (typeof iv === "string") {
      iv = forge$h.util.createBuffer(iv);
    }
    if (forge$h.util.isArray(iv) && iv.length > 4) {
      var tmp = iv;
      iv = forge$h.util.createBuffer();
      for (var i = 0;i < tmp.length; ++i) {
        iv.putByte(tmp[i]);
      }
    }
    if (iv.length() < blockSize) {
      throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
    }
    if (!forge$h.util.isArray(iv)) {
      var ints = [];
      var blocks = blockSize / 4;
      for (var i = 0;i < blocks; ++i) {
        ints.push(iv.getInt32());
      }
      iv = ints;
    }
    return iv;
  };
  var inc32 = function(block) {
    block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
  };
  var from64To32 = function(num) {
    return [num / 4294967296 | 0, num & 4294967295];
  };
  var registerAlgorithm$1 = function(name2, mode) {
    var factory = function() {
      return new forge$g.aes.Algorithm(name2, mode);
    };
    forge$g.cipher.registerAlgorithm(name2, factory);
  };
  var initialize = function() {
    init = true;
    rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    var xtime = new Array(256);
    for (var i = 0;i < 128; ++i) {
      xtime[i] = i << 1;
      xtime[i + 128] = i + 128 << 1 ^ 283;
    }
    sbox = new Array(256);
    isbox = new Array(256);
    mix = new Array(4);
    imix = new Array(4);
    for (var i = 0;i < 4; ++i) {
      mix[i] = new Array(256);
      imix[i] = new Array(256);
    }
    var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
    for (var i = 0;i < 256; ++i) {
      sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
      sx = sx >> 8 ^ sx & 255 ^ 99;
      sbox[e] = sx;
      isbox[sx] = e;
      sx2 = xtime[sx];
      e2 = xtime[e];
      e4 = xtime[e2];
      e8 = xtime[e4];
      me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
      ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
      for (var n = 0;n < 4; ++n) {
        mix[n][e] = me;
        imix[n][sx] = ime;
        me = me << 24 | me >>> 8;
        ime = ime << 24 | ime >>> 8;
      }
      if (e === 0) {
        e = ei = 1;
      } else {
        e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
        ei ^= xtime[xtime[ei]];
      }
    }
  };
  var _expandKey = function(key, decrypt2) {
    var w = key.slice(0);
    var temp, iNk = 1;
    var Nk = w.length;
    var Nr1 = Nk + 6 + 1;
    var end = Nb * Nr1;
    for (var i = Nk;i < end; ++i) {
      temp = w[i - 1];
      if (i % Nk === 0) {
        temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
        iNk++;
      } else if (Nk > 6 && i % Nk === 4) {
        temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
      }
      w[i] = w[i - Nk] ^ temp;
    }
    if (decrypt2) {
      var tmp;
      var m0 = imix[0];
      var m1 = imix[1];
      var m2 = imix[2];
      var m3 = imix[3];
      var wnew = w.slice(0);
      end = w.length;
      for (var i = 0, wi = end - Nb;i < end; i += Nb, wi -= Nb) {
        if (i === 0 || i === end - Nb) {
          wnew[i] = w[wi];
          wnew[i + 1] = w[wi + 3];
          wnew[i + 2] = w[wi + 2];
          wnew[i + 3] = w[wi + 1];
        } else {
          for (var n = 0;n < Nb; ++n) {
            tmp = w[wi + n];
            wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
          }
        }
      }
      w = wnew;
    }
    return w;
  };
  var _updateBlock$1 = function(w, input, output2, decrypt2) {
    var Nr = w.length / 4 - 1;
    var m0, m1, m2, m3, sub;
    if (decrypt2) {
      m0 = imix[0];
      m1 = imix[1];
      m2 = imix[2];
      m3 = imix[3];
      sub = isbox;
    } else {
      m0 = mix[0];
      m1 = mix[1];
      m2 = mix[2];
      m3 = mix[3];
      sub = sbox;
    }
    var a, b, c, d, a2, b2, c2;
    a = input[0] ^ w[0];
    b = input[decrypt2 ? 3 : 1] ^ w[1];
    c = input[2] ^ w[2];
    d = input[decrypt2 ? 1 : 3] ^ w[3];
    var i = 3;
    for (var round = 1;round < Nr; ++round) {
      a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
      b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
      c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
      d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
      a = a2;
      b = b2;
      c = c2;
    }
    output2[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
    output2[decrypt2 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
    output2[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
    output2[decrypt2 ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
  };
  var _createCipher$1 = function(options) {
    options = options || {};
    var mode = (options.mode || "CBC").toUpperCase();
    var algorithm = "AES-" + mode;
    var cipher;
    if (options.decrypt) {
      cipher = forge$g.cipher.createDecipher(algorithm, options.key);
    } else {
      cipher = forge$g.cipher.createCipher(algorithm, options.key);
    }
    var start = cipher.start;
    cipher.start = function(iv, options2) {
      var output2 = null;
      if (options2 instanceof forge$g.util.ByteBuffer) {
        output2 = options2;
        options2 = {};
      }
      options2 = options2 || {};
      options2.output = output2;
      options2.iv = iv;
      start.call(cipher, options2);
    };
    return cipher;
  };
  var registerAlgorithm = function(name2, mode) {
    var factory = function() {
      return new forge$f.des.Algorithm(name2, mode);
    };
    forge$f.cipher.registerAlgorithm(name2, factory);
  };
  var _createKeys = function(key) {
    var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
    var iterations = key.length() > 8 ? 3 : 1;
    var keys = [];
    var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
    var n = 0, tmp;
    for (var j = 0;j < iterations; j++) {
      var left2 = key.getInt32();
      var right2 = key.getInt32();
      tmp = (left2 >>> 4 ^ right2) & 252645135;
      right2 ^= tmp;
      left2 ^= tmp << 4;
      tmp = (right2 >>> -16 ^ left2) & 65535;
      left2 ^= tmp;
      right2 ^= tmp << -16;
      tmp = (left2 >>> 2 ^ right2) & 858993459;
      right2 ^= tmp;
      left2 ^= tmp << 2;
      tmp = (right2 >>> -16 ^ left2) & 65535;
      left2 ^= tmp;
      right2 ^= tmp << -16;
      tmp = (left2 >>> 1 ^ right2) & 1431655765;
      right2 ^= tmp;
      left2 ^= tmp << 1;
      tmp = (right2 >>> 8 ^ left2) & 16711935;
      left2 ^= tmp;
      right2 ^= tmp << 8;
      tmp = (left2 >>> 1 ^ right2) & 1431655765;
      right2 ^= tmp;
      left2 ^= tmp << 1;
      tmp = left2 << 8 | right2 >>> 20 & 240;
      left2 = right2 << 24 | right2 << 8 & 16711680 | right2 >>> 8 & 65280 | right2 >>> 24 & 240;
      right2 = tmp;
      for (var i = 0;i < shifts.length; ++i) {
        if (shifts[i]) {
          left2 = left2 << 2 | left2 >>> 26;
          right2 = right2 << 2 | right2 >>> 26;
        } else {
          left2 = left2 << 1 | left2 >>> 27;
          right2 = right2 << 1 | right2 >>> 27;
        }
        left2 &= -15;
        right2 &= -15;
        var lefttmp = pc2bytes0[left2 >>> 28] | pc2bytes1[left2 >>> 24 & 15] | pc2bytes2[left2 >>> 20 & 15] | pc2bytes3[left2 >>> 16 & 15] | pc2bytes4[left2 >>> 12 & 15] | pc2bytes5[left2 >>> 8 & 15] | pc2bytes6[left2 >>> 4 & 15];
        var righttmp = pc2bytes7[right2 >>> 28] | pc2bytes8[right2 >>> 24 & 15] | pc2bytes9[right2 >>> 20 & 15] | pc2bytes10[right2 >>> 16 & 15] | pc2bytes11[right2 >>> 12 & 15] | pc2bytes12[right2 >>> 8 & 15] | pc2bytes13[right2 >>> 4 & 15];
        tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
        keys[n++] = lefttmp ^ tmp;
        keys[n++] = righttmp ^ tmp << 16;
      }
    }
    return keys;
  };
  var _updateBlock = function(keys, input, output2, decrypt2) {
    var iterations = keys.length === 32 ? 3 : 9;
    var looping;
    if (iterations === 3) {
      looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
    } else {
      looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
    }
    var tmp;
    var left2 = input[0];
    var right2 = input[1];
    tmp = (left2 >>> 4 ^ right2) & 252645135;
    right2 ^= tmp;
    left2 ^= tmp << 4;
    tmp = (left2 >>> 16 ^ right2) & 65535;
    right2 ^= tmp;
    left2 ^= tmp << 16;
    tmp = (right2 >>> 2 ^ left2) & 858993459;
    left2 ^= tmp;
    right2 ^= tmp << 2;
    tmp = (right2 >>> 8 ^ left2) & 16711935;
    left2 ^= tmp;
    right2 ^= tmp << 8;
    tmp = (left2 >>> 1 ^ right2) & 1431655765;
    right2 ^= tmp;
    left2 ^= tmp << 1;
    left2 = left2 << 1 | left2 >>> 31;
    right2 = right2 << 1 | right2 >>> 31;
    for (var j = 0;j < iterations; j += 3) {
      var endloop = looping[j + 1];
      var loopinc = looping[j + 2];
      for (var i = looping[j];i != endloop; i += loopinc) {
        var right1 = right2 ^ keys[i];
        var right22 = (right2 >>> 4 | right2 << 28) ^ keys[i + 1];
        tmp = left2;
        left2 = right2;
        right2 = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right22 >>> 24 & 63] | spfunction3[right22 >>> 16 & 63] | spfunction5[right22 >>> 8 & 63] | spfunction7[right22 & 63]);
      }
      tmp = left2;
      left2 = right2;
      right2 = tmp;
    }
    left2 = left2 >>> 1 | left2 << 31;
    right2 = right2 >>> 1 | right2 << 31;
    tmp = (left2 >>> 1 ^ right2) & 1431655765;
    right2 ^= tmp;
    left2 ^= tmp << 1;
    tmp = (right2 >>> 8 ^ left2) & 16711935;
    left2 ^= tmp;
    right2 ^= tmp << 8;
    tmp = (right2 >>> 2 ^ left2) & 858993459;
    left2 ^= tmp;
    right2 ^= tmp << 2;
    tmp = (left2 >>> 16 ^ right2) & 65535;
    right2 ^= tmp;
    left2 ^= tmp << 16;
    tmp = (left2 >>> 4 ^ right2) & 252645135;
    right2 ^= tmp;
    left2 ^= tmp << 4;
    output2[0] = left2;
    output2[1] = right2;
  };
  var _createCipher = function(options) {
    options = options || {};
    var mode = (options.mode || "CBC").toUpperCase();
    var algorithm = "DES-" + mode;
    var cipher;
    if (options.decrypt) {
      cipher = forge$f.cipher.createDecipher(algorithm, options.key);
    } else {
      cipher = forge$f.cipher.createCipher(algorithm, options.key);
    }
    var start = cipher.start;
    cipher.start = function(iv, options2) {
      var output2 = null;
      if (options2 instanceof forge$f.util.ByteBuffer) {
        output2 = options2;
        options2 = {};
      }
      options2 = options2 || {};
      options2.output = output2;
      options2.iv = iv;
      start.call(cipher, options2);
    };
    return cipher;
  };
  var foldHeader = function(header2) {
    var rval = header2.name + ": ";
    var values = [];
    var insertSpace = function(match, $1) {
      return " " + $1;
    };
    for (var i = 0;i < header2.values.length; ++i) {
      values.push(header2.values[i].replace(/^(\S+\r\n)/, insertSpace));
    }
    rval += values.join(",") + "\r\n";
    var length2 = 0;
    var candidate = -1;
    for (var i = 0;i < rval.length; ++i, ++length2) {
      if (length2 > 65 && candidate !== -1) {
        var insert = rval[candidate];
        if (insert === ",") {
          ++candidate;
          rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
        } else {
          rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
        }
        length2 = i - candidate - 1;
        candidate = -1;
        ++i;
      } else if (rval[i] === " " || rval[i] === "\t" || rval[i] === ",") {
        candidate = i;
      }
    }
    return rval;
  };
  var ltrim = function(str) {
    return str.replace(/^\s+/, "");
  };
  var _init$2 = function() {
    _padding$2 = String.fromCharCode(128);
    _padding$2 += forge$a.util.fillString(String.fromCharCode(0), 64);
    _k$1 = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    _initialized$2 = true;
  };
  var _update$2 = function(s2, w, bytes2) {
    var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
    var len = bytes2.length();
    while (len >= 64) {
      for (i = 0;i < 16; ++i) {
        w[i] = bytes2.getInt32();
      }
      for (;i < 64; ++i) {
        t1 = w[i - 2];
        t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        t2 = w[i - 15];
        t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
        w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
      }
      a = s2.h0;
      b = s2.h1;
      c = s2.h2;
      d = s2.h3;
      e = s2.h4;
      f = s2.h5;
      g = s2.h6;
      h = s2.h7;
      for (i = 0;i < 64; ++i) {
        s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
        ch = g ^ e & (f ^ g);
        s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
        maj = a & b | c & (a ^ b);
        t1 = h + s1 + ch + _k$1[i] + w[i];
        t2 = s0 + maj;
        h = g;
        g = f;
        f = e;
        e = d + t1 >>> 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 >>> 0;
      }
      s2.h0 = s2.h0 + a | 0;
      s2.h1 = s2.h1 + b | 0;
      s2.h2 = s2.h2 + c | 0;
      s2.h3 = s2.h3 + d | 0;
      s2.h4 = s2.h4 + e | 0;
      s2.h5 = s2.h5 + f | 0;
      s2.h6 = s2.h6 + g | 0;
      s2.h7 = s2.h7 + h | 0;
      len -= 64;
    }
  };
  var BigInteger$2 = function(a, b, c) {
    this.data = [];
    if (a != null)
      if (typeof a == "number")
        this.fromNumber(a, b, c);
      else if (b == null && typeof a != "string")
        this.fromString(a, 256);
      else
        this.fromString(a, b);
  };
  var nbi = function() {
    return new BigInteger$2(null);
  };
  var am1 = function(i, x, w, j, c, n) {
    while (--n >= 0) {
      var v = x * this.data[i++] + w.data[j] + c;
      c = Math.floor(v / 67108864);
      w.data[j++] = v & 67108863;
    }
    return c;
  };
  var am2 = function(i, x, w, j, c, n) {
    var xl = x & 32767, xh = x >> 15;
    while (--n >= 0) {
      var l = this.data[i] & 32767;
      var h = this.data[i++] >> 15;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
      w.data[j++] = l & 1073741823;
    }
    return c;
  };
  var am3 = function(i, x, w, j, c, n) {
    var xl = x & 16383, xh = x >> 14;
    while (--n >= 0) {
      var l = this.data[i] & 16383;
      var h = this.data[i++] >> 14;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
      c = (l >> 28) + (m >> 14) + xh * h;
      w.data[j++] = l & 268435455;
    }
    return c;
  };
  var int2char = function(n) {
    return BI_RM.charAt(n);
  };
  var intAt = function(s2, i) {
    var c = BI_RC[s2.charCodeAt(i)];
    return c == null ? -1 : c;
  };
  var bnpCopyTo = function(r) {
    for (var i = this.t - 1;i >= 0; --i)
      r.data[i] = this.data[i];
    r.t = this.t;
    r.s = this.s;
  };
  var bnpFromInt = function(x) {
    this.t = 1;
    this.s = x < 0 ? -1 : 0;
    if (x > 0)
      this.data[0] = x;
    else if (x < -1)
      this.data[0] = x + this.DV;
    else
      this.t = 0;
  };
  var nbv = function(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
  };
  var bnpFromString = function(s2, b) {
    var k;
    if (b == 16)
      k = 4;
    else if (b == 8)
      k = 3;
    else if (b == 256)
      k = 8;
    else if (b == 2)
      k = 1;
    else if (b == 32)
      k = 5;
    else if (b == 4)
      k = 2;
    else {
      this.fromRadix(s2, b);
      return;
    }
    this.t = 0;
    this.s = 0;
    var i = s2.length, mi = false, sh = 0;
    while (--i >= 0) {
      var x = k == 8 ? s2[i] & 255 : intAt(s2, i);
      if (x < 0) {
        if (s2.charAt(i) == "-")
          mi = true;
        continue;
      }
      mi = false;
      if (sh == 0)
        this.data[this.t++] = x;
      else if (sh + k > this.DB) {
        this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
        this.data[this.t++] = x >> this.DB - sh;
      } else
        this.data[this.t - 1] |= x << sh;
      sh += k;
      if (sh >= this.DB)
        sh -= this.DB;
    }
    if (k == 8 && (s2[0] & 128) != 0) {
      this.s = -1;
      if (sh > 0)
        this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
    }
    this.clamp();
    if (mi)
      BigInteger$2.ZERO.subTo(this, this);
  };
  var bnpClamp = function() {
    var c = this.s & this.DM;
    while (this.t > 0 && this.data[this.t - 1] == c)
      --this.t;
  };
  var bnToString = function(b) {
    if (this.s < 0)
      return "-" + this.negate().toString(b);
    var k;
    if (b == 16)
      k = 4;
    else if (b == 8)
      k = 3;
    else if (b == 2)
      k = 1;
    else if (b == 32)
      k = 5;
    else if (b == 4)
      k = 2;
    else
      return this.toRadix(b);
    var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
    var p = this.DB - i * this.DB % k;
    if (i-- > 0) {
      if (p < this.DB && (d = this.data[i] >> p) > 0) {
        m = true;
        r = int2char(d);
      }
      while (i >= 0) {
        if (p < k) {
          d = (this.data[i] & (1 << p) - 1) << k - p;
          d |= this.data[--i] >> (p += this.DB - k);
        } else {
          d = this.data[i] >> (p -= k) & km;
          if (p <= 0) {
            p += this.DB;
            --i;
          }
        }
        if (d > 0)
          m = true;
        if (m)
          r += int2char(d);
      }
    }
    return m ? r : "0";
  };
  var bnNegate = function() {
    var r = nbi();
    BigInteger$2.ZERO.subTo(this, r);
    return r;
  };
  var bnAbs = function() {
    return this.s < 0 ? this.negate() : this;
  };
  var bnCompareTo = function(a) {
    var r = this.s - a.s;
    if (r != 0)
      return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0)
      return this.s < 0 ? -r : r;
    while (--i >= 0)
      if ((r = this.data[i] - a.data[i]) != 0)
        return r;
    return 0;
  };
  var nbits = function(x) {
    var r = 1, t;
    if ((t = x >>> 16) != 0) {
      x = t;
      r += 16;
    }
    if ((t = x >> 8) != 0) {
      x = t;
      r += 8;
    }
    if ((t = x >> 4) != 0) {
      x = t;
      r += 4;
    }
    if ((t = x >> 2) != 0) {
      x = t;
      r += 2;
    }
    if ((t = x >> 1) != 0) {
      x = t;
      r += 1;
    }
    return r;
  };
  var bnBitLength = function() {
    if (this.t <= 0)
      return 0;
    return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
  };
  var bnpDLShiftTo = function(n, r) {
    var i;
    for (i = this.t - 1;i >= 0; --i)
      r.data[i + n] = this.data[i];
    for (i = n - 1;i >= 0; --i)
      r.data[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
  };
  var bnpDRShiftTo = function(n, r) {
    for (var i = n;i < this.t; ++i)
      r.data[i - n] = this.data[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
  };
  var bnpLShiftTo = function(n, r) {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
    for (i = this.t - 1;i >= 0; --i) {
      r.data[i + ds + 1] = this.data[i] >> cbs | c;
      c = (this.data[i] & bm) << bs;
    }
    for (i = ds - 1;i >= 0; --i)
      r.data[i] = 0;
    r.data[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
  };
  var bnpRShiftTo = function(n, r) {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t) {
      r.t = 0;
      return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r.data[0] = this.data[ds] >> bs;
    for (var i = ds + 1;i < this.t; ++i) {
      r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
      r.data[i - ds] = this.data[i] >> bs;
    }
    if (bs > 0)
      r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
  };
  var bnpSubTo = function(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
      c += this.data[i] - a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t) {
      c -= a.s;
      while (i < this.t) {
        c += this.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    } else {
      c += this.s;
      while (i < a.t) {
        c -= a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = c < 0 ? -1 : 0;
    if (c < -1)
      r.data[i++] = this.DV + c;
    else if (c > 0)
      r.data[i++] = c;
    r.t = i;
    r.clamp();
  };
  var bnpMultiplyTo = function(a, r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = 0;i < y.t; ++i)
      r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s)
      BigInteger$2.ZERO.subTo(r, r);
  };
  var bnpSquareTo = function(r) {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = 0;i < x.t - 1; ++i) {
      var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
      if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
        r.data[i + x.t] -= x.DV;
        r.data[i + x.t + 1] = 1;
      }
    }
    if (r.t > 0)
      r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
  };
  var bnpDivRemTo = function(m, q, r) {
    var pm = m.abs();
    if (pm.t <= 0)
      return;
    var pt = this.abs();
    if (pt.t < pm.t) {
      if (q != null)
        q.fromInt(0);
      if (r != null)
        this.copyTo(r);
      return;
    }
    if (r == null)
      r = nbi();
    var y = nbi(), ts = this.s, ms2 = m.s;
    var nsh = this.DB - nbits(pm.data[pm.t - 1]);
    if (nsh > 0) {
      pm.lShiftTo(nsh, y);
      pt.lShiftTo(nsh, r);
    } else {
      pm.copyTo(y);
      pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y.data[ys - 1];
    if (y0 == 0)
      return;
    var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
    var i = r.t, j = i - ys, t = q == null ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0) {
      r.data[r.t++] = 1;
      r.subTo(t, r);
    }
    BigInteger$2.ONE.dlShiftTo(ys, t);
    t.subTo(y, y);
    while (y.t < ys)
      y.data[y.t++] = 0;
    while (--j >= 0) {
      var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
      if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
        y.dlShiftTo(j, t);
        r.subTo(t, r);
        while (r.data[i] < --qd)
          r.subTo(t, r);
      }
    }
    if (q != null) {
      r.drShiftTo(ys, q);
      if (ts != ms2)
        BigInteger$2.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0)
      r.rShiftTo(nsh, r);
    if (ts < 0)
      BigInteger$2.ZERO.subTo(r, r);
  };
  var bnMod = function(a) {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(BigInteger$2.ZERO) > 0)
      a.subTo(r, r);
    return r;
  };
  var Classic = function(m) {
    this.m = m;
  };
  var cConvert = function(x) {
    if (x.s < 0 || x.compareTo(this.m) >= 0)
      return x.mod(this.m);
    else
      return x;
  };
  var cRevert = function(x) {
    return x;
  };
  var cReduce = function(x) {
    x.divRemTo(this.m, null, x);
  };
  var cMulTo = function(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  };
  var cSqrTo = function(x, r) {
    x.squareTo(r);
    this.reduce(r);
  };
  var bnpInvDigit = function() {
    if (this.t < 1)
      return 0;
    var x = this.data[0];
    if ((x & 1) == 0)
      return 0;
    var y = x & 3;
    y = y * (2 - (x & 15) * y) & 15;
    y = y * (2 - (x & 255) * y) & 255;
    y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
    y = y * (2 - x * y % this.DV) % this.DV;
    return y > 0 ? this.DV - y : -y;
  };
  var Montgomery = function(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 32767;
    this.mph = this.mp >> 15;
    this.um = (1 << m.DB - 15) - 1;
    this.mt2 = 2 * m.t;
  };
  var montConvert = function(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(BigInteger$2.ZERO) > 0)
      this.m.subTo(r, r);
    return r;
  };
  var montRevert = function(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  };
  var montReduce = function(x) {
    while (x.t <= this.mt2)
      x.data[x.t++] = 0;
    for (var i = 0;i < this.m.t; ++i) {
      var j = x.data[i] & 32767;
      var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
      j = i + this.m.t;
      x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
      while (x.data[j] >= x.DV) {
        x.data[j] -= x.DV;
        x.data[++j]++;
      }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0)
      x.subTo(this.m, x);
  };
  var montSqrTo = function(x, r) {
    x.squareTo(r);
    this.reduce(r);
  };
  var montMulTo = function(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  };
  var bnpIsEven = function() {
    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
  };
  var bnpExp = function(e, z) {
    if (e > 4294967295 || e < 1)
      return BigInteger$2.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0) {
      z.sqrTo(r, r2);
      if ((e & 1 << i) > 0)
        z.mulTo(r2, g, r);
      else {
        var t = r;
        r = r2;
        r2 = t;
      }
    }
    return z.revert(r);
  };
  var bnModPowInt = function(e, m) {
    var z;
    if (e < 256 || m.isEven())
      z = new Classic(m);
    else
      z = new Montgomery(m);
    return this.exp(e, z);
  };
  var bnClone = function() {
    var r = nbi();
    this.copyTo(r);
    return r;
  };
  var bnIntValue = function() {
    if (this.s < 0) {
      if (this.t == 1)
        return this.data[0] - this.DV;
      else if (this.t == 0)
        return -1;
    } else if (this.t == 1)
      return this.data[0];
    else if (this.t == 0)
      return 0;
    return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
  };
  var bnByteValue = function() {
    return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
  };
  var bnShortValue = function() {
    return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
  };
  var bnpChunkSize = function(r) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
  };
  var bnSigNum = function() {
    if (this.s < 0)
      return -1;
    else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
      return 0;
    else
      return 1;
  };
  var bnpToRadix = function(b) {
    if (b == null)
      b = 10;
    if (this.signum() == 0 || b < 2 || b > 36)
      return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0) {
      r = (a + z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
  };
  var bnpFromRadix = function(s2, b) {
    this.fromInt(0);
    if (b == null)
      b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
    for (var i = 0;i < s2.length; ++i) {
      var x = intAt(s2, i);
      if (x < 0) {
        if (s2.charAt(i) == "-" && this.signum() == 0)
          mi = true;
        continue;
      }
      w = b * w + x;
      if (++j >= cs) {
        this.dMultiply(d);
        this.dAddOffset(w, 0);
        j = 0;
        w = 0;
      }
    }
    if (j > 0) {
      this.dMultiply(Math.pow(b, j));
      this.dAddOffset(w, 0);
    }
    if (mi)
      BigInteger$2.ZERO.subTo(this, this);
  };
  var bnpFromNumber = function(a, b, c) {
    if (typeof b == "number") {
      if (a < 2)
        this.fromInt(1);
      else {
        this.fromNumber(a, c);
        if (!this.testBit(a - 1))
          this.bitwiseTo(BigInteger$2.ONE.shiftLeft(a - 1), op_or, this);
        if (this.isEven())
          this.dAddOffset(1, 0);
        while (!this.isProbablePrime(b)) {
          this.dAddOffset(2, 0);
          if (this.bitLength() > a)
            this.subTo(BigInteger$2.ONE.shiftLeft(a - 1), this);
        }
      }
    } else {
      var x = new Array, t = a & 7;
      x.length = (a >> 3) + 1;
      b.nextBytes(x);
      if (t > 0)
        x[0] &= (1 << t) - 1;
      else
        x[0] = 0;
      this.fromString(x, 256);
    }
  };
  var bnToByteArray = function() {
    var i = this.t, r = new Array;
    r[0] = this.s;
    var p = this.DB - i * this.DB % 8, d, k = 0;
    if (i-- > 0) {
      if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
        r[k++] = d | this.s << this.DB - p;
      while (i >= 0) {
        if (p < 8) {
          d = (this.data[i] & (1 << p) - 1) << 8 - p;
          d |= this.data[--i] >> (p += this.DB - 8);
        } else {
          d = this.data[i] >> (p -= 8) & 255;
          if (p <= 0) {
            p += this.DB;
            --i;
          }
        }
        if ((d & 128) != 0)
          d |= -256;
        if (k == 0 && (this.s & 128) != (d & 128))
          ++k;
        if (k > 0 || d != this.s)
          r[k++] = d;
      }
    }
    return r;
  };
  var bnEquals = function(a) {
    return this.compareTo(a) == 0;
  };
  var bnMin = function(a) {
    return this.compareTo(a) < 0 ? this : a;
  };
  var bnMax = function(a) {
    return this.compareTo(a) > 0 ? this : a;
  };
  var bnpBitwiseTo = function(a, op, r) {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0;i < m; ++i)
      r.data[i] = op(this.data[i], a.data[i]);
    if (a.t < this.t) {
      f = a.s & this.DM;
      for (i = m;i < this.t; ++i)
        r.data[i] = op(this.data[i], f);
      r.t = this.t;
    } else {
      f = this.s & this.DM;
      for (i = m;i < a.t; ++i)
        r.data[i] = op(f, a.data[i]);
      r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
  };
  var op_and = function(x, y) {
    return x & y;
  };
  var bnAnd = function(a) {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
  };
  var op_or = function(x, y) {
    return x | y;
  };
  var bnOr = function(a) {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
  };
  var op_xor = function(x, y) {
    return x ^ y;
  };
  var bnXor = function(a) {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
  };
  var op_andnot = function(x, y) {
    return x & ~y;
  };
  var bnAndNot = function(a) {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
  };
  var bnNot = function() {
    var r = nbi();
    for (var i = 0;i < this.t; ++i)
      r.data[i] = this.DM & ~this.data[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
  };
  var bnShiftLeft = function(n) {
    var r = nbi();
    if (n < 0)
      this.rShiftTo(-n, r);
    else
      this.lShiftTo(n, r);
    return r;
  };
  var bnShiftRight = function(n) {
    var r = nbi();
    if (n < 0)
      this.lShiftTo(-n, r);
    else
      this.rShiftTo(n, r);
    return r;
  };
  var lbit = function(x) {
    if (x == 0)
      return -1;
    var r = 0;
    if ((x & 65535) == 0) {
      x >>= 16;
      r += 16;
    }
    if ((x & 255) == 0) {
      x >>= 8;
      r += 8;
    }
    if ((x & 15) == 0) {
      x >>= 4;
      r += 4;
    }
    if ((x & 3) == 0) {
      x >>= 2;
      r += 2;
    }
    if ((x & 1) == 0)
      ++r;
    return r;
  };
  var bnGetLowestSetBit = function() {
    for (var i = 0;i < this.t; ++i)
      if (this.data[i] != 0)
        return i * this.DB + lbit(this.data[i]);
    if (this.s < 0)
      return this.t * this.DB;
    return -1;
  };
  var cbit = function(x) {
    var r = 0;
    while (x != 0) {
      x &= x - 1;
      ++r;
    }
    return r;
  };
  var bnBitCount = function() {
    var r = 0, x = this.s & this.DM;
    for (var i = 0;i < this.t; ++i)
      r += cbit(this.data[i] ^ x);
    return r;
  };
  var bnTestBit = function(n) {
    var j = Math.floor(n / this.DB);
    if (j >= this.t)
      return this.s != 0;
    return (this.data[j] & 1 << n % this.DB) != 0;
  };
  var bnpChangeBit = function(n, op) {
    var r = BigInteger$2.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
  };
  var bnSetBit = function(n) {
    return this.changeBit(n, op_or);
  };
  var bnClearBit = function(n) {
    return this.changeBit(n, op_andnot);
  };
  var bnFlipBit = function(n) {
    return this.changeBit(n, op_xor);
  };
  var bnpAddTo = function(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
      c += this.data[i] + a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t) {
      c += a.s;
      while (i < this.t) {
        c += this.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    } else {
      c += this.s;
      while (i < a.t) {
        c += a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = c < 0 ? -1 : 0;
    if (c > 0)
      r.data[i++] = c;
    else if (c < -1)
      r.data[i++] = this.DV + c;
    r.t = i;
    r.clamp();
  };
  var bnAdd = function(a) {
    var r = nbi();
    this.addTo(a, r);
    return r;
  };
  var bnSubtract = function(a) {
    var r = nbi();
    this.subTo(a, r);
    return r;
  };
  var bnMultiply = function(a) {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
  };
  var bnDivide = function(a) {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
  };
  var bnRemainder = function(a) {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
  };
  var bnDivideAndRemainder = function(a) {
    var q = nbi(), r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
  };
  var bnpDMultiply = function(n) {
    this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  };
  var bnpDAddOffset = function(n, w) {
    if (n == 0)
      return;
    while (this.t <= w)
      this.data[this.t++] = 0;
    this.data[w] += n;
    while (this.data[w] >= this.DV) {
      this.data[w] -= this.DV;
      if (++w >= this.t)
        this.data[this.t++] = 0;
      ++this.data[w];
    }
  };
  var NullExp = function() {
  };
  var nNop = function(x) {
    return x;
  };
  var nMulTo = function(x, y, r) {
    x.multiplyTo(y, r);
  };
  var nSqrTo = function(x, r) {
    x.squareTo(r);
  };
  var bnPow = function(e) {
    return this.exp(e, new NullExp);
  };
  var bnpMultiplyLowerTo = function(a, n, r) {
    var i = Math.min(this.t + a.t, n);
    r.s = 0;
    r.t = i;
    while (i > 0)
      r.data[--i] = 0;
    var j;
    for (j = r.t - this.t;i < j; ++i)
      r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n);i < j; ++i)
      this.am(0, a.data[i], r, i, 0, n - i);
    r.clamp();
  };
  var bnpMultiplyUpperTo = function(a, n, r) {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = Math.max(n - this.t, 0);i < a.t; ++i)
      r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
  };
  var Barrett = function(m) {
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger$2.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
  };
  var barrettConvert = function(x) {
    if (x.s < 0 || x.t > 2 * this.m.t)
      return x.mod(this.m);
    else if (x.compareTo(this.m) < 0)
      return x;
    else {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
  };
  var barrettRevert = function(x) {
    return x;
  };
  var barrettReduce = function(x) {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1) {
      x.t = this.m.t + 1;
      x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0)
      x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0)
      x.subTo(this.m, x);
  };
  var barrettSqrTo = function(x, r) {
    x.squareTo(r);
    this.reduce(r);
  };
  var barrettMulTo = function(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  };
  var bnModPow = function(e, m) {
    var i = e.bitLength(), k, r = nbv(1), z;
    if (i <= 0)
      return r;
    else if (i < 18)
      k = 1;
    else if (i < 48)
      k = 3;
    else if (i < 144)
      k = 4;
    else if (i < 768)
      k = 5;
    else
      k = 6;
    if (i < 8)
      z = new Classic(m);
    else if (m.isEven())
      z = new Barrett(m);
    else
      z = new Montgomery(m);
    var g = new Array, n = 3, k1 = k - 1, km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1) {
      var g2 = nbi();
      z.sqrTo(g[1], g2);
      while (n <= km) {
        g[n] = nbi();
        z.mulTo(g2, g[n - 2], g[n]);
        n += 2;
      }
    }
    var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
    i = nbits(e.data[j]) - 1;
    while (j >= 0) {
      if (i >= k1)
        w = e.data[j] >> i - k1 & km;
      else {
        w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
        if (j > 0)
          w |= e.data[j - 1] >> this.DB + i - k1;
      }
      n = k;
      while ((w & 1) == 0) {
        w >>= 1;
        --n;
      }
      if ((i -= n) < 0) {
        i += this.DB;
        --j;
      }
      if (is1) {
        g[w].copyTo(r);
        is1 = false;
      } else {
        while (n > 1) {
          z.sqrTo(r, r2);
          z.sqrTo(r2, r);
          n -= 2;
        }
        if (n > 0)
          z.sqrTo(r, r2);
        else {
          t = r;
          r = r2;
          r2 = t;
        }
        z.mulTo(r2, g[w], r);
      }
      while (j >= 0 && (e.data[j] & 1 << i) == 0) {
        z.sqrTo(r, r2);
        t = r;
        r = r2;
        r2 = t;
        if (--i < 0) {
          i = this.DB - 1;
          --j;
        }
      }
    }
    return z.revert(r);
  };
  var bnGCD = function(a) {
    var x = this.s < 0 ? this.negate() : this.clone();
    var y = a.s < 0 ? a.negate() : a.clone();
    if (x.compareTo(y) < 0) {
      var t = x;
      x = y;
      y = t;
    }
    var i = x.getLowestSetBit(), g = y.getLowestSetBit();
    if (g < 0)
      return x;
    if (i < g)
      g = i;
    if (g > 0) {
      x.rShiftTo(g, x);
      y.rShiftTo(g, y);
    }
    while (x.signum() > 0) {
      if ((i = x.getLowestSetBit()) > 0)
        x.rShiftTo(i, x);
      if ((i = y.getLowestSetBit()) > 0)
        y.rShiftTo(i, y);
      if (x.compareTo(y) >= 0) {
        x.subTo(y, x);
        x.rShiftTo(1, x);
      } else {
        y.subTo(x, y);
        y.rShiftTo(1, y);
      }
    }
    if (g > 0)
      y.lShiftTo(g, y);
    return y;
  };
  var bnpModInt = function(n) {
    if (n <= 0)
      return 0;
    var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
    if (this.t > 0)
      if (d == 0)
        r = this.data[0] % n;
      else
        for (var i = this.t - 1;i >= 0; --i)
          r = (d * r + this.data[i]) % n;
    return r;
  };
  var bnModInverse = function(m) {
    var ac = m.isEven();
    if (this.isEven() && ac || m.signum() == 0)
      return BigInteger$2.ZERO;
    var u = m.clone(), v = this.clone();
    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
    while (u.signum() != 0) {
      while (u.isEven()) {
        u.rShiftTo(1, u);
        if (ac) {
          if (!a.isEven() || !b.isEven()) {
            a.addTo(this, a);
            b.subTo(m, b);
          }
          a.rShiftTo(1, a);
        } else if (!b.isEven())
          b.subTo(m, b);
        b.rShiftTo(1, b);
      }
      while (v.isEven()) {
        v.rShiftTo(1, v);
        if (ac) {
          if (!c.isEven() || !d.isEven()) {
            c.addTo(this, c);
            d.subTo(m, d);
          }
          c.rShiftTo(1, c);
        } else if (!d.isEven())
          d.subTo(m, d);
        d.rShiftTo(1, d);
      }
      if (u.compareTo(v) >= 0) {
        u.subTo(v, u);
        if (ac)
          a.subTo(c, a);
        b.subTo(d, b);
      } else {
        v.subTo(u, v);
        if (ac)
          c.subTo(a, c);
        d.subTo(b, d);
      }
    }
    if (v.compareTo(BigInteger$2.ONE) != 0)
      return BigInteger$2.ZERO;
    if (d.compareTo(m) >= 0)
      return d.subtract(m);
    if (d.signum() < 0)
      d.addTo(m, d);
    else
      return d;
    if (d.signum() < 0)
      return d.add(m);
    else
      return d;
  };
  var bnIsProbablePrime = function(t) {
    var i, x = this.abs();
    if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
      for (i = 0;i < lowprimes.length; ++i)
        if (x.data[0] == lowprimes[i])
          return true;
      return false;
    }
    if (x.isEven())
      return false;
    i = 1;
    while (i < lowprimes.length) {
      var m = lowprimes[i], j = i + 1;
      while (j < lowprimes.length && m < lplim)
        m *= lowprimes[j++];
      m = x.modInt(m);
      while (i < j)
        if (m % lowprimes[i++] == 0)
          return false;
    }
    return x.millerRabin(t);
  };
  var bnpMillerRabin = function(t) {
    var n1 = this.subtract(BigInteger$2.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0)
      return false;
    var r = n1.shiftRight(k);
    var prng2 = bnGetPrng();
    var a;
    for (var i = 0;i < t; ++i) {
      do {
        a = new BigInteger$2(this.bitLength(), prng2);
      } while (a.compareTo(BigInteger$2.ONE) <= 0 || a.compareTo(n1) >= 0);
      var y = a.modPow(r, this);
      if (y.compareTo(BigInteger$2.ONE) != 0 && y.compareTo(n1) != 0) {
        var j = 1;
        while (j++ < k && y.compareTo(n1) != 0) {
          y = y.modPowInt(2, this);
          if (y.compareTo(BigInteger$2.ONE) == 0)
            return false;
        }
        if (y.compareTo(n1) != 0)
          return false;
      }
    }
    return true;
  };
  var bnGetPrng = function() {
    return {
      nextBytes: function(x) {
        for (var i = 0;i < x.length; ++i) {
          x[i] = Math.floor(Math.random() * 256);
        }
      }
    };
  };
  var _init$1 = function() {
    _padding$1 = String.fromCharCode(128);
    _padding$1 += forge$5.util.fillString(String.fromCharCode(0), 64);
    _initialized$1 = true;
  };
  var _update$1 = function(s2, w, bytes2) {
    var t, a, b, c, d, e, f, i;
    var len = bytes2.length();
    while (len >= 64) {
      a = s2.h0;
      b = s2.h1;
      c = s2.h2;
      d = s2.h3;
      e = s2.h4;
      for (i = 0;i < 16; ++i) {
        t = bytes2.getInt32();
        w[i] = t;
        f = d ^ b & (c ^ d);
        t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (;i < 20; ++i) {
        t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
        t = t << 1 | t >>> 31;
        w[i] = t;
        f = d ^ b & (c ^ d);
        t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (;i < 32; ++i) {
        t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
        t = t << 1 | t >>> 31;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (;i < 40; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (;i < 60; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b & c | d & (b ^ c);
        t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (;i < 80; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      s2.h0 = s2.h0 + a | 0;
      s2.h1 = s2.h1 + b | 0;
      s2.h2 = s2.h2 + c | 0;
      s2.h3 = s2.h3 + d | 0;
      s2.h4 = s2.h4 + e | 0;
      len -= 64;
    }
  };
  var rsa_mgf1 = function(seed, maskLength, hash2) {
    if (!hash2) {
      hash2 = forge$4.md.sha1.create();
    }
    var t = "";
    var count = Math.ceil(maskLength / hash2.digestLength);
    for (var i = 0;i < count; ++i) {
      var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
      hash2.start();
      hash2.update(seed + c);
      t += hash2.digest().getBytes();
    }
    return t.substring(0, maskLength);
  };
  var _encodePkcs1_v1_5 = function(m, key, bt) {
    var eb = forge$2.util.createBuffer();
    var k = Math.ceil(key.n.bitLength() / 8);
    if (m.length > k - 11) {
      var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
      error.length = m.length;
      error.max = k - 11;
      throw error;
    }
    eb.putByte(0);
    eb.putByte(bt);
    var padNum = k - 3 - m.length;
    var padByte;
    if (bt === 0 || bt === 1) {
      padByte = bt === 0 ? 0 : 255;
      for (var i = 0;i < padNum; ++i) {
        eb.putByte(padByte);
      }
    } else {
      while (padNum > 0) {
        var numZeros = 0;
        var padBytes = forge$2.random.getBytes(padNum);
        for (var i = 0;i < padNum; ++i) {
          padByte = padBytes.charCodeAt(i);
          if (padByte === 0) {
            ++numZeros;
          } else {
            eb.putByte(padByte);
          }
        }
        padNum = numZeros;
      }
    }
    eb.putByte(0);
    eb.putBytes(m);
    return eb;
  };
  var _decodePkcs1_v1_5 = function(em, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8);
    var eb = forge$2.util.createBuffer(em);
    var first2 = eb.getByte();
    var bt = eb.getByte();
    if (first2 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
      throw new Error("Encryption block is invalid.");
    }
    var padNum = 0;
    if (bt === 0) {
      padNum = k - 3 - ml;
      for (var i = 0;i < padNum; ++i) {
        if (eb.getByte() !== 0) {
          throw new Error("Encryption block is invalid.");
        }
      }
    } else if (bt === 1) {
      padNum = 0;
      while (eb.length() > 1) {
        if (eb.getByte() !== 255) {
          --eb.read;
          break;
        }
        ++padNum;
      }
    } else if (bt === 2) {
      padNum = 0;
      while (eb.length() > 1) {
        if (eb.getByte() === 0) {
          --eb.read;
          break;
        }
        ++padNum;
      }
    }
    var zero = eb.getByte();
    if (zero !== 0 || padNum !== k - 3 - eb.length()) {
      throw new Error("Encryption block is invalid.");
    }
    return eb.getBytes();
  };
  var _generateKeyPair = function(state, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var opts = {
      algorithm: {
        name: options.algorithm || "PRIMEINC",
        options: {
          workers: options.workers || 2,
          workLoad: options.workLoad || 100,
          workerScript: options.workerScript
        }
      }
    };
    if ("prng" in options) {
      opts.prng = options.prng;
    }
    generate();
    function generate() {
      getPrime(state.pBits, function(err, num) {
        if (err) {
          return callback(err);
        }
        state.p = num;
        if (state.q !== null) {
          return finish(err, state.q);
        }
        getPrime(state.qBits, finish);
      });
    }
    function getPrime(bits2, callback2) {
      forge$2.prime.generateProbablePrime(bits2, opts, callback2);
    }
    function finish(err, num) {
      if (err) {
        return callback(err);
      }
      state.q = num;
      if (state.p.compareTo(state.q) < 0) {
        var tmp = state.p;
        state.p = state.q;
        state.q = tmp;
      }
      if (state.p.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
        state.p = null;
        generate();
        return;
      }
      if (state.q.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
        state.q = null;
        getPrime(state.qBits, finish);
        return;
      }
      state.p1 = state.p.subtract(BigInteger$1.ONE);
      state.q1 = state.q.subtract(BigInteger$1.ONE);
      state.phi = state.p1.multiply(state.q1);
      if (state.phi.gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
        state.p = state.q = null;
        generate();
        return;
      }
      state.n = state.p.multiply(state.q);
      if (state.n.bitLength() !== state.bits) {
        state.q = null;
        getPrime(state.qBits, finish);
        return;
      }
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki$1.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
        publicKey: pki$1.rsa.setPublicKey(state.n, state.e)
      };
      callback(null, state.keys);
    }
  };
  var _bnToBytes = function(b) {
    var hex = b.toString(16);
    if (hex[0] >= "8") {
      hex = "00" + hex;
    }
    var bytes2 = forge$2.util.hexToBytes(hex);
    if (bytes2.length > 1 && (bytes2.charCodeAt(0) === 0 && (bytes2.charCodeAt(1) & 128) === 0 || bytes2.charCodeAt(0) === 255 && (bytes2.charCodeAt(1) & 128) === 128)) {
      return bytes2.substr(1);
    }
    return bytes2;
  };
  var _getMillerRabinTests = function(bits2) {
    if (bits2 <= 100)
      return 27;
    if (bits2 <= 150)
      return 18;
    if (bits2 <= 200)
      return 15;
    if (bits2 <= 250)
      return 12;
    if (bits2 <= 300)
      return 9;
    if (bits2 <= 350)
      return 8;
    if (bits2 <= 400)
      return 7;
    if (bits2 <= 500)
      return 6;
    if (bits2 <= 600)
      return 5;
    if (bits2 <= 800)
      return 4;
    if (bits2 <= 1250)
      return 3;
    return 2;
  };
  var _detectNodeCrypto = function(fn) {
    return forge$2.util.isNodejs && typeof _crypto[fn] === "function";
  };
  var _detectSubtleCrypto = function(fn) {
    return typeof util$1.globalScope !== "undefined" && typeof util$1.globalScope.crypto === "object" && typeof util$1.globalScope.crypto.subtle === "object" && typeof util$1.globalScope.crypto.subtle[fn] === "function";
  };
  var _detectSubtleMsCrypto = function(fn) {
    return typeof util$1.globalScope !== "undefined" && typeof util$1.globalScope.msCrypto === "object" && typeof util$1.globalScope.msCrypto.subtle === "object" && typeof util$1.globalScope.msCrypto.subtle[fn] === "function";
  };
  var _intToUint8Array = function(x) {
    var bytes2 = forge$2.util.hexToBytes(x.toString(16));
    var buffer = new Uint8Array(bytes2.length);
    for (var i = 0;i < bytes2.length; ++i) {
      buffer[i] = bytes2.charCodeAt(i);
    }
    return buffer;
  };
  var hash = function(md, bytes2) {
    return md.start().update(bytes2).digest().getBytes();
  };
  var prfOidToMessageDigest = function(prfOid) {
    var prfAlgorithm;
    if (!prfOid) {
      prfAlgorithm = "hmacWithSHA1";
    } else {
      prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
      if (!prfAlgorithm) {
        var error = new Error("Unsupported PRF OID.");
        error.oid = prfOid;
        error.supported = [
          "hmacWithSHA1",
          "hmacWithSHA224",
          "hmacWithSHA256",
          "hmacWithSHA384",
          "hmacWithSHA512"
        ];
        throw error;
      }
    }
    return prfAlgorithmToMessageDigest(prfAlgorithm);
  };
  var prfAlgorithmToMessageDigest = function(prfAlgorithm) {
    var factory = forge$1.md;
    switch (prfAlgorithm) {
      case "hmacWithSHA224":
        factory = forge$1.md.sha512;
      case "hmacWithSHA1":
      case "hmacWithSHA256":
      case "hmacWithSHA384":
      case "hmacWithSHA512":
        prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
        break;
      default:
        var error = new Error("Unsupported PRF algorithm.");
        error.algorithm = prfAlgorithm;
        error.supported = [
          "hmacWithSHA1",
          "hmacWithSHA224",
          "hmacWithSHA256",
          "hmacWithSHA384",
          "hmacWithSHA512"
        ];
        throw error;
    }
    if (!factory || !(prfAlgorithm in factory)) {
      throw new Error("Unknown hash algorithm: " + prfAlgorithm);
    }
    return factory[prfAlgorithm].create();
  };
  var createPbkdf2Params = function(salt, countBytes, dkLen, prfAlgorithm) {
    var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
    ]);
    if (prfAlgorithm !== "hmacWithSHA1") {
      params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge$1.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
    }
    return params;
  };
  var base$d = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$z = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$7) {
      out[offset++] = num & 255 | MSB$9;
      num /= 128;
    }
    while (num & MSBALL$7) {
      out[offset++] = num & 255 | MSB$9;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$z.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$8 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$8.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1$7) << shift : (b & REST$1$7) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1$7);
    read$8.bytes = counter2 - offset;
    return res;
  };
  var constTimeNegate$1 = function(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  };
  var assertExtPoint = function(other) {
    if (!(other instanceof ExtendedPoint))
      throw new TypeError("ExtendedPoint expected");
  };
  var assertRstPoint = function(other) {
    if (!(other instanceof RistrettoPoint))
      throw new TypeError("RistrettoPoint expected");
  };
  var legacyRist = function() {
    throw new Error("Legacy method: switch to RistrettoPoint");
  };
  var concatBytes$1 = function(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
      throw new Error("Expected Uint8Array list");
    if (arrays.length === 1)
      return arrays[0];
    const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length2);
    for (let i = 0, pad = 0;i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  };
  var bytesToHex$1 = function(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < uint8a.length; i++) {
      hex += hexes$1[uint8a[i]];
    }
    return hex;
  };
  var hexToBytes$1 = function(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    }
    if (hex.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  };
  var numberTo32BytesBE = function(num) {
    const length2 = 32;
    const hex = num.toString(16).padStart(length2 * 2, "0");
    return hexToBytes$1(hex);
  };
  var numberTo32BytesLE = function(num) {
    return numberTo32BytesBE(num).reverse();
  };
  var edIsNegative = function(num) {
    return (mod$1(num) & _1n$3) === _1n$3;
  };
  var bytesToNumberLE = function(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    return BigInt("0x" + bytesToHex$1(Uint8Array.from(uint8a).reverse()));
  };
  var bytes255ToNumberLE = function(bytes2) {
    return mod$1(bytesToNumberLE(bytes2) & MAX_255B);
  };
  var mod$1 = function(a, b = CURVE$1.P) {
    const res = a % b;
    return res >= _0n$2 ? res : b + res;
  };
  var invert$1 = function(number2, modulo = CURVE$1.P) {
    if (number2 === _0n$2 || modulo <= _0n$2) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a = mod$1(number2, modulo);
    let b = modulo;
    let x = _0n$2, u = _1n$3;
    while (a !== _0n$2) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      b = a, a = r, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n$3)
      throw new Error("invert: does not exist");
    return mod$1(x, modulo);
  };
  var invertBatch$1 = function(nums, p = CURVE$1.P) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (num === _0n$2)
        return acc;
      tmp[i] = acc;
      return mod$1(acc * num, p);
    }, _1n$3);
    const inverted = invert$1(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
      if (num === _0n$2)
        return acc;
      tmp[i] = mod$1(acc * tmp[i], p);
      return mod$1(acc * num, p);
    }, inverted);
    return tmp;
  };
  var pow2$1 = function(x, power) {
    const { P } = CURVE$1;
    let res = x;
    while (power-- > _0n$2) {
      res *= res;
      res %= P;
    }
    return res;
  };
  var pow_2_252_3 = function(x) {
    const { P } = CURVE$1;
    const _5n2 = BigInt(5);
    const _10n2 = BigInt(10);
    const _20n2 = BigInt(20);
    const _40n2 = BigInt(40);
    const _80n2 = BigInt(80);
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2$1(b2, _2n$2) * b2 % P;
    const b5 = pow2$1(b4, _1n$3) * x % P;
    const b10 = pow2$1(b5, _5n2) * b5 % P;
    const b20 = pow2$1(b10, _10n2) * b10 % P;
    const b40 = pow2$1(b20, _20n2) * b20 % P;
    const b80 = pow2$1(b40, _40n2) * b40 % P;
    const b160 = pow2$1(b80, _80n2) * b80 % P;
    const b240 = pow2$1(b160, _80n2) * b80 % P;
    const b250 = pow2$1(b240, _10n2) * b10 % P;
    const pow_p_5_8 = pow2$1(b250, _2n$2) * x % P;
    return { pow_p_5_8, b2 };
  };
  var uvRatio = function(u, v) {
    const v3 = mod$1(v * v * v);
    const v7 = mod$1(v3 * v3 * v);
    const pow3 = pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod$1(u * v3 * pow3);
    const vx2 = mod$1(v * x * x);
    const root1 = x;
    const root2 = mod$1(x * SQRT_M1);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod$1(-u);
    const noRoot = vx2 === mod$1(-u * SQRT_M1);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (edIsNegative(x))
      x = mod$1(-x);
    return { isValid: useRoot1 || useRoot2, value: x };
  };
  var invertSqrt = function(number2) {
    return uvRatio(_1n$3, number2);
  };
  var modlLE = function(hash2) {
    return mod$1(bytesToNumberLE(hash2), CURVE$1.l);
  };
  var equalBytes = function(b1, b2) {
    if (b1.length !== b2.length) {
      return false;
    }
    for (let i = 0;i < b1.length; i++) {
      if (b1[i] !== b2[i]) {
        return false;
      }
    }
    return true;
  };
  var ensureBytes$1 = function(hex, expectedLength) {
    const bytes2 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes$1(hex);
    if (typeof expectedLength === "number" && bytes2.length !== expectedLength)
      throw new Error(`Expected ${expectedLength} bytes`);
    return bytes2;
  };
  var normalizeScalar$1 = function(num, max, strict = true) {
    if (!max)
      throw new TypeError("Specify max value");
    if (typeof num === "number" && Number.isSafeInteger(num))
      num = BigInt(num);
    if (typeof num === "bigint" && num < max) {
      if (strict) {
        if (_0n$2 < num)
          return num;
      } else {
        if (_0n$2 <= num)
          return num;
      }
    }
    throw new TypeError("Expected valid scalar: 0 < scalar < max");
  };
  var adjustBytes25519 = function(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  };
  var checkPrivateKey = function(key) {
    key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar$1(key, POW_2_256$1)) : ensureBytes$1(key);
    if (key.length !== 32)
      throw new Error(`Expected 32 bytes`);
    return key;
  };
  var getKeyFromHash = function(hashed) {
    const head = adjustBytes25519(hashed.slice(0, 32));
    const prefix = hashed.slice(32, 64);
    const scalar = modlLE(head);
    const point = Point$1.BASE.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  };
  async function getExtendedPublicKey(key) {
    return getKeyFromHash(await utils$1.sha512(checkPrivateKey(key)));
  }
  async function getPublicKey$1(privateKey) {
    return (await getExtendedPublicKey(privateKey)).pointBytes;
  }
  async function sign$2(message2, privateKey) {
    message2 = ensureBytes$1(message2);
    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
    const r = modlLE(await utils$1.sha512(prefix, message2));
    const R2 = Point$1.BASE.multiply(r);
    const k = modlLE(await utils$1.sha512(R2.toRawBytes(), pointBytes, message2));
    const s2 = mod$1(r + k * scalar, CURVE$1.l);
    return new Signature$1(R2, s2).toRawBytes();
  }
  var prepareVerification = function(sig, message2, publicKey) {
    message2 = ensureBytes$1(message2);
    if (!(publicKey instanceof Point$1))
      publicKey = Point$1.fromHex(publicKey, false);
    const { r, s: s2 } = sig instanceof Signature$1 ? sig.assertValidity() : Signature$1.fromHex(sig);
    const SB = ExtendedPoint.BASE.multiplyUnsafe(s2);
    return { r, s: s2, SB, pub: publicKey, msg: message2 };
  };
  var finishVerification = function(publicKey, r, SB, hashed) {
    const k = modlLE(hashed);
    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
    const RkA = ExtendedPoint.fromAffine(r).add(kA);
    return RkA.subtract(SB).multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO);
  };
  async function verify$1(sig, message2, publicKey) {
    const { r, SB, msg, pub } = prepareVerification(sig, message2, publicKey);
    const hashed = await utils$1.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
    return finishVerification(pub, r, SB, hashed);
  }
  async function generateKey$k() {
    const privateKeyRaw = utils$1.randomPrivateKey();
    const publicKey = await getPublicKey$1(privateKeyRaw);
    const privateKey = concatKeys$6(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function generateKeyFromSeed$6(seed) {
    if (seed.length !== KEYS_BYTE_LENGTH$6) {
      throw new TypeError('"seed" must be 32 bytes in length.');
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
    }
    const privateKeyRaw = seed;
    const publicKey = await getPublicKey$1(privateKeyRaw);
    const privateKey = concatKeys$6(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSign$k(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH$6);
    return sign$2(msg, privateKeyRaw);
  }
  async function hashAndVerify$k(publicKey, sig, msg) {
    return verify$1(sig, msg, publicKey);
  }
  var concatKeys$6 = function(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH$6);
    for (let i = 0;i < KEYS_BYTE_LENGTH$6; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH$6 + i] = publicKey[i];
    }
    return privateKey;
  };
  var create$d = function(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest2 = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto2 = webcrypto$6.get();
    keyLength *= 8;
    async function encrypt2(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$6, { name: "AES-GCM" }, true, ["encrypt"]);
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$6, { name: "AES-GCM" }, true, ["encrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      }
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat$1([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt2(data, password) {
      const salt = data.subarray(0, saltLength);
      const nonce = data.subarray(saltLength, saltLength + nonceLength);
      const ciphertext = data.subarray(saltLength + nonceLength);
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$6, { name: "AES-GCM" }, true, ["decrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      }
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    const cipher = {
      encrypt: encrypt2,
      decrypt: decrypt2
    };
    return cipher;
  };
  async function exporter$6(privateKey, password) {
    const cipher = create$d();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return base64$d.encode(encryptedKey);
  }
  var unmarshalEd25519PrivateKey$6 = function(bytes2) {
    if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH$6) {
      bytes2 = ensureKey$6(bytes2, PRIVATE_KEY_BYTE_LENGTH$6 + PUBLIC_KEY_BYTE_LENGTH$6);
      const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$6);
      const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH$6, bytes2.length);
      return new Ed25519PrivateKey$6(privateKeyBytes2, publicKeyBytes2);
    }
    bytes2 = ensureKey$6(bytes2, PRIVATE_KEY_BYTE_LENGTH$6);
    const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$6);
    const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH$6);
    return new Ed25519PrivateKey$6(privateKeyBytes, publicKeyBytes);
  };
  var unmarshalEd25519PublicKey$6 = function(bytes2) {
    bytes2 = ensureKey$6(bytes2, PUBLIC_KEY_BYTE_LENGTH$6);
    return new Ed25519PublicKey$6(bytes2);
  };
  async function generateKeyPair$m() {
    const { privateKey, publicKey } = await generateKey$k();
    return new Ed25519PrivateKey$6(privateKey, publicKey);
  }
  async function generateKeyPairFromSeed$6(seed) {
    const { privateKey, publicKey } = await generateKeyFromSeed$6(seed);
    return new Ed25519PrivateKey$6(privateKey, publicKey);
  }
  var ensureKey$6 = function(key, length2) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length2) {
      throw new CodeError$3(`Key must be a Uint8Array of length ${length2}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
    }
    return key;
  };
  var bigIntegerToUintBase64url$6 = function(num, len) {
    let buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.subarray(1) : buf;
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return toString$9(buf, "base64url");
  };
  var base64urlToBigInteger$6 = function(str) {
    const buf = base64urlToBuffer$6(str);
    return new forge$n.jsbn.BigInteger(toString$9(buf, "base16"), 16);
  };
  var base64urlToBuffer$6 = function(str, len) {
    let buf = fromString$3(str, "base64urlpad");
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return buf;
  };
  var _init = function() {
    _padding = String.fromCharCode(128);
    _padding += forge.util.fillString(String.fromCharCode(0), 128);
    _k = [
      [1116352408, 3609767458],
      [1899447441, 602891725],
      [3049323471, 3964484399],
      [3921009573, 2173295548],
      [961987163, 4081628472],
      [1508970993, 3053834265],
      [2453635748, 2937671579],
      [2870763221, 3664609560],
      [3624381080, 2734883394],
      [310598401, 1164996542],
      [607225278, 1323610764],
      [1426881987, 3590304994],
      [1925078388, 4068182383],
      [2162078206, 991336113],
      [2614888103, 633803317],
      [3248222580, 3479774868],
      [3835390401, 2666613458],
      [4022224774, 944711139],
      [264347078, 2341262773],
      [604807628, 2007800933],
      [770255983, 1495990901],
      [1249150122, 1856431235],
      [1555081692, 3175218132],
      [1996064986, 2198950837],
      [2554220882, 3999719339],
      [2821834349, 766784016],
      [2952996808, 2566594879],
      [3210313671, 3203337956],
      [3336571891, 1034457026],
      [3584528711, 2466948901],
      [113926993, 3758326383],
      [338241895, 168717936],
      [666307205, 1188179964],
      [773529912, 1546045734],
      [1294757372, 1522805485],
      [1396182291, 2643833823],
      [1695183700, 2343527390],
      [1986661051, 1014477480],
      [2177026350, 1206759142],
      [2456956037, 344077627],
      [2730485921, 1290863460],
      [2820302411, 3158454273],
      [3259730800, 3505952657],
      [3345764771, 106217008],
      [3516065817, 3606008344],
      [3600352804, 1432725776],
      [4094571909, 1467031594],
      [275423344, 851169720],
      [430227734, 3100823752],
      [506948616, 1363258195],
      [659060556, 3750685593],
      [883997877, 3785050280],
      [958139571, 3318307427],
      [1322822218, 3812723403],
      [1537002063, 2003034995],
      [1747873779, 3602036899],
      [1955562222, 1575990012],
      [2024104815, 1125592928],
      [2227730452, 2716904306],
      [2361852424, 442776044],
      [2428436474, 593698344],
      [2756734187, 3733110249],
      [3204031479, 2999351573],
      [3329325298, 3815920427],
      [3391569614, 3928383900],
      [3515267271, 566280711],
      [3940187606, 3454069534],
      [4118630271, 4000239992],
      [116418474, 1914138554],
      [174292421, 2731055270],
      [289380356, 3203993006],
      [460393269, 320620315],
      [685471733, 587496836],
      [852142971, 1086792851],
      [1017036298, 365543100],
      [1126000580, 2618297676],
      [1288033470, 3409855158],
      [1501505948, 4234509866],
      [1607167915, 987167468],
      [1816402316, 1246189591]
    ];
    _states = {};
    _states["SHA-512"] = [
      [1779033703, 4089235720],
      [3144134277, 2227873595],
      [1013904242, 4271175723],
      [2773480762, 1595750129],
      [1359893119, 2917565137],
      [2600822924, 725511199],
      [528734635, 4215389547],
      [1541459225, 327033209]
    ];
    _states["SHA-384"] = [
      [3418070365, 3238371032],
      [1654270250, 914150663],
      [2438529370, 812702999],
      [355462360, 4144912697],
      [1731405415, 4290775857],
      [2394180231, 1750603025],
      [3675008525, 1694076839],
      [1203062813, 3204075428]
    ];
    _states["SHA-512/256"] = [
      [573645204, 4230739756],
      [2673172387, 3360449730],
      [596883563, 1867755857],
      [2520282905, 1497426621],
      [2519219938, 2827943907],
      [3193839141, 1401305490],
      [721525244, 746961066],
      [246885852, 2177182882]
    ];
    _states["SHA-512/224"] = [
      [2352822216, 424955298],
      [1944164710, 2312950998],
      [502970286, 855612546],
      [1738396948, 1479516111],
      [258812777, 2077511080],
      [2011393907, 79989058],
      [1067287976, 1780299464],
      [286451373, 2446758561]
    ];
    _initialized = true;
  };
  var _update = function(s2, w, bytes2) {
    var t1_hi, t1_lo;
    var t2_hi, t2_lo;
    var s0_hi, s0_lo;
    var s1_hi, s1_lo;
    var ch_hi, ch_lo;
    var maj_hi, maj_lo;
    var a_hi, a_lo;
    var b_hi, b_lo;
    var c_hi, c_lo;
    var d_hi, d_lo;
    var e_hi, e_lo;
    var f_hi, f_lo;
    var g_hi, g_lo;
    var h_hi, h_lo;
    var i, hi, lo, w2, w7, w15, w16;
    var len = bytes2.length();
    while (len >= 128) {
      for (i = 0;i < 16; ++i) {
        w[i][0] = bytes2.getInt32() >>> 0;
        w[i][1] = bytes2.getInt32() >>> 0;
      }
      for (;i < 80; ++i) {
        w2 = w[i - 2];
        hi = w2[0];
        lo = w2[1];
        t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
        t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
        w15 = w[i - 15];
        hi = w15[0];
        lo = w15[1];
        t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
        t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
        w7 = w[i - 7];
        w16 = w[i - 16];
        lo = t1_lo + w7[1] + t2_lo + w16[1];
        w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
        w[i][1] = lo >>> 0;
      }
      a_hi = s2[0][0];
      a_lo = s2[0][1];
      b_hi = s2[1][0];
      b_lo = s2[1][1];
      c_hi = s2[2][0];
      c_lo = s2[2][1];
      d_hi = s2[3][0];
      d_lo = s2[3][1];
      e_hi = s2[4][0];
      e_lo = s2[4][1];
      f_hi = s2[5][0];
      f_lo = s2[5][1];
      g_hi = s2[6][0];
      g_lo = s2[6][1];
      h_hi = s2[7][0];
      h_lo = s2[7][1];
      for (i = 0;i < 80; ++i) {
        s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
        s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
        ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
        ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
        s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
        s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
        maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
        maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
        lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
        t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
        t1_lo = lo >>> 0;
        lo = s0_lo + maj_lo;
        t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
        t2_lo = lo >>> 0;
        h_hi = g_hi;
        h_lo = g_lo;
        g_hi = f_hi;
        g_lo = f_lo;
        f_hi = e_hi;
        f_lo = e_lo;
        lo = d_lo + t1_lo;
        e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
        e_lo = lo >>> 0;
        d_hi = c_hi;
        d_lo = c_lo;
        c_hi = b_hi;
        c_lo = b_lo;
        b_hi = a_hi;
        b_lo = a_lo;
        lo = t1_lo + t2_lo;
        a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
        a_lo = lo >>> 0;
      }
      lo = s2[0][1] + a_lo;
      s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
      s2[0][1] = lo >>> 0;
      lo = s2[1][1] + b_lo;
      s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
      s2[1][1] = lo >>> 0;
      lo = s2[2][1] + c_lo;
      s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
      s2[2][1] = lo >>> 0;
      lo = s2[3][1] + d_lo;
      s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
      s2[3][1] = lo >>> 0;
      lo = s2[4][1] + e_lo;
      s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
      s2[4][1] = lo >>> 0;
      lo = s2[5][1] + f_lo;
      s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
      s2[5][1] = lo >>> 0;
      lo = s2[6][1] + g_lo;
      s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
      s2[6][1] = lo >>> 0;
      lo = s2[7][1] + h_lo;
      s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
      s2[7][1] = lo >>> 0;
      len -= 128;
    }
  };
  var weierstrass$1 = function(x) {
    const { a, b } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
  };
  var assertJacPoint = function(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
  };
  var constTimeNegate = function(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  };
  var sliceDER = function(s2) {
    return Number.parseInt(s2[0], 16) >= 8 ? "00" + s2 : s2;
  };
  var parseDERInt = function(data) {
    if (data.length < 2 || data[0] !== 2) {
      throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
    }
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) {
      throw new Error(`Invalid signature integer: wrong length`);
    }
    if (res[0] === 0 && res[1] <= 127) {
      throw new Error("Invalid signature integer: trailing length");
    }
    return { data: bytesToNumber(res), left: data.subarray(len + 2) };
  };
  var parseDERSignature = function(data) {
    if (data.length < 2 || data[0] != 48) {
      throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
    }
    if (data[1] !== data.length - 2) {
      throw new Error("Invalid signature: incorrect length");
    }
    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
    const { data: s2, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) {
      throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    }
    return { r, s: s2 };
  };
  var concatBytes = function(...arrays) {
    if (!arrays.every((b) => b instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (arrays.length === 1)
      return arrays[0];
    const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length2);
    for (let i = 0, pad = 0;i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  };
  var bytesToHex = function(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let hex = "";
    for (let i = 0;i < uint8a.length; i++) {
      hex += hexes[uint8a[i]];
    }
    return hex;
  };
  var numTo32bStr = function(num) {
    if (typeof num !== "bigint")
      throw new Error("Expected bigint");
    if (!(_0n$1 <= num && num < POW_2_256))
      throw new Error("Expected number 0 <= n < 2^256");
    return num.toString(16).padStart(64, "0");
  };
  var numTo32b = function(num) {
    const b = hexToBytes(numTo32bStr(num));
    if (b.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return b;
  };
  var numberToHexUnpadded = function(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  };
  var hexToNumber = function(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToNumber: expected string, got " + typeof hex);
    }
    return BigInt(`0x${hex}`);
  };
  var hexToBytes = function(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    }
    if (hex.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  };
  var bytesToNumber = function(bytes2) {
    return hexToNumber(bytesToHex(bytes2));
  };
  var ensureBytes = function(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  };
  var normalizeScalar = function(num) {
    if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
      return BigInt(num);
    if (typeof num === "bigint" && isWithinCurveOrder(num))
      return num;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  };
  var mod = function(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n$1 ? result : b + result;
  };
  var pow2 = function(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n$1) {
      res *= res;
      res %= P;
    }
    return res;
  };
  var sqrtMod$1 = function(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = x * x * x % P;
    const b3 = b2 * b2 * x % P;
    const b6 = pow2(b3, _3n$1) * b3 % P;
    const b9 = pow2(b6, _3n$1) * b3 % P;
    const b11 = pow2(b9, _2n$1) * b2 % P;
    const b22 = pow2(b11, _11n) * b11 % P;
    const b44 = pow2(b22, _22n) * b22 % P;
    const b88 = pow2(b44, _44n) * b44 % P;
    const b176 = pow2(b88, _88n) * b88 % P;
    const b220 = pow2(b176, _44n) * b44 % P;
    const b223 = pow2(b220, _3n$1) * b3 % P;
    const t1 = pow2(b223, _23n) * b22 % P;
    const t2 = pow2(t1, _6n) * b2 % P;
    const rt = pow2(t2, _2n$1);
    const xc = rt * rt % P;
    if (xc !== x)
      throw new Error("Cannot find square root");
    return rt;
  };
  var invert = function(number2, modulo = CURVE.P) {
    if (number2 === _0n$1 || modulo <= _0n$1) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a = mod(number2, modulo);
    let b = modulo;
    let x = _0n$1, u = _1n$2;
    while (a !== _0n$1) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      b = a, a = r, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n$2)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  };
  var invertBatch = function(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (num === _0n$1)
        return acc;
      scratch[i] = acc;
      return mod(acc * num, p);
    }, _1n$2);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
      if (num === _0n$1)
        return acc;
      scratch[i] = mod(acc * scratch[i], p);
      return mod(acc * num, p);
    }, inverted);
    return scratch;
  };
  var bits2int_2 = function(bytes2) {
    const delta = bytes2.length * 8 - groupLen * 8;
    const num = bytesToNumber(bytes2);
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  var truncateHash = function(hash2, truncateOnly = false) {
    const h = bits2int_2(hash2);
    if (truncateOnly)
      return h;
    const { n } = CURVE;
    return h >= n ? h - n : h;
  };
  var isWithinCurveOrder = function(num) {
    return _0n$1 < num && num < CURVE.n;
  };
  var isValidFieldElement = function(num) {
    return _0n$1 < num && num < CURVE.P;
  };
  var kmdToSig = function(kBytes, m, d, lowS = true) {
    const { n } = CURVE;
    const k = truncateHash(kBytes, true);
    if (!isWithinCurveOrder(k))
      return;
    const kinv = invert(k, n);
    const q = Point.BASE.multiply(k);
    const r = mod(q.x, n);
    if (r === _0n$1)
      return;
    const s2 = mod(kinv * mod(m + d * r, n), n);
    if (s2 === _0n$1)
      return;
    let sig = new Signature(r, s2);
    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n$2);
    if (lowS && sig.hasHighS()) {
      sig = sig.normalizeS();
      recovery ^= 1;
    }
    return { sig, recovery };
  };
  var normalizePrivateKey = function(key) {
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
      num = BigInt(key);
    } else if (typeof key === "string") {
      if (key.length !== 2 * groupLen)
        throw new Error("Expected 32 bytes of private key");
      num = hexToNumber(key);
    } else if (key instanceof Uint8Array) {
      if (key.length !== groupLen)
        throw new Error("Expected 32 bytes of private key");
      num = bytesToNumber(key);
    } else {
      throw new TypeError("Expected valid private key");
    }
    if (!isWithinCurveOrder(num))
      throw new Error("Expected private key: 0 < key < n");
    return num;
  };
  var normalizePublicKey = function(publicKey) {
    if (publicKey instanceof Point) {
      publicKey.assertValidity();
      return publicKey;
    } else {
      return Point.fromHex(publicKey);
    }
  };
  var normalizeSignature = function(signature) {
    if (signature instanceof Signature) {
      signature.assertValidity();
      return signature;
    }
    try {
      return Signature.fromDER(signature);
    } catch (error) {
      return Signature.fromCompact(signature);
    }
  };
  var getPublicKey = function(privateKey, isCompressed = false) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  };
  var bits2int = function(bytes2) {
    const slice = bytes2.length > fieldLen ? bytes2.slice(0, fieldLen) : bytes2;
    return bytesToNumber(slice);
  };
  var bits2octets = function(bytes2) {
    const z1 = bits2int(bytes2);
    const z2 = mod(z1, CURVE.n);
    return int2octets(z2 < _0n$1 ? z1 : z2);
  };
  var int2octets = function(num) {
    return numTo32b(num);
  };
  var initSigArgs = function(msgHash, privateKey, extraEntropy) {
    if (msgHash == null)
      throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
    const h1 = ensureBytes(msgHash);
    const d = normalizePrivateKey(privateKey);
    const seedArgs = [int2octets(d), bits2octets(h1)];
    if (extraEntropy != null) {
      if (extraEntropy === true)
        extraEntropy = utils.randomBytes(fieldLen);
      const e = ensureBytes(extraEntropy);
      if (e.length !== fieldLen)
        throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
      seedArgs.push(e);
    }
    const seed = concatBytes(...seedArgs);
    const m = bits2int(h1);
    return { seed, m, d };
  };
  var finalizeSig = function(recSig, opts) {
    const { sig, recovery } = recSig;
    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [hashed, recovery] : hashed;
  };
  async function sign$1(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    await drbg.reseed(seed);
    let sig;
    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))
      await drbg.reseed();
    return finalizeSig(sig, opts);
  }
  var verify = function(signature, msgHash, publicKey, opts = vopts) {
    let sig;
    try {
      sig = normalizeSignature(signature);
      msgHash = ensureBytes(msgHash);
    } catch (error) {
      return false;
    }
    const { r, s: s2 } = sig;
    if (opts.strict && sig.hasHighS())
      return false;
    const h = truncateHash(msgHash);
    let P;
    try {
      P = normalizePublicKey(publicKey);
    } catch (error) {
      return false;
    }
    const { n } = CURVE;
    const sinv = invert(s2, n);
    const u1 = mod(h * sinv, n);
    const u2 = mod(r * sinv, n);
    const R2 = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
    if (!R2)
      return false;
    const v = mod(R2.x, n);
    return v === r;
  };
  var randomBytes$6 = function(length2) {
    if (isNaN(length2) || length2 <= 0) {
      throw new CodeError$3("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
    }
    return utils.randomBytes(length2);
  };
  var convert$6 = function(key, types) {
    return types.map((t) => base64urlToBigInteger$6(key[t]));
  };
  var jwk2priv$6 = function(key) {
    return forge$n.pki.setRsaPrivateKey(...convert$6(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
  };
  var jwk2pub$6 = function(key) {
    return forge$n.pki.setRsaPublicKey(...convert$6(key, ["n", "e"]));
  };
  var pkcs1ToJwk$6 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$6(privateKey.n),
      e: bigIntegerToUintBase64url$6(privateKey.e),
      d: bigIntegerToUintBase64url$6(privateKey.d),
      p: bigIntegerToUintBase64url$6(privateKey.p),
      q: bigIntegerToUintBase64url$6(privateKey.q),
      dp: bigIntegerToUintBase64url$6(privateKey.dP),
      dq: bigIntegerToUintBase64url$6(privateKey.dQ),
      qi: bigIntegerToUintBase64url$6(privateKey.qInv),
      alg: "RS256"
    };
  };
  var jwkToPkcs1$6 = function(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.privateKeyToAsn1({
      n: base64urlToBigInteger$6(jwk.n),
      e: base64urlToBigInteger$6(jwk.e),
      d: base64urlToBigInteger$6(jwk.d),
      p: base64urlToBigInteger$6(jwk.p),
      q: base64urlToBigInteger$6(jwk.q),
      dP: base64urlToBigInteger$6(jwk.dp),
      dQ: base64urlToBigInteger$6(jwk.dq),
      qInv: base64urlToBigInteger$6(jwk.qi)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  var pkixToJwk$6 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const publicKey = forge$n.pki.publicKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$6(publicKey.n),
      e: bigIntegerToUintBase64url$6(publicKey.e)
    };
  };
  var jwkToPkix$6 = function(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.publicKeyToAsn1({
      n: base64urlToBigInteger$6(jwk.n),
      e: base64urlToBigInteger$6(jwk.e)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  async function generateKey$j(bits2) {
    const pair2 = await webcrypto$6.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits2,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    const keys = await exportKey$6(pair2);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function unmarshalPrivateKey$a(key) {
    const privateKey = await webcrypto$6.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["sign"]);
    const pair2 = [
      privateKey,
      await derivePublicFromPrivate$6(key)
    ];
    const keys = await exportKey$6({
      privateKey: pair2[0],
      publicKey: pair2[1]
    });
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign$j(key, msg) {
    const privateKey = await webcrypto$6.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const sig = await webcrypto$6.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify$j(key, sig, msg) {
    const publicKey = await webcrypto$6.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    return webcrypto$6.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
  }
  async function exportKey$6(pair2) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new CodeError$3("Private and public key are required", "ERR_INVALID_PARAMETERS");
    }
    return Promise.all([
      webcrypto$6.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto$6.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
  }
  async function derivePublicFromPrivate$6(jwKey) {
    return webcrypto$6.get().subtle.importKey("jwk", {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    }, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["verify"]);
  }
  var convertKey$6 = function(key, pub, msg, handle2) {
    const fkey = pub ? jwk2pub$6(key) : jwk2priv$6(key);
    const fmsg = toString$9(Uint8Array.from(msg), "ascii");
    const fomsg = handle2(fmsg, fkey);
    return fromString$3(fomsg, "ascii");
  };
  var encrypt$6 = function(key, msg) {
    return convertKey$6(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
  };
  var decrypt$6 = function(key, msg) {
    return convertKey$6(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
  };
  var keySize$5 = function(jwk) {
    if (jwk.kty !== "RSA") {
      throw new CodeError$3("invalid key type", "ERR_INVALID_KEY_TYPE");
    } else if (jwk.n == null) {
      throw new CodeError$3("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
    }
    const bytes2 = fromString$3(jwk.n, "base64url");
    return bytes2.length * 8;
  };
  async function unmarshalRsaPrivateKey$6(bytes2) {
    const jwk = pkcs1ToJwk$6(bytes2);
    if (keySize$5(jwk) > MAX_KEY_SIZE$5) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$a(jwk);
    return new RsaPrivateKey$6(keys.privateKey, keys.publicKey);
  }
  var unmarshalRsaPublicKey$6 = function(bytes2) {
    const jwk = pkixToJwk$6(bytes2);
    if (keySize$5(jwk) > MAX_KEY_SIZE$5) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    return new RsaPublicKey$6(jwk);
  };
  async function fromJwk$6(jwk) {
    if (keySize$5(jwk) > MAX_KEY_SIZE$5) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$a(jwk);
    return new RsaPrivateKey$6(keys.privateKey, keys.publicKey);
  }
  async function generateKeyPair$l(bits2) {
    if (bits2 > MAX_KEY_SIZE$5) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await generateKey$j(bits2);
    return new RsaPrivateKey$6(keys.privateKey, keys.publicKey);
  }
  var generateKey$i = function() {
    return utils.randomPrivateKey();
  };
  async function hashAndSign$i(key, msg) {
    const { digest: digest2 } = await sha256$8.digest(msg);
    try {
      return await sign$1(digest2, key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  async function hashAndVerify$i(key, sig, msg) {
    try {
      const { digest: digest2 } = await sha256$8.digest(msg);
      return verify(sig, digest2, key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  var compressPublicKey$6 = function(key) {
    const point = Point.fromHex(key).toRawBytes(true);
    return point;
  };
  var validatePrivateKey$6 = function(key) {
    try {
      getPublicKey(key, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var validatePublicKey$6 = function(key) {
    try {
      Point.fromHex(key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PUBLIC_KEY");
    }
  };
  var computePublicKey$6 = function(privateKey) {
    try {
      return getPublicKey(privateKey, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var unmarshalSecp256k1PrivateKey$6 = function(bytes2) {
    return new Secp256k1PrivateKey$6(bytes2);
  };
  var unmarshalSecp256k1PublicKey$6 = function(bytes2) {
    return new Secp256k1PublicKey$6(bytes2);
  };
  async function generateKeyPair$k() {
    const privateKeyBytes = generateKey$i();
    return new Secp256k1PrivateKey$6(privateKeyBytes);
  }
  var unsupportedKey$5 = function(type) {
    const supported = Object.keys(supportedKeys$6).join(" / ");
    return new CodeError$3(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
  };
  var unmarshalPublicKey$3 = function(buf) {
    const decoded = PublicKey$7.decode(buf);
    const data = decoded.Data ?? new Uint8Array;
    switch (decoded.Type) {
      case KeyType$7.RSA:
        return supportedKeys$6.rsa.unmarshalRsaPublicKey(data);
      case KeyType$7.Ed25519:
        return supportedKeys$6.ed25519.unmarshalEd25519PublicKey(data);
      case KeyType$7.Secp256k1:
        return supportedKeys$6.secp256k1.unmarshalSecp256k1PublicKey(data);
      default:
        throw unsupportedKey$5(decoded.Type ?? "RSA");
    }
  };
  async function unmarshalPrivateKey$9(buf) {
    const decoded = PrivateKey$7.decode(buf);
    const data = decoded.Data ?? new Uint8Array;
    switch (decoded.Type) {
      case KeyType$7.RSA:
        return supportedKeys$6.rsa.unmarshalRsaPrivateKey(data);
      case KeyType$7.Ed25519:
        return supportedKeys$6.ed25519.unmarshalEd25519PrivateKey(data);
      case KeyType$7.Secp256k1:
        return supportedKeys$6.secp256k1.unmarshalSecp256k1PrivateKey(data);
      default:
        throw unsupportedKey$5(decoded.Type ?? "RSA");
    }
  }
  var base$c = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$w = function(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars$1[c];
      return p;
    }, "");
  };
  var decode$r = function(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes$1[char.codePointAt(0)];
      if (byt === undefined) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  };
  var encode$v = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$6) {
      out[offset++] = num & 255 | MSB$8;
      num /= 128;
    }
    while (num & MSBALL$6) {
      out[offset++] = num & 255 | MSB$8;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$v.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$7 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$7.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1$6) << shift : (b & REST$1$6) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1$6);
    read$7.bytes = counter2 - offset;
    return res;
  };
  var peerIdFromPeerId = function(other) {
    if (other.type === "RSA") {
      return new RSAPeerIdImpl(other);
    }
    if (other.type === "Ed25519") {
      return new Ed25519PeerIdImpl(other);
    }
    if (other.type === "secp256k1") {
      return new Secp256k1PeerIdImpl(other);
    }
    throw new CodeError$3("Not a PeerId", "ERR_INVALID_PARAMETERS");
  };
  var peerIdFromString = function(str, decoder) {
    if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
      const multihash = decode$o(base58btc$a.decode(`z${str}`));
      if (str.startsWith("12D")) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (str.startsWith("16U")) {
        return new Secp256k1PeerIdImpl({ multihash });
      } else {
        return new RSAPeerIdImpl({ multihash });
      }
    }
    return peerIdFromBytes(baseDecoder.decode(str));
  };
  var peerIdFromBytes = function(buf) {
    try {
      const multihash = decode$o(buf);
      if (multihash.code === identity$7.code) {
        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
          return new Ed25519PeerIdImpl({ multihash });
        } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
          return new Secp256k1PeerIdImpl({ multihash });
        }
      }
      if (multihash.code === sha256$7.code) {
        return new RSAPeerIdImpl({ multihash });
      }
    } catch {
      return peerIdFromCID(CID$1.decode(buf));
    }
    throw new Error("Supplied PeerID CID is invalid");
  };
  var peerIdFromCID = function(cid) {
    if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
      throw new Error("Supplied PeerID CID is invalid");
    }
    const multihash = cid.multihash;
    if (multihash.code === sha256$7.code) {
      return new RSAPeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.code === identity$7.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash: cid.multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
      }
    }
    throw new Error("Supplied PeerID CID is invalid");
  };
  async function peerIdFromKeys(publicKey, privateKey) {
    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: create$c(identity$7.code, publicKey), privateKey });
    }
    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: create$c(identity$7.code, publicKey), privateKey });
    }
    return new RSAPeerIdImpl({ multihash: await sha256$7.digest(publicKey), publicKey, privateKey });
  }
  async function getPayload(localPeer, staticPublicKey, extensions) {
    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
    if (localPeer.publicKey == null) {
      throw new Error("PublicKey was missing from local PeerId");
    }
    return createHandshakePayload(localPeer.publicKey, signedPayload, extensions);
  }
  var createHandshakePayload = function(libp2pPublicKey, signedPayload, extensions) {
    return NoiseHandshakePayload.encode({
      identityKey: libp2pPublicKey,
      identitySig: signedPayload,
      extensions: extensions ?? { webtransportCerthashes: [] }
    }).subarray();
  };
  async function signPayload(peerId, payload) {
    if (peerId.privateKey == null) {
      throw new Error("PrivateKey was missing from PeerId");
    }
    const privateKey = await unmarshalPrivateKey$9(peerId.privateKey);
    return privateKey.sign(payload);
  }
  async function getPeerIdFromPayload(payload) {
    return peerIdFromKeys(payload.identityKey);
  }
  var decodePayload = function(payload) {
    return NoiseHandshakePayload.decode(payload);
  };
  var getHandshakePayload = function(publicKey) {
    const prefix = fromString$3("noise-libp2p-static-key:");
    return concat$1([prefix, publicKey], prefix.length + publicKey.length);
  };
  async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
    const payloadPeerId = await peerIdFromKeys(payload.identityKey);
    if (!payloadPeerId.equals(remotePeer)) {
      throw new Error(`Payload identity key ${payloadPeerId.toString()} does not match expected remote peer ${remotePeer.toString()}`);
    }
    const generatedPayload = getHandshakePayload(noiseStaticKey);
    if (payloadPeerId.publicKey == null) {
      throw new Error("PublicKey was missing from PeerId");
    }
    if (payload.identitySig == null) {
      throw new Error("Signature was missing from message");
    }
    const publicKey = unmarshalPublicKey$3(payloadPeerId.publicKey);
    const valid = await publicKey.verify(generatedPayload, payload.identitySig);
    if (!valid) {
      throw new Error("Static key doesn't match to peer that signed payload!");
    }
    return payloadPeerId;
  }
  var isValidPublicKey = function(pk) {
    if (!(pk instanceof Uint8Array)) {
      return false;
    }
    if (pk.length !== 32) {
      return false;
    }
    return true;
  };
  var createDisabledLogger$7 = function(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  };
  var logger$9 = function(name2) {
    let trace = createDisabledLogger$7(`${name2}:trace`);
    if (debug.enabled(`${name2}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = debug(`${name2}:trace`);
    }
    return Object.assign(debug(name2), {
      error: debug(`${name2}:error`),
      trace
    });
  };
  var logLocalStaticKeys = function(s2) {
    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString$9(s2.publicKey, "hex")}`);
    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString$9(s2.privateKey, "hex")}`);
  };
  var logLocalEphemeralKeys = function(e) {
    if (e) {
      keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString$9(e.publicKey, "hex")}`);
      keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString$9(e.privateKey, "hex")}`);
    } else {
      keyLogger("Missing local ephemeral keys.");
    }
  };
  var logRemoteStaticKey = function(rs) {
    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString$9(rs, "hex")}`);
  };
  var logRemoteEphemeralKey = function(re) {
    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString$9(re, "hex")}`);
  };
  var logCipherState = function(session) {
    if (session.cs1 && session.cs2) {
      keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${toString$9(session.cs1.k, "hex")}`);
      keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${toString$9(session.cs2.k, "hex")}`);
    } else {
      keyLogger("Missing cipher state.");
    }
  };
  var registerMetrics = function(metrics) {
    return {
      xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
        help: "Total count of noise xxHandshakes successes_"
      }),
      xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
        help: "Total count of noise xxHandshakes errors"
      }),
      encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
        help: "Total count of noise encrypted packets successfully"
      }),
      decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
        help: "Total count of noise decrypted packets"
      }),
      decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
        help: "Total count of noise decrypt errors"
      })
    };
  };
  var noise = function(init2 = {}) {
    return () => new Noise(init2);
  };
  var base$b = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var createDisabledLogger$6 = function(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  };
  var logger$8 = function(name2) {
    let trace = createDisabledLogger$6(`${name2}:trace`);
    if (debug.enabled(`${name2}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = debug(`${name2}:trace`);
    }
    return Object.assign(debug(name2), {
      error: debug(`${name2}:error`),
      trace
    });
  };
  var getIterator = function(obj) {
    if (obj != null) {
      if (typeof obj[Symbol.iterator] === "function") {
        return obj[Symbol.iterator]();
      }
      if (typeof obj[Symbol.asyncIterator] === "function") {
        return obj[Symbol.asyncIterator]();
      }
      if (typeof obj.next === "function") {
        return obj;
      }
    }
    throw new Error("argument is not an iterator or iterable");
  };
  var abortableSource = function(source2, signal, options) {
    const opts = options ?? {};
    const iterator = getIterator(source2);
    async function* abortable() {
      let nextAbortHandler;
      const abortHandler = () => {
        if (nextAbortHandler != null)
          nextAbortHandler();
      };
      signal.addEventListener("abort", abortHandler);
      while (true) {
        let result;
        try {
          if (signal.aborted) {
            const { abortMessage, abortCode } = opts;
            throw new AbortError$4(abortMessage, abortCode);
          }
          const abort = new Promise((resolve5, reject) => {
            nextAbortHandler = () => {
              const { abortMessage, abortCode } = opts;
              reject(new AbortError$4(abortMessage, abortCode));
            };
          });
          result = await Promise.race([abort, iterator.next()]);
          nextAbortHandler = null;
        } catch (err) {
          signal.removeEventListener("abort", abortHandler);
          const isKnownAborter = err.type === "aborted" && signal.aborted;
          if (isKnownAborter && opts.onAbort != null) {
            opts.onAbort(source2);
          }
          if (typeof iterator.return === "function") {
            try {
              const p = iterator.return();
              if (p instanceof Promise) {
                p.catch((err2) => {
                  if (opts.onReturnError != null) {
                    opts.onReturnError(err2);
                  }
                });
              }
            } catch (err2) {
              if (opts.onReturnError != null) {
                opts.onReturnError(err2);
              }
            }
          }
          if (isKnownAborter && opts.returnOnAbort === true) {
            return;
          }
          throw err;
        }
        if (result.done === true) {
          break;
        }
        yield result.value;
      }
      signal.removeEventListener("abort", abortHandler);
    }
    return abortable();
  };
  var getDriverVersion$1 = function(client) {
    try {
      const _client = client.client ? client.client : client;
      const { version: version2 } = _client.topology.s.options.metadata.driver;
      const _v = version2.split(".").map((v) => parseInt(v));
      return {
        major: _v[0],
        feature: _v[1],
        patch: _v[2]
      };
    } catch (err) {
      return { major: 0, feature: 0, patch: 0 };
    }
  };
  var readVarInt = function(buf, offset = 0) {
    let res = 0;
    let shift = 0;
    let counter2 = offset;
    let b;
    const l = buf.length;
    do {
      if (counter2 >= l || shift > 49) {
        offset = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf.get(counter2++);
      res += shift < 28 ? (b & REST$7) << shift : (b & REST$7) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$7);
    offset = counter2 - offset;
    return {
      value: res,
      offset
    };
  };
  var isAsyncIterable$7 = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var batchedBytes = function(source2, options) {
    if (isAsyncIterable$7(source2)) {
      return async function* () {
        let buffer = new Uint8ArrayList;
        let ended = false;
        let deferred = pDefer();
        let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);
        if (isNaN(size) || size === 0 || size < 0) {
          size = DEFAULT_BATCH_SIZE;
        }
        if (size !== Math.round(size)) {
          throw new Error("Batch size must be an integer");
        }
        const yieldAfter = options?.yieldAfter ?? 0;
        const serialize = options?.serialize ?? DEFAULT_SERIALIZE;
        Promise.resolve().then(async () => {
          try {
            let timeout;
            for await (const buf of source2) {
              serialize(buf, buffer);
              if (buffer.byteLength >= size) {
                clearTimeout(timeout);
                deferred.resolve();
                continue;
              }
              timeout = setTimeout(() => {
                deferred.resolve();
              }, yieldAfter);
            }
            clearTimeout(timeout);
            deferred.resolve();
          } catch (err) {
            deferred.reject(err);
          } finally {
            ended = true;
          }
        });
        while (!ended) {
          await deferred.promise;
          deferred = pDefer();
          if (buffer.byteLength > 0) {
            const b = buffer;
            buffer = new Uint8ArrayList;
            yield b.subarray();
          }
        }
      }();
    }
    return function* () {
      const buffer = new Uint8ArrayList;
      let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);
      if (isNaN(size) || size === 0 || size < 0) {
        size = DEFAULT_BATCH_SIZE;
      }
      if (size !== Math.round(size)) {
        throw new Error("Batch size must be an integer");
      }
      const serialize = options?.serialize ?? DEFAULT_SERIALIZE;
      for (const buf of source2) {
        serialize(buf, buffer);
        if (buffer.byteLength >= size) {
          yield buffer.subarray(0, size);
          buffer.consume(size);
        }
      }
      if (buffer.byteLength > 0) {
        yield buffer.subarray();
      }
    }();
  };
  var allocUnsafe = function(size) {
    return new Uint8Array(size);
  };
  async function* encode$s(source2, minSendBytes = 0) {
    if (minSendBytes == null || minSendBytes === 0) {
      for await (const messages2 of source2) {
        const list = new Uint8ArrayList;
        for (const msg of messages2) {
          encoder.write(msg, list);
        }
        yield list.subarray();
      }
      return;
    }
    yield* batchedBytes(source2, {
      size: minSendBytes,
      serialize: (obj, list) => {
        for (const m of obj) {
          encoder.write(m, list);
        }
      }
    });
  }
  var isPromise$1 = function(res) {
    return res != null && typeof res.then === "function";
  };
  var createStream = function(options) {
    const { id, name: name2, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
    return new MplexStream({
      id: type === "initiator" ? `i${id}` : `r${id}`,
      streamId: id,
      name: `${name2 == null ? id : name2}`,
      direction: type === "initiator" ? "outbound" : "inbound",
      maxDataSize: maxMsgSize,
      onEnd,
      send,
      log: logger$8(`libp2p:mplex:stream:${type}:${id}`)
    });
  };
  var printMessage = function(msg) {
    const output2 = {
      ...msg,
      type: `${MessageTypeNames[msg.type]} (${msg.type})`
    };
    if (msg.type === MessageTypes.NEW_STREAM) {
      output2.data = toString$9(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
    }
    if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
      output2.data = toString$9(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
    }
    return output2;
  };
  var mplex = function(init2 = {}) {
    return () => new Mplex(init2);
  };
  var base$a = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var createDisabledLogger$5 = function(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  };
  var logger$7 = function(name2) {
    let trace = createDisabledLogger$5(`${name2}:trace`);
    if (debug.enabled(`${name2}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = debug(`${name2}:trace`);
    }
    return Object.assign(debug(name2), {
      error: debug(`${name2}:error`),
      trace
    });
  };
  var createProtocol = function(code2, size, name2, resolvable, path) {
    return {
      code: code2,
      size,
      name: name2,
      resolvable: Boolean(resolvable),
      path: Boolean(path)
    };
  };
  var getProtocol = function(proto) {
    if (typeof proto === "number") {
      if (codes$4[proto] != null) {
        return codes$4[proto];
      }
      throw new Error(`no protocol with code: ${proto}`);
    } else if (typeof proto === "string") {
      if (names[proto] != null) {
        return names[proto];
      }
      throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
  };
  var encode$q = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$5) {
      out[offset++] = num & 255 | MSB$6;
      num /= 128;
    }
    while (num & MSBALL$5) {
      out[offset++] = num & 255 | MSB$6;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$q.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$6 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$6.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1$5) << shift : (b & REST$1$5) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1$5);
    read$6.bytes = counter2 - offset;
    return res;
  };
  var base$9 = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$o = function(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars[c];
      return p;
    }, "");
  };
  var decode$h = function(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes[char.codePointAt(0)];
      if (byt === undefined) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  };
  var convertToString = function(proto, buf) {
    const protocol = getProtocol(proto);
    switch (protocol.code) {
      case 4:
      case 41:
        return bytes2ip(buf);
      case 42:
        return bytes2str(buf);
      case 6:
      case 273:
      case 33:
      case 132:
        return bytes2port(buf).toString();
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 449:
      case 777:
        return bytes2str(buf);
      case 421:
        return bytes2mh(buf);
      case 444:
        return bytes2onion(buf);
      case 445:
        return bytes2onion(buf);
      case 466:
        return bytes2mb(buf);
      default:
        return toString$9(buf, "base16");
    }
  };
  var convertToBytes = function(proto, str) {
    const protocol = getProtocol(proto);
    switch (protocol.code) {
      case 4:
        return ip2bytes(str);
      case 41:
        return ip2bytes(str);
      case 42:
        return str2bytes(str);
      case 6:
      case 273:
      case 33:
      case 132:
        return port2bytes(parseInt(str, 10));
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 449:
      case 777:
        return str2bytes(str);
      case 421:
        return mh2bytes(str);
      case 444:
        return onion2bytes(str);
      case 445:
        return onion32bytes(str);
      case 466:
        return mb2bytes(str);
      default:
        return fromString$3(str, "base16");
    }
  };
  var ip2bytes = function(ipString) {
    if (!isIP(ipString)) {
      throw new Error("invalid ip address");
    }
    return toBytes(ipString);
  };
  var bytes2ip = function(ipBuff) {
    const ipString = toString$6(ipBuff, 0, ipBuff.length);
    if (ipString == null) {
      throw new Error("ipBuff is required");
    }
    if (!isIP(ipString)) {
      throw new Error("invalid ip address");
    }
    return ipString;
  };
  var port2bytes = function(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
  };
  var bytes2port = function(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
  };
  var str2bytes = function(str) {
    const buf = fromString$3(str);
    const size = Uint8Array.from(varint$9.encode(buf.length));
    return concat$1([size, buf], size.length + buf.length);
  };
  var bytes2str = function(buf) {
    const size = varint$9.decode(buf);
    buf = buf.slice(varint$9.decode.bytes);
    if (buf.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return toString$9(buf);
  };
  var mh2bytes = function(hash2) {
    let mh;
    if (hash2[0] === "Q" || hash2[0] === "1") {
      mh = decode$j(base58btc$7.decode(`z${hash2}`)).bytes;
    } else {
      mh = CID.parse(hash2).multihash.bytes;
    }
    const size = Uint8Array.from(varint$9.encode(mh.length));
    return concat$1([size, mh], size.length + mh.length);
  };
  var mb2bytes = function(mbstr) {
    const mb = anybaseDecoder.decode(mbstr);
    const size = Uint8Array.from(varint$9.encode(mb.length));
    return concat$1([size, mb], size.length + mb.length);
  };
  var bytes2mb = function(buf) {
    const size = varint$9.decode(buf);
    const hash2 = buf.slice(varint$9.decode.bytes);
    if (hash2.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return "u" + toString$9(hash2, "base64url");
  };
  var bytes2mh = function(buf) {
    const size = varint$9.decode(buf);
    const address = buf.slice(varint$9.decode.bytes);
    if (address.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return toString$9(address, "base58btc");
  };
  var onion2bytes = function(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    const buf = base32$7.decode("b" + addr[0]);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return concat$1([buf, portBuf], buf.length + portBuf.length);
  };
  var onion32bytes = function(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    const buf = base32$7.decode(`b${addr[0]}`);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return concat$1([buf, portBuf], buf.length + portBuf.length);
  };
  var bytes2onion = function(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = toString$9(addrBytes, "base32");
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
  };
  var stringToStringTuples = function(str) {
    const tuples = [];
    const parts = str.split("/").slice(1);
    if (parts.length === 1 && parts[0] === "") {
      return [];
    }
    for (let p = 0;p < parts.length; p++) {
      const part = parts[p];
      const proto = getProtocol(part);
      if (proto.size === 0) {
        tuples.push([part]);
        continue;
      }
      p++;
      if (p >= parts.length) {
        throw ParseError("invalid address: " + str);
      }
      if (proto.path === true) {
        tuples.push([
          part,
          cleanPath(parts.slice(p).join("/"))
        ]);
        break;
      }
      tuples.push([part, parts[p]]);
    }
    return tuples;
  };
  var stringTuplesToString = function(tuples) {
    const parts = [];
    tuples.map((tup) => {
      const proto = protoFromTuple(tup);
      parts.push(proto.name);
      if (tup.length > 1 && tup[1] != null) {
        parts.push(tup[1]);
      }
      return null;
    });
    return cleanPath(parts.join("/"));
  };
  var stringTuplesToTuples = function(tuples) {
    return tuples.map((tup) => {
      if (!Array.isArray(tup)) {
        tup = [tup];
      }
      const proto = protoFromTuple(tup);
      if (tup.length > 1) {
        return [proto.code, convertToBytes(proto.code, tup[1])];
      }
      return [proto.code];
    });
  };
  var tuplesToStringTuples = function(tuples) {
    return tuples.map((tup) => {
      const proto = protoFromTuple(tup);
      if (tup[1] != null) {
        return [proto.code, convertToString(proto.code, tup[1])];
      }
      return [proto.code];
    });
  };
  var tuplesToBytes = function(tuples) {
    return fromBytes(concat$1(tuples.map((tup) => {
      const proto = protoFromTuple(tup);
      let buf = Uint8Array.from(varint$9.encode(proto.code));
      if (tup.length > 1 && tup[1] != null) {
        buf = concat$1([buf, tup[1]]);
      }
      return buf;
    })));
  };
  var sizeForAddr = function(p, addr) {
    if (p.size > 0) {
      return p.size / 8;
    } else if (p.size === 0) {
      return 0;
    } else {
      const size = varint$9.decode(addr);
      return size + (varint$9.decode.bytes ?? 0);
    }
  };
  var bytesToTuples = function(buf) {
    const tuples = [];
    let i = 0;
    while (i < buf.length) {
      const code2 = varint$9.decode(buf, i);
      const n = varint$9.decode.bytes ?? 0;
      const p = getProtocol(code2);
      const size = sizeForAddr(p, buf.slice(i + n));
      if (size === 0) {
        tuples.push([code2]);
        i += n;
        continue;
      }
      const addr = buf.slice(i + n, i + n + size);
      i += size + n;
      if (i > buf.length) {
        throw ParseError("Invalid address Uint8Array: " + toString$9(buf, "base16"));
      }
      tuples.push([code2, addr]);
    }
    return tuples;
  };
  var bytesToString = function(buf) {
    const a = bytesToTuples(buf);
    const b = tuplesToStringTuples(a);
    return stringTuplesToString(b);
  };
  var stringToBytes = function(str) {
    str = cleanPath(str);
    const a = stringToStringTuples(str);
    const b = stringTuplesToTuples(a);
    return tuplesToBytes(b);
  };
  var fromString = function(str) {
    return stringToBytes(str);
  };
  var fromBytes = function(buf) {
    const err = validateBytes(buf);
    if (err != null) {
      throw err;
    }
    return Uint8Array.from(buf);
  };
  var validateBytes = function(buf) {
    try {
      bytesToTuples(buf);
    } catch (err) {
      return err;
    }
  };
  var cleanPath = function(str) {
    return "/" + str.trim().split("/").filter((a) => a).join("/");
  };
  var ParseError = function(str) {
    return new Error("Error parsing address: " + str);
  };
  var protoFromTuple = function(tup) {
    const proto = getProtocol(tup[0]);
    return proto;
  };
  var isMultiaddr = function(value) {
    return Boolean(value?.[symbol$1]);
  };
  var multiaddr = function(addr) {
    return new DefaultMultiaddr(addr);
  };
  var multiaddrToUri = function(input, opts) {
    const ma = multiaddr(input);
    const parts = ma.toString().split("/").slice(1);
    return ma.tuples().map((tuple) => ({
      protocol: parts.shift() ?? "",
      content: tuple[1] != null ? parts.shift() ?? "" : ""
    })).reduce((str, part, i, parts2) => {
      const reduce = Reducers[part.protocol];
      if (reduce == null) {
        throw new Error(`Unsupported protocol ${part.protocol}`);
      }
      return reduce(str, part.content, i, parts2, opts);
    }, "");
  };
  var subscribe = function(event, options, evOptions) {
    return new event_iterator_1.EventIterator(({ push }) => {
      this.addEventListener(event, push, options);
      return () => this.removeEventListener(event, push, options);
    }, evOptions);
  };
  var isArrayBuffer = function(obj) {
    return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
  };
  var getDefaultBase = function() {
    if (isReactNative$1) {
      return "http://localhost";
    }
    if (!self.location) {
      return "";
    }
    return self.location.protocol + "//" + self.location.host;
  };
  var format$2 = function(obj) {
    if (typeof obj === "string") {
      const url = new URL$2(obj);
      return url.toString();
    }
    if (!(obj instanceof URL$2)) {
      const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
      const auth = obj.auth ? obj.auth + "@" : "";
      const port = obj.port ? ":" + obj.port : "";
      const protocol = obj.protocol ? obj.protocol + "//" : "";
      const host = obj.host || "";
      const hostname = obj.hostname || "";
      const search = obj.search || (obj.query ? "?" + obj.query : "");
      const hash2 = obj.hash || "";
      const pathname = obj.pathname || "";
      const path = obj.path || pathname + search;
      return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash2}`;
    }
  };
  var connect = function(addr, opts) {
    const location = typeof window === "undefined" ? "" : window.location;
    opts = opts ?? {};
    const url = wsurl(addr, location.toString());
    const socket = new WebSocket$1(url, opts.websocket);
    return duplex(socket, opts);
  };
  var isElectron$1 = function() {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
      return true;
    }
    if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  };
  var makeMatchesFunction = function(partialMatch) {
    function matches(a) {
      let ma;
      try {
        ma = multiaddr$1(a);
      } catch (err) {
        return false;
      }
      const out = partialMatch(ma.protoNames());
      if (out === null) {
        return false;
      }
      if (out === true || out === false) {
        return out;
      }
      return out.length === 0;
    }
    return matches;
  };
  var and = function(...args) {
    function partialMatch(a) {
      if (a.length < args.length) {
        return null;
      }
      let out = a;
      args.some((arg) => {
        out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
        if (Array.isArray(out)) {
          a = out;
        }
        if (out === null) {
          return true;
        }
        return false;
      });
      return out;
    }
    return {
      toString: function() {
        return "{ " + args.join(" ") + " }";
      },
      input: args,
      matches: makeMatchesFunction(partialMatch),
      partialMatch
    };
  };
  var or$8 = function(...args) {
    function partialMatch(a) {
      let out = null;
      args.some((arg) => {
        const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
        if (res != null) {
          out = res;
          return true;
        }
        return false;
      });
      return out;
    }
    const result = {
      toString: function() {
        return "{ " + args.join(" ") + " }";
      },
      input: args,
      matches: makeMatchesFunction(partialMatch),
      partialMatch
    };
    return result;
  };
  var base$8 = function(n) {
    const name2 = n;
    function matches(a) {
      let ma;
      try {
        ma = multiaddr$1(a);
      } catch (err) {
        return false;
      }
      const pnames = ma.protoNames();
      if (pnames.length === 1 && pnames[0] === name2) {
        return true;
      }
      return false;
    }
    function partialMatch(protos) {
      if (protos.length === 0) {
        return null;
      }
      if (protos[0] === name2) {
        return protos.slice(1);
      }
      return null;
    }
    return {
      toString: function() {
        return name2;
      },
      matches,
      partialMatch
    };
  };
  var all = function(multiaddrs) {
    return multiaddrs.filter((ma) => {
      if (ma.protoCodes().includes(CODE_CIRCUIT)) {
        return false;
      }
      const testMa = ma.decapsulateCode(CODE_P2P);
      return WebSockets$1.matches(testMa) || WebSocketsSecure.matches(testMa);
    });
  };
  var wss = function(multiaddrs) {
    return multiaddrs.filter((ma) => {
      if (ma.protoCodes().includes(CODE_CIRCUIT)) {
        return false;
      }
      const testMa = ma.decapsulateCode(CODE_P2P);
      return WebSocketsSecure.matches(testMa);
    });
  };
  var createListener = function() {
    throw new Error("WebSocket Servers can not be created in the browser!");
  };
  var socketToMaConn = function(stream, remoteAddr, options) {
    options = options ?? {};
    const maConn = {
      async sink(source2) {
        if (options?.signal != null) {
          source2 = abortableSource(source2, options.signal);
        }
        try {
          await stream.sink(source2);
        } catch (err) {
          if (err.type !== "aborted") {
            log$x.error(err);
          }
        }
      },
      source: options.signal != null ? abortableSource(stream.source, options.signal) : stream.source,
      remoteAddr,
      timeline: { open: Date.now() },
      async close(options2 = {}) {
        const start = Date.now();
        options2.signal = options2.signal ?? AbortSignal.timeout(CLOSE_TIMEOUT$1);
        const listener = () => {
          const { host, port } = maConn.remoteAddr.toOptions();
          log$x("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
          this.abort(new CodeError$3("Socket close timeout", "ERR_SOCKET_CLOSE_TIMEOUT"));
        };
        options2.signal.addEventListener("abort", listener);
        try {
          await stream.close();
        } catch (err) {
          this.abort(err);
        } finally {
          options2.signal.removeEventListener("abort", listener);
          maConn.timeline.close = Date.now();
        }
      },
      abort(err) {
        const { host, port } = maConn.remoteAddr.toOptions();
        log$x("timeout closing stream to %s:%s due to error", host, port, err);
        stream.destroy();
        maConn.timeline.close = Date.now();
      }
    };
    stream.socket.addEventListener("close", () => {
      if (maConn.timeline.close == null) {
        maConn.timeline.close = Date.now();
      }
    }, { once: true });
    return maConn;
  };
  var webSockets = function(init2 = {}) {
    return () => {
      return new WebSockets(init2);
    };
  };
  var keccak256 = function(input) {
    return new Uint8Array(sha3.keccak256.arrayBuffer(input));
  };
  var verifySignature = function(signature, message2, publicKey) {
    try {
      const _signature = Signature.fromCompact(signature.slice(0, 64));
      return verify(_signature, message2, publicKey);
    } catch {
      return false;
    }
  };
  var multiaddrFromFields = function(ipFamily, protocol, ipBytes, protocolBytes) {
    let ma = multiaddr$1("/" + ipFamily + "/" + convertToString$1(ipFamily, ipBytes));
    ma = ma.encapsulate(multiaddr$1("/" + protocol + "/" + convertToString$1(protocol, protocolBytes)));
    return ma;
  };
  var locationMultiaddrFromEnrFields = function(enr, protocol) {
    switch (protocol) {
      case "udp":
        return locationMultiaddrFromEnrFields(enr, "udp4") || locationMultiaddrFromEnrFields(enr, "udp6");
      case "tcp":
        return locationMultiaddrFromEnrFields(enr, "tcp4") || locationMultiaddrFromEnrFields(enr, "tcp6");
    }
    const isIpv6 = protocol.endsWith("6");
    const ipVal = enr.get(isIpv6 ? "ip6" : "ip");
    if (!ipVal)
      return;
    const protoName = protocol.slice(0, 3);
    let protoVal;
    switch (protoName) {
      case "udp":
        protoVal = isIpv6 ? enr.get("udp6") : enr.get("udp");
        break;
      case "tcp":
        protoVal = isIpv6 ? enr.get("tcp6") : enr.get("tcp");
        break;
      default:
        return;
    }
    if (!protoVal)
      return;
    return multiaddrFromFields(isIpv6 ? "ip6" : "ip4", protoName, ipVal, protoVal);
  };
  async function generateKey$h() {
    const privateKeyRaw = utils$1.randomPrivateKey();
    const publicKey = await getPublicKey$1(privateKeyRaw);
    const privateKey = concatKeys$5(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function generateKeyFromSeed$5(seed) {
    if (seed.length !== KEYS_BYTE_LENGTH$5) {
      throw new TypeError('"seed" must be 32 bytes in length.');
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
    }
    const privateKeyRaw = seed;
    const publicKey = await getPublicKey$1(privateKeyRaw);
    const privateKey = concatKeys$5(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSign$h(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH$5);
    return sign$2(msg, privateKeyRaw);
  }
  async function hashAndVerify$h(publicKey, sig, msg) {
    return verify$1(sig, msg, publicKey);
  }
  var concatKeys$5 = function(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH$5);
    for (let i = 0;i < KEYS_BYTE_LENGTH$5; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH$5 + i] = publicKey[i];
    }
    return privateKey;
  };
  var create$a = function(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest2 = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto2 = webcrypto$5.get();
    keyLength *= 8;
    async function encrypt2(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$5, { name: "AES-GCM" }, true, ["encrypt"]);
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$5, { name: "AES-GCM" }, true, ["encrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      }
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat$1([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt2(data, password) {
      const salt = data.subarray(0, saltLength);
      const nonce = data.subarray(saltLength, saltLength + nonceLength);
      const ciphertext = data.subarray(saltLength + nonceLength);
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$5, { name: "AES-GCM" }, true, ["decrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      }
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    const cipher = {
      encrypt: encrypt2,
      decrypt: decrypt2
    };
    return cipher;
  };
  async function exporter$5(privateKey, password) {
    const cipher = create$a();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return base64$7.encode(encryptedKey);
  }
  var unmarshalEd25519PrivateKey$5 = function(bytes2) {
    if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH$5) {
      bytes2 = ensureKey$5(bytes2, PRIVATE_KEY_BYTE_LENGTH$5 + PUBLIC_KEY_BYTE_LENGTH$5);
      const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$5);
      const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH$5, bytes2.length);
      return new Ed25519PrivateKey$5(privateKeyBytes2, publicKeyBytes2);
    }
    bytes2 = ensureKey$5(bytes2, PRIVATE_KEY_BYTE_LENGTH$5);
    const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$5);
    const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH$5);
    return new Ed25519PrivateKey$5(privateKeyBytes, publicKeyBytes);
  };
  var unmarshalEd25519PublicKey$5 = function(bytes2) {
    bytes2 = ensureKey$5(bytes2, PUBLIC_KEY_BYTE_LENGTH$5);
    return new Ed25519PublicKey$5(bytes2);
  };
  async function generateKeyPair$j() {
    const { privateKey, publicKey } = await generateKey$h();
    return new Ed25519PrivateKey$5(privateKey, publicKey);
  }
  async function generateKeyPairFromSeed$5(seed) {
    const { privateKey, publicKey } = await generateKeyFromSeed$5(seed);
    return new Ed25519PrivateKey$5(privateKey, publicKey);
  }
  var ensureKey$5 = function(key, length2) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length2) {
      throw new CodeError(`Key must be a Uint8Array of length ${length2}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
    }
    return key;
  };
  var bigIntegerToUintBase64url$5 = function(num, len) {
    let buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.subarray(1) : buf;
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return toString$9(buf, "base64url");
  };
  var base64urlToBigInteger$5 = function(str) {
    const buf = base64urlToBuffer$5(str);
    return new forge$n.jsbn.BigInteger(toString$9(buf, "base16"), 16);
  };
  var base64urlToBuffer$5 = function(str, len) {
    let buf = fromString$3(str, "base64urlpad");
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return buf;
  };
  var randomBytes$5 = function(length2) {
    if (isNaN(length2) || length2 <= 0) {
      throw new CodeError("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
    }
    return utils.randomBytes(length2);
  };
  var convert$5 = function(key, types) {
    return types.map((t) => base64urlToBigInteger$5(key[t]));
  };
  var jwk2priv$5 = function(key) {
    return forge$n.pki.setRsaPrivateKey(...convert$5(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
  };
  var jwk2pub$5 = function(key) {
    return forge$n.pki.setRsaPublicKey(...convert$5(key, ["n", "e"]));
  };
  var pkcs1ToJwk$5 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$5(privateKey.n),
      e: bigIntegerToUintBase64url$5(privateKey.e),
      d: bigIntegerToUintBase64url$5(privateKey.d),
      p: bigIntegerToUintBase64url$5(privateKey.p),
      q: bigIntegerToUintBase64url$5(privateKey.q),
      dp: bigIntegerToUintBase64url$5(privateKey.dP),
      dq: bigIntegerToUintBase64url$5(privateKey.dQ),
      qi: bigIntegerToUintBase64url$5(privateKey.qInv),
      alg: "RS256"
    };
  };
  var jwkToPkcs1$5 = function(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.privateKeyToAsn1({
      n: base64urlToBigInteger$5(jwk.n),
      e: base64urlToBigInteger$5(jwk.e),
      d: base64urlToBigInteger$5(jwk.d),
      p: base64urlToBigInteger$5(jwk.p),
      q: base64urlToBigInteger$5(jwk.q),
      dP: base64urlToBigInteger$5(jwk.dp),
      dQ: base64urlToBigInteger$5(jwk.dq),
      qInv: base64urlToBigInteger$5(jwk.qi)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  var pkixToJwk$5 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const publicKey = forge$n.pki.publicKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$5(publicKey.n),
      e: bigIntegerToUintBase64url$5(publicKey.e)
    };
  };
  var jwkToPkix$5 = function(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.publicKeyToAsn1({
      n: base64urlToBigInteger$5(jwk.n),
      e: base64urlToBigInteger$5(jwk.e)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  async function generateKey$g(bits2) {
    const pair2 = await webcrypto$5.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits2,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    const keys = await exportKey$5(pair2);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function unmarshalPrivateKey$8(key) {
    const privateKey = await webcrypto$5.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["sign"]);
    const pair2 = [
      privateKey,
      await derivePublicFromPrivate$5(key)
    ];
    const keys = await exportKey$5({
      privateKey: pair2[0],
      publicKey: pair2[1]
    });
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign$g(key, msg) {
    const privateKey = await webcrypto$5.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const sig = await webcrypto$5.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify$g(key, sig, msg) {
    const publicKey = await webcrypto$5.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    return webcrypto$5.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
  }
  async function exportKey$5(pair2) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new CodeError("Private and public key are required", "ERR_INVALID_PARAMETERS");
    }
    return Promise.all([
      webcrypto$5.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto$5.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
  }
  async function derivePublicFromPrivate$5(jwKey) {
    return webcrypto$5.get().subtle.importKey("jwk", {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    }, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["verify"]);
  }
  var convertKey$5 = function(key, pub, msg, handle2) {
    const fkey = pub ? jwk2pub$5(key) : jwk2priv$5(key);
    const fmsg = toString$9(Uint8Array.from(msg), "ascii");
    const fomsg = handle2(fmsg, fkey);
    return fromString$3(fomsg, "ascii");
  };
  var encrypt$5 = function(key, msg) {
    return convertKey$5(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
  };
  var decrypt$5 = function(key, msg) {
    return convertKey$5(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
  };
  async function unmarshalRsaPrivateKey$5(bytes2) {
    const jwk = pkcs1ToJwk$5(bytes2);
    const keys = await unmarshalPrivateKey$8(jwk);
    return new RsaPrivateKey$5(keys.privateKey, keys.publicKey);
  }
  var unmarshalRsaPublicKey$5 = function(bytes2) {
    const jwk = pkixToJwk$5(bytes2);
    return new RsaPublicKey$5(jwk);
  };
  async function fromJwk$5(jwk) {
    const keys = await unmarshalPrivateKey$8(jwk);
    return new RsaPrivateKey$5(keys.privateKey, keys.publicKey);
  }
  async function generateKeyPair$i(bits2) {
    const keys = await generateKey$g(bits2);
    return new RsaPrivateKey$5(keys.privateKey, keys.publicKey);
  }
  var generateKey$f = function() {
    return utils.randomPrivateKey();
  };
  async function hashAndSign$f(key, msg) {
    const { digest: digest2 } = await sha256$6.digest(msg);
    try {
      return await sign$1(digest2, key);
    } catch (err) {
      throw new CodeError(String(err), "ERR_INVALID_INPUT");
    }
  }
  async function hashAndVerify$f(key, sig, msg) {
    try {
      const { digest: digest2 } = await sha256$6.digest(msg);
      return verify(sig, digest2, key);
    } catch (err) {
      throw new CodeError(String(err), "ERR_INVALID_INPUT");
    }
  }
  var compressPublicKey$5 = function(key) {
    const point = Point.fromHex(key).toRawBytes(true);
    return point;
  };
  var validatePrivateKey$5 = function(key) {
    try {
      getPublicKey(key, true);
    } catch (err) {
      throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var validatePublicKey$5 = function(key) {
    try {
      Point.fromHex(key);
    } catch (err) {
      throw new CodeError(String(err), "ERR_INVALID_PUBLIC_KEY");
    }
  };
  var computePublicKey$5 = function(privateKey) {
    try {
      return getPublicKey(privateKey, true);
    } catch (err) {
      throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var unmarshalSecp256k1PrivateKey$5 = function(bytes2) {
    return new Secp256k1PrivateKey$5(bytes2);
  };
  var unmarshalSecp256k1PublicKey$5 = function(bytes2) {
    return new Secp256k1PublicKey$5(bytes2);
  };
  async function generateKeyPair$h() {
    const privateKeyBytes = generateKey$f();
    return new Secp256k1PrivateKey$5(privateKeyBytes);
  }
  var createPeerIdFromPublicKey = function(publicKey) {
    const _publicKey = new supportedKeys$5.secp256k1.Secp256k1PublicKey(publicKey);
    return peerIdFromKeys(_publicKey.bytes, undefined);
  };
  var decodeMultiaddrs = function(bytes2) {
    const multiaddrs = [];
    let index2 = 0;
    while (index2 < bytes2.length) {
      const sizeDataView = new DataView(bytes2.buffer, index2, MULTIADDR_LENGTH_SIZE);
      const size = sizeDataView.getUint16(0);
      index2 += MULTIADDR_LENGTH_SIZE;
      const multiaddrBytes = bytes2.slice(index2, index2 + size);
      index2 += size;
      multiaddrs.push(multiaddr$1(multiaddrBytes));
    }
    return multiaddrs;
  };
  var encodeMultiaddrs = function(multiaddrs) {
    const totalLength = multiaddrs.reduce((acc, ma) => acc + MULTIADDR_LENGTH_SIZE + ma.bytes.length, 0);
    const bytes2 = new Uint8Array(totalLength);
    const dataView = new DataView(bytes2.buffer);
    let index2 = 0;
    multiaddrs.forEach((multiaddr2) => {
      if (multiaddr2.getPeerId())
        throw new Error("`multiaddr` field MUST not contain peer id");
      dataView.setUint16(index2, multiaddr2.bytes.length);
      index2 += MULTIADDR_LENGTH_SIZE;
      bytes2.set(multiaddr2.bytes, index2);
      index2 += multiaddr2.bytes.length;
    });
    return bytes2;
  };
  var encodeWaku2 = function(protocols) {
    let byte = 0;
    if (protocols.lightPush)
      byte += 1;
    byte = byte << 1;
    if (protocols.filter)
      byte += 1;
    byte = byte << 1;
    if (protocols.store)
      byte += 1;
    byte = byte << 1;
    if (protocols.relay)
      byte += 1;
    return byte;
  };
  var decodeWaku2 = function(byte) {
    const waku2 = {
      relay: false,
      store: false,
      filter: false,
      lightPush: false
    };
    if (byte % 2)
      waku2.relay = true;
    byte = byte >> 1;
    if (byte % 2)
      waku2.store = true;
    byte = byte >> 1;
    if (byte % 2)
      waku2.filter = true;
    byte = byte >> 1;
    if (byte % 2)
      waku2.lightPush = true;
    return waku2;
  };
  var getStringValue = function(map2, key, proto) {
    const raw = map2.get(key);
    if (!raw)
      return;
    return convertToString$1(proto, raw);
  };
  var getNumberAsStringValue = function(map2, key, proto) {
    const raw = map2.get(key);
    if (!raw)
      return;
    return Number(convertToString$1(proto, raw));
  };
  var setStringValue = function(map2, key, proto, value) {
    deleteUndefined(map2, key, value, convertToBytes$1.bind({}, proto));
  };
  var setNumberAsStringValue = function(map2, key, proto, value) {
    setStringValue(map2, key, proto, value?.toString(10));
  };
  var deleteUndefined = function(map2, key, value, transform) {
    if (value !== undefined) {
      map2.set(key, transform(value));
    } else {
      map2.delete(key);
    }
  };
  async function sign(privKey, msg) {
    return sign$1(keccak256(msg), privKey, {
      der: false
    });
  }
  var nodeId = function(pubKey) {
    const publicKey = Point.fromHex(pubKey);
    const uncompressedPubkey = publicKey.toRawBytes(false);
    return bytesToHex$3(keccak256(uncompressedPubkey.slice(1)));
  };
  var _checkNormalize = function() {
    try {
      const missing = [];
      ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
        try {
          if ("test".normalize(form) !== "test") {
            throw new Error("bad normalize");
          }
        } catch (error) {
          missing.push(form);
        }
      });
      if (missing.length) {
        throw new Error("missing " + missing.join(", "));
      }
      if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
        throw new Error("broken implementation");
      }
    } catch (error) {
      return error.message;
    }
    return null;
  };
  var isHexable = function(value) {
    return !!value.toHexString;
  };
  var addSlice = function(array) {
    if (array.slice) {
      return array;
    }
    array.slice = function() {
      const args = Array.prototype.slice.call(arguments);
      return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
  };
  var isBytesLike = function(value) {
    return isHexString(value) && !(value.length % 2) || isBytes(value);
  };
  var isInteger = function(value) {
    return typeof value === "number" && value == value && value % 1 === 0;
  };
  var isBytes = function(value) {
    if (value == null) {
      return false;
    }
    if (value.constructor === Uint8Array) {
      return true;
    }
    if (typeof value === "string") {
      return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
      return false;
    }
    for (let i = 0;i < value.length; i++) {
      const v = value[i];
      if (!isInteger(v) || v < 0 || v >= 256) {
        return false;
      }
    }
    return true;
  };
  var arrayify = function(value, options) {
    if (!options) {
      options = {};
    }
    if (typeof value === "number") {
      logger$6.checkSafeUint53(value, "invalid arrayify value");
      const result = [];
      while (value) {
        result.unshift(value & 255);
        value = parseInt(String(value / 256));
      }
      if (result.length === 0) {
        result.push(0);
      }
      return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      value = value.toHexString();
    }
    if (isHexString(value)) {
      let hex = value.substring(2);
      if (hex.length % 2) {
        if (options.hexPad === "left") {
          hex = "0" + hex;
        } else if (options.hexPad === "right") {
          hex += "0";
        } else {
          logger$6.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      const result = [];
      for (let i = 0;i < hex.length; i += 2) {
        result.push(parseInt(hex.substring(i, i + 2), 16));
      }
      return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
      return addSlice(new Uint8Array(value));
    }
    return logger$6.throwArgumentError("invalid arrayify value", "value", value);
  };
  var isHexString = function(value, length2) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (length2 && value.length !== 2 + 2 * length2) {
      return false;
    }
    return true;
  };
  var hexlify = function(value, options) {
    if (!options) {
      options = {};
    }
    if (typeof value === "number") {
      logger$6.checkSafeUint53(value, "invalid hexlify value");
      let hex = "";
      while (value) {
        hex = HexCharacters[value & 15] + hex;
        value = Math.floor(value / 16);
      }
      if (hex.length) {
        if (hex.length % 2) {
          hex = "0" + hex;
        }
        return "0x" + hex;
      }
      return "0x00";
    }
    if (typeof value === "bigint") {
      value = value.toString(16);
      if (value.length % 2) {
        return "0x0" + value;
      }
      return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      return value.toHexString();
    }
    if (isHexString(value)) {
      if (value.length % 2) {
        if (options.hexPad === "left") {
          value = "0x0" + value.substring(2);
        } else if (options.hexPad === "right") {
          value += "0";
        } else {
          logger$6.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      return value.toLowerCase();
    }
    if (isBytes(value)) {
      let result = "0x";
      for (let i = 0;i < value.length; i++) {
        let v = value[i];
        result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
      }
      return result;
    }
    return logger$6.throwArgumentError("invalid hexlify value", "value", value);
  };
  var arrayifyInteger = function(value) {
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value >>= 8;
    }
    return result;
  };
  var unarrayifyInteger = function(data, offset, length2) {
    let result = 0;
    for (let i = 0;i < length2; i++) {
      result = result * 256 + data[offset + i];
    }
    return result;
  };
  var _encode = function(object) {
    if (Array.isArray(object)) {
      let payload = [];
      object.forEach(function(child) {
        payload = payload.concat(_encode(child));
      });
      if (payload.length <= 55) {
        payload.unshift(192 + payload.length);
        return payload;
      }
      const length3 = arrayifyInteger(payload.length);
      length3.unshift(247 + length3.length);
      return length3.concat(payload);
    }
    if (!isBytesLike(object)) {
      logger$5.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call(arrayify(object));
    if (data.length === 1 && data[0] <= 127) {
      return data;
    } else if (data.length <= 55) {
      data.unshift(128 + data.length);
      return data;
    }
    const length2 = arrayifyInteger(data.length);
    length2.unshift(183 + length2.length);
    return length2.concat(data);
  };
  var encode$m = function(object) {
    return hexlify(_encode(object));
  };
  var _decodeChildren = function(data, offset, childOffset, length2) {
    const result = [];
    while (childOffset < offset + 1 + length2) {
      const decoded = _decode(data, childOffset);
      result.push(decoded.result);
      childOffset += decoded.consumed;
      if (childOffset > offset + 1 + length2) {
        logger$5.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
      }
    }
    return { consumed: 1 + length2, result };
  };
  var _decode = function(data, offset) {
    if (data.length === 0) {
      logger$5.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    if (data[offset] >= 248) {
      const lengthLength = data[offset] - 247;
      if (offset + 1 + lengthLength > data.length) {
        logger$5.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const length2 = unarrayifyInteger(data, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length2 > data.length) {
        logger$5.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length2);
    } else if (data[offset] >= 192) {
      const length2 = data[offset] - 192;
      if (offset + 1 + length2 > data.length) {
        logger$5.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data, offset, offset + 1, length2);
    } else if (data[offset] >= 184) {
      const lengthLength = data[offset] - 183;
      if (offset + 1 + lengthLength > data.length) {
        logger$5.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const length2 = unarrayifyInteger(data, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length2 > data.length) {
        logger$5.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
      return { consumed: 1 + lengthLength + length2, result };
    } else if (data[offset] >= 128) {
      const length2 = data[offset] - 128;
      if (offset + 1 + length2 > data.length) {
        logger$5.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const result = hexlify(data.slice(offset + 1, offset + 1 + length2));
      return { consumed: 1 + length2, result };
    }
    return { consumed: 1, result: hexlify(data[offset]) };
  };
  var decode$g = function(data) {
    const bytes2 = arrayify(data);
    const decoded = _decode(bytes2, 0);
    if (decoded.consumed !== bytes2.length) {
      logger$5.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
  };
  async function fromValues(values) {
    const { signature, seq, kvs } = checkValues(values);
    const obj = {};
    for (let i = 0;i < kvs.length; i += 2) {
      try {
        obj[bytesToUtf8(kvs[i])] = kvs[i + 1];
      } catch (e) {
        browserExports.log("Failed to decode ENR key to UTF-8, skipping it", kvs[i], e);
      }
    }
    const _seq = decodeSeq(seq);
    const enr = await ENR.create(obj, _seq, signature);
    checkSignature(seq, kvs, enr, signature);
    return enr;
  }
  var decodeSeq = function(seq) {
    if (!seq.length)
      return BigInt(0);
    return BigInt("0x" + bytesToHex$3(seq));
  };
  var checkValues = function(values) {
    if (!Array.isArray(values)) {
      throw new Error("Decoded ENR must be an array");
    }
    if (values.length % 2 !== 0) {
      throw new Error("Decoded ENR must have an even number of elements");
    }
    const [signature, seq, ...kvs] = values;
    if (!signature || Array.isArray(signature)) {
      throw new Error("Decoded ENR invalid signature: must be a byte array");
    }
    if (!seq || Array.isArray(seq)) {
      throw new Error("Decoded ENR invalid sequence number: must be a byte array");
    }
    return { signature, seq, kvs };
  };
  var checkSignature = function(seq, kvs, enr, signature) {
    const rlpEncodedBytes = hexToBytes$3(encode$m([seq, ...kvs]));
    if (!enr.verify(rlpEncodedBytes, signature)) {
      throw new Error("Unable to verify ENR signature");
    }
  };
  var sizeOf = function(ip) {
    if (v4$1.isFormat(ip))
      return v4$1.size;
    if (v6$1.isFormat(ip))
      return v6$1.size;
    throw Error(`Invalid ip address: ${ip}`);
  };
  var familyOf = function(string2) {
    return sizeOf(string2) === v4$1.size ? 1 : 2;
  };
  var encode$l = function(ip, buff, offset) {
    offset = ~~offset;
    const size = sizeOf(ip);
    if (typeof buff === "function") {
      buff = buff(offset + size);
    }
    if (size === v4$1.size) {
      return v4$1.encode(ip, buff, offset);
    }
    return v6$1.encode(ip, buff, offset);
  };
  var decode$f = function(buff, offset, length2) {
    offset = ~~offset;
    length2 = length2 || buff.length - offset;
    if (length2 === v4$1.size) {
      return v4$1.decode(buff, offset, length2);
    }
    if (length2 === v6$1.size) {
      return v6$1.decode(buff, offset, length2);
    }
    throw Error(`Invalid buffer size needs to be ${v4$1.size} for v4 or ${v6$1.size} for v6.`);
  };
  var toString$4 = function(type) {
    switch (type) {
      case 1:
        return "A";
      case 10:
        return "NULL";
      case 28:
        return "AAAA";
      case 18:
        return "AFSDB";
      case 42:
        return "APL";
      case 257:
        return "CAA";
      case 60:
        return "CDNSKEY";
      case 59:
        return "CDS";
      case 37:
        return "CERT";
      case 5:
        return "CNAME";
      case 49:
        return "DHCID";
      case 32769:
        return "DLV";
      case 39:
        return "DNAME";
      case 48:
        return "DNSKEY";
      case 43:
        return "DS";
      case 55:
        return "HIP";
      case 13:
        return "HINFO";
      case 45:
        return "IPSECKEY";
      case 25:
        return "KEY";
      case 36:
        return "KX";
      case 29:
        return "LOC";
      case 15:
        return "MX";
      case 35:
        return "NAPTR";
      case 2:
        return "NS";
      case 47:
        return "NSEC";
      case 50:
        return "NSEC3";
      case 51:
        return "NSEC3PARAM";
      case 12:
        return "PTR";
      case 46:
        return "RRSIG";
      case 17:
        return "RP";
      case 24:
        return "SIG";
      case 6:
        return "SOA";
      case 99:
        return "SPF";
      case 33:
        return "SRV";
      case 44:
        return "SSHFP";
      case 32768:
        return "TA";
      case 249:
        return "TKEY";
      case 52:
        return "TLSA";
      case 250:
        return "TSIG";
      case 16:
        return "TXT";
      case 252:
        return "AXFR";
      case 251:
        return "IXFR";
      case 41:
        return "OPT";
      case 255:
        return "ANY";
    }
    return "UNKNOWN_" + type;
  };
  var toType = function(name2) {
    switch (name2.toUpperCase()) {
      case "A":
        return 1;
      case "NULL":
        return 10;
      case "AAAA":
        return 28;
      case "AFSDB":
        return 18;
      case "APL":
        return 42;
      case "CAA":
        return 257;
      case "CDNSKEY":
        return 60;
      case "CDS":
        return 59;
      case "CERT":
        return 37;
      case "CNAME":
        return 5;
      case "DHCID":
        return 49;
      case "DLV":
        return 32769;
      case "DNAME":
        return 39;
      case "DNSKEY":
        return 48;
      case "DS":
        return 43;
      case "HIP":
        return 55;
      case "HINFO":
        return 13;
      case "IPSECKEY":
        return 45;
      case "KEY":
        return 25;
      case "KX":
        return 36;
      case "LOC":
        return 29;
      case "MX":
        return 15;
      case "NAPTR":
        return 35;
      case "NS":
        return 2;
      case "NSEC":
        return 47;
      case "NSEC3":
        return 50;
      case "NSEC3PARAM":
        return 51;
      case "PTR":
        return 12;
      case "RRSIG":
        return 46;
      case "RP":
        return 17;
      case "SIG":
        return 24;
      case "SOA":
        return 6;
      case "SPF":
        return 99;
      case "SRV":
        return 33;
      case "SSHFP":
        return 44;
      case "TA":
        return 32768;
      case "TKEY":
        return 249;
      case "TLSA":
        return 52;
      case "TSIG":
        return 250;
      case "TXT":
        return 16;
      case "AXFR":
        return 252;
      case "IXFR":
        return 251;
      case "OPT":
        return 41;
      case "ANY":
        return 255;
      case "*":
        return 255;
    }
    if (name2.toUpperCase().startsWith("UNKNOWN_"))
      return parseInt(name2.slice(8));
    return 0;
  };
  var toString$3 = function(rcode) {
    switch (rcode) {
      case 0:
        return "NOERROR";
      case 1:
        return "FORMERR";
      case 2:
        return "SERVFAIL";
      case 3:
        return "NXDOMAIN";
      case 4:
        return "NOTIMP";
      case 5:
        return "REFUSED";
      case 6:
        return "YXDOMAIN";
      case 7:
        return "YXRRSET";
      case 8:
        return "NXRRSET";
      case 9:
        return "NOTAUTH";
      case 10:
        return "NOTZONE";
      case 11:
        return "RCODE_11";
      case 12:
        return "RCODE_12";
      case 13:
        return "RCODE_13";
      case 14:
        return "RCODE_14";
      case 15:
        return "RCODE_15";
    }
    return "RCODE_" + rcode;
  };
  var toString$2 = function(opcode) {
    switch (opcode) {
      case 0:
        return "QUERY";
      case 1:
        return "IQUERY";
      case 2:
        return "STATUS";
      case 3:
        return "OPCODE_3";
      case 4:
        return "NOTIFY";
      case 5:
        return "UPDATE";
      case 6:
        return "OPCODE_6";
      case 7:
        return "OPCODE_7";
      case 8:
        return "OPCODE_8";
      case 9:
        return "OPCODE_9";
      case 10:
        return "OPCODE_10";
      case 11:
        return "OPCODE_11";
      case 12:
        return "OPCODE_12";
      case 13:
        return "OPCODE_13";
      case 14:
        return "OPCODE_14";
      case 15:
        return "OPCODE_15";
    }
    return "OPCODE_" + opcode;
  };
  var toString$1 = function(klass) {
    switch (klass) {
      case 1:
        return "IN";
      case 2:
        return "CS";
      case 3:
        return "CH";
      case 4:
        return "HS";
      case 255:
        return "ANY";
    }
    return "UNKNOWN_" + klass;
  };
  var toClass = function(name2) {
    switch (name2.toUpperCase()) {
      case "IN":
        return 1;
      case "CS":
        return 2;
      case "CH":
        return 3;
      case "HS":
        return 4;
      case "ANY":
        return 255;
    }
    return 0;
  };
  var toString = function(type) {
    switch (type) {
      case 1:
        return "LLQ";
      case 2:
        return "UL";
      case 3:
        return "NSID";
      case 5:
        return "DAU";
      case 6:
        return "DHU";
      case 7:
        return "N3U";
      case 8:
        return "CLIENT_SUBNET";
      case 9:
        return "EXPIRE";
      case 10:
        return "COOKIE";
      case 11:
        return "TCP_KEEPALIVE";
      case 12:
        return "PADDING";
      case 13:
        return "CHAIN";
      case 14:
        return "KEY_TAG";
      case 26946:
        return "DEVICEID";
    }
    if (type < 0) {
      return null;
    }
    return `OPTION_${type}`;
  };
  var toCode = function(name2) {
    if (typeof name2 === "number") {
      return name2;
    }
    if (!name2) {
      return -1;
    }
    switch (name2.toUpperCase()) {
      case "OPTION_0":
        return 0;
      case "LLQ":
        return 1;
      case "UL":
        return 2;
      case "NSID":
        return 3;
      case "OPTION_4":
        return 4;
      case "DAU":
        return 5;
      case "DHU":
        return 6;
      case "N3U":
        return 7;
      case "CLIENT_SUBNET":
        return 8;
      case "EXPIRE":
        return 9;
      case "COOKIE":
        return 10;
      case "TCP_KEEPALIVE":
        return 11;
      case "PADDING":
        return 12;
      case "CHAIN":
        return 13;
      case "KEY_TAG":
        return 14;
      case "DEVICEID":
        return 26946;
      case "OPTION_65535":
        return 65535;
    }
    const m = name2.match(/_(\d+)$/);
    if (m) {
      return parseInt(m[1], 10);
    }
    return -1;
  };
  var encodingLength$6 = function(str) {
    let len = 0;
    const strLen = str.length;
    for (let i = 0;i < strLen; i += 1) {
      const code2 = str.charCodeAt(i);
      if (code2 <= 127) {
        len += 1;
      } else if (code2 <= 2047) {
        len += 2;
      } else if ((code2 & 63488) !== SURROGATE_A) {
        len += 3;
      } else {
        const next = i + 1;
        if (next === strLen || code2 >= SURROGATE_B) {
          len += 3;
        } else {
          const nextCode = str.charCodeAt(next);
          if ((nextCode & 64512) !== SURROGATE_B) {
            len += 3;
          } else {
            i = next;
            len += 4;
          }
        }
      }
    }
    return len;
  };
  var encode$k = function(str, buf, offset) {
    const strLen = str.length;
    if (offset === undefined || offset === null) {
      offset = 0;
    }
    if (buf === undefined) {
      buf = new Uint8Array(encodingLength$6(str) + offset);
    }
    let off = offset;
    for (let i = 0;i < strLen; i += 1) {
      let code2 = str.charCodeAt(i);
      if (code2 <= 127) {
        buf[off++] = code2;
      } else if (code2 <= 2047) {
        buf[off++] = 192 | (code2 & 1984) >> 6;
        buf[off++] = 128 | code2 & 63;
      } else if ((code2 & 63488) !== SURROGATE_A) {
        buf[off++] = 224 | (code2 & 61440) >> 12;
        buf[off++] = 128 | (code2 & 4032) >> 6;
        buf[off++] = 128 | code2 & 63;
      } else {
        const next = i + 1;
        if (next === strLen || code2 >= SURROGATE_B) {
          buf[off++] = 239;
          buf[off++] = 191;
          buf[off++] = 189;
        } else {
          const nextCode = str.charCodeAt(next);
          if ((nextCode & 64512) !== SURROGATE_B) {
            buf[off++] = 239;
            buf[off++] = 191;
            buf[off++] = 189;
          } else {
            i = next;
            code2 = 65536 | (code2 & 1023) << 10 | nextCode & 1023;
            buf[off++] = 240 | (code2 & 1835008) >> 18;
            buf[off++] = 128 | (code2 & 258048) >> 12;
            buf[off++] = 128 | (code2 & 4032) >> 6;
            buf[off++] = 128 | code2 & 63;
          }
        }
      }
    }
    encode$k.bytes = off - offset;
    return buf;
  };
  var decode$e = function(buf, start, end) {
    let result = "";
    if (start === undefined || start === null) {
      start = 0;
    }
    if (end === undefined || end === null) {
      end = buf.length;
    }
    for (let offset = start;offset < end; ) {
      const code2 = buf[offset++];
      let num;
      if (code2 <= 128) {
        num = code2;
      } else if (code2 > 191 && code2 < 224) {
        num = (code2 & 31) << 6 | buf[offset++] & 63;
      } else if (code2 > 239 && code2 < 365) {
        num = ((code2 & 7) << 18 | (buf[offset++] & 63) << 12 | (buf[offset++] & 63) << 6 | buf[offset++] & 63) - 65536;
        const numA = SURROGATE_A | num >> 10 & 1023;
        result += String.fromCharCode(numA);
        num = SURROGATE_B | num & 1023;
      } else {
        num = (code2 & 15) << 12 | (buf[offset++] & 63) << 6 | buf[offset++] & 63;
      }
      result += String.fromCharCode(num);
    }
    decode$e.bytes = end - start;
    return result;
  };
  var bytelength = function(input) {
    return typeof input === "string" ? encodingLength$6(input) : input.byteLength;
  };
  var from$d = function(input) {
    if (input instanceof Uint8Array) {
      return input;
    }
    if (Array.isArray(input)) {
      return new Uint8Array(input);
    }
    return encode$k(input);
  };
  var write$1 = function(arr, str, start) {
    if (typeof str !== "string") {
      throw new Error("unknown input type");
    }
    encode$k(str, arr, start);
    return encode$k.bytes;
  };
  var copy = function(source2, target, targetStart, sourceStart, sourceEnd) {
    if (targetStart < 0) {
      sourceStart -= targetStart;
      targetStart = 0;
    }
    if (sourceStart < 0) {
      sourceStart = 0;
    }
    if (sourceEnd < 0) {
      return new Uint8Array(0);
    }
    if (targetStart >= target.length || sourceStart >= sourceEnd) {
      return 0;
    }
    return _copyActual(source2, target, targetStart, sourceStart, sourceEnd);
  };
  var _copyActual = function(source2, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
      sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source2.length - sourceStart;
    if (nb > sourceLen) {
      nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source2.length) {
      source2 = new Uint8Array(source2.buffer, source2.byteOffset + sourceStart, nb);
    }
    target.set(source2, targetStart);
    return nb;
  };
  var codec = function({ bytes: bytes2 = 0, encode: encode3, decode: decode3, encodingLength: encodingLength2 }) {
    encode3.bytes = bytes2;
    decode3.bytes = bytes2;
    return {
      encode: encode3,
      decode: decode3,
      encodingLength: encodingLength2 || (() => bytes2)
    };
  };
  var renc = function(type) {
    switch (type.toUpperCase()) {
      case "A":
        return ra;
      case "PTR":
        return rptr;
      case "CNAME":
        return rptr;
      case "DNAME":
        return rptr;
      case "TXT":
        return rtxt;
      case "NULL":
        return rnull;
      case "AAAA":
        return raaaa;
      case "SRV":
        return rsrv;
      case "HINFO":
        return rhinfo;
      case "CAA":
        return rcaa;
      case "NS":
        return rns;
      case "SOA":
        return rsoa;
      case "MX":
        return rmx;
      case "OPT":
        return ropt;
      case "DNSKEY":
        return rdnskey;
      case "RRSIG":
        return rrrsig;
      case "RP":
        return rrp;
      case "NSEC":
        return rnsec;
      case "NSEC3":
        return rnsec3;
      case "DS":
        return rds;
    }
    return runknown;
  };
  var encodingLengthList = function(list, enc) {
    let len = 0;
    for (let i = 0;i < list.length; i++)
      len += enc.encodingLength(list[i]);
    return len;
  };
  var encodeList = function(list, enc, buf, offset) {
    for (let i = 0;i < list.length; i++) {
      enc.encode(list[i], buf, offset);
      offset += enc.encode.bytes;
    }
    return offset;
  };
  var decodeList = function(list, enc, buf, offset) {
    for (let i = 0;i < list.length; i++) {
      list[i] = enc.decode(buf, offset);
      offset += enc.decode.bytes;
    }
    return offset;
  };
  var make = function(name2, charset, padding, paddingMode) {
    if (charset.length !== 64) {
      throw new Error(`Charset needs to be 64 characters long! (${charset.length})`);
    }
    const byCharCode = new Uint8Array(256);
    const byNum = new Uint8Array(64);
    for (let i = 0;i < 64; i += 1) {
      const code2 = charset.charCodeAt(i);
      if (code2 > 255) {
        throw new Error(`Character #${i} in charset [code=${code2}, char=${charset.charAt(i)}] is too high! (max=255)`);
      }
      if (byCharCode[code2] !== 0) {
        throw new Error(`Character [code=${code2}, char=${charset.charAt(i)}] is more than once in the charset!`);
      }
      byCharCode[code2] = i;
      byNum[i] = code2;
    }
    const padCode = padding.charCodeAt(0);
    const codec2 = {
      name: name2,
      encodingLength(str) {
        const strLen = str.length;
        const len = strLen * 0.75 | 0;
        if (str.charCodeAt(strLen - 1) === padCode) {
          if (str.charCodeAt(strLen - 2) === padCode) {
            return len - 2;
          }
          return len - 1;
        }
        return len;
      },
      encode(str, buffer, offset) {
        if (buffer === null || buffer === undefined) {
          buffer = new Uint8Array(codec2.encodingLength(str));
        }
        if (offset === null || offset === undefined) {
          offset = 0;
        }
        let strLen = str.length;
        if (str.charCodeAt(strLen - 1) === padCode) {
          if (str.charCodeAt(strLen - 2) === padCode) {
            strLen -= 2;
          } else {
            strLen -= 1;
          }
        }
        const padding2 = strLen % 4;
        const safeLen = strLen - padding2;
        let off = offset;
        let i = 0;
        while (i < safeLen) {
          const code2 = byCharCode[str.charCodeAt(i)] << 18 | byCharCode[str.charCodeAt(i + 1)] << 12 | byCharCode[str.charCodeAt(i + 2)] << 6 | byCharCode[str.charCodeAt(i + 3)];
          buffer[off++] = code2 >> 16;
          buffer[off++] = code2 >> 8;
          buffer[off++] = code2;
          i += 4;
        }
        if (padding2 === 3) {
          const code2 = byCharCode[str.charCodeAt(i)] << 10 | byCharCode[str.charCodeAt(i + 1)] << 4 | byCharCode[str.charCodeAt(i + 2)] >> 2;
          buffer[off++] = code2 >> 8;
          buffer[off++] = code2;
        } else if (padding2 === 2) {
          buffer[off++] = byCharCode[str.charCodeAt(i)] << 2 | byCharCode[str.charCodeAt(i + 1)] >> 4;
        }
        codec2.encode.bytes = off - offset;
        return buffer;
      },
      decode(buffer, start, end) {
        if (start === null || start === undefined) {
          start = 0;
        }
        if (end === null || end === undefined) {
          end = buffer.length;
        }
        const length2 = end - start;
        const pad = length2 % 3;
        const safeEnd = start + length2 - pad;
        const codes2 = [];
        for (let off = start;off < safeEnd; off += 3) {
          const num = buffer[off] << 16 | buffer[off + 1] << 8 | buffer[off + 2];
          codes2.push(byNum[num >> 18 & 63], byNum[num >> 12 & 63], byNum[num >> 6 & 63], byNum[num & 63]);
        }
        if (pad === 2) {
          const num = (buffer[end - 2] << 8) + buffer[end - 1];
          codes2.push(byNum[num >> 10], byNum[num >> 4 & 63], byNum[num << 2 & 63]);
          if (paddingMode === PREFERS_PADDING) {
            codes2.push(padCode);
          }
        } else if (pad === 1) {
          const num = buffer[end - 1];
          codes2.push(byNum[num >> 2], byNum[num << 4 & 63]);
          if (paddingMode === PREFERS_PADDING) {
            codes2.push(padCode, padCode);
          }
        }
        codec2.decode.bytes = length2;
        return String.fromCharCode.apply(String, codes2);
      }
    };
    return codec2;
  };
  var reduceError = function(err) {
    if (typeof err === "string") {
      return {
        message: err
      };
    }
    try {
      const json = JSON.stringify(err);
      if (json !== "{}") {
        return JSON.parse(json);
      }
    } catch (e) {
    }
    const error = {
      message: String(err.message || err)
    };
    if (err.code !== undefined) {
      error.code = String(err.code);
    }
    return error;
  };
  var parseEndpoint = function(endpoint) {
    const parts = baseParts.exec(endpoint);
    const protocol = parts[2] || "https:";
    const host = parts[3];
    const port = parts[5];
    const path = parts[6];
    const rest = parts[7];
    if (protocol === "https:" || protocol === "http:") {
      const flags = parseFlags(rest, httpFlags);
      return {
        name: flags.name,
        protocol,
        ipv4: flags.ipv4,
        ipv6: flags.ipv6,
        host,
        port,
        path,
        method: flags.post ? "POST" : "GET"
      };
    }
    if (protocol === "udp:" || protocol === "udp4:" || protocol === "udp6:") {
      const flags = parseFlags(rest, updFlags);
      const v6Parts = /^\[(.*)\]$/.exec(host);
      if (v6Parts && protocol === "udp4:") {
        throw new Error(`Endpoint parsing error: Cannot use ipv6 host with udp4: (endpoint=${endpoint})`);
      }
      if (!v6Parts && protocol === "udp6:") {
        throw new Error(`Endpoint parsing error: Incorrectly formatted host for udp6: (endpoint=${endpoint})`);
      }
      if (v6Parts) {
        return new UDP6Endpoint({ protocol: "udp6:", ipv6: v6Parts[1], port, pk: flags.pk, name: flags.name });
      }
      return new UDP4Endpoint({ protocol: "udp4:", ipv4: host, port, pk: flags.pk, name: flags.name });
    }
    throw new InvalidProtocolError(protocol, endpoint);
  };
  var parseFlags = function(rest, regex) {
    regex.lastIndex = 0;
    const result = {};
    while (true) {
      const match = regex.exec(rest);
      if (!match)
        break;
      if (match[2]) {
        result[match[3].toLowerCase()] = match[4];
      } else {
        result[match[1].toLowerCase()] = true;
      }
    }
    return result;
  };
  var safeHost = function(host) {
    return v6Regex.test(host) && !v4Regex.test(host) ? `[${host}]` : host;
  };
  var toEndpoint = function(input) {
    let opts;
    if (typeof input === "string") {
      opts = parseEndpoint(input);
    } else {
      if (typeof input !== "object" || input === null || Array.isArray(input)) {
        throw new Error(`Can not convert ${input} to an endpoint`);
      } else if (input instanceof BaseEndpoint) {
        return input;
      }
      opts = input;
    }
    if (opts.protocol === null || opts.protocol === undefined) {
      opts.protocol = "https:";
    }
    const protocol = opts.protocol;
    if (protocol === "udp4:") {
      return new UDP4Endpoint(opts);
    }
    if (protocol === "udp6:") {
      return new UDP6Endpoint(opts);
    }
    if (protocol === "https:" || protocol === "http:") {
      return new HTTPEndpoint(opts);
    }
    throw new InvalidProtocolError(protocol, JSON.stringify(opts));
  };
  var noop = function() {
  };
  var queryDns = function() {
    throw new Error('Only "doh" endpoints are supported in the browser');
  };
  async function loadJSON(url, cache2, timeout, abortSignal) {
    const cacheKey = cache2 ? cache2.localStoragePrefix + cache2.name : null;
    if (cacheKey) {
      try {
        const cached = JSON.parse(localStorage.getItem(cacheKey));
        if (cached && cached.time > cache2.maxTime) {
          return cached;
        }
      } catch (err) {
      }
    }
    const { data } = await requestRaw(url, "GET", null, timeout, abortSignal);
    const result = {
      time: Date.now(),
      data: JSON.parse(decode$e(data))
    };
    if (cacheKey) {
      try {
        localStorage.setItem(cacheKey, JSON.stringify(result));
      } catch (err) {
        result.time = null;
      }
    }
    return result;
  }
  var requestRaw = function(url, method, data, timeout, abortSignal) {
    return new Promise((resolve5, reject) => {
      const target = new URL$1(url);
      if (method === "GET" && data) {
        target.search = "?dns=" + base64URL.decode(data);
      }
      const uri = target.toString();
      const xhr = new XMLHttpRequest;
      xhr.open(method, uri, true);
      xhr.setRequestHeader("Accept", contentType);
      if (method === "POST") {
        xhr.setRequestHeader("Content-Type", contentType);
      }
      xhr.responseType = "arraybuffer";
      xhr.timeout = timeout;
      xhr.ontimeout = ontimeout;
      xhr.onreadystatechange = onreadystatechange;
      xhr.onerror = onerror;
      xhr.onload = onload;
      if (method === "POST") {
        xhr.send(data);
      } else {
        xhr.send();
      }
      if (abortSignal) {
        abortSignal.addEventListener("abort", onabort);
      }
      function ontimeout() {
        finish(new TimeoutError$2(timeout));
        try {
          xhr.abort();
        } catch (e) {
        }
      }
      function onload() {
        if (xhr.status !== 200) {
          finish(new HTTPStatusError(uri, xhr.status, method));
        } else {
          let buf;
          if (typeof xhr.response === "string") {
            buf = encode$k(xhr.response);
          } else if (xhr.response instanceof Uint8Array) {
            buf = xhr.response;
          } else if (Array.isArray(xhr.response) || xhr.response instanceof ArrayBuffer) {
            buf = new Uint8Array(xhr.response);
          } else {
            throw new Error("Unprocessable response " + xhr.response);
          }
          finish(null, buf);
        }
      }
      function onreadystatechange() {
        if (xhr.readyState > 1 && xhr.status !== 200 && xhr.status !== 0) {
          finish(new HTTPStatusError(uri, xhr.status, method));
          try {
            xhr.abort();
          } catch (e) {
          }
        }
      }
      let finish = function(error, data2) {
        finish = noop;
        if (abortSignal) {
          abortSignal.removeEventListener("abort", onabort);
        }
        if (error) {
          resolve5({
            error,
            response: xhr
          });
        } else {
          resolve5({
            data: data2,
            response: xhr
          });
        }
      };
      function onerror() {
        finish(xhr.status === 200 ? new Error("Inexplicable XHR Error") : new HTTPStatusError(uri, xhr.status, method));
      }
      function onabort() {
        finish(new AbortError$3);
        try {
          xhr.abort();
        } catch (e) {
        }
      }
    });
  };
  var request$1 = function(url, method, packet2, timeout, abortSignal) {
    return requestRaw(url, method, packet2, timeout, abortSignal);
  };
  var processResolvers$1 = function(resolvers2) {
    return resolvers2.filter((resolver) => resolver.cors || resolver.endpoint.cors);
  };
  var processResolvers = function(res) {
    const time = res.time === null || res.time === undefined ? Date.now() : res.time;
    const resolvers2 = processResolvers$1(res.data.map((resolver) => {
      resolver.endpoint = toEndpoint(Object.assign({ name: resolver.name }, resolver.endpoint));
      return resolver;
    }));
    const endpoints = resolvers2.map((resolver) => resolver.endpoint);
    return {
      data: {
        resolvers: resolvers2,
        resolverByName: resolvers2.reduce((byName, resolver) => {
          byName[resolver.name] = resolver;
          return byName;
        }, {}),
        endpoints,
        endpointByName: endpoints.reduce((byName, endpoint) => {
          byName[endpoint.name] = endpoint;
          return byName;
        }, {})
      },
      time
    };
  };
  var toMultiQuery = function(singleQuery) {
    const query2 = Object.assign({
      type: "query"
    }, singleQuery);
    delete query2.question;
    query2.questions = [];
    if (singleQuery.question) {
      query2.questions.push(singleQuery.question);
    }
    return query2;
  };
  var queryOne = function(endpoint, query2, timeout, abortSignal) {
    if (abortSignal && abortSignal.aborted) {
      return Promise.reject(new AbortError$3);
    }
    if (endpoint.protocol === "udp4:" || endpoint.protocol === "udp6:") {
      return queryDns();
    }
    return queryDoh(endpoint, query2, timeout, abortSignal);
  };
  var queryDoh = function(endpoint, query2, timeout, abortSignal) {
    return request$1(endpoint.url, endpoint.method, encode$j(Object.assign({
      flags: RECURSION_DESIRED
    }, query2)), timeout, abortSignal).then(function(res) {
      const data = res.data;
      const response = res.response;
      let error = res.error;
      if (error === undefined) {
        if (data.length === 0) {
          error = new ResponseError("Empty.");
        } else {
          try {
            const decoded = decode$d(data);
            decoded.response = response;
            return decoded;
          } catch (err) {
            error = new ResponseError("Invalid packet (cause=" + err.message + ")", err);
          }
        }
      }
      throw Object.assign(error, { response });
    });
  };
  var isNameString = function(entry) {
    return /^@/.test(entry);
  };
  var isPromise2 = function(input) {
    if (input === null) {
      return false;
    }
    if (typeof input !== "object") {
      return false;
    }
    return typeof input.then === "function";
  };
  var toPromise = function(input) {
    return isPromise2(input) ? input : Promise.resolve(input);
  };
  var query = function(q, opts) {
    opts = Object.assign({
      retries: 5,
      timeout: 30000
    }, opts);
    if (!q.question)
      return Promise.reject(new Error("To request data you need to specify a .question!"));
    return toPromise(opts.endpoints).then((endpoints) => {
      if (!Array.isArray(endpoints) || endpoints.length === 0) {
        throw new Error("No endpoints defined to lookup dns records.");
      }
      return queryN(endpoints.map(toEndpoint), toMultiQuery(q), opts);
    }).then((data) => {
      data.question = data.questions[0];
      delete data.questions;
      return data;
    });
  };
  var queryN = function(endpoints, q, opts) {
    const endpoint = endpoints.length === 1 ? endpoints[0] : endpoints[Math.floor(Math.random() * endpoints.length) % endpoints.length];
    return queryOne(endpoint, q, opts.timeout, opts.signal).then((data) => {
      data.endpoint = endpoint.toString();
      return data;
    }, (err) => {
      if (err.name === "AbortError" || opts.retries === 0) {
        err.endpoint = endpoint.toString();
        throw err;
      }
      if (opts.retries > 0) {
        opts.retries -= 1;
      }
      return queryN(endpoints, q, opts);
    });
  };
  var filterDoh = function(endpoint) {
    return endpoint.protocol === "https:" || endpoint.protocol === "http:";
  };
  var filterDns = function(endpoint) {
    return endpoint.protocol === "udp4:" || endpoint.protocol === "udp6:";
  };
  async function fetchNodesUntilCapabilitiesFulfilled(wantedNodeCapabilityCount, errorTolerance, getNode) {
    const wanted = {
      relay: wantedNodeCapabilityCount.relay ?? 0,
      store: wantedNodeCapabilityCount.store ?? 0,
      filter: wantedNodeCapabilityCount.filter ?? 0,
      lightPush: wantedNodeCapabilityCount.lightPush ?? 0
    };
    const maxSearches = wanted.relay + wanted.store + wanted.filter + wanted.lightPush;
    const actual = {
      relay: 0,
      store: 0,
      filter: 0,
      lightPush: 0
    };
    let totalSearches = 0;
    const peers = [];
    while (!isSatisfied(wanted, actual) && totalSearches < maxSearches + errorTolerance) {
      const peer = await getNode();
      if (peer && isNewPeer(peer, peers)) {
        if (peer.waku2) {
          if (helpsSatisfyCapabilities(peer.waku2, wanted, actual)) {
            addCapabilities(peer.waku2, actual);
            peers.push(peer);
          }
        }
        log$t(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);
      }
      totalSearches++;
    }
    return peers;
  }
  async function* yieldNodesUntilCapabilitiesFulfilled(wantedNodeCapabilityCount, errorTolerance, getNode) {
    const wanted = {
      relay: wantedNodeCapabilityCount.relay ?? 0,
      store: wantedNodeCapabilityCount.store ?? 0,
      filter: wantedNodeCapabilityCount.filter ?? 0,
      lightPush: wantedNodeCapabilityCount.lightPush ?? 0
    };
    const maxSearches = wanted.relay + wanted.store + wanted.filter + wanted.lightPush;
    const actual = {
      relay: 0,
      store: 0,
      filter: 0,
      lightPush: 0
    };
    let totalSearches = 0;
    const peerNodeIds = new Set;
    while (!isSatisfied(wanted, actual) && totalSearches < maxSearches + errorTolerance) {
      const peer = await getNode();
      if (peer && peer.nodeId && !peerNodeIds.has(peer.nodeId)) {
        peerNodeIds.add(peer.nodeId);
        if (peer.waku2) {
          if (helpsSatisfyCapabilities(peer.waku2, wanted, actual)) {
            addCapabilities(peer.waku2, actual);
            yield peer;
          }
        }
        log$t(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);
      }
      totalSearches++;
    }
  }
  var isSatisfied = function(wanted, actual) {
    return actual.relay >= wanted.relay && actual.store >= wanted.store && actual.filter >= wanted.filter && actual.lightPush >= wanted.lightPush;
  };
  var isNewPeer = function(peer, peers) {
    if (!peer.nodeId)
      return false;
    for (const existingPeer of peers) {
      if (peer.nodeId === existingPeer.nodeId) {
        return false;
      }
    }
    return true;
  };
  var addCapabilities = function(node2, total) {
    if (node2.relay)
      total.relay += 1;
    if (node2.store)
      total.store += 1;
    if (node2.filter)
      total.filter += 1;
    if (node2.lightPush)
      total.lightPush += 1;
  };
  var helpsSatisfyCapabilities = function(node2, wanted, actual) {
    if (isSatisfied(wanted, actual)) {
      throw "Internal Error: Waku2 wanted capabilities are already fulfilled";
    }
    const missing = missingCapabilities(wanted, actual);
    return missing.relay && node2.relay || missing.store && node2.store || missing.filter && node2.filter || missing.lightPush && node2.lightPush;
  };
  var missingCapabilities = function(wanted, actual) {
    return {
      relay: actual.relay < wanted.relay,
      store: actual.store < wanted.store,
      filter: actual.filter < wanted.filter,
      lightPush: actual.lightPush < wanted.lightPush
    };
  };
  var getEntryType = function(entry) {
    if (entry.startsWith(ENRTree.ROOT_PREFIX))
      return ENRTree.ROOT_PREFIX;
    if (entry.startsWith(ENRTree.BRANCH_PREFIX))
      return ENRTree.BRANCH_PREFIX;
    if (entry.startsWith(ENRTree.RECORD_PREFIX))
      return ENRTree.RECORD_PREFIX;
    return "";
  };
  var selectRandomPath = function(branches, context) {
    const circularRefs = {};
    for (const [idx, subdomain] of branches.entries()) {
      if (context.visits[subdomain]) {
        circularRefs[idx] = true;
      }
    }
    if (Object.keys(circularRefs).length === branches.length) {
      throw new Error("Unresolvable circular path detected");
    }
    let index2;
    do {
      index2 = Math.floor(Math.random() * branches.length);
    } while (circularRefs[index2]);
    return branches[index2];
  };
  var wakuDnsDiscovery = function(enrUrls, wantedNodeCapabilityCount = DEFAULT_NODE_REQUIREMENTS$1) {
    return (components) => new PeerDiscoveryDns(components, { enrUrls, wantedNodeCapabilityCount });
  };
  var wakuPeerExchangeDiscovery = function() {
    return (components) => new PeerExchangeDiscovery(components);
  };
  var base$7 = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var createDisabledLogger$4 = function(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  };
  var logger$4 = function(name2) {
    let trace = createDisabledLogger$4(`${name2}:trace`);
    if (debug.enabled(`${name2}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = debug(`${name2}:trace`);
    }
    return Object.assign(debug(name2), {
      error: debug(`${name2}:error`),
      trace
    });
  };
  var commonjsRequire = function(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  };
  var Service = function(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  };
  var shuffle = function(arr) {
    if (arr.length <= 1) {
      return arr;
    }
    const randInt = () => {
      return Math.floor(Math.random() * Math.floor(arr.length));
    };
    for (let i = 0;i < arr.length; i++) {
      const j = randInt();
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  };
  var messageIdToString = function(msgId2) {
    return toString$9(msgId2, "base64");
  };
  var encode$h = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$4) {
      out[offset++] = num & 255 | MSB$5;
      num /= 128;
    }
    while (num & MSBALL$4) {
      out[offset++] = num & 255 | MSB$5;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$h.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$5 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$5.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1$4) << shift : (b & REST$1$4) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1$4);
    read$5.bytes = counter2 - offset;
    return res;
  };
  async function generateKey$e() {
    const privateKeyRaw = utils$1.randomPrivateKey();
    const publicKey = await getPublicKey$1(privateKeyRaw);
    const privateKey = concatKeys$4(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function generateKeyFromSeed$4(seed) {
    if (seed.length !== KEYS_BYTE_LENGTH$4) {
      throw new TypeError('"seed" must be 32 bytes in length.');
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
    }
    const privateKeyRaw = seed;
    const publicKey = await getPublicKey$1(privateKeyRaw);
    const privateKey = concatKeys$4(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSign$e(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH$4);
    return sign$2(msg, privateKeyRaw);
  }
  async function hashAndVerify$e(publicKey, sig, msg) {
    return verify$1(sig, msg, publicKey);
  }
  var concatKeys$4 = function(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH$4);
    for (let i = 0;i < KEYS_BYTE_LENGTH$4; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH$4 + i] = publicKey[i];
    }
    return privateKey;
  };
  var create$8 = function(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest2 = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto2 = webcrypto$4.get();
    keyLength *= 8;
    async function encrypt2(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$4, { name: "AES-GCM" }, true, ["encrypt"]);
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$4, { name: "AES-GCM" }, true, ["encrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      }
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat$1([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt2(data, password) {
      const salt = data.subarray(0, saltLength);
      const nonce = data.subarray(saltLength, saltLength + nonceLength);
      const ciphertext = data.subarray(saltLength + nonceLength);
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$4, { name: "AES-GCM" }, true, ["decrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      }
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    const cipher = {
      encrypt: encrypt2,
      decrypt: decrypt2
    };
    return cipher;
  };
  async function exporter$4(privateKey, password) {
    const cipher = create$8();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return base64$6.encode(encryptedKey);
  }
  var unmarshalEd25519PrivateKey$4 = function(bytes2) {
    if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH$4) {
      bytes2 = ensureKey$4(bytes2, PRIVATE_KEY_BYTE_LENGTH$4 + PUBLIC_KEY_BYTE_LENGTH$4);
      const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$4);
      const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH$4, bytes2.length);
      return new Ed25519PrivateKey$4(privateKeyBytes2, publicKeyBytes2);
    }
    bytes2 = ensureKey$4(bytes2, PRIVATE_KEY_BYTE_LENGTH$4);
    const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$4);
    const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH$4);
    return new Ed25519PrivateKey$4(privateKeyBytes, publicKeyBytes);
  };
  var unmarshalEd25519PublicKey$4 = function(bytes2) {
    bytes2 = ensureKey$4(bytes2, PUBLIC_KEY_BYTE_LENGTH$4);
    return new Ed25519PublicKey$4(bytes2);
  };
  async function generateKeyPair$g() {
    const { privateKey, publicKey } = await generateKey$e();
    return new Ed25519PrivateKey$4(privateKey, publicKey);
  }
  async function generateKeyPairFromSeed$4(seed) {
    const { privateKey, publicKey } = await generateKeyFromSeed$4(seed);
    return new Ed25519PrivateKey$4(privateKey, publicKey);
  }
  var ensureKey$4 = function(key, length2) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length2) {
      throw new CodeError$3(`Key must be a Uint8Array of length ${length2}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
    }
    return key;
  };
  var bigIntegerToUintBase64url$4 = function(num, len) {
    let buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.subarray(1) : buf;
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return toString$9(buf, "base64url");
  };
  var base64urlToBigInteger$4 = function(str) {
    const buf = base64urlToBuffer$4(str);
    return new forge$n.jsbn.BigInteger(toString$9(buf, "base16"), 16);
  };
  var base64urlToBuffer$4 = function(str, len) {
    let buf = fromString$3(str, "base64urlpad");
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return buf;
  };
  var randomBytes$4 = function(length2) {
    if (isNaN(length2) || length2 <= 0) {
      throw new CodeError$3("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
    }
    return utils.randomBytes(length2);
  };
  var convert$4 = function(key, types) {
    return types.map((t) => base64urlToBigInteger$4(key[t]));
  };
  var jwk2priv$4 = function(key) {
    return forge$n.pki.setRsaPrivateKey(...convert$4(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
  };
  var jwk2pub$4 = function(key) {
    return forge$n.pki.setRsaPublicKey(...convert$4(key, ["n", "e"]));
  };
  var pkcs1ToJwk$4 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$4(privateKey.n),
      e: bigIntegerToUintBase64url$4(privateKey.e),
      d: bigIntegerToUintBase64url$4(privateKey.d),
      p: bigIntegerToUintBase64url$4(privateKey.p),
      q: bigIntegerToUintBase64url$4(privateKey.q),
      dp: bigIntegerToUintBase64url$4(privateKey.dP),
      dq: bigIntegerToUintBase64url$4(privateKey.dQ),
      qi: bigIntegerToUintBase64url$4(privateKey.qInv),
      alg: "RS256"
    };
  };
  var jwkToPkcs1$4 = function(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.privateKeyToAsn1({
      n: base64urlToBigInteger$4(jwk.n),
      e: base64urlToBigInteger$4(jwk.e),
      d: base64urlToBigInteger$4(jwk.d),
      p: base64urlToBigInteger$4(jwk.p),
      q: base64urlToBigInteger$4(jwk.q),
      dP: base64urlToBigInteger$4(jwk.dp),
      dQ: base64urlToBigInteger$4(jwk.dq),
      qInv: base64urlToBigInteger$4(jwk.qi)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  var pkixToJwk$4 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const publicKey = forge$n.pki.publicKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$4(publicKey.n),
      e: bigIntegerToUintBase64url$4(publicKey.e)
    };
  };
  var jwkToPkix$4 = function(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.publicKeyToAsn1({
      n: base64urlToBigInteger$4(jwk.n),
      e: base64urlToBigInteger$4(jwk.e)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  async function generateKey$d(bits2) {
    const pair2 = await webcrypto$4.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits2,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    const keys = await exportKey$4(pair2);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function unmarshalPrivateKey$7(key) {
    const privateKey = await webcrypto$4.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["sign"]);
    const pair2 = [
      privateKey,
      await derivePublicFromPrivate$4(key)
    ];
    const keys = await exportKey$4({
      privateKey: pair2[0],
      publicKey: pair2[1]
    });
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign$d(key, msg) {
    const privateKey = await webcrypto$4.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const sig = await webcrypto$4.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify$d(key, sig, msg) {
    const publicKey = await webcrypto$4.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    return webcrypto$4.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
  }
  async function exportKey$4(pair2) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new CodeError$3("Private and public key are required", "ERR_INVALID_PARAMETERS");
    }
    return Promise.all([
      webcrypto$4.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto$4.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
  }
  async function derivePublicFromPrivate$4(jwKey) {
    return webcrypto$4.get().subtle.importKey("jwk", {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    }, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["verify"]);
  }
  var convertKey$4 = function(key, pub, msg, handle2) {
    const fkey = pub ? jwk2pub$4(key) : jwk2priv$4(key);
    const fmsg = toString$9(Uint8Array.from(msg), "ascii");
    const fomsg = handle2(fmsg, fkey);
    return fromString$3(fomsg, "ascii");
  };
  var encrypt$4 = function(key, msg) {
    return convertKey$4(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
  };
  var decrypt$4 = function(key, msg) {
    return convertKey$4(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
  };
  var keySize$4 = function(jwk) {
    if (jwk.kty !== "RSA") {
      throw new CodeError$3("invalid key type", "ERR_INVALID_KEY_TYPE");
    } else if (jwk.n == null) {
      throw new CodeError$3("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
    }
    const bytes2 = fromString$3(jwk.n, "base64url");
    return bytes2.length * 8;
  };
  async function unmarshalRsaPrivateKey$4(bytes2) {
    const jwk = pkcs1ToJwk$4(bytes2);
    if (keySize$4(jwk) > MAX_KEY_SIZE$4) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$7(jwk);
    return new RsaPrivateKey$4(keys.privateKey, keys.publicKey);
  }
  var unmarshalRsaPublicKey$4 = function(bytes2) {
    const jwk = pkixToJwk$4(bytes2);
    if (keySize$4(jwk) > MAX_KEY_SIZE$4) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    return new RsaPublicKey$4(jwk);
  };
  async function fromJwk$4(jwk) {
    if (keySize$4(jwk) > MAX_KEY_SIZE$4) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$7(jwk);
    return new RsaPrivateKey$4(keys.privateKey, keys.publicKey);
  }
  async function generateKeyPair$f(bits2) {
    if (bits2 > MAX_KEY_SIZE$4) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await generateKey$d(bits2);
    return new RsaPrivateKey$4(keys.privateKey, keys.publicKey);
  }
  var generateKey$c = function() {
    return utils.randomPrivateKey();
  };
  async function hashAndSign$c(key, msg) {
    const { digest: digest2 } = await sha256$5.digest(msg);
    try {
      return await sign$1(digest2, key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  async function hashAndVerify$c(key, sig, msg) {
    try {
      const { digest: digest2 } = await sha256$5.digest(msg);
      return verify(sig, digest2, key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  var compressPublicKey$4 = function(key) {
    const point = Point.fromHex(key).toRawBytes(true);
    return point;
  };
  var validatePrivateKey$4 = function(key) {
    try {
      getPublicKey(key, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var validatePublicKey$4 = function(key) {
    try {
      Point.fromHex(key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PUBLIC_KEY");
    }
  };
  var computePublicKey$4 = function(privateKey) {
    try {
      return getPublicKey(privateKey, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var unmarshalSecp256k1PrivateKey$4 = function(bytes2) {
    return new Secp256k1PrivateKey$4(bytes2);
  };
  var unmarshalSecp256k1PublicKey$4 = function(bytes2) {
    return new Secp256k1PublicKey$4(bytes2);
  };
  async function generateKeyPair$e() {
    const privateKeyBytes = generateKey$c();
    return new Secp256k1PrivateKey$4(privateKeyBytes);
  }
  var unsupportedKey$4 = function(type) {
    const supported = Object.keys(supportedKeys$4).join(" / ");
    return new CodeError$3(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
  };
  var typeToKey$2 = function(type) {
    type = type.toLowerCase();
    if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
      return supportedKeys$4[type];
    }
    throw unsupportedKey$4(type);
  };
  var unmarshalPublicKey$2 = function(buf) {
    const decoded = PublicKey$5.decode(buf);
    const data = decoded.Data ?? new Uint8Array;
    switch (decoded.Type) {
      case KeyType$5.RSA:
        return supportedKeys$4.rsa.unmarshalRsaPublicKey(data);
      case KeyType$5.Ed25519:
        return supportedKeys$4.ed25519.unmarshalEd25519PublicKey(data);
      case KeyType$5.Secp256k1:
        return supportedKeys$4.secp256k1.unmarshalSecp256k1PublicKey(data);
      default:
        throw unsupportedKey$4(decoded.Type ?? "RSA");
    }
  };
  var marshalPublicKey$1 = function(key, type) {
    type = (type ?? "rsa").toLowerCase();
    typeToKey$2(type);
    return key.bytes;
  };
  async function unmarshalPrivateKey$6(buf) {
    const decoded = PrivateKey$5.decode(buf);
    const data = decoded.Data ?? new Uint8Array;
    switch (decoded.Type) {
      case KeyType$5.RSA:
        return supportedKeys$4.rsa.unmarshalRsaPrivateKey(data);
      case KeyType$5.Ed25519:
        return supportedKeys$4.ed25519.unmarshalEd25519PrivateKey(data);
      case KeyType$5.Secp256k1:
        return supportedKeys$4.secp256k1.unmarshalSecp256k1PrivateKey(data);
      default:
        throw unsupportedKey$4(decoded.Type ?? "RSA");
    }
  }
  var rejectReasonFromAcceptance = function(acceptance) {
    switch (acceptance) {
      case TopicValidatorResult.Ignore:
        return RejectReason.Ignore;
      case TopicValidatorResult.Reject:
        return RejectReason.Reject;
    }
  };
  async function getPublishConfigFromPeerId(signaturePolicy, peerId) {
    switch (signaturePolicy) {
      case StrictSign: {
        if (!peerId) {
          throw Error("Must provide PeerId");
        }
        if (peerId.privateKey == null) {
          throw Error("Cannot sign message, no private key present");
        }
        if (peerId.publicKey == null) {
          throw Error("Cannot sign message, no public key present");
        }
        const privateKey = await unmarshalPrivateKey$6(peerId.privateKey);
        return {
          type: PublishConfigType.Signing,
          author: peerId,
          key: peerId.publicKey,
          privateKey
        };
      }
      case StrictNoSign:
        return {
          type: PublishConfigType.Anonymous
        };
      default:
        throw new Error(`Unknown signature policy "${signaturePolicy}"`);
    }
  }
  var createPeerScoreParams = function(p = {}) {
    return {
      ...defaultPeerScoreParams,
      ...p,
      topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
        topics[topic] = createTopicScoreParams(topicScoreParams);
        return topics;
      }, {}) : {}
    };
  };
  var createTopicScoreParams = function(p = {}) {
    return {
      ...defaultTopicScoreParams,
      ...p
    };
  };
  var validatePeerScoreParams = function(p) {
    for (const [topic, params] of Object.entries(p.topics)) {
      try {
        validateTopicScoreParams(params);
      } catch (e) {
        throw new CodeError$3(`invalid score parameters for topic ${topic}: ${e.message}`, ERR_INVALID_PEER_SCORE_PARAMS);
      }
    }
    if (p.topicScoreCap < 0) {
      throw new CodeError$3("invalid topic score cap; must be positive (or 0 for no cap)", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.appSpecificScore === null || p.appSpecificScore === undefined) {
      throw new CodeError$3("missing application specific score function", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.IPColocationFactorWeight > 0) {
      throw new CodeError$3("invalid IPColocationFactorWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
      throw new CodeError$3("invalid IPColocationFactorThreshold; must be at least 1", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.behaviourPenaltyWeight > 0) {
      throw new CodeError$3("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
      throw new CodeError$3("invalid BehaviourPenaltyDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.decayInterval < 1000) {
      throw new CodeError$3("invalid DecayInterval; must be at least 1s", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.decayToZero <= 0 || p.decayToZero >= 1) {
      throw new CodeError$3("invalid DecayToZero; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
    }
  };
  var validateTopicScoreParams = function(p) {
    if (p.topicWeight < 0) {
      throw new CodeError$3("invalid topic weight; must be >= 0", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.timeInMeshQuantum === 0) {
      throw new CodeError$3("invalid TimeInMeshQuantum; must be non zero", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.timeInMeshWeight < 0) {
      throw new CodeError$3("invalid TimeInMeshWeight; must be positive (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
      throw new CodeError$3("invalid TimeInMeshQuantum; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
      throw new CodeError$3("invalid TimeInMeshCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.firstMessageDeliveriesWeight < 0) {
      throw new CodeError$3("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
      throw new CodeError$3("invalid FirstMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
      throw new CodeError$3("invalid FirstMessageDeliveriesCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight > 0) {
      throw new CodeError$3("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
      throw new CodeError$3("invalid MeshMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
      throw new CodeError$3("invalid MeshMessageDeliveriesCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
      throw new CodeError$3("invalid MeshMessageDeliveriesThreshold; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWindow < 0) {
      throw new CodeError$3("invalid MeshMessageDeliveriesWindow; must be non-negative", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1000) {
      throw new CodeError$3("invalid MeshMessageDeliveriesActivation; must be at least 1s", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshFailurePenaltyWeight > 0) {
      throw new CodeError$3("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
      throw new CodeError$3("invalid MeshFailurePenaltyDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.invalidMessageDeliveriesWeight > 0) {
      throw new CodeError$3("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
      throw new CodeError$3("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
    }
  };
  var createPeerScoreThresholds = function(p = {}) {
    return {
      ...defaultPeerScoreThresholds,
      ...p
    };
  };
  var computeScore = function(peer, pstats, params, peerIPs) {
    let score = 0;
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      const topicParams = params.topics[topic];
      if (topicParams === undefined) {
        return;
      }
      let topicScore = 0;
      if (tstats.inMesh) {
        let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
        if (p1 > topicParams.timeInMeshCap) {
          p1 = topicParams.timeInMeshCap;
        }
        topicScore += p1 * topicParams.timeInMeshWeight;
      }
      let p2 = tstats.firstMessageDeliveries;
      if (p2 > topicParams.firstMessageDeliveriesCap) {
        p2 = topicParams.firstMessageDeliveriesCap;
      }
      topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
      if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
        const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
        const p3 = deficit * deficit;
        topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
      }
      const p3b = tstats.meshFailurePenalty;
      topicScore += p3b * topicParams.meshFailurePenaltyWeight;
      const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
      topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
      score += topicScore * topicParams.topicWeight;
    });
    if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
      score = params.topicScoreCap;
    }
    const p5 = params.appSpecificScore(peer);
    score += p5 * params.appSpecificWeight;
    pstats.knownIPs.forEach((ip) => {
      if (params.IPColocationFactorWhitelist.has(ip)) {
        return;
      }
      const peersInIP = peerIPs.get(ip);
      const numPeersInIP = peersInIP ? peersInIP.size : 0;
      if (numPeersInIP > params.IPColocationFactorThreshold) {
        const surplus = numPeersInIP - params.IPColocationFactorThreshold;
        const p6 = surplus * surplus;
        score += p6 * params.IPColocationFactorWeight;
      }
    });
    if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
      const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
      const p7 = excess * excess;
      score += p7 * params.behaviourPenaltyWeight;
    }
    return score;
  };
  var Denque = function(array, options) {
    var options = options || {};
    this._capacity = options.capacity;
    this._head = 0;
    this._tail = 0;
    if (Array.isArray(array)) {
      this._fromArray(array);
    } else {
      this._capacityMask = 3;
      this._list = new Array(4);
    }
  };
  var removeItemsFromSet = function(superSet, ineed, cond = () => true) {
    const subset = new Set;
    if (ineed <= 0)
      return subset;
    for (const id of superSet) {
      if (subset.size >= ineed)
        break;
      if (cond(id)) {
        subset.add(id);
        superSet.delete(id);
      }
    }
    return subset;
  };
  var removeFirstNItemsFromSet = function(superSet, ineed) {
    return removeItemsFromSet(superSet, ineed, () => true);
  };
  var getMetrics = function(register, topicStrToLabel, opts) {
    return {
      protocolsEnabled: register.gauge({
        name: "gossipsub_protocol",
        help: "Status of enabled protocols",
        labelNames: ["protocol"]
      }),
      topicSubscriptionStatus: register.gauge({
        name: "gossipsub_topic_subscription_status",
        help: "Status of our subscription to this topic",
        labelNames: ["topicStr"]
      }),
      topicPeersCount: register.gauge({
        name: "gossipsub_topic_peer_count",
        help: "Number of peers subscribed to each topic",
        labelNames: ["topicStr"]
      }),
      meshPeerCounts: register.gauge({
        name: "gossipsub_mesh_peer_count",
        help: "Number of peers in our mesh",
        labelNames: ["topicStr"]
      }),
      meshPeerInclusionEventsFanout: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_fanout_total",
        help: "Number of times we include peers in a topic mesh for fanout reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsRandom: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_random_total",
        help: "Number of times we include peers in a topic mesh for random reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsSubscribed: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_subscribed_total",
        help: "Number of times we include peers in a topic mesh for subscribed reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsOutbound: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_outbound_total",
        help: "Number of times we include peers in a topic mesh for outbound reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsNotEnough: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_not_enough_total",
        help: "Number of times we include peers in a topic mesh for not_enough reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsOpportunistic: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_opportunistic_total",
        help: "Number of times we include peers in a topic mesh for opportunistic reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsUnknown: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_unknown_total",
        help: "Number of times we include peers in a topic mesh for unknown reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsDisconnected: register.gauge({
        name: "gossipsub_peer_churn_events_disconnected_total",
        help: "Number of times we remove peers in a topic mesh for disconnected reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsBadScore: register.gauge({
        name: "gossipsub_peer_churn_events_bad_score_total",
        help: "Number of times we remove peers in a topic mesh for bad_score reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsPrune: register.gauge({
        name: "gossipsub_peer_churn_events_prune_total",
        help: "Number of times we remove peers in a topic mesh for prune reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsExcess: register.gauge({
        name: "gossipsub_peer_churn_events_excess_total",
        help: "Number of times we remove peers in a topic mesh for excess reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsUnknown: register.gauge({
        name: "gossipsub_peer_churn_events_unknown_total",
        help: "Number of times we remove peers in a topic mesh for unknown reasons",
        labelNames: ["topic"]
      }),
      peersPerProtocol: register.gauge({
        name: "gossipsub_peers_per_protocol_count",
        help: "Peers connected for each topic",
        labelNames: ["protocol"]
      }),
      heartbeatDuration: register.histogram({
        name: "gossipsub_heartbeat_duration_seconds",
        help: "The time it takes to complete one iteration of the heartbeat",
        buckets: [0.01, 0.1, 1]
      }),
      heartbeatSkipped: register.gauge({
        name: "gossipsub_heartbeat_skipped",
        help: "Heartbeat run took longer than heartbeat interval so next is skipped"
      }),
      acceptedMessagesTotal: register.gauge({
        name: "gossipsub_accepted_messages_total",
        help: "Total accepted messages for each topic",
        labelNames: ["topic"]
      }),
      ignoredMessagesTotal: register.gauge({
        name: "gossipsub_ignored_messages_total",
        help: "Total ignored messages for each topic",
        labelNames: ["topic"]
      }),
      rejectedMessagesTotal: register.gauge({
        name: "gossipsub_rejected_messages_total",
        help: "Total rejected messages for each topic",
        labelNames: ["topic"]
      }),
      unknownValidationResultsTotal: register.gauge({
        name: "gossipsub_unknown_validation_results_total",
        help: "Total unknown validation results for each topic",
        labelNames: ["topic"]
      }),
      asyncValidationMcacheHit: register.gauge({
        name: "gossipsub_async_validation_mcache_hit_total",
        help: "Async validation result reported by the user layer",
        labelNames: ["hit"]
      }),
      asyncValidationDelayFromFirstSeenSec: register.histogram({
        name: "gossipsub_async_validation_delay_from_first_seen",
        help: "Async validation report delay from first seen in second",
        labelNames: ["topic"],
        buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]
      }),
      asyncValidationUnknownFirstSeen: register.gauge({
        name: "gossipsub_async_validation_unknown_first_seen_count_total",
        help: "Async validation report unknown first seen value for message"
      }),
      peerReadStreamError: register.gauge({
        name: "gossipsub_peer_read_stream_err_count_total",
        help: "Peer read stream error"
      }),
      rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
      rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
      rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
      rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
      rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
      rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
      rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
      rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
      rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
      rpcDataError: register.gauge({ name: "gossipsub_rpc_data_err_count_total", help: "RPC data error" }),
      rpcRecvError: register.gauge({ name: "gossipsub_rpc_recv_err_count_total", help: "RPC recv error" }),
      rpcRecvNotAccepted: register.gauge({
        name: "gossipsub_rpc_rcv_not_accepted_total",
        help: "Total count of RPC dropped because acceptFrom() == false"
      }),
      rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
      rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
      rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
      rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
      rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
      rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
      rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
      rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
      rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
      msgPublishCount: register.gauge({
        name: "gossipsub_msg_publish_count_total",
        help: "Total count of msg published by topic",
        labelNames: ["topic"]
      }),
      msgPublishPeersByTopic: register.gauge({
        name: "gossipsub_msg_publish_peers_total",
        help: "Total count of peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      directPeersPublishedTotal: register.gauge({
        name: "gossipsub_direct_peers_published_total",
        help: "Total direct peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      floodsubPeersPublishedTotal: register.gauge({
        name: "gossipsub_floodsub_peers_published_total",
        help: "Total floodsub peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      meshPeersPublishedTotal: register.gauge({
        name: "gossipsub_mesh_peers_published_total",
        help: "Total mesh peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      fanoutPeersPublishedTotal: register.gauge({
        name: "gossipsub_fanout_peers_published_total",
        help: "Total fanout peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      msgPublishBytes: register.gauge({
        name: "gossipsub_msg_publish_bytes_total",
        help: "Total count of msg publish data.length bytes",
        labelNames: ["topic"]
      }),
      msgPublishTime: register.histogram({
        name: "gossipsub_msg_publish_seconds",
        help: "Total time in seconds to publish a message",
        buckets: [0.001, 0.002, 0.005, 0.01, 0.1, 0.5, 1],
        labelNames: ["topic"]
      }),
      msgForwardCount: register.gauge({
        name: "gossipsub_msg_forward_count_total",
        help: "Total count of msg forwarded by topic",
        labelNames: ["topic"]
      }),
      msgForwardPeers: register.gauge({
        name: "gossipsub_msg_forward_peers_total",
        help: "Total count of peers that we forward a msg to",
        labelNames: ["topic"]
      }),
      msgReceivedPreValidation: register.gauge({
        name: "gossipsub_msg_received_prevalidation_total",
        help: "Total count of recv msgs before any validation",
        labelNames: ["topic"]
      }),
      msgReceivedError: register.gauge({
        name: "gossipsub_msg_received_error_total",
        help: "Total count of recv msgs error",
        labelNames: ["topic"]
      }),
      prevalidationInvalidTotal: register.gauge({
        name: "gossipsub_pre_validation_invalid_total",
        help: "Total count of invalid messages received",
        labelNames: ["topic"]
      }),
      prevalidationValidTotal: register.gauge({
        name: "gossipsub_pre_validation_valid_total",
        help: "Total count of valid messages received",
        labelNames: ["topic"]
      }),
      prevalidationDuplicateTotal: register.gauge({
        name: "gossipsub_pre_validation_duplicate_total",
        help: "Total count of duplicate messages received",
        labelNames: ["topic"]
      }),
      prevalidationUnknownTotal: register.gauge({
        name: "gossipsub_pre_validation_unknown_status_total",
        help: "Total count of unknown_status messages received",
        labelNames: ["topic"]
      }),
      msgReceivedInvalid: register.gauge({
        name: "gossipsub_msg_received_invalid_total",
        help: "Tracks specific reason of invalid",
        labelNames: ["error"]
      }),
      msgReceivedInvalidByTopic: register.gauge({
        name: "gossipsub_msg_received_invalid_by_topic_total",
        help: "Tracks specific invalid message by topic",
        labelNames: ["topic"]
      }),
      duplicateMsgDeliveryDelay: register.histogram({
        name: "gossisub_duplicate_msg_delivery_delay_seconds",
        help: "Time since the 1st duplicated message validated",
        labelNames: ["topic"],
        buckets: [
          0.25 * opts.maxMeshMessageDeliveriesWindowSec,
          0.5 * opts.maxMeshMessageDeliveriesWindowSec,
          1 * opts.maxMeshMessageDeliveriesWindowSec,
          2 * opts.maxMeshMessageDeliveriesWindowSec,
          4 * opts.maxMeshMessageDeliveriesWindowSec
        ]
      }),
      duplicateMsgLateDelivery: register.gauge({
        name: "gossisub_duplicate_msg_late_delivery_total",
        help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
        labelNames: ["topic"]
      }),
      duplicateMsgIgnored: register.gauge({
        name: "gossisub_ignored_published_duplicate_msgs_total",
        help: "Total count of published duplicate message ignored by topic",
        labelNames: ["topic"]
      }),
      scoreFnCalls: register.gauge({
        name: "gossipsub_score_fn_calls_total",
        help: "Total times score() is called"
      }),
      scoreFnRuns: register.gauge({
        name: "gossipsub_score_fn_runs_total",
        help: "Total times score() call actually computed computeScore(), no cache"
      }),
      scoreCachedDelta: register.histogram({
        name: "gossipsub_score_cache_delta",
        help: "Delta of score between cached values that expired",
        buckets: [10, 100, 1000]
      }),
      peersByScoreThreshold: register.gauge({
        name: "gossipsub_peers_by_score_threshold_count",
        help: "Current count of peers by score threshold",
        labelNames: ["threshold"]
      }),
      score: register.avgMinMax({
        name: "gossipsub_score",
        help: "Avg min max of gossip scores"
      }),
      scoreWeights: register.avgMinMax({
        name: "gossipsub_score_weights",
        help: "Separate score weights",
        labelNames: ["topic", "p"]
      }),
      scorePerMesh: register.avgMinMax({
        name: "gossipsub_score_per_mesh",
        help: "Histogram of the scores for each mesh topic",
        labelNames: ["topic"]
      }),
      scoringPenalties: register.gauge({
        name: "gossipsub_scoring_penalties_total",
        help: "A counter of the kind of penalties being applied to peers",
        labelNames: ["penalty"]
      }),
      behaviourPenalty: register.histogram({
        name: "gossipsub_peer_stat_behaviour_penalty",
        help: "Current peer stat behaviour_penalty at each scrape",
        buckets: [
          0.25 * opts.behaviourPenaltyThreshold,
          0.5 * opts.behaviourPenaltyThreshold,
          1 * opts.behaviourPenaltyThreshold,
          2 * opts.behaviourPenaltyThreshold,
          4 * opts.behaviourPenaltyThreshold
        ]
      }),
      ihaveRcvIgnored: register.gauge({
        name: "gossipsub_ihave_rcv_ignored_total",
        help: "Total received IHAVE messages that we ignore for some reason",
        labelNames: ["reason"]
      }),
      ihaveRcvMsgids: register.gauge({
        name: "gossipsub_ihave_rcv_msgids_total",
        help: "Total received IHAVE messages by topic",
        labelNames: ["topic"]
      }),
      ihaveRcvNotSeenMsgids: register.gauge({
        name: "gossipsub_ihave_rcv_not_seen_msgids_total",
        help: "Total messages per topic we do not have, not actual requests",
        labelNames: ["topic"]
      }),
      iwantRcvMsgids: register.gauge({
        name: "gossipsub_iwant_rcv_msgids_total",
        help: "Total received IWANT messages by topic",
        labelNames: ["topic"]
      }),
      iwantRcvDonthaveMsgids: register.gauge({
        name: "gossipsub_iwant_rcv_dont_have_msgids_total",
        help: "Total requested messageIDs that we do not have"
      }),
      iwantPromiseStarted: register.gauge({
        name: "gossipsub_iwant_promise_sent_total",
        help: "Total count of started IWANT promises"
      }),
      iwantPromiseResolved: register.gauge({
        name: "gossipsub_iwant_promise_resolved_total",
        help: "Total count of resolved IWANT promises"
      }),
      iwantPromiseResolvedFromDuplicate: register.gauge({
        name: "gossipsub_iwant_promise_resolved_from_duplicate_total",
        help: "Total count of resolved IWANT promises from duplicate messages"
      }),
      iwantPromiseResolvedPeers: register.gauge({
        name: "gossipsub_iwant_promise_resolved_peers",
        help: "Total count of peers we have asked IWANT promises that are resolved"
      }),
      iwantPromiseBroken: register.gauge({
        name: "gossipsub_iwant_promise_broken",
        help: "Total count of broken IWANT promises"
      }),
      iwantMessagePruned: register.gauge({
        name: "gossipsub_iwant_message_pruned",
        help: "Total count of pruned IWANT messages"
      }),
      iwantPromiseDeliveryTime: register.histogram({
        name: "gossipsub_iwant_promise_delivery_seconds",
        help: "Histogram of delivery time of resolved IWANT promises",
        buckets: [
          0.5 * opts.gossipPromiseExpireSec,
          1 * opts.gossipPromiseExpireSec,
          2 * opts.gossipPromiseExpireSec,
          4 * opts.gossipPromiseExpireSec
        ]
      }),
      iwantPromiseUntracked: register.gauge({
        name: "gossip_iwant_promise_untracked",
        help: "Total count of untracked IWANT promise"
      }),
      connectedPeersBackoffSec: register.histogram({
        name: "gossipsub_connected_peers_backoff_seconds",
        help: "Backoff time in seconds",
        buckets: [1, 2, 4, 10, 20, 60, 120]
      }),
      cacheSize: register.gauge({
        name: "gossipsub_cache_size",
        help: "Unbounded cache sizes",
        labelNames: ["cache"]
      }),
      mcacheSize: register.gauge({
        name: "gossipsub_mcache_size",
        help: "Current mcache msg count"
      }),
      mcacheNotValidatedCount: register.gauge({
        name: "gossipsub_mcache_not_validated_count",
        help: "Current mcache msg count not validated"
      }),
      fastMsgIdCacheCollision: register.gauge({
        name: "gossipsub_fastmsgid_cache_collision_total",
        help: "Total count of key collisions on fastmsgid cache put"
      }),
      newConnectionCount: register.gauge({
        name: "gossipsub_new_connection_total",
        help: "Total new connection by status",
        labelNames: ["status"]
      }),
      topicStrToLabel,
      toTopic(topicStr) {
        return this.topicStrToLabel.get(topicStr) ?? topicStr;
      },
      onJoin(topicStr) {
        this.topicSubscriptionStatus.set({ topicStr }, 1);
        this.meshPeerCounts.set({ topicStr }, 0);
      },
      onLeave(topicStr) {
        this.topicSubscriptionStatus.set({ topicStr }, 0);
        this.meshPeerCounts.set({ topicStr }, 0);
      },
      onAddToMesh(topicStr, reason, count) {
        const topic = this.toTopic(topicStr);
        switch (reason) {
          case InclusionReason.Fanout:
            this.meshPeerInclusionEventsFanout.inc({ topic }, count);
            break;
          case InclusionReason.Random:
            this.meshPeerInclusionEventsRandom.inc({ topic }, count);
            break;
          case InclusionReason.Subscribed:
            this.meshPeerInclusionEventsSubscribed.inc({ topic }, count);
            break;
          case InclusionReason.Outbound:
            this.meshPeerInclusionEventsOutbound.inc({ topic }, count);
            break;
          case InclusionReason.NotEnough:
            this.meshPeerInclusionEventsNotEnough.inc({ topic }, count);
            break;
          case InclusionReason.Opportunistic:
            this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count);
            break;
          default:
            this.meshPeerInclusionEventsUnknown.inc({ topic }, count);
            break;
        }
      },
      onRemoveFromMesh(topicStr, reason, count) {
        const topic = this.toTopic(topicStr);
        switch (reason) {
          case ChurnReason.Dc:
            this.meshPeerChurnEventsDisconnected.inc({ topic }, count);
            break;
          case ChurnReason.BadScore:
            this.meshPeerChurnEventsBadScore.inc({ topic }, count);
            break;
          case ChurnReason.Prune:
            this.meshPeerChurnEventsPrune.inc({ topic }, count);
            break;
          case ChurnReason.Excess:
            this.meshPeerChurnEventsExcess.inc({ topic }, count);
            break;
          default:
            this.meshPeerChurnEventsUnknown.inc({ topic }, count);
            break;
        }
      },
      onReportValidation(messageRecord, acceptance, firstSeenTimestampMs) {
        this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? "hit" : "miss" });
        if (messageRecord != null) {
          const topic = this.toTopic(messageRecord.message.topic);
          switch (acceptance) {
            case TopicValidatorResult.Accept:
              this.acceptedMessagesTotal.inc({ topic });
              break;
            case TopicValidatorResult.Ignore:
              this.ignoredMessagesTotal.inc({ topic });
              break;
            case TopicValidatorResult.Reject:
              this.rejectedMessagesTotal.inc({ topic });
              break;
            default:
              this.unknownValidationResultsTotal.inc({ topic });
              break;
          }
        }
        if (firstSeenTimestampMs != null) {
          this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1000);
        } else {
          this.asyncValidationUnknownFirstSeen.inc();
        }
      },
      onScorePenalty(penalty) {
        this.scoringPenalties.inc({ penalty }, 1);
      },
      onIhaveRcv(topicStr, ihave, idonthave) {
        const topic = this.toTopic(topicStr);
        this.ihaveRcvMsgids.inc({ topic }, ihave);
        this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
      },
      onIwantRcv(iwantByTopic, iwantDonthave) {
        for (const [topicStr, iwant] of iwantByTopic) {
          const topic = this.toTopic(topicStr);
          this.iwantRcvMsgids.inc({ topic }, iwant);
        }
        this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
      },
      onForwardMsg(topicStr, tosendCount) {
        const topic = this.toTopic(topicStr);
        this.msgForwardCount.inc({ topic }, 1);
        this.msgForwardPeers.inc({ topic }, tosendCount);
      },
      onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen, ms2) {
        const topic = this.toTopic(topicStr);
        this.msgPublishCount.inc({ topic }, 1);
        this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
        this.msgPublishPeersByTopic.inc({ topic }, tosendCount);
        this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct);
        this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub);
        this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh);
        this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout);
        this.msgPublishTime.observe({ topic }, ms2 / 1000);
      },
      onMsgRecvPreValidation(topicStr) {
        const topic = this.toTopic(topicStr);
        this.msgReceivedPreValidation.inc({ topic }, 1);
      },
      onMsgRecvError(topicStr) {
        const topic = this.toTopic(topicStr);
        this.msgReceivedError.inc({ topic }, 1);
      },
      onPrevalidationResult(topicStr, status) {
        const topic = this.toTopic(topicStr);
        switch (status) {
          case MessageStatus.duplicate:
            this.prevalidationDuplicateTotal.inc({ topic });
            break;
          case MessageStatus.invalid:
            this.prevalidationInvalidTotal.inc({ topic });
            break;
          case MessageStatus.valid:
            this.prevalidationValidTotal.inc({ topic });
            break;
          default:
            this.prevalidationUnknownTotal.inc({ topic });
            break;
        }
      },
      onMsgRecvInvalid(topicStr, reason) {
        const topic = this.toTopic(topicStr);
        const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
        this.msgReceivedInvalid.inc({ error }, 1);
        this.msgReceivedInvalidByTopic.inc({ topic }, 1);
      },
      onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
        this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1000);
        if (isLateDelivery) {
          const topic = this.toTopic(topicStr);
          this.duplicateMsgLateDelivery.inc({ topic }, 1);
        }
      },
      onPublishDuplicateMsg(topicStr) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgIgnored.inc({ topic }, 1);
      },
      onPeerReadStreamError() {
        this.peerReadStreamError.inc(1);
      },
      onRpcRecvError() {
        this.rpcRecvError.inc(1);
      },
      onRpcDataError() {
        this.rpcDataError.inc(1);
      },
      onRpcRecv(rpc2, rpcBytes) {
        this.rpcRecvBytes.inc(rpcBytes);
        this.rpcRecvCount.inc(1);
        if (rpc2.subscriptions)
          this.rpcRecvSubscription.inc(rpc2.subscriptions.length);
        if (rpc2.messages)
          this.rpcRecvMessage.inc(rpc2.messages.length);
        if (rpc2.control) {
          this.rpcRecvControl.inc(1);
          if (rpc2.control.ihave)
            this.rpcRecvIHave.inc(rpc2.control.ihave.length);
          if (rpc2.control.iwant)
            this.rpcRecvIWant.inc(rpc2.control.iwant.length);
          if (rpc2.control.graft)
            this.rpcRecvGraft.inc(rpc2.control.graft.length);
          if (rpc2.control.prune)
            this.rpcRecvPrune.inc(rpc2.control.prune.length);
        }
      },
      onRpcSent(rpc2, rpcBytes) {
        this.rpcSentBytes.inc(rpcBytes);
        this.rpcSentCount.inc(1);
        if (rpc2.subscriptions)
          this.rpcSentSubscription.inc(rpc2.subscriptions.length);
        if (rpc2.messages)
          this.rpcSentMessage.inc(rpc2.messages.length);
        if (rpc2.control) {
          const ihave = rpc2.control.ihave?.length ?? 0;
          const iwant = rpc2.control.iwant?.length ?? 0;
          const graft = rpc2.control.graft?.length ?? 0;
          const prune = rpc2.control.prune?.length ?? 0;
          if (ihave > 0)
            this.rpcSentIHave.inc(ihave);
          if (iwant > 0)
            this.rpcSentIWant.inc(iwant);
          if (graft > 0)
            this.rpcSentGraft.inc(graft);
          if (prune > 0)
            this.rpcSentPrune.inc(prune);
          if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0)
            this.rpcSentControl.inc(1);
        }
      },
      registerScores(scores, scoreThresholds) {
        let graylist = 0;
        let publish = 0;
        let gossip = 0;
        let mesh = 0;
        for (const score of scores) {
          if (score >= scoreThresholds.graylistThreshold)
            graylist++;
          if (score >= scoreThresholds.publishThreshold)
            publish++;
          if (score >= scoreThresholds.gossipThreshold)
            gossip++;
          if (score >= 0)
            mesh++;
        }
        this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
        this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
        this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
        this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
        this.score.set(scores);
      },
      registerScoreWeights(sw) {
        for (const [topic, wsTopic] of sw.byTopic) {
          this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
          this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
          this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
          this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
          this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
        }
        this.scoreWeights.set({ p: "p5" }, sw.p5w);
        this.scoreWeights.set({ p: "p6" }, sw.p6w);
        this.scoreWeights.set({ p: "p7" }, sw.p7w);
      },
      registerScorePerMesh(mesh, scoreByPeer) {
        const peersPerTopicLabel = new Map;
        mesh.forEach((peers, topicStr) => {
          const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
          let peersInMesh = peersPerTopicLabel.get(topicLabel);
          if (!peersInMesh) {
            peersInMesh = new Set;
            peersPerTopicLabel.set(topicLabel, peersInMesh);
          }
          peers.forEach((p) => peersInMesh?.add(p));
        });
        for (const [topic, peers] of peersPerTopicLabel) {
          const meshScores = [];
          peers.forEach((peer) => {
            meshScores.push(scoreByPeer.get(peer) ?? 0);
          });
          this.scorePerMesh.set({ topic }, meshScores);
        }
      }
    };
  };
  async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
    switch (publishConfig.type) {
      case PublishConfigType.Signing: {
        const rpcMsg = {
          from: publishConfig.author.toBytes(),
          data: transformedData,
          seqno: randomBytes$4(8),
          topic,
          signature: undefined,
          key: undefined
        };
        const bytes2 = concat$1([SignPrefix, RPC.Message.encode(rpcMsg).finish()]);
        rpcMsg.signature = await publishConfig.privateKey.sign(bytes2);
        rpcMsg.key = publishConfig.key;
        const msg = {
          type: "signed",
          from: publishConfig.author,
          data: originalData,
          sequenceNumber: BigInt(`0x${toString$9(rpcMsg.seqno, "base16")}`),
          topic,
          signature: rpcMsg.signature,
          key: rpcMsg.key
        };
        return {
          raw: rpcMsg,
          msg
        };
      }
      case PublishConfigType.Anonymous: {
        return {
          raw: {
            from: undefined,
            data: transformedData,
            seqno: undefined,
            topic,
            signature: undefined,
            key: undefined
          },
          msg: {
            type: "unsigned",
            data: originalData,
            topic
          }
        };
      }
    }
  }
  async function validateToRawMessage(signaturePolicy, msg) {
    switch (signaturePolicy) {
      case StrictNoSign:
        if (msg.signature != null)
          return { valid: false, error: ValidateError.SignaturePresent };
        if (msg.seqno != null)
          return { valid: false, error: ValidateError.SeqnoPresent };
        if (msg.key != null)
          return { valid: false, error: ValidateError.FromPresent };
        return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
      case StrictSign: {
        if (msg.seqno == null)
          return { valid: false, error: ValidateError.InvalidSeqno };
        if (msg.seqno.length !== 8) {
          return { valid: false, error: ValidateError.InvalidSeqno };
        }
        if (msg.signature == null)
          return { valid: false, error: ValidateError.InvalidSignature };
        if (msg.from == null)
          return { valid: false, error: ValidateError.InvalidPeerId };
        let fromPeerId;
        try {
          fromPeerId = peerIdFromBytes(msg.from);
        } catch (e) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        let publicKey;
        if (msg.key) {
          publicKey = unmarshalPublicKey$2(msg.key);
          if (fromPeerId.publicKey !== undefined && !equals$4(publicKey.bytes, fromPeerId.publicKey)) {
            return { valid: false, error: ValidateError.InvalidPeerId };
          }
        } else {
          if (fromPeerId.publicKey == null) {
            return { valid: false, error: ValidateError.InvalidPeerId };
          }
          publicKey = unmarshalPublicKey$2(fromPeerId.publicKey);
        }
        const rpcMsgPreSign = {
          from: msg.from,
          data: msg.data,
          seqno: msg.seqno,
          topic: msg.topic,
          signature: undefined,
          key: undefined
        };
        const bytes2 = concat$1([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()]);
        if (!await publicKey.verify(bytes2, msg.signature)) {
          return { valid: false, error: ValidateError.InvalidSignature };
        }
        return {
          valid: true,
          message: {
            type: "signed",
            from: fromPeerId,
            data: msg.data ?? new Uint8Array(0),
            sequenceNumber: BigInt(`0x${toString$9(msg.seqno, "base16")}`),
            topic: msg.topic,
            signature: msg.signature,
            key: msg.key ?? marshalPublicKey$1(publicKey)
          }
        };
      }
    }
  }
  var base$6 = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var msgIdFnStrictSign = function(msg) {
    if (msg.type !== "signed") {
      throw new Error("expected signed message type");
    }
    if (msg.sequenceNumber == null)
      throw Error("missing seqno field");
    return msgId(msg.from.toBytes(), msg.sequenceNumber);
  };
  async function msgIdFnStrictNoSign(msg) {
    return await sha256$5.encode(msg.data);
  }
  var computeScoreWeights = function(peer, pstats, params, peerIPs, topicStrToLabel) {
    let score = 0;
    const byTopic = new Map;
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
      const topicParams = params.topics[topic];
      if (topicParams === undefined) {
        return;
      }
      let topicScores = byTopic.get(topicLabel);
      if (!topicScores) {
        topicScores = {
          p1w: 0,
          p2w: 0,
          p3w: 0,
          p3bw: 0,
          p4w: 0
        };
        byTopic.set(topicLabel, topicScores);
      }
      let p1w = 0;
      let p2w = 0;
      let p3w = 0;
      let p3bw = 0;
      let p4w = 0;
      if (tstats.inMesh) {
        const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
        p1w += p1 * topicParams.timeInMeshWeight;
      }
      let p2 = tstats.firstMessageDeliveries;
      if (p2 > topicParams.firstMessageDeliveriesCap) {
        p2 = topicParams.firstMessageDeliveriesCap;
      }
      p2w += p2 * topicParams.firstMessageDeliveriesWeight;
      if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
        const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
        const p3 = deficit * deficit;
        p3w += p3 * topicParams.meshMessageDeliveriesWeight;
      }
      const p3b = tstats.meshFailurePenalty;
      p3bw += p3b * topicParams.meshFailurePenaltyWeight;
      const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
      p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
      score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
      topicScores.p1w += p1w;
      topicScores.p2w += p2w;
      topicScores.p3w += p3w;
      topicScores.p3bw += p3bw;
      topicScores.p4w += p4w;
    });
    if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
      score = params.topicScoreCap;
      const capF = params.topicScoreCap / score;
      for (const ws of byTopic.values()) {
        ws.p1w *= capF;
        ws.p2w *= capF;
        ws.p3w *= capF;
        ws.p3bw *= capF;
        ws.p4w *= capF;
      }
    }
    let p5w = 0;
    let p6w = 0;
    let p7w = 0;
    const p5 = params.appSpecificScore(peer);
    p5w += p5 * params.appSpecificWeight;
    pstats.knownIPs.forEach((ip) => {
      if (params.IPColocationFactorWhitelist.has(ip)) {
        return;
      }
      const peersInIP = peerIPs.get(ip);
      const numPeersInIP = peersInIP ? peersInIP.size : 0;
      if (numPeersInIP > params.IPColocationFactorThreshold) {
        const surplus = numPeersInIP - params.IPColocationFactorThreshold;
        const p6 = surplus * surplus;
        p6w += p6 * params.IPColocationFactorWeight;
      }
    });
    const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
    p7w += p7 * params.behaviourPenaltyWeight;
    score += p5w + p6w + p7w;
    return {
      byTopic,
      p5w,
      p6w,
      p7w,
      score
    };
  };
  var computeAllPeersScoreWeights = function(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
    const sw = {
      byTopic: new Map,
      p5w: [],
      p6w: [],
      p7w: [],
      score: []
    };
    for (const peerIdStr of peerIdStrs) {
      const pstats = peerStats.get(peerIdStr);
      if (pstats) {
        const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
        for (const [topic, swPeerTopic] of swPeer.byTopic) {
          let swTopic = sw.byTopic.get(topic);
          if (!swTopic) {
            swTopic = {
              p1w: [],
              p2w: [],
              p3w: [],
              p3bw: [],
              p4w: []
            };
            sw.byTopic.set(topic, swTopic);
          }
          swTopic.p1w.push(swPeerTopic.p1w);
          swTopic.p2w.push(swPeerTopic.p2w);
          swTopic.p3w.push(swPeerTopic.p3w);
          swTopic.p3bw.push(swPeerTopic.p3bw);
          swTopic.p4w.push(swPeerTopic.p4w);
        }
        sw.p5w.push(swPeer.p5w);
        sw.p6w.push(swPeer.p6w);
        sw.p7w.push(swPeer.p7w);
        sw.score.push(swPeer.score);
      } else {
        sw.p5w.push(0);
        sw.p6w.push(0);
        sw.p7w.push(0);
        sw.score.push(0);
      }
    }
    return sw;
  };
  var decodeRpc = function(bytes2, opts) {
    opts = { ...opts };
    const r = protobuf.Reader.create(bytes2);
    const l = bytes2.length;
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.subscriptions && m.subscriptions.length))
            m.subscriptions = [];
          if (m.subscriptions.length < opts.maxSubscriptions)
            m.subscriptions.push(decodeSubOpts(r, r.uint32()));
          else
            r.skipType(t & 7);
          break;
        case 2:
          if (!(m.messages && m.messages.length))
            m.messages = [];
          if (m.messages.length < opts.maxMessages)
            m.messages.push(decodeMessage(r, r.uint32()));
          else
            r.skipType(t & 7);
          break;
        case 3:
          m.control = decodeControlMessage(r, r.uint32(), opts);
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  var decodeSubOpts = function(r, l) {
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.subscribe = r.bool();
          break;
        case 2:
          m.topic = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  var decodeMessage = function(r, l) {
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.from = r.bytes();
          break;
        case 2:
          m.data = r.bytes();
          break;
        case 3:
          m.seqno = r.bytes();
          break;
        case 4:
          m.topic = r.string();
          break;
        case 5:
          m.signature = r.bytes();
          break;
        case 6:
          m.key = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.topic)
      throw Error("missing required 'topic'");
    return m;
  };
  var decodeControlMessage = function(r, l, opts) {
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.ihave && m.ihave.length))
            m.ihave = [];
          if (m.ihave.length < opts.maxControlMessages)
            m.ihave.push(decodeControlIHave(r, r.uint32(), opts));
          else
            r.skipType(t & 7);
          break;
        case 2:
          if (!(m.iwant && m.iwant.length))
            m.iwant = [];
          if (m.iwant.length < opts.maxControlMessages)
            m.iwant.push(decodeControlIWant(r, r.uint32(), opts));
          else
            r.skipType(t & 7);
          break;
        case 3:
          if (!(m.graft && m.graft.length))
            m.graft = [];
          if (m.graft.length < opts.maxControlMessages)
            m.graft.push(decodeControlGraft(r, r.uint32()));
          else
            r.skipType(t & 7);
          break;
        case 4:
          if (!(m.prune && m.prune.length))
            m.prune = [];
          if (m.prune.length < opts.maxControlMessages)
            m.prune.push(decodeControlPrune(r, r.uint32(), opts));
          else
            r.skipType(t & 7);
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  var decodeControlIHave = function(r, l, opts) {
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.topicID = r.string();
          break;
        case 2:
          if (!(m.messageIDs && m.messageIDs.length))
            m.messageIDs = [];
          if (opts.maxIhaveMessageIDs-- > 0)
            m.messageIDs.push(r.bytes());
          else
            r.skipType(t & 7);
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  var decodeControlIWant = function(r, l, opts) {
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.messageIDs && m.messageIDs.length))
            m.messageIDs = [];
          if (opts.maxIwantMessageIDs-- > 0)
            m.messageIDs.push(r.bytes());
          else
            r.skipType(t & 7);
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  var decodeControlGraft = function(r, l) {
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.topicID = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  var decodeControlPrune = function(r, l, opts) {
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.topicID = r.string();
          break;
        case 2:
          if (!(m.peers && m.peers.length))
            m.peers = [];
          if (opts.maxPeerInfos-- > 0)
            m.peers.push(decodePeerInfo(r, r.uint32()));
          else
            r.skipType(t & 7);
          break;
        case 3:
          m.backoff = r.uint64();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  var decodePeerInfo = function(r, l) {
    const c = l === undefined ? r.len : r.pos + l;
    const m = {};
    while (r.pos < c) {
      const t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.peerID = r.bytes();
          break;
        case 2:
          m.signedPeerRecord = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  var multiaddrToIPStr = function(multiaddr2) {
    for (const tuple of multiaddr2.tuples()) {
      switch (tuple[0]) {
        case Protocol.ip4:
        case Protocol.ip6:
          return convertToString$1(tuple[0], tuple[1]);
      }
    }
    return null;
  };
  var messageValidator = function(peer, message$12) {
    const startTime = performance.now();
    log$n(`validating message from ${peer} received on ${message$12.topic}`);
    let result = TopicValidatorResult.Accept;
    try {
      const protoMessage = WakuMessage$4.decode(message$12.data);
      if (!protoMessage.contentTopic || !protoMessage.contentTopic.length || !protoMessage.payload || !protoMessage.payload.length) {
        result = TopicValidatorResult.Reject;
      }
    } catch (e) {
      result = TopicValidatorResult.Reject;
    }
    const endTime = performance.now();
    log$n(`Validation time (must be <100ms): ${endTime - startTime}ms`);
    return result;
  };
  var wakuRelay = function(init2 = {}) {
    return (libp2p) => new Relay(libp2p, init2);
  };
  var wakuGossipSub = function(init2 = {}) {
    return (components) => {
      init2 = {
        ...init2,
        msgIdFn: ({ data }) => sha256$a(data),
        globalSignaturePolicy: SignaturePolicy.StrictNoSign,
        fallbackToFloodsub: false
      };
      const pubsub = new GossipSub(components, init2);
      pubsub.multicodecs = RelayCodecs;
      return pubsub;
    };
  };
  var toObservers = function(decoders2, callback) {
    const contentTopicToDecoders = Array.from(groupByContentTopic(decoders2).entries());
    const contentTopicToObserversEntries = contentTopicToDecoders.map(([contentTopic, decoders3]) => [
      contentTopic,
      new Set(decoders3.map((decoder) => ({
        decoder,
        callback
      })))
    ]);
    return new Map(contentTopicToObserversEntries);
  };
  var union = function(left2, right2) {
    for (const val of right2.values()) {
      left2.add(val);
    }
    return left2;
  };
  var leftMinusJoin = function(left2, right2) {
    for (const val of right2.values()) {
      if (left2.has(val)) {
        left2.delete(val);
      }
    }
    return left2;
  };
  var ProcessEmitWarning = function(warning) {
    if (console && console.warn)
      console.warn(warning);
  };
  var EventEmitter$1 = function() {
    EventEmitter$1.init.call(this);
  };
  var checkListener = function(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  };
  var _getMaxListeners = function(that) {
    if (that._maxListeners === undefined)
      return EventEmitter$1.defaultMaxListeners;
    return that._maxListeners;
  };
  var _addListener = function(target, type, listener, prepend) {
    var m;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === undefined) {
      events2 = target._events = Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== undefined) {
        target.emit("newListener", type, listener.listener ? listener.listener : listener);
        events2 = target._events;
      }
      existing = events2[type];
    }
    if (existing === undefined) {
      existing = events2[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  };
  var onceWrapper = function() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  };
  var _onceWrap = function(target, type, listener) {
    var state = { fired: false, wrapFn: undefined, target, type, listener };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  };
  var _listeners = function(target, type, unwrap) {
    var events2 = target._events;
    if (events2 === undefined)
      return [];
    var evlistener = events2[type];
    if (evlistener === undefined)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  };
  var listenerCount = function(type) {
    var events2 = this._events;
    if (events2 !== undefined) {
      var evlistener = events2[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== undefined) {
        return evlistener.length;
      }
    }
    return 0;
  };
  var arrayClone = function(arr, n) {
    var copy2 = new Array(n);
    for (var i = 0;i < n; ++i)
      copy2[i] = arr[i];
    return copy2;
  };
  var spliceOne = function(list, index2) {
    for (;index2 + 1 < list.length; index2++)
      list[index2] = list[index2 + 1];
    list.pop();
  };
  var unwrapListeners = function(arr) {
    var ret = new Array(arr.length);
    for (var i = 0;i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  };
  var once = function(emitter, name2) {
    return new Promise(function(resolve5, reject) {
      function errorListener(err) {
        emitter.removeListener(name2, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve5([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
      if (name2 !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  };
  var addErrorHandlerIfEventEmitter = function(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  };
  var eventTargetAgnosticAddListener = function(emitter, name2, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name2, listener);
      } else {
        emitter.on(name2, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name2, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name2, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  };
  var base$5 = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$d = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$3) {
      out[offset++] = num & 255 | MSB$4;
      num /= 128;
    }
    while (num & MSBALL$3) {
      out[offset++] = num & 255 | MSB$4;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$d.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$4 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$4.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1$3) << shift : (b & REST$1$3) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1$3);
    read$4.bytes = counter2 - offset;
    return res;
  };
  async function generateKey$b() {
    const privateKeyRaw = ed25519.utils.randomPrivateKey();
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys$3(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function generateKeyFromSeed$3(seed) {
    if (seed.length !== KEYS_BYTE_LENGTH$3) {
      throw new TypeError('"seed" must be 32 bytes in length.');
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
    }
    const privateKeyRaw = seed;
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys$3(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSign$b(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH$3);
    return ed25519.sign(msg, privateKeyRaw);
  }
  async function hashAndVerify$b(publicKey, sig, msg) {
    return ed25519.verify(sig, msg, publicKey);
  }
  var concatKeys$3 = function(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH$3);
    for (let i = 0;i < KEYS_BYTE_LENGTH$3; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH$3 + i] = publicKey[i];
    }
    return privateKey;
  };
  var create$6 = function(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest2 = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto2 = webcrypto$3.get();
    keyLength *= 8;
    async function encrypt2(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$3, { name: "AES-GCM" }, true, ["encrypt"]);
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$3, { name: "AES-GCM" }, true, ["encrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      }
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat$1([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt2(data, password) {
      const salt = data.subarray(0, saltLength);
      const nonce = data.subarray(saltLength, saltLength + nonceLength);
      const ciphertext = data.subarray(saltLength + nonceLength);
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$3, { name: "AES-GCM" }, true, ["decrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      }
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    const cipher = {
      encrypt: encrypt2,
      decrypt: decrypt2
    };
    return cipher;
  };
  async function exporter$3(privateKey, password) {
    const cipher = create$6();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return base64$5.encode(encryptedKey);
  }
  var unmarshalEd25519PrivateKey$3 = function(bytes2) {
    if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH$3) {
      bytes2 = ensureKey$3(bytes2, PRIVATE_KEY_BYTE_LENGTH$3 + PUBLIC_KEY_BYTE_LENGTH$3);
      const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$3);
      const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH$3, bytes2.length);
      return new Ed25519PrivateKey$3(privateKeyBytes2, publicKeyBytes2);
    }
    bytes2 = ensureKey$3(bytes2, PRIVATE_KEY_BYTE_LENGTH$3);
    const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$3);
    const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH$3);
    return new Ed25519PrivateKey$3(privateKeyBytes, publicKeyBytes);
  };
  var unmarshalEd25519PublicKey$3 = function(bytes2) {
    bytes2 = ensureKey$3(bytes2, PUBLIC_KEY_BYTE_LENGTH$3);
    return new Ed25519PublicKey$3(bytes2);
  };
  async function generateKeyPair$d() {
    const { privateKey, publicKey } = await generateKey$b();
    return new Ed25519PrivateKey$3(privateKey, publicKey);
  }
  async function generateKeyPairFromSeed$3(seed) {
    const { privateKey, publicKey } = await generateKeyFromSeed$3(seed);
    return new Ed25519PrivateKey$3(privateKey, publicKey);
  }
  var ensureKey$3 = function(key, length2) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length2) {
      throw new CodeError$3(`Key must be a Uint8Array of length ${length2}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
    }
    return key;
  };
  var bigIntegerToUintBase64url$3 = function(num, len) {
    let buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.subarray(1) : buf;
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return toString$9(buf, "base64url");
  };
  var base64urlToBigInteger$3 = function(str) {
    const buf = base64urlToBuffer$3(str);
    return new forge$n.jsbn.BigInteger(toString$9(buf, "base16"), 16);
  };
  var base64urlToBuffer$3 = function(str, len) {
    let buf = fromString$3(str, "base64urlpad");
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return buf;
  };
  var randomBytes$3 = function(length2) {
    if (isNaN(length2) || length2 <= 0) {
      throw new CodeError$3("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
    }
    return randomBytes$8(length2);
  };
  var convert$3 = function(key, types) {
    return types.map((t) => base64urlToBigInteger$3(key[t]));
  };
  var jwk2priv$3 = function(key) {
    return forge$n.pki.setRsaPrivateKey(...convert$3(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
  };
  var jwk2pub$3 = function(key) {
    return forge$n.pki.setRsaPublicKey(...convert$3(key, ["n", "e"]));
  };
  var pkcs1ToJwk$3 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$3(privateKey.n),
      e: bigIntegerToUintBase64url$3(privateKey.e),
      d: bigIntegerToUintBase64url$3(privateKey.d),
      p: bigIntegerToUintBase64url$3(privateKey.p),
      q: bigIntegerToUintBase64url$3(privateKey.q),
      dp: bigIntegerToUintBase64url$3(privateKey.dP),
      dq: bigIntegerToUintBase64url$3(privateKey.dQ),
      qi: bigIntegerToUintBase64url$3(privateKey.qInv),
      alg: "RS256"
    };
  };
  var jwkToPkcs1$3 = function(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.privateKeyToAsn1({
      n: base64urlToBigInteger$3(jwk.n),
      e: base64urlToBigInteger$3(jwk.e),
      d: base64urlToBigInteger$3(jwk.d),
      p: base64urlToBigInteger$3(jwk.p),
      q: base64urlToBigInteger$3(jwk.q),
      dP: base64urlToBigInteger$3(jwk.dp),
      dQ: base64urlToBigInteger$3(jwk.dq),
      qInv: base64urlToBigInteger$3(jwk.qi)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  var pkixToJwk$3 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const publicKey = forge$n.pki.publicKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$3(publicKey.n),
      e: bigIntegerToUintBase64url$3(publicKey.e)
    };
  };
  var jwkToPkix$3 = function(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.publicKeyToAsn1({
      n: base64urlToBigInteger$3(jwk.n),
      e: base64urlToBigInteger$3(jwk.e)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  async function generateKey$a(bits2) {
    const pair2 = await webcrypto$3.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits2,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    const keys = await exportKey$3(pair2);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function unmarshalPrivateKey$5(key) {
    const privateKey = await webcrypto$3.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["sign"]);
    const pair2 = [
      privateKey,
      await derivePublicFromPrivate$3(key)
    ];
    const keys = await exportKey$3({
      privateKey: pair2[0],
      publicKey: pair2[1]
    });
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign$a(key, msg) {
    const privateKey = await webcrypto$3.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const sig = await webcrypto$3.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify$a(key, sig, msg) {
    const publicKey = await webcrypto$3.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    return webcrypto$3.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
  }
  async function exportKey$3(pair2) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new CodeError$3("Private and public key are required", "ERR_INVALID_PARAMETERS");
    }
    return Promise.all([
      webcrypto$3.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto$3.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
  }
  async function derivePublicFromPrivate$3(jwKey) {
    return webcrypto$3.get().subtle.importKey("jwk", {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    }, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["verify"]);
  }
  var convertKey$3 = function(key, pub, msg, handle2) {
    const fkey = pub ? jwk2pub$3(key) : jwk2priv$3(key);
    const fmsg = toString$9(Uint8Array.from(msg), "ascii");
    const fomsg = handle2(fmsg, fkey);
    return fromString$3(fomsg, "ascii");
  };
  var encrypt$3 = function(key, msg) {
    return convertKey$3(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
  };
  var decrypt$3 = function(key, msg) {
    return convertKey$3(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
  };
  var keySize$3 = function(jwk) {
    if (jwk.kty !== "RSA") {
      throw new CodeError$3("invalid key type", "ERR_INVALID_KEY_TYPE");
    } else if (jwk.n == null) {
      throw new CodeError$3("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
    }
    const bytes2 = fromString$3(jwk.n, "base64url");
    return bytes2.length * 8;
  };
  async function unmarshalRsaPrivateKey$3(bytes2) {
    const jwk = pkcs1ToJwk$3(bytes2);
    if (keySize$3(jwk) > MAX_KEY_SIZE$3) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$5(jwk);
    return new RsaPrivateKey$3(keys.privateKey, keys.publicKey);
  }
  var unmarshalRsaPublicKey$3 = function(bytes2) {
    const jwk = pkixToJwk$3(bytes2);
    if (keySize$3(jwk) > MAX_KEY_SIZE$3) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    return new RsaPublicKey$3(jwk);
  };
  async function fromJwk$3(jwk) {
    if (keySize$3(jwk) > MAX_KEY_SIZE$3) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$5(jwk);
    return new RsaPrivateKey$3(keys.privateKey, keys.publicKey);
  }
  async function generateKeyPair$c(bits2) {
    if (bits2 > MAX_KEY_SIZE$3) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await generateKey$a(bits2);
    return new RsaPrivateKey$3(keys.privateKey, keys.publicKey);
  }
  var validatePointOpts = function(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: endo2, Fp: Fp2, a } = opts;
    if (endo2) {
      if (!Fp2.eql(a, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo2 !== "object" || typeof endo2.beta !== "bigint" || typeof endo2.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  };
  var weierstrassPoints = function(opts) {
    const CURVE2 = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE2;
    const toBytes2 = CURVE2.toBytes || ((c, point, isCompressed) => {
      const a = point.toAffine();
      return concatBytes$2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
    });
    const fromBytes2 = CURVE2.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE2;
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE2.Gy), weierstrassEquation(CURVE2.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder2(num) {
      return typeof num === "bigint" && _0n < num && num < CURVE2.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder2(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE2;
      if (lengths && typeof key !== "bigint") {
        if (key instanceof Uint8Array)
          key = bytesToHex$2(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes$2("private key", key, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod$2(num, n);
      assertGE(num);
      return num;
    }
    const pointPrecomputes2 = new Map;
    function assertPrjPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }

    class Point2 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
      }
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
        if (is0(x) && is0(y))
          return Point2.ZERO;
        return new Point2(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      static fromHex(hex) {
        const P = Point2.fromAffine(fromBytes2(ensureBytes$2("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes2.delete(this);
      }
      assertValidity() {
        if (this.is0()) {
          if (CURVE2.allowInfinityPoint)
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = this.toAffine();
        if (!Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left2 = Fp2.sqr(y);
        const right2 = weierstrassEquation(x);
        if (!Fp2.eql(left2, right2))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      negate() {
        return new Point2(this.px, Fp2.neg(this.py), this.pz);
      }
      double() {
        const { a, b } = CURVE2;
        const b3 = Fp2.mul(b, _3n);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp2;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp2;
        const a = CURVE2.a;
        const b3 = Fp2.mul(CURVE2.b, _3n);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes2, n, (comp) => {
          const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
          return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
        });
      }
      multiplyUnsafe(n) {
        const I = Point2.ZERO;
        if (n === _0n)
          return I;
        assertGE(n);
        if (n === _1n$1)
          return this;
        const { endo: endo2 } = CURVE2;
        if (!endo2)
          return wnaf.unsafeLadder(this, n);
        let { k1neg, k1, k2neg, k2 } = endo2.splitScalar(n);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n$1)
            k1p = k1p.add(d);
          if (k2 & _1n$1)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n$1;
          k2 >>= _1n$1;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point2(Fp2.mul(k2p.px, endo2.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      multiply(scalar) {
        assertGE(scalar);
        let n = scalar;
        let point, fake;
        const { endo: endo2 } = CURVE2;
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point2(Fp2.mul(k2p.px, endo2.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(n);
          point = p;
          fake = f;
        }
        return Point2.normalizeZ([point, fake])[0];
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point2.BASE;
        const mul = (P, a2) => a2 === _0n || a2 === _1n$1 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? undefined : sum;
      }
      toAffine(iz) {
        const { px: x, py: y, pz: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp2.ONE : Fp2.inv(z);
        const ax = Fp2.mul(x, iz);
        const ay = Fp2.mul(y, iz);
        const zz = Fp2.mul(z, iz);
        if (is0)
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        if (!Fp2.eql(zz, Fp2.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE2;
        if (cofactor === _1n$1)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE2;
        if (cofactor === _1n$1)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(CURVE2.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes2(Point2, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex$2(this.toRawBytes(isCompressed));
      }
    }
    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, Fp2.ONE);
    Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE2.nBitLength;
    const wnaf = wNAF(Point2, CURVE2.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE: CURVE2,
      ProjectivePoint: Point2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder: isWithinCurveOrder2
    };
  };
  var validateOpts = function(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  };
  var weierstrass = function(curveDef) {
    const CURVE2 = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE2;
    const compressedLen2 = Fp2.BYTES + 1;
    const uncompressedLen2 = 2 * Fp2.BYTES + 1;
    function isValidFieldElement2(num) {
      return _0n < num && num < Fp2.ORDER;
    }
    function modN(a) {
      return mod$2(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert$2(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder: isWithinCurveOrder2 } = weierstrassPoints({
      ...CURVE2,
      toBytes(c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp2.toBytes(a.x);
        const cat = concatBytes$2;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen2 && (head === 2 || head === 3)) {
          const x = bytesToNumberBE(tail);
          if (!isValidFieldElement2(x))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y = Fp2.sqrt(y2);
          const isYOdd = (y & _1n$1) === _1n$1;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp2.neg(y);
          return { x, y };
        } else if (len === uncompressedLen2 && head === 4) {
          const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen2} compressed bytes or ${uncompressedLen2} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex$2(numberToBytesBE(num, CURVE2.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n$1;
      return number2 > HALF;
    }
    function normalizeS(s2) {
      return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
    }
    const slcNum = (b, from2, to) => bytesToNumberBE(b.slice(from2, to));

    class Signature2 {
      constructor(r, s2, recovery) {
        this.r = r;
        this.s = s2;
        this.recovery = recovery;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const l = CURVE2.nByteLength;
        hex = ensureBytes$2("compactSignature", hex, l * 2);
        return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      static fromDER(hex) {
        const { r, s: s2 } = DER.toSig(ensureBytes$2("DER", hex));
        return new Signature2(r, s2);
      }
      assertValidity() {
        if (!isWithinCurveOrder2(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder2(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s: s2, recovery: rec } = this;
        const h = bits2int_modN(ensureBytes$2("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE2.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R2 = Point2.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h * ir);
        const u2 = modN(s2 * ir);
        const Q = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return hexToBytes$2(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return hexToBytes$2(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const rand = CURVE2.randomBytes(Fp2.BYTES + 8);
        const num = hashToPrivateScalar(rand, CURVE_ORDER);
        return numberToBytesBE(num, CURVE2.nByteLength);
      },
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey2(privateKey, isCompressed = true) {
      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen2 || len === uncompressedLen2;
      if (str)
        return len === 2 * compressedLen2 || len === 2 * uncompressedLen2;
      if (item instanceof Point2)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point2.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int2 = CURVE2.bits2int || function(bytes2) {
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE2.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE2.bits2int_modN || function(bytes2) {
      return modN(bits2int2(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE2.nBitLength);
    function int2octets2(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE2.nBitLength}`);
      return numberToBytesBE(num, CURVE2.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => (k in opts)))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2, randomBytes: randomBytes2 } = CURVE2;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes$2("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes$2("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets2(d), int2octets2(h1int)];
      if (ent != null) {
        const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes$2("extraEntropy", e, Fp2.BYTES));
      }
      const seed = concatBytes$2(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int2(kBytes);
        if (!isWithinCurveOrder2(k))
          return;
        const ik = invN(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = modN(q.x);
        if (r === _0n)
          return;
        const s2 = modN(ik * modN(m + r * d));
        if (s2 === _0n)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1);
        let normS = s2;
        if (lowS && isBiggerThanHalfOrder(s2)) {
          normS = normalizeS(s2);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE2.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE2.lowS, prehash: false };
    function sign2(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE2;
      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point2.BASE._setWindowSize(8);
    function verify2(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes$2("msgHash", msgHash);
      publicKey = ensureBytes$2("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = undefined;
      let P;
      try {
        if (typeof sg === "string" || sg instanceof Uint8Array) {
          try {
            _sig = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature2.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s3 } = sg;
          _sig = new Signature2(r2, s3);
        } else {
          throw new Error("PARSE");
        }
        P = Point2.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE2.hash(msgHash);
      const { r, s: s2 } = _sig;
      const h = bits2int_modN(msgHash);
      const is = invN(s2);
      const u1 = modN(h * is);
      const u2 = modN(r * is);
      const R2 = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
      if (!R2)
        return false;
      const v = modN(R2.x);
      return v === r;
    }
    return {
      CURVE: CURVE2,
      getPublicKey: getPublicKey2,
      getSharedSecret,
      sign: sign2,
      verify: verify2,
      ProjectivePoint: Point2,
      Signature: Signature2,
      utils: utils2
    };
  };
  var getHash = function(hash2) {
    return {
      hash: hash2,
      hmac: (key, ...msgs) => hmac(hash2, key, concatBytes$3(...msgs)),
      randomBytes: randomBytes$7
    };
  };
  var createCurve = function(curveDef, defHash) {
    const create2 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
    return Object.freeze({ ...create2(defHash), create: create2 });
  };
  var sqrtMod = function(y) {
    const P = secp256k1P;
    const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2$2(b3, _3n2, P) * b3 % P;
    const b9 = pow2$2(b6, _3n2, P) * b3 % P;
    const b11 = pow2$2(b9, _2n, P) * b2 % P;
    const b22 = pow2$2(b11, _11n, P) * b11 % P;
    const b44 = pow2$2(b22, _22n, P) * b22 % P;
    const b88 = pow2$2(b44, _44n, P) * b44 % P;
    const b176 = pow2$2(b88, _88n, P) * b88 % P;
    const b220 = pow2$2(b176, _44n, P) * b44 % P;
    const b223 = pow2$2(b220, _3n2, P) * b3 % P;
    const t1 = pow2$2(b223, _23n, P) * b22 % P;
    const t2 = pow2$2(t1, _6n, P) * b2 % P;
    const root = pow2$2(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  };
  var generateKey$9 = function() {
    return secp256k1.utils.randomPrivateKey();
  };
  async function hashAndSign$9(key, msg) {
    const { digest: digest2 } = await sha256$4.digest(msg);
    try {
      const signature = secp256k1.sign(digest2, key);
      return signature.toDERRawBytes();
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  async function hashAndVerify$9(key, sig, msg) {
    try {
      const { digest: digest2 } = await sha256$4.digest(msg);
      return secp256k1.verify(sig, digest2, key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  var compressPublicKey$3 = function(key) {
    const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
    return point;
  };
  var validatePrivateKey$3 = function(key) {
    try {
      secp256k1.getPublicKey(key, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var validatePublicKey$3 = function(key) {
    try {
      secp256k1.ProjectivePoint.fromHex(key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PUBLIC_KEY");
    }
  };
  var computePublicKey$3 = function(privateKey) {
    try {
      return secp256k1.getPublicKey(privateKey, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var unmarshalSecp256k1PrivateKey$3 = function(bytes2) {
    return new Secp256k1PrivateKey$3(bytes2);
  };
  var unmarshalSecp256k1PublicKey$3 = function(bytes2) {
    return new Secp256k1PublicKey$3(bytes2);
  };
  async function generateKeyPair$b() {
    const privateKeyBytes = generateKey$9();
    return new Secp256k1PrivateKey$3(privateKeyBytes);
  }
  var unsupportedKey$3 = function(type) {
    const supported = Object.keys(supportedKeys$3).join(" / ");
    return new CodeError$3(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
  };
  var unmarshalPublicKey$1 = function(buf) {
    const decoded = PublicKey$3.decode(buf);
    const data = decoded.Data ?? new Uint8Array;
    switch (decoded.Type) {
      case KeyType$3.RSA:
        return supportedKeys$3.rsa.unmarshalRsaPublicKey(data);
      case KeyType$3.Ed25519:
        return supportedKeys$3.ed25519.unmarshalEd25519PublicKey(data);
      case KeyType$3.Secp256k1:
        return supportedKeys$3.secp256k1.unmarshalSecp256k1PublicKey(data);
      default:
        throw unsupportedKey$3(decoded.Type ?? "RSA");
    }
  };
  var base$4 = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$a = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$2) {
      out[offset++] = num & 255 | MSB$3;
      num /= 128;
    }
    while (num & MSBALL$2) {
      out[offset++] = num & 255 | MSB$3;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$a.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$3 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$3.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1$2) << shift : (b & REST$1$2) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1$2);
    read$3.bytes = counter2 - offset;
    return res;
  };
  async function generateKey$8() {
    const privateKeyRaw = ed25519.utils.randomPrivateKey();
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys$2(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function generateKeyFromSeed$2(seed) {
    if (seed.length !== KEYS_BYTE_LENGTH$2) {
      throw new TypeError('"seed" must be 32 bytes in length.');
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
    }
    const privateKeyRaw = seed;
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys$2(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSign$8(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH$2);
    return ed25519.sign(msg, privateKeyRaw);
  }
  async function hashAndVerify$8(publicKey, sig, msg) {
    return ed25519.verify(sig, msg, publicKey);
  }
  var concatKeys$2 = function(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH$2);
    for (let i = 0;i < KEYS_BYTE_LENGTH$2; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH$2 + i] = publicKey[i];
    }
    return privateKey;
  };
  var create$4 = function(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest2 = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto2 = webcrypto$2.get();
    keyLength *= 8;
    async function encrypt2(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$2, { name: "AES-GCM" }, true, ["encrypt"]);
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$2, { name: "AES-GCM" }, true, ["encrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      }
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat$1([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt2(data, password) {
      const salt = data.subarray(0, saltLength);
      const nonce = data.subarray(saltLength, saltLength + nonceLength);
      const ciphertext = data.subarray(saltLength + nonceLength);
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$2, { name: "AES-GCM" }, true, ["decrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      }
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    const cipher = {
      encrypt: encrypt2,
      decrypt: decrypt2
    };
    return cipher;
  };
  async function exporter$2(privateKey, password) {
    const cipher = create$4();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return base64$4.encode(encryptedKey);
  }
  var unmarshalEd25519PrivateKey$2 = function(bytes2) {
    if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH$2) {
      bytes2 = ensureKey$2(bytes2, PRIVATE_KEY_BYTE_LENGTH$2 + PUBLIC_KEY_BYTE_LENGTH$2);
      const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$2);
      const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH$2, bytes2.length);
      return new Ed25519PrivateKey$2(privateKeyBytes2, publicKeyBytes2);
    }
    bytes2 = ensureKey$2(bytes2, PRIVATE_KEY_BYTE_LENGTH$2);
    const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$2);
    const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH$2);
    return new Ed25519PrivateKey$2(privateKeyBytes, publicKeyBytes);
  };
  var unmarshalEd25519PublicKey$2 = function(bytes2) {
    bytes2 = ensureKey$2(bytes2, PUBLIC_KEY_BYTE_LENGTH$2);
    return new Ed25519PublicKey$2(bytes2);
  };
  async function generateKeyPair$a() {
    const { privateKey, publicKey } = await generateKey$8();
    return new Ed25519PrivateKey$2(privateKey, publicKey);
  }
  async function generateKeyPairFromSeed$2(seed) {
    const { privateKey, publicKey } = await generateKeyFromSeed$2(seed);
    return new Ed25519PrivateKey$2(privateKey, publicKey);
  }
  var ensureKey$2 = function(key, length2) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length2) {
      throw new CodeError$3(`Key must be a Uint8Array of length ${length2}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
    }
    return key;
  };
  var bigIntegerToUintBase64url$2 = function(num, len) {
    let buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.subarray(1) : buf;
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return toString$9(buf, "base64url");
  };
  var base64urlToBigInteger$2 = function(str) {
    const buf = base64urlToBuffer$2(str);
    return new forge$n.jsbn.BigInteger(toString$9(buf, "base16"), 16);
  };
  var base64urlToBuffer$2 = function(str, len) {
    let buf = fromString$3(str, "base64urlpad");
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return buf;
  };
  async function importer(privateKey, password) {
    const encryptedKey = base64$4.decode(privateKey);
    const cipher = create$4();
    return cipher.decrypt(encryptedKey, password);
  }
  var randomBytes$2 = function(length2) {
    if (isNaN(length2) || length2 <= 0) {
      throw new CodeError$3("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
    }
    return randomBytes$8(length2);
  };
  var convert$2 = function(key, types) {
    return types.map((t) => base64urlToBigInteger$2(key[t]));
  };
  var jwk2priv$2 = function(key) {
    return forge$n.pki.setRsaPrivateKey(...convert$2(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
  };
  var jwk2pub$2 = function(key) {
    return forge$n.pki.setRsaPublicKey(...convert$2(key, ["n", "e"]));
  };
  var pkcs1ToJwk$2 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$2(privateKey.n),
      e: bigIntegerToUintBase64url$2(privateKey.e),
      d: bigIntegerToUintBase64url$2(privateKey.d),
      p: bigIntegerToUintBase64url$2(privateKey.p),
      q: bigIntegerToUintBase64url$2(privateKey.q),
      dp: bigIntegerToUintBase64url$2(privateKey.dP),
      dq: bigIntegerToUintBase64url$2(privateKey.dQ),
      qi: bigIntegerToUintBase64url$2(privateKey.qInv),
      alg: "RS256"
    };
  };
  var jwkToPkcs1$2 = function(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.privateKeyToAsn1({
      n: base64urlToBigInteger$2(jwk.n),
      e: base64urlToBigInteger$2(jwk.e),
      d: base64urlToBigInteger$2(jwk.d),
      p: base64urlToBigInteger$2(jwk.p),
      q: base64urlToBigInteger$2(jwk.q),
      dP: base64urlToBigInteger$2(jwk.dp),
      dQ: base64urlToBigInteger$2(jwk.dq),
      qInv: base64urlToBigInteger$2(jwk.qi)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  var pkixToJwk$2 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const publicKey = forge$n.pki.publicKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$2(publicKey.n),
      e: bigIntegerToUintBase64url$2(publicKey.e)
    };
  };
  var jwkToPkix$2 = function(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.publicKeyToAsn1({
      n: base64urlToBigInteger$2(jwk.n),
      e: base64urlToBigInteger$2(jwk.e)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  async function generateKey$7(bits2) {
    const pair2 = await webcrypto$2.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits2,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    const keys = await exportKey$2(pair2);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function unmarshalPrivateKey$4(key) {
    const privateKey = await webcrypto$2.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["sign"]);
    const pair2 = [
      privateKey,
      await derivePublicFromPrivate$2(key)
    ];
    const keys = await exportKey$2({
      privateKey: pair2[0],
      publicKey: pair2[1]
    });
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign$7(key, msg) {
    const privateKey = await webcrypto$2.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const sig = await webcrypto$2.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify$7(key, sig, msg) {
    const publicKey = await webcrypto$2.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    return webcrypto$2.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
  }
  async function exportKey$2(pair2) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new CodeError$3("Private and public key are required", "ERR_INVALID_PARAMETERS");
    }
    return Promise.all([
      webcrypto$2.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto$2.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
  }
  async function derivePublicFromPrivate$2(jwKey) {
    return webcrypto$2.get().subtle.importKey("jwk", {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    }, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["verify"]);
  }
  var convertKey$2 = function(key, pub, msg, handle2) {
    const fkey = pub ? jwk2pub$2(key) : jwk2priv$2(key);
    const fmsg = toString$9(Uint8Array.from(msg), "ascii");
    const fomsg = handle2(fmsg, fkey);
    return fromString$3(fomsg, "ascii");
  };
  var encrypt$2 = function(key, msg) {
    return convertKey$2(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
  };
  var decrypt$2 = function(key, msg) {
    return convertKey$2(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
  };
  var keySize$2 = function(jwk) {
    if (jwk.kty !== "RSA") {
      throw new CodeError$3("invalid key type", "ERR_INVALID_KEY_TYPE");
    } else if (jwk.n == null) {
      throw new CodeError$3("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
    }
    const bytes2 = fromString$3(jwk.n, "base64url");
    return bytes2.length * 8;
  };
  async function unmarshalRsaPrivateKey$2(bytes2) {
    const jwk = pkcs1ToJwk$2(bytes2);
    if (keySize$2(jwk) > MAX_KEY_SIZE$2) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$4(jwk);
    return new RsaPrivateKey$2(keys.privateKey, keys.publicKey);
  }
  var unmarshalRsaPublicKey$2 = function(bytes2) {
    const jwk = pkixToJwk$2(bytes2);
    if (keySize$2(jwk) > MAX_KEY_SIZE$2) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    return new RsaPublicKey$2(jwk);
  };
  async function fromJwk$2(jwk) {
    if (keySize$2(jwk) > MAX_KEY_SIZE$2) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$4(jwk);
    return new RsaPrivateKey$2(keys.privateKey, keys.publicKey);
  }
  async function generateKeyPair$9(bits2) {
    if (bits2 > MAX_KEY_SIZE$2) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await generateKey$7(bits2);
    return new RsaPrivateKey$2(keys.privateKey, keys.publicKey);
  }
  var generateKey$6 = function() {
    return secp256k1.utils.randomPrivateKey();
  };
  async function hashAndSign$6(key, msg) {
    const { digest: digest2 } = await sha256$2.digest(msg);
    try {
      const signature = secp256k1.sign(digest2, key);
      return signature.toDERRawBytes();
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  async function hashAndVerify$6(key, sig, msg) {
    try {
      const { digest: digest2 } = await sha256$2.digest(msg);
      return secp256k1.verify(sig, digest2, key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  var compressPublicKey$2 = function(key) {
    const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
    return point;
  };
  var validatePrivateKey$2 = function(key) {
    try {
      secp256k1.getPublicKey(key, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var validatePublicKey$2 = function(key) {
    try {
      secp256k1.ProjectivePoint.fromHex(key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PUBLIC_KEY");
    }
  };
  var computePublicKey$2 = function(privateKey) {
    try {
      return secp256k1.getPublicKey(privateKey, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var unmarshalSecp256k1PrivateKey$2 = function(bytes2) {
    return new Secp256k1PrivateKey$2(bytes2);
  };
  var unmarshalSecp256k1PublicKey$2 = function(bytes2) {
    return new Secp256k1PublicKey$2(bytes2);
  };
  async function generateKeyPair$8() {
    const privateKeyBytes = generateKey$6();
    return new Secp256k1PrivateKey$2(privateKeyBytes);
  }
  var unsupportedKey$2 = function(type) {
    const supported = Object.keys(supportedKeys$2).join(" / ");
    return new CodeError$3(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
  };
  var typeToKey$1 = function(type) {
    type = type.toLowerCase();
    if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
      return supportedKeys$2[type];
    }
    throw unsupportedKey$2(type);
  };
  async function generateKeyPair$7(type, bits2) {
    return typeToKey$1(type).generateKeyPair(bits2 ?? 2048);
  }
  async function unmarshalPrivateKey$3(buf) {
    const decoded = PrivateKey$2.decode(buf);
    const data = decoded.Data ?? new Uint8Array;
    switch (decoded.Type) {
      case KeyType$2.RSA:
        return supportedKeys$2.rsa.unmarshalRsaPrivateKey(data);
      case KeyType$2.Ed25519:
        return supportedKeys$2.ed25519.unmarshalEd25519PrivateKey(data);
      case KeyType$2.Secp256k1:
        return supportedKeys$2.secp256k1.unmarshalSecp256k1PrivateKey(data);
      default:
        throw unsupportedKey$2(decoded.Type ?? "RSA");
    }
  }
  async function importKey(encryptedKey, password) {
    try {
      const key2 = await importer(encryptedKey, password);
      return await unmarshalPrivateKey$3(key2);
    } catch (_) {
    }
    const key = forge$n.pki.decryptRsaPrivateKey(encryptedKey, password);
    if (key === null) {
      throw new CodeError$3("Cannot read the key, most likely the password is wrong or not a RSA key", "ERR_CANNOT_DECRYPT_PEM");
    }
    let der = forge$n.asn1.toDer(forge$n.pki.privateKeyToAsn1(key));
    der = fromString$3(der.getBytes(), "ascii");
    return supportedKeys$2.rsa.unmarshalRsaPrivateKey(der);
  }
  var pbkdf2 = function(password, salt, iterations, keySize2, hash2) {
    if (hash2 !== "sha1" && hash2 !== "sha2-256" && hash2 !== "sha2-512") {
      const types = Object.keys(hashName).join(" / ");
      throw new CodeError$3(`Hash '${hash2}' is unknown or not supported. Must be ${types}`, "ERR_UNSUPPORTED_HASH_TYPE");
    }
    const hasher = hashName[hash2];
    const dek = forgePbkdf2(password, salt, iterations, keySize2, hasher);
    return forgeUtil.encode64(dek, null);
  };
  var createDisabledLogger$3 = function(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  };
  var logger$3 = function(name2) {
    let trace = createDisabledLogger$3(`${name2}:trace`);
    if (debug.enabled(`${name2}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = debug(`${name2}:trace`);
    }
    return Object.assign(debug(name2), {
      error: debug(`${name2}:error`),
      trace
    });
  };
  var namespaceType = function(ns) {
    const parts = ns.split(":");
    if (parts.length < 2) {
      return "";
    }
    return parts.slice(0, -1).join(":");
  };
  var namespaceValue = function(ns) {
    const parts = ns.split(":");
    return parts[parts.length - 1];
  };
  var flatten = function(arr) {
    return [].concat(...arr);
  };
  var clone = function(value) {
    if (Array.isArray(value)) {
      return cloneArray(value);
    }
    if (isOptionObject(value)) {
      return cloneOptionObject(value);
    }
    return value;
  };
  var cloneArray = function(array) {
    const result = array.slice(0, 0);
    getEnumerableOwnPropertyKeys(array).forEach((key) => {
      defineProperty(result, key, clone(array[key]));
    });
    return result;
  };
  var cloneOptionObject = function(object) {
    const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
    getEnumerableOwnPropertyKeys(object).forEach((key) => {
      defineProperty(result, key, clone(object[key]));
    });
    return result;
  };
  var merge = function(merged, source2, config) {
    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source2)) {
      return concatArrays(merged, source2, config);
    }
    if (!isOptionObject(source2) || !isOptionObject(merged)) {
      return clone(source2);
    }
    return mergeKeys(merged, source2, getEnumerableOwnPropertyKeys(source2), config);
  };
  var isHighSurrogate$1 = function(codePoint) {
    return codePoint >= 55296 && codePoint <= 56319;
  };
  var isLowSurrogate$1 = function(codePoint) {
    return codePoint >= 56320 && codePoint <= 57343;
  };
  var isHighSurrogate = function(codePoint) {
    return codePoint >= 55296 && codePoint <= 56319;
  };
  var isLowSurrogate = function(codePoint) {
    return codePoint >= 56320 && codePoint <= 57343;
  };
  var sanitize = function(input, replacement) {
    if (typeof input !== "string") {
      throw new Error("Input must be string");
    }
    var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
    return truncate(sanitized, 255);
  };
  var validateKeyName = function(name2) {
    if (name2 == null) {
      return false;
    }
    if (typeof name2 !== "string") {
      return false;
    }
    return name2 === sanitize$1(name2.trim()) && name2.length > 0;
  };
  async function randomDelay() {
    const min = 200;
    const max = 1000;
    const delay = Math.random() * (max - min) + min;
    await new Promise((resolve5) => setTimeout(resolve5, delay));
  }
  var DsName = function(name2) {
    return new Key(keyPrefix + name2);
  };
  var DsInfoName = function(name2) {
    return new Key(infoPrefix + name2);
  };
  var createDisabledLogger$2 = function(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  };
  var logger$2 = function(name2) {
    let trace = createDisabledLogger$2(`${name2}:trace`);
    if (debug.enabled(`${name2}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = debug(`${name2}:trace`);
    }
    return Object.assign(debug(name2), {
      error: debug(`${name2}:error`),
      trace
    });
  };
  var mapIterable = function(iter, map2) {
    const iterator = {
      [Symbol.iterator]: () => {
        return iterator;
      },
      next: () => {
        const next = iter.next();
        const val = next.value;
        if (next.done === true || val == null) {
          const result = {
            done: true,
            value: undefined
          };
          return result;
        }
        return {
          done: false,
          value: map2(val)
        };
      }
    };
    return iterator;
  };
  var base$3 = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$7 = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT$1) {
      out[offset++] = num & 255 | MSB$2;
      num /= 128;
    }
    while (num & MSBALL$1) {
      out[offset++] = num & 255 | MSB$2;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$7.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$2 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$2.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1$1) << shift : (b & REST$1$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1$1);
    read$2.bytes = counter2 - offset;
    return res;
  };
  async function generateKey$5() {
    const privateKeyRaw = ed25519.utils.randomPrivateKey();
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys$1(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function generateKeyFromSeed$1(seed) {
    if (seed.length !== KEYS_BYTE_LENGTH$1) {
      throw new TypeError('"seed" must be 32 bytes in length.');
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
    }
    const privateKeyRaw = seed;
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys$1(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSign$5(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH$1);
    return ed25519.sign(msg, privateKeyRaw);
  }
  async function hashAndVerify$5(publicKey, sig, msg) {
    return ed25519.verify(sig, msg, publicKey);
  }
  var concatKeys$1 = function(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH$1);
    for (let i = 0;i < KEYS_BYTE_LENGTH$1; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH$1 + i] = publicKey[i];
    }
    return privateKey;
  };
  var create$2 = function(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest2 = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto2 = webcrypto$1.get();
    keyLength *= 8;
    async function encrypt2(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$1, { name: "AES-GCM" }, true, ["encrypt"]);
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$1, { name: "AES-GCM" }, true, ["encrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      }
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat$1([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt2(data, password) {
      const salt = data.subarray(0, saltLength);
      const nonce = data.subarray(saltLength, saltLength + nonceLength);
      const ciphertext = data.subarray(saltLength + nonceLength);
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey$1, { name: "AES-GCM" }, true, ["decrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      }
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    const cipher = {
      encrypt: encrypt2,
      decrypt: decrypt2
    };
    return cipher;
  };
  async function exporter$1(privateKey, password) {
    const cipher = create$2();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return base64$3.encode(encryptedKey);
  }
  var unmarshalEd25519PrivateKey$1 = function(bytes2) {
    if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH$1) {
      bytes2 = ensureKey$1(bytes2, PRIVATE_KEY_BYTE_LENGTH$1 + PUBLIC_KEY_BYTE_LENGTH$1);
      const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$1);
      const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH$1, bytes2.length);
      return new Ed25519PrivateKey$1(privateKeyBytes2, publicKeyBytes2);
    }
    bytes2 = ensureKey$1(bytes2, PRIVATE_KEY_BYTE_LENGTH$1);
    const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH$1);
    const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH$1);
    return new Ed25519PrivateKey$1(privateKeyBytes, publicKeyBytes);
  };
  var unmarshalEd25519PublicKey$1 = function(bytes2) {
    bytes2 = ensureKey$1(bytes2, PUBLIC_KEY_BYTE_LENGTH$1);
    return new Ed25519PublicKey$1(bytes2);
  };
  async function generateKeyPair$6() {
    const { privateKey, publicKey } = await generateKey$5();
    return new Ed25519PrivateKey$1(privateKey, publicKey);
  }
  async function generateKeyPairFromSeed$1(seed) {
    const { privateKey, publicKey } = await generateKeyFromSeed$1(seed);
    return new Ed25519PrivateKey$1(privateKey, publicKey);
  }
  var ensureKey$1 = function(key, length2) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length2) {
      throw new CodeError$3(`Key must be a Uint8Array of length ${length2}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
    }
    return key;
  };
  var bigIntegerToUintBase64url$1 = function(num, len) {
    let buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.subarray(1) : buf;
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return toString$9(buf, "base64url");
  };
  var base64urlToBigInteger$1 = function(str) {
    const buf = base64urlToBuffer$1(str);
    return new forge$n.jsbn.BigInteger(toString$9(buf, "base16"), 16);
  };
  var base64urlToBuffer$1 = function(str, len) {
    let buf = fromString$3(str, "base64urlpad");
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return buf;
  };
  var randomBytes$1 = function(length2) {
    if (isNaN(length2) || length2 <= 0) {
      throw new CodeError$3("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
    }
    return randomBytes$8(length2);
  };
  var convert$1 = function(key, types) {
    return types.map((t) => base64urlToBigInteger$1(key[t]));
  };
  var jwk2priv$1 = function(key) {
    return forge$n.pki.setRsaPrivateKey(...convert$1(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
  };
  var jwk2pub$1 = function(key) {
    return forge$n.pki.setRsaPublicKey(...convert$1(key, ["n", "e"]));
  };
  var pkcs1ToJwk$1 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$1(privateKey.n),
      e: bigIntegerToUintBase64url$1(privateKey.e),
      d: bigIntegerToUintBase64url$1(privateKey.d),
      p: bigIntegerToUintBase64url$1(privateKey.p),
      q: bigIntegerToUintBase64url$1(privateKey.q),
      dp: bigIntegerToUintBase64url$1(privateKey.dP),
      dq: bigIntegerToUintBase64url$1(privateKey.dQ),
      qi: bigIntegerToUintBase64url$1(privateKey.qInv),
      alg: "RS256"
    };
  };
  var jwkToPkcs1$1 = function(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.privateKeyToAsn1({
      n: base64urlToBigInteger$1(jwk.n),
      e: base64urlToBigInteger$1(jwk.e),
      d: base64urlToBigInteger$1(jwk.d),
      p: base64urlToBigInteger$1(jwk.p),
      q: base64urlToBigInteger$1(jwk.q),
      dP: base64urlToBigInteger$1(jwk.dp),
      dQ: base64urlToBigInteger$1(jwk.dq),
      qInv: base64urlToBigInteger$1(jwk.qi)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  var pkixToJwk$1 = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const publicKey = forge$n.pki.publicKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url$1(publicKey.n),
      e: bigIntegerToUintBase64url$1(publicKey.e)
    };
  };
  var jwkToPkix$1 = function(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.publicKeyToAsn1({
      n: base64urlToBigInteger$1(jwk.n),
      e: base64urlToBigInteger$1(jwk.e)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  async function generateKey$4(bits2) {
    const pair2 = await webcrypto$1.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits2,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    const keys = await exportKey$1(pair2);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function unmarshalPrivateKey$2(key) {
    const privateKey = await webcrypto$1.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["sign"]);
    const pair2 = [
      privateKey,
      await derivePublicFromPrivate$1(key)
    ];
    const keys = await exportKey$1({
      privateKey: pair2[0],
      publicKey: pair2[1]
    });
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign$4(key, msg) {
    const privateKey = await webcrypto$1.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const sig = await webcrypto$1.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify$4(key, sig, msg) {
    const publicKey = await webcrypto$1.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    return webcrypto$1.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
  }
  async function exportKey$1(pair2) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new CodeError$3("Private and public key are required", "ERR_INVALID_PARAMETERS");
    }
    return Promise.all([
      webcrypto$1.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto$1.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
  }
  async function derivePublicFromPrivate$1(jwKey) {
    return webcrypto$1.get().subtle.importKey("jwk", {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    }, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["verify"]);
  }
  var convertKey$1 = function(key, pub, msg, handle2) {
    const fkey = pub ? jwk2pub$1(key) : jwk2priv$1(key);
    const fmsg = toString$9(Uint8Array.from(msg), "ascii");
    const fomsg = handle2(fmsg, fkey);
    return fromString$3(fomsg, "ascii");
  };
  var encrypt$1 = function(key, msg) {
    return convertKey$1(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
  };
  var decrypt$1 = function(key, msg) {
    return convertKey$1(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
  };
  var keySize$1 = function(jwk) {
    if (jwk.kty !== "RSA") {
      throw new CodeError$3("invalid key type", "ERR_INVALID_KEY_TYPE");
    } else if (jwk.n == null) {
      throw new CodeError$3("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
    }
    const bytes2 = fromString$3(jwk.n, "base64url");
    return bytes2.length * 8;
  };
  async function unmarshalRsaPrivateKey$1(bytes2) {
    const jwk = pkcs1ToJwk$1(bytes2);
    if (keySize$1(jwk) > MAX_KEY_SIZE$1) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$2(jwk);
    return new RsaPrivateKey$1(keys.privateKey, keys.publicKey);
  }
  var unmarshalRsaPublicKey$1 = function(bytes2) {
    const jwk = pkixToJwk$1(bytes2);
    if (keySize$1(jwk) > MAX_KEY_SIZE$1) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    return new RsaPublicKey$1(jwk);
  };
  async function fromJwk$1(jwk) {
    if (keySize$1(jwk) > MAX_KEY_SIZE$1) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$2(jwk);
    return new RsaPrivateKey$1(keys.privateKey, keys.publicKey);
  }
  async function generateKeyPair$5(bits2) {
    if (bits2 > MAX_KEY_SIZE$1) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await generateKey$4(bits2);
    return new RsaPrivateKey$1(keys.privateKey, keys.publicKey);
  }
  var generateKey$3 = function() {
    return secp256k1.utils.randomPrivateKey();
  };
  async function hashAndSign$3(key, msg) {
    const { digest: digest2 } = await sha256$1.digest(msg);
    try {
      const signature = secp256k1.sign(digest2, key);
      return signature.toDERRawBytes();
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  async function hashAndVerify$3(key, sig, msg) {
    try {
      const { digest: digest2 } = await sha256$1.digest(msg);
      return secp256k1.verify(sig, digest2, key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  var compressPublicKey$1 = function(key) {
    const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
    return point;
  };
  var validatePrivateKey$1 = function(key) {
    try {
      secp256k1.getPublicKey(key, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var validatePublicKey$1 = function(key) {
    try {
      secp256k1.ProjectivePoint.fromHex(key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PUBLIC_KEY");
    }
  };
  var computePublicKey$1 = function(privateKey) {
    try {
      return secp256k1.getPublicKey(privateKey, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var unmarshalSecp256k1PrivateKey$1 = function(bytes2) {
    return new Secp256k1PrivateKey$1(bytes2);
  };
  var unmarshalSecp256k1PublicKey$1 = function(bytes2) {
    return new Secp256k1PublicKey$1(bytes2);
  };
  async function generateKeyPair$4() {
    const privateKeyBytes = generateKey$3();
    return new Secp256k1PrivateKey$1(privateKeyBytes);
  }
  var unsupportedKey$1 = function(type) {
    const supported = Object.keys(supportedKeys$1).join(" / ");
    return new CodeError$3(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
  };
  var typeToKey = function(type) {
    type = type.toLowerCase();
    if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
      return supportedKeys$1[type];
    }
    throw unsupportedKey$1(type);
  };
  async function generateKeyPair$3(type, bits2) {
    return typeToKey(type).generateKeyPair(bits2 ?? 2048);
  }
  var marshalPublicKey = function(key, type) {
    type = (type ?? "rsa").toLowerCase();
    typeToKey(type);
    return key.bytes;
  };
  var marshalPrivateKey = function(key, type) {
    type = (type ?? "rsa").toLowerCase();
    typeToKey(type);
    return key.bytes;
  };
  async function createFromPrivKey(privateKey) {
    return peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey));
  }
  var base$2 = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var createDisabledLogger$1 = function(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  };
  var logger$1 = function(name2) {
    let trace = createDisabledLogger$1(`${name2}:trace`);
    if (debug.enabled(`${name2}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = debug(`${name2}:trace`);
    }
    return Object.assign(debug(name2), {
      error: debug(`${name2}:error`),
      trace
    });
  };
  var base$1 = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var encode$3 = function(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$3.bytes = offset - oldOffset + 1;
    return out;
  };
  var read$1 = function(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter2 = offset, b, l = buf.length;
    do {
      if (counter2 >= l) {
        read$1.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter2++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read$1.bytes = counter2 - offset;
    return res;
  };
  async function generateKey$2() {
    const privateKeyRaw = ed25519.utils.randomPrivateKey();
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function generateKeyFromSeed(seed) {
    if (seed.length !== KEYS_BYTE_LENGTH) {
      throw new TypeError('"seed" must be 32 bytes in length.');
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
    }
    const privateKeyRaw = seed;
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSign$2(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
    return ed25519.sign(msg, privateKeyRaw);
  }
  async function hashAndVerify$2(publicKey, sig, msg) {
    return ed25519.verify(sig, msg, publicKey);
  }
  var concatKeys = function(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
    for (let i = 0;i < KEYS_BYTE_LENGTH; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
    }
    return privateKey;
  };
  var create = function(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest2 = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto2 = webcrypto.get();
    keyLength *= 8;
    async function encrypt2(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      }
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat$1([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt2(data, password) {
      const salt = data.subarray(0, saltLength);
      const nonce = data.subarray(saltLength, saltLength + nonceLength);
      const ciphertext = data.subarray(saltLength + nonceLength);
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString$3(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["decrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      }
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    const cipher = {
      encrypt: encrypt2,
      decrypt: decrypt2
    };
    return cipher;
  };
  async function exporter(privateKey, password) {
    const cipher = create();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return base64$1.encode(encryptedKey);
  }
  var unmarshalEd25519PrivateKey = function(bytes2) {
    if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH) {
      bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
      const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
      const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes2.length);
      return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
    }
    bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH);
    const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH);
    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
  };
  var unmarshalEd25519PublicKey = function(bytes2) {
    bytes2 = ensureKey(bytes2, PUBLIC_KEY_BYTE_LENGTH);
    return new Ed25519PublicKey(bytes2);
  };
  async function generateKeyPair$2() {
    const { privateKey, publicKey } = await generateKey$2();
    return new Ed25519PrivateKey(privateKey, publicKey);
  }
  async function generateKeyPairFromSeed(seed) {
    const { privateKey, publicKey } = await generateKeyFromSeed(seed);
    return new Ed25519PrivateKey(privateKey, publicKey);
  }
  var ensureKey = function(key, length2) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length2) {
      throw new CodeError$3(`Key must be a Uint8Array of length ${length2}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
    }
    return key;
  };
  var bigIntegerToUintBase64url = function(num, len) {
    let buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.subarray(1) : buf;
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return toString$9(buf, "base64url");
  };
  var base64urlToBigInteger = function(str) {
    const buf = base64urlToBuffer(str);
    return new forge$n.jsbn.BigInteger(toString$9(buf, "base16"), 16);
  };
  var base64urlToBuffer = function(str, len) {
    let buf = fromString$3(str, "base64urlpad");
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = concat$1([new Uint8Array(len - buf.length), buf]);
    }
    return buf;
  };
  var randomBytes = function(length2) {
    if (isNaN(length2) || length2 <= 0) {
      throw new CodeError$3("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
    }
    return randomBytes$8(length2);
  };
  var convert = function(key, types) {
    return types.map((t) => base64urlToBigInteger(key[t]));
  };
  var jwk2priv = function(key) {
    return forge$n.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
  };
  var jwk2pub = function(key) {
    return forge$n.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
  };
  var pkcs1ToJwk = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url(privateKey.n),
      e: bigIntegerToUintBase64url(privateKey.e),
      d: bigIntegerToUintBase64url(privateKey.d),
      p: bigIntegerToUintBase64url(privateKey.p),
      q: bigIntegerToUintBase64url(privateKey.q),
      dp: bigIntegerToUintBase64url(privateKey.dP),
      dq: bigIntegerToUintBase64url(privateKey.dQ),
      qi: bigIntegerToUintBase64url(privateKey.qInv),
      alg: "RS256"
    };
  };
  var jwkToPkcs1 = function(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.privateKeyToAsn1({
      n: base64urlToBigInteger(jwk.n),
      e: base64urlToBigInteger(jwk.e),
      d: base64urlToBigInteger(jwk.d),
      p: base64urlToBigInteger(jwk.p),
      q: base64urlToBigInteger(jwk.q),
      dP: base64urlToBigInteger(jwk.dp),
      dQ: base64urlToBigInteger(jwk.dq),
      qInv: base64urlToBigInteger(jwk.qi)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  var pkixToJwk = function(bytes2) {
    const asn12 = forge$n.asn1.fromDer(toString$9(bytes2, "ascii"));
    const publicKey = forge$n.pki.publicKeyFromAsn1(asn12);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url(publicKey.n),
      e: bigIntegerToUintBase64url(publicKey.e)
    };
  };
  var jwkToPkix = function(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new CodeError$3("JWK was missing components", "ERR_INVALID_PARAMETERS");
    }
    const asn12 = forge$n.pki.publicKeyToAsn1({
      n: base64urlToBigInteger(jwk.n),
      e: base64urlToBigInteger(jwk.e)
    });
    return fromString$3(forge$n.asn1.toDer(asn12).getBytes(), "ascii");
  };
  async function generateKey$1(bits2) {
    const pair2 = await webcrypto.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits2,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    const keys = await exportKey(pair2);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function unmarshalPrivateKey$1(key) {
    const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["sign"]);
    const pair2 = [
      privateKey,
      await derivePublicFromPrivate(key)
    ];
    const keys = await exportKey({
      privateKey: pair2[0],
      publicKey: pair2[1]
    });
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign$1(key, msg) {
    const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const sig = await webcrypto.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify$1(key, sig, msg) {
    const publicKey = await webcrypto.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    return webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
  }
  async function exportKey(pair2) {
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new CodeError$3("Private and public key are required", "ERR_INVALID_PARAMETERS");
    }
    return Promise.all([
      webcrypto.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
  }
  async function derivePublicFromPrivate(jwKey) {
    return webcrypto.get().subtle.importKey("jwk", {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    }, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, true, ["verify"]);
  }
  var convertKey = function(key, pub, msg, handle2) {
    const fkey = pub ? jwk2pub(key) : jwk2priv(key);
    const fmsg = toString$9(Uint8Array.from(msg), "ascii");
    const fomsg = handle2(fmsg, fkey);
    return fromString$3(fomsg, "ascii");
  };
  var encrypt = function(key, msg) {
    return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
  };
  var decrypt = function(key, msg) {
    return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
  };
  var keySize = function(jwk) {
    if (jwk.kty !== "RSA") {
      throw new CodeError$3("invalid key type", "ERR_INVALID_KEY_TYPE");
    } else if (jwk.n == null) {
      throw new CodeError$3("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
    }
    const bytes2 = fromString$3(jwk.n, "base64url");
    return bytes2.length * 8;
  };
  async function unmarshalRsaPrivateKey(bytes2) {
    const jwk = pkcs1ToJwk(bytes2);
    if (keySize(jwk) > MAX_KEY_SIZE) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$1(jwk);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
  }
  var unmarshalRsaPublicKey = function(bytes2) {
    const jwk = pkixToJwk(bytes2);
    if (keySize(jwk) > MAX_KEY_SIZE) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    return new RsaPublicKey(jwk);
  };
  async function fromJwk(jwk) {
    if (keySize(jwk) > MAX_KEY_SIZE) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await unmarshalPrivateKey$1(jwk);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
  }
  async function generateKeyPair$1(bits2) {
    if (bits2 > MAX_KEY_SIZE) {
      throw new CodeError$3("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    }
    const keys = await generateKey$1(bits2);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
  }
  var generateKey = function() {
    return secp256k1.utils.randomPrivateKey();
  };
  async function hashAndSign(key, msg) {
    const { digest: digest2 } = await sha256.digest(msg);
    try {
      const signature = secp256k1.sign(digest2, key);
      return signature.toDERRawBytes();
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  async function hashAndVerify(key, sig, msg) {
    try {
      const { digest: digest2 } = await sha256.digest(msg);
      return secp256k1.verify(sig, digest2, key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_INPUT");
    }
  }
  var compressPublicKey = function(key) {
    const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
    return point;
  };
  var validatePrivateKey = function(key) {
    try {
      secp256k1.getPublicKey(key, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var validatePublicKey = function(key) {
    try {
      secp256k1.ProjectivePoint.fromHex(key);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PUBLIC_KEY");
    }
  };
  var computePublicKey = function(privateKey) {
    try {
      return secp256k1.getPublicKey(privateKey, true);
    } catch (err) {
      throw new CodeError$3(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
  };
  var unmarshalSecp256k1PrivateKey = function(bytes2) {
    return new Secp256k1PrivateKey(bytes2);
  };
  var unmarshalSecp256k1PublicKey = function(bytes2) {
    return new Secp256k1PublicKey(bytes2);
  };
  async function generateKeyPair() {
    const privateKeyBytes = generateKey();
    return new Secp256k1PrivateKey(privateKeyBytes);
  }
  var unsupportedKey = function(type) {
    const supported = Object.keys(supportedKeys).join(" / ");
    return new CodeError$3(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
  };
  var unmarshalPublicKey = function(buf) {
    const decoded = PublicKey.decode(buf);
    const data = decoded.Data ?? new Uint8Array;
    switch (decoded.Type) {
      case KeyType.RSA:
        return supportedKeys.rsa.unmarshalRsaPublicKey(data);
      case KeyType.Ed25519:
        return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
      case KeyType.Secp256k1:
        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
      default:
        throw unsupportedKey(decoded.Type ?? "RSA");
    }
  };
  async function unmarshalPrivateKey(buf) {
    const decoded = PrivateKey.decode(buf);
    const data = decoded.Data ?? new Uint8Array;
    switch (decoded.Type) {
      case KeyType.RSA:
        return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
      case KeyType.Ed25519:
        return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
      case KeyType.Secp256k1:
        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
      default:
        throw unsupportedKey(decoded.Type ?? "RSA");
    }
  }
  var arrayEquals = function(a, b) {
    const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
    if (a.length !== b.length) {
      return false;
    }
    b.sort(sort2);
    return a.sort(sort2).every((item, index2) => b[index2].equals(item));
  };
  var pTimeout$1 = function(promise, milliseconds, fallback, options) {
    let timer;
    const cancelablePromise = new Promise((resolve5, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        resolve5(promise);
        return;
      }
      options = {
        customTimers: { setTimeout, clearTimeout },
        ...options
      };
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason$1(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason$1(signal));
        });
      }
      timer = options.customTimers.setTimeout.call(undefined, () => {
        if (typeof fallback === "function") {
          try {
            resolve5(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError$1(message2);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      (async () => {
        try {
          resolve5(await promise);
        } catch (error) {
          reject(error);
        } finally {
          options.customTimers.clearTimeout.call(undefined, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      clearTimeout(timer);
      timer = undefined;
    };
    return cancelablePromise;
  };
  var lowerBound$1 = function(array, value, comparator) {
    let first2 = 0;
    let count = array.length;
    while (count > 0) {
      const step = Math.trunc(count / 2);
      let it = first2 + step;
      if (comparator(array[it], value) <= 0) {
        first2 = ++it;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first2;
  };
  var pTimeout = function(promise, options) {
    const { milliseconds, fallback, message: message2, customTimers = { setTimeout, clearTimeout } } = options;
    let timer;
    const wrappedPromise = new Promise((resolve5, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason(signal));
        });
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        promise.then(resolve5, reject);
        return;
      }
      const timeoutError = new TimeoutError;
      timer = customTimers.setTimeout.call(undefined, () => {
        if (fallback) {
          try {
            resolve5(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        if (message2 === false) {
          resolve5();
        } else if (message2 instanceof Error) {
          reject(message2);
        } else {
          timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
          reject(timeoutError);
        }
      }, milliseconds);
      (async () => {
        try {
          resolve5(await promise);
        } catch (error) {
          reject(error);
        }
      })();
    });
    const cancelablePromise = wrappedPromise.finally(() => {
      cancelablePromise.clear();
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(undefined, timer);
      timer = undefined;
    };
    return cancelablePromise;
  };
  async function createReleaseable(queue, options) {
    let res;
    const p = new Promise((resolve5) => {
      res = resolve5;
    });
    queue.add(async () => await pTimeout((async () => {
      return await new Promise((resolve5) => {
        res(() => {
          resolve5();
        });
      });
    })(), {
      milliseconds: options.timeout
    }));
    return await p;
  }
  var createMortice = function(options) {
    const opts = Object.assign({}, defaultOptions$4, options);
    if (implementation == null) {
      implementation = impl(opts);
      if (implementation.isWorker !== true) {
        implementation.addEventListener("requestReadLock", (event) => {
          if (mutexes[event.data.name] == null) {
            return;
          }
          mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
        });
        implementation.addEventListener("requestWriteLock", async (event) => {
          if (mutexes[event.data.name] == null) {
            return;
          }
          mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
        });
      }
    }
    if (mutexes[opts.name] == null) {
      mutexes[opts.name] = createMutex(opts.name, opts);
    }
    return mutexes[opts.name];
  };
  var bytesToPeer = function(peerId, buf) {
    const peer = Peer.decode(buf);
    if (peer.publicKey != null && peerId.publicKey == null) {
      peerId = peerIdFromPeerId({
        ...peerId,
        publicKey: peerId.publicKey
      });
    }
    const tags = new Map;
    const now = BigInt(Date.now());
    for (const [key, tag] of peer.tags.entries()) {
      if (tag.expiry != null && tag.expiry < now) {
        continue;
      }
      tags.set(key, tag);
    }
    return {
      ...peer,
      id: peerId,
      addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr$1(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata: peer.metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined,
      tags
    };
  };
  var peerIdToDatastoreKey = function(peerId) {
    if (!isPeerId(peerId) || peerId.type == null) {
      throw new CodeError$3("Invalid PeerId", codes$1.ERR_INVALID_PARAMETERS);
    }
    const b32key = peerId.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  };
  async function dedupeFilterAndSortAddresses(peerId, filter2, addresses) {
    const addressMap = new Map;
    for (const addr of addresses) {
      if (addr == null) {
        continue;
      }
      if (addr.multiaddr instanceof Uint8Array) {
        addr.multiaddr = multiaddr$1(addr.multiaddr);
      }
      if (!isMultiaddr$1(addr.multiaddr)) {
        throw new CodeError$3("Multiaddr was invalid", codes$1.ERR_INVALID_PARAMETERS);
      }
      if (!await filter2(peerId, addr.multiaddr)) {
        continue;
      }
      const isCertified = addr.isCertified ?? false;
      const maStr = addr.multiaddr.toString();
      const existingAddr = addressMap.get(maStr);
      if (existingAddr != null) {
        addr.isCertified = existingAddr.isCertified || isCertified;
      } else {
        addressMap.set(maStr, {
          multiaddr: addr.multiaddr,
          isCertified
        });
      }
    }
    return [...addressMap.values()].sort((a, b) => {
      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ isCertified, multiaddr: multiaddr2 }) => ({
      isCertified,
      multiaddr: multiaddr2.bytes
    }));
  }
  async function toPeerPB(peerId, data, strategy, options) {
    if (data == null) {
      throw new CodeError$3("Invalid PeerData", codes$1.ERR_INVALID_PARAMETERS);
    }
    if (data.publicKey != null && peerId.publicKey != null && !equals$4(data.publicKey, peerId.publicKey)) {
      throw new CodeError$3("publicKey bytes do not match peer id publicKey bytes", codes$1.ERR_INVALID_PARAMETERS);
    }
    const existingPeer = options.existingPeer;
    if (existingPeer != null && !peerId.equals(existingPeer.id)) {
      throw new CodeError$3("peer id did not match existing peer id", codes$1.ERR_INVALID_PARAMETERS);
    }
    let addresses = existingPeer?.addresses ?? [];
    let protocols = new Set(existingPeer?.protocols ?? []);
    let metadata = existingPeer?.metadata ?? new Map;
    let tags = existingPeer?.tags ?? new Map;
    let peerRecordEnvelope = existingPeer?.peerRecordEnvelope;
    if (strategy === "patch") {
      if (data.multiaddrs != null || data.addresses != null) {
        addresses = [];
        if (data.multiaddrs != null) {
          addresses.push(...data.multiaddrs.map((multiaddr2) => ({
            isCertified: false,
            multiaddr: multiaddr2
          })));
        }
        if (data.addresses != null) {
          addresses.push(...data.addresses);
        }
      }
      if (data.protocols != null) {
        protocols = new Set(data.protocols);
      }
      if (data.metadata != null) {
        const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
        metadata = createSortedMap(metadataEntries, {
          validate: validateMetadata
        });
      }
      if (data.tags != null) {
        const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
        tags = createSortedMap(tagsEntries, {
          validate: validateTag,
          map: mapTag
        });
      }
      if (data.peerRecordEnvelope != null) {
        peerRecordEnvelope = data.peerRecordEnvelope;
      }
    }
    if (strategy === "merge") {
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
      if (data.protocols != null) {
        protocols = new Set([...protocols, ...data.protocols]);
      }
      if (data.metadata != null) {
        const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
        for (const [key, value] of metadataEntries) {
          if (value == null) {
            metadata.delete(key);
          } else {
            metadata.set(key, value);
          }
        }
        metadata = createSortedMap([...metadata.entries()], {
          validate: validateMetadata
        });
      }
      if (data.tags != null) {
        const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
        const mergedTags = new Map(tags);
        for (const [key, value] of tagsEntries) {
          if (value == null) {
            mergedTags.delete(key);
          } else {
            mergedTags.set(key, value);
          }
        }
        tags = createSortedMap([...mergedTags.entries()], {
          validate: validateTag,
          map: mapTag
        });
      }
      if (data.peerRecordEnvelope != null) {
        peerRecordEnvelope = data.peerRecordEnvelope;
      }
    }
    const output2 = {
      addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses),
      protocols: [...protocols.values()].sort((a, b) => {
        return a.localeCompare(b);
      }),
      metadata,
      tags,
      publicKey: existingPeer?.id.publicKey ?? data.publicKey ?? peerId.publicKey,
      peerRecordEnvelope
    };
    if (peerId.type !== "RSA") {
      delete output2.publicKey;
    }
    return output2;
  }
  var createSortedMap = function(entries, options) {
    const output2 = new Map;
    for (const [key, value] of entries) {
      if (value == null) {
        continue;
      }
      options.validate(key, value);
    }
    for (const [key, value] of entries.sort(([a], [b]) => {
      return a.localeCompare(b);
    })) {
      if (value != null) {
        output2.set(key, options.map?.(key, value) ?? value);
      }
    }
    return output2;
  };
  var validateMetadata = function(key, value) {
    if (typeof key !== "string") {
      throw new CodeError$3("Metadata key must be a string", codes$1.ERR_INVALID_PARAMETERS);
    }
    if (!(value instanceof Uint8Array)) {
      throw new CodeError$3("Metadata value must be a Uint8Array", codes$1.ERR_INVALID_PARAMETERS);
    }
  };
  var validateTag = function(key, tag) {
    if (typeof key !== "string") {
      throw new CodeError$3("Tag name must be a string", codes$1.ERR_INVALID_PARAMETERS);
    }
    if (tag.value != null) {
      if (parseInt(`${tag.value}`, 10) !== tag.value) {
        throw new CodeError$3("Tag value must be an integer", codes$1.ERR_INVALID_PARAMETERS);
      }
      if (tag.value < 0 || tag.value > 100) {
        throw new CodeError$3("Tag value must be between 0-100", codes$1.ERR_INVALID_PARAMETERS);
      }
    }
    if (tag.ttl != null) {
      if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
        throw new CodeError$3("Tag ttl must be an integer", codes$1.ERR_INVALID_PARAMETERS);
      }
      if (tag.ttl < 0) {
        throw new CodeError$3("Tag ttl must be between greater than 0", codes$1.ERR_INVALID_PARAMETERS);
      }
    }
  };
  var mapTag = function(key, tag) {
    let expiry;
    if (tag.expiry != null) {
      expiry = tag.expiry;
    }
    if (tag.ttl != null) {
      expiry = BigInt(Date.now() + Number(tag.ttl));
    }
    return {
      value: tag.value ?? 0,
      expiry
    };
  };
  var decodePeer = function(key, value, cache2) {
    const base32Str = key.toString().split("/")[2];
    const buf = base32$1.decode(base32Str);
    const peerId = peerIdFromBytes(buf);
    const cached = cache2.get(peerId);
    if (cached != null) {
      return cached;
    }
    const peer = bytesToPeer(peerId, value);
    cache2.set(peerId, peer);
    return peer;
  };
  var mapQuery = function(query2, cache2) {
    if (query2 == null) {
      return {};
    }
    return {
      prefix: NAMESPACE_COMMON,
      filters: (query2.filters ?? []).map((fn) => ({ key, value }) => {
        return fn(decodePeer(key, value, cache2));
      }),
      orders: (query2.orders ?? []).map((fn) => (a, b) => {
        return fn(decodePeer(a.key, a.value, cache2), decodePeer(b.key, b.value, cache2));
      })
    };
  };
  var isAsyncIterable$6 = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var drain = function(source2) {
    if (isAsyncIterable$6(source2)) {
      return (async () => {
        for await (const _ of source2) {
        }
      })();
    } else {
      for (const _ of source2) {
      }
    }
  };
  var peekable = function(iterable) {
    const [iterator, symbol2] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
    const queue = [];
    return {
      peek: () => {
        return iterator.next();
      },
      push: (value) => {
        queue.push(value);
      },
      next: () => {
        if (queue.length > 0) {
          return {
            done: false,
            value: queue.shift()
          };
        }
        return iterator.next();
      },
      [symbol2]() {
        return this;
      }
    };
  };
  var isAsyncIterable$5 = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var filter$1 = function(source2, fn) {
    if (isAsyncIterable$5(source2)) {
      return async function* () {
        for await (const entry of source2) {
          if (await fn(entry)) {
            yield entry;
          }
        }
      }();
    }
    const peekable$1 = peekable(source2);
    const { value, done } = peekable$1.next();
    if (done === true) {
      return function* () {
      }();
    }
    const res = fn(value);
    if (typeof res.then === "function") {
      return async function* () {
        if (await res) {
          yield value;
        }
        for await (const entry of peekable$1) {
          if (await fn(entry)) {
            yield entry;
          }
        }
      }();
    }
    const func = fn;
    return function* () {
      if (res === true) {
        yield value;
      }
      for (const entry of peekable$1) {
        if (func(entry)) {
          yield entry;
        }
      }
    }();
  };
  var isAsyncIterable$4 = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var sort = function(source2, sorter) {
    if (isAsyncIterable$4(source2)) {
      return async function* () {
        const arr = await all$1(source2);
        yield* arr.sort(sorter);
      }();
    }
    return function* () {
      const arr = all$1(source2);
      yield* arr.sort(sorter);
    }();
  };
  var isAsyncIterable$3 = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var take = function(source2, limit) {
    if (isAsyncIterable$3(source2)) {
      return async function* () {
        let items = 0;
        if (limit < 1) {
          return;
        }
        for await (const entry of source2) {
          yield entry;
          items++;
          if (items === limit) {
            return;
          }
        }
      }();
    }
    return function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for (const entry of source2) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  };
  var notFoundError = function(err) {
    err = err ?? new Error("Not Found");
    return errCode$1(err, "ERR_NOT_FOUND");
  };
  var debounce = function(func, wait2) {
    let timeout;
    return function() {
      const later = function() {
        timeout = undefined;
        func();
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait2);
    };
  };
  var stripPeerId = function(ma, peerId) {
    const observedPeerIdStr = ma.getPeerId();
    if (observedPeerIdStr != null) {
      const observedPeerId = peerIdFromString(observedPeerIdStr);
      if (observedPeerId.equals(peerId)) {
        ma = ma.decapsulate(multiaddr$1(`/p2p/${peerId.toString()}`));
      }
    }
    return ma;
  };
  var isStartable = function(obj) {
    return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
  };
  var defaultComponents = function(init2 = {}) {
    const components = new DefaultComponents(init2);
    const proxy = new Proxy(components, {
      get(target, prop, receiver) {
        if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
          const service2 = components.components[prop];
          if (service2 == null && !OPTIONAL_SERVICES.includes(prop)) {
            throw new CodeError$3(`${prop} not set`, "ERR_SERVICE_MISSING");
          }
          return service2;
        }
        return Reflect.get(target, prop, receiver);
      },
      set(target, prop, value) {
        if (typeof prop === "string") {
          components.components[prop] = value;
        } else {
          Reflect.set(target, prop, value);
        }
        return true;
      }
    });
    return proxy;
  };
  var ipv4_check = function(ip_addr) {
    for (let r of NETMASK_RANGES) {
      if (r.contains(ip_addr))
        return true;
    }
    return false;
  };
  var ipv6_check = function(ip_addr) {
    return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
  };
  var connectionGater = function(gater = {}) {
    return {
      denyDialPeer: async () => false,
      denyDialMultiaddr: async (multiaddr2) => {
        const tuples = multiaddr2.stringTuples();
        if (tuples[0][0] === 4 || tuples[0][0] === 41) {
          return Boolean(is_ip_private(`${tuples[0][1]}`));
        }
        return false;
      },
      denyInboundConnection: async () => false,
      denyOutboundConnection: async () => false,
      denyInboundEncryptedConnection: async () => false,
      denyOutboundEncryptedConnection: async () => false,
      denyInboundUpgradedConnection: async () => false,
      denyOutboundUpgradedConnection: async () => false,
      filterMultiaddrForPeer: async () => true,
      ...gater
    };
  };
  var isPrivate = function(ma) {
    try {
      const { address } = ma.nodeAddress();
      return Boolean(is_ip_private(address));
    } catch {
      return true;
    }
  };
  var publicAddressesFirst = function(a, b) {
    const isAPrivate = isPrivate(a.multiaddr);
    const isBPrivate = isPrivate(b.multiaddr);
    if (isAPrivate && !isBPrivate) {
      return 1;
    } else if (!isAPrivate && isBPrivate) {
      return -1;
    }
    if (a.isCertified && !b.isCertified) {
      return -1;
    } else if (!a.isCertified && b.isCertified) {
      return 1;
    }
    return 0;
  };
  var getUID = function() {
    return (Math.random() * 1e9 >>> 0) + counter++;
  };
  var Receptacle = function(options) {
    options = options || {};
    this.id = options.id || getUID();
    this.max = options.max || Infinity;
    this.items = options.items || [];
    this._lookup = {};
    this.size = this.items.length;
    this.lastModified = new Date(options.lastModified || new Date);
    for (var item, ttl, i = this.items.length;i--; ) {
      item = this.items[i];
      ttl = new Date(item.expires) - new Date;
      this._lookup[item.key] = item;
      if (ttl > 0)
        this.expire(item.key, ttl);
      else if (ttl <= 0)
        this.delete(item.key);
    }
  };
  var buildResource = function(serverResolver, hostname, recordType) {
    return `${serverResolver}?name=${hostname}&type=${recordType}`;
  };
  async function request(resource, signal) {
    const req = await globalFetch(resource, {
      headers: new globalHeaders({
        accept: "application/dns-json"
      }),
      signal
    });
    const res = await req.json();
    return res;
  }
  var getCacheKey = function(hostname, recordType) {
    return `${recordType}_${hostname}`;
  };
  async function dnsaddrResolver(addr, options = {}) {
    const resolver = new Resolver;
    if (options.signal != null) {
      options.signal.addEventListener("abort", () => {
        resolver.cancel();
      });
    }
    const peerId = addr.getPeerId();
    const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
    if (hostname == null) {
      throw new Error("No hostname found in multiaddr");
    }
    const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
    let addresses = records.flat().map((a) => a.split("=")[1]).filter(Boolean);
    if (peerId != null) {
      addresses = addresses.filter((entry) => entry.includes(peerId));
    }
    return addresses;
  }
  var validateConfig = function(opts) {
    const resultingOptions = mergeOptions$1(DefaultConfig, opts);
    if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {
      throw new CodeError$3(messages.ERR_TRANSPORTS_REQUIRED, codes.ERR_TRANSPORTS_REQUIRED);
    }
    if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
      throw new CodeError$3(messages.ERR_PROTECTOR_REQUIRED, codes.ERR_PROTECTOR_REQUIRED);
    }
    return resultingOptions;
  };
  var getDriverVersion = function(client) {
    try {
      const _client = client.client ? client.client : client;
      const { version: version2 } = _client.topology.s.options.metadata.driver;
      const _v = version2.split(".").map((v) => parseInt(v));
      return {
        major: _v[0],
        feature: _v[1],
        patch: _v[2]
      };
    } catch (err) {
      return { major: 0, feature: 0, patch: 0 };
    }
  };
  var getPeerAddress = function(peer) {
    if (isPeerId(peer)) {
      return { peerId: peer, multiaddrs: [] };
    }
    if (!Array.isArray(peer)) {
      peer = [peer];
    }
    let peerId;
    if (peer.length > 0) {
      const peerIdStr = peer[0].getPeerId();
      peerId = peerIdStr == null ? undefined : peerIdFromString(peerIdStr);
      peer.forEach((ma) => {
        if (!isMultiaddr$1(ma)) {
          log$g.error("multiaddr %s was invalid", ma);
          throw new CodeError$3("Invalid Multiaddr", codes.ERR_INVALID_MULTIADDR);
        }
        const maPeerIdStr = ma.getPeerId();
        if (maPeerIdStr == null) {
          if (peerId != null) {
            throw new CodeError$3("Multiaddrs must all have the same peer id or have no peer id", codes.ERR_INVALID_PARAMETERS);
          }
        } else {
          const maPeerId = peerIdFromString(maPeerIdStr);
          if (peerId == null || !peerId.equals(maPeerId)) {
            throw new CodeError$3("Multiaddrs must all have the same peer id or have no peer id", codes.ERR_INVALID_PARAMETERS);
          }
        }
      });
    }
    return {
      peerId,
      multiaddrs: peer
    };
  };
  var lowerBound = function(array, value, comparator) {
    let first2 = 0;
    let count = array.length;
    while (count > 0) {
      const step = Math.trunc(count / 2);
      let it = first2 + step;
      if (comparator(array[it], value) <= 0) {
        first2 = ++it;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first2;
  };
  var anySignal = function(signals) {
    const controller = new globalThis.AbortController;
    function onAbort() {
      controller.abort();
      for (const signal2 of signals) {
        if (signal2?.removeEventListener != null) {
          signal2.removeEventListener("abort", onAbort);
        }
      }
    }
    for (const signal2 of signals) {
      if (signal2?.aborted === true) {
        onAbort();
        break;
      }
      if (signal2?.addEventListener != null) {
        signal2.addEventListener("abort", onAbort);
      }
    }
    function clear() {
      for (const signal2 of signals) {
        if (signal2?.removeEventListener != null) {
          signal2.removeEventListener("abort", onAbort);
        }
      }
    }
    const signal = controller.signal;
    signal.clear = clear;
    return signal;
  };
  async function resolveMultiaddrs(ma, options) {
    const resolvableProto = ma.protoNames().includes("dnsaddr");
    if (!resolvableProto) {
      return [ma];
    }
    const resolvedMultiaddrs = await resolveRecord(ma, options);
    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {
      return resolveMultiaddrs(nm, options);
    }));
    const addrs = recursiveMultiaddrs.flat();
    const output2 = addrs.reduce((array, newM) => {
      if (array.find((m) => m.equals(newM)) == null) {
        array.push(newM);
      }
      return array;
    }, []);
    log$d("resolved %s to", ma, output2.map((ma2) => ma2.toString()));
    return output2;
  }
  async function resolveRecord(ma, options) {
    try {
      ma = multiaddr$1(ma.toString());
      const multiaddrs = await ma.resolve(options);
      return multiaddrs;
    } catch (err) {
      log$d.error(`multiaddr ${ma.toString()} could not be resolved`, err);
      return [];
    }
  }
  var combineSignals = function(...signals) {
    const sigs = [];
    for (const sig of signals) {
      if (sig != null) {
        try {
          eventsExports.setMaxListeners?.(Infinity, sig);
        } catch {
        }
        sigs.push(sig);
      }
    }
    const signal = anySignal(sigs);
    try {
      eventsExports.setMaxListeners?.(Infinity, signal);
    } catch {
    }
    return signal;
  };
  var randomId = function() {
    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
  };
  var isAsyncIterable$2 = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var filter = function(source2, fn) {
    if (isAsyncIterable$2(source2)) {
      return async function* () {
        for await (const entry of source2) {
          if (await fn(entry)) {
            yield entry;
          }
        }
      }();
    }
    const peekable$1 = peekable(source2);
    const { value, done } = peekable$1.next();
    if (done === true) {
      return function* () {
      }();
    }
    const res = fn(value);
    if (typeof res.then === "function") {
      return async function* () {
        if (await res) {
          yield value;
        }
        for await (const entry of peekable$1) {
          if (await fn(entry)) {
            yield entry;
          }
        }
      }();
    }
    const func = fn;
    return function* () {
      if (res === true) {
        yield value;
      }
      for (const entry of peekable$1) {
        if (func(entry)) {
          yield entry;
        }
      }
    }();
  };
  var isAsyncIterable$1 = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var map = function(source2, func) {
    if (isAsyncIterable$1(source2)) {
      return async function* () {
        for await (const val of source2) {
          yield func(val);
        }
      }();
    }
    const peekable$1 = peekable(source2);
    const { value, done } = peekable$1.next();
    if (done === true) {
      return function* () {
      }();
    }
    const res = func(value);
    if (typeof res.then === "function") {
      return async function* () {
        yield await res;
        for await (const val of peekable$1) {
          yield func(val);
        }
      }();
    }
    const fn = func;
    return function* () {
      yield res;
      for (const val of peekable$1) {
        yield fn(val);
      }
    }();
  };
  async function* storeAddresses(source2, peerStore) {
    yield* map(source2, async (peer) => {
      await peerStore.merge(peer.id, {
        multiaddrs: peer.multiaddrs
      });
      return peer;
    });
  }
  var uniquePeers = function(source2) {
    const seen = new Set;
    return filter(source2, (peer) => {
      if (seen.has(peer.id.toString())) {
        return false;
      }
      seen.add(peer.id.toString());
      return true;
    });
  };
  async function* requirePeers(source2, min = 1) {
    let seen = 0;
    for await (const peer of source2) {
      seen++;
      yield peer;
    }
    if (seen < min) {
      throw new CodeError$3(`more peers required, seen: ${seen}  min: ${min}`, "NOT_FOUND");
    }
  }
  var isAsyncIterable = function(thing) {
    return thing[Symbol.asyncIterator] != null;
  };
  var first = function(source2) {
    if (isAsyncIterable(source2)) {
      return (async () => {
        for await (const entry of source2) {
          return entry;
        }
        return;
      })();
    }
    for (const entry of source2) {
      return entry;
    }
    return;
  };
  var trackedMap = function(config) {
    const { name: name2, metrics } = config;
    let map2;
    if (metrics != null) {
      map2 = new TrackedMap({ name: name2, metrics });
    } else {
      map2 = new Map;
    }
    return map2;
  };
  var base = function(ALPHABET, name2) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source2) {
      if (source2 instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source2)) {
        source2 = new Uint8Array(source2.buffer, source2.byteOffset, source2.byteLength);
      } else if (Array.isArray(source2)) {
        source2 = Uint8Array.from(source2);
      }
      if (!(source2 instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source2.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source2.length;
      while (pbegin !== pend && source2[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source2[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source2) {
      if (typeof source2 !== "string") {
        throw new TypeError("Expected String");
      }
      if (source2.length === 0) {
        return new Uint8Array;
      }
      var psz = 0;
      if (source2[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source2[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source2.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source2[psz]) {
        var carry = BASE_MAP[source2.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source2[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode3
    };
  };
  var createDisabledLogger = function(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  };
  var logger = function(name2) {
    let trace = createDisabledLogger(`${name2}:trace`);
    if (debug.enabled(`${name2}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = debug(`${name2}:trace`);
    }
    return Object.assign(debug(name2), {
      error: debug(`${name2}:error`),
      trace
    });
  };
  var reader = function(source2) {
    const reader2 = async function* () {
      let bytes2 = yield;
      let bl = new Uint8ArrayList;
      for await (const chunk of source2) {
        if (bytes2 == null) {
          bl.append(chunk);
          bytes2 = yield bl;
          bl = new Uint8ArrayList;
          continue;
        }
        bl.append(chunk);
        while (bl.length >= bytes2) {
          const data = bl.sublist(0, bytes2);
          bl.consume(bytes2);
          bytes2 = yield data;
          if (bytes2 == null) {
            if (bl.length > 0) {
              bytes2 = yield bl;
              bl = new Uint8ArrayList;
            }
            break;
          }
        }
      }
      if (bytes2 != null) {
        throw Object.assign(new Error(`stream ended before ${bytes2} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
      }
    }();
    reader2.next();
    return reader2;
  };
  var handshake = function(stream) {
    const writer2 = pushable();
    const source2 = reader(stream.source);
    const sourcePromise = pDefer();
    let sinkErr;
    const sinkPromise = stream.sink(async function* () {
      yield* writer2;
      const source3 = await sourcePromise.promise;
      yield* source3;
    }());
    sinkPromise.catch((err) => {
      sinkErr = err;
    });
    const rest = {
      sink: async (source3) => {
        if (sinkErr != null) {
          await Promise.reject(sinkErr);
          return;
        }
        sourcePromise.resolve(source3);
        await sinkPromise;
      },
      source: source2
    };
    return {
      reader: source2,
      writer: writer2,
      stream: rest,
      rest: () => writer2.end(),
      write: writer2.push,
      read: async () => {
        const res = await source2.next();
        if (res.value != null) {
          return res.value;
        }
      }
    };
  };
  var encode = function(buffer) {
    const list = new Uint8ArrayList(buffer, NewLine);
    return encode$B.single(list);
  };
  var write = function(writer2, buffer, options = {}) {
    const encoded = encode(buffer);
    if (options.writeBytes === true) {
      writer2.push(encoded.subarray());
    } else {
      writer2.push(encoded);
    }
  };
  var writeAll = function(writer2, buffers, options = {}) {
    const list = new Uint8ArrayList;
    for (const buf of buffers) {
      list.append(encode(buf));
    }
    if (options.writeBytes === true) {
      writer2.push(list.subarray());
    } else {
      writer2.push(list);
    }
  };
  async function read(reader2, options) {
    let byteLength = 1;
    const varByteSource = {
      [Symbol.asyncIterator]: () => varByteSource,
      next: async () => reader2.next(byteLength)
    };
    let input = varByteSource;
    if (options?.signal != null) {
      input = abortableSource(varByteSource, options.signal);
    }
    const onLength = (l) => {
      byteLength = l;
    };
    const buf = await pipe(input, (source2) => decode$v(source2, { onLength, maxDataLength: MAX_PROTOCOL_LENGTH }), async (source2) => first(source2));
    if (buf == null || buf.length === 0) {
      throw new CodeError$3("no buffer returned", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
    }
    if (buf.get(buf.byteLength - 1) !== NewLine[0]) {
      log$7.error("Invalid mss message - missing newline - %s", buf.subarray());
      throw new CodeError$3("missing newline", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
    }
    return buf.sublist(0, -1);
  }
  async function readString(reader2, options) {
    const buf = await read(reader2, options);
    return toString$9(buf.subarray());
  }
  async function select(stream, protocols, options = {}) {
    protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
    const { reader: reader2, writer: writer2, rest, stream: shakeStream } = handshake(stream);
    const protocol = protocols.shift();
    if (protocol == null) {
      throw new Error("At least one protocol must be specified");
    }
    log$6.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
    const p1 = fromString$3(PROTOCOL_ID);
    const p2 = fromString$3(protocol);
    writeAll(writer2, [p1, p2], options);
    let response = await readString(reader2, options);
    log$6.trace('select: read "%s"', response);
    if (response === PROTOCOL_ID) {
      response = await readString(reader2, options);
      log$6.trace('select: read "%s"', response);
    }
    if (response === protocol) {
      rest();
      return { stream: shakeStream, protocol };
    }
    for (const protocol2 of protocols) {
      log$6.trace('select: write "%s"', protocol2);
      write(writer2, fromString$3(protocol2), options);
      const response2 = await readString(reader2, options);
      log$6.trace('select: read "%s" for "%s"', response2, protocol2);
      if (response2 === protocol2) {
        rest();
        return { stream: shakeStream, protocol: protocol2 };
      }
    }
    rest();
    throw new CodeError$3("protocol selection failed", "ERR_UNSUPPORTED_PROTOCOL");
  }
  async function handle(stream, protocols, options) {
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    const { writer: writer2, reader: reader2, rest, stream: shakeStream } = handshake(stream);
    while (true) {
      const protocol = await readString(reader2, options);
      log$5.trace('read "%s"', protocol);
      if (protocol === PROTOCOL_ID) {
        log$5.trace('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
        write(writer2, fromString$3(PROTOCOL_ID), options);
        continue;
      }
      if (protocols.includes(protocol)) {
        write(writer2, fromString$3(protocol), options);
        log$5.trace('respond with "%s" for "%s"', protocol, protocol);
        rest();
        return { stream: shakeStream, protocol };
      }
      if (protocol === "ls") {
        write(writer2, new Uint8ArrayList(...protocols.map((p) => encode(fromString$3(p)))), options);
        log$5.trace('respond with "%s" for %s', protocols, protocol);
        continue;
      }
      write(writer2, fromString$3("na"), options);
      log$5('respond with "na" for "%s"', protocol);
    }
  }
  var createConnection = function(init2) {
    return new ConnectionImpl(init2);
  };
  var findIncomingStreamLimit = function(protocol, registrar) {
    try {
      const { options } = registrar.getHandler(protocol);
      return options.maxInboundStreams;
    } catch (err) {
      if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {
        throw err;
      }
    }
    return DEFAULT_MAX_INBOUND_STREAMS;
  };
  var findOutgoingStreamLimit = function(protocol, registrar, options = {}) {
    try {
      const { options: options2 } = registrar.getHandler(protocol);
      if (options2.maxOutboundStreams != null) {
        return options2.maxOutboundStreams;
      }
    } catch (err) {
      if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {
        throw err;
      }
    }
    return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
  };
  var countStreams = function(protocol, direction, connection) {
    let streamCount = 0;
    connection.streams.forEach((stream) => {
      if (stream.direction === direction && stream.protocol === protocol) {
        streamCount++;
      }
    });
    return streamCount;
  };
  async function createLibp2pNode(options) {
    if (options.peerId == null) {
      const datastore = options.datastore;
      if (datastore != null) {
        try {
          const keyChain = new DefaultKeyChain({
            datastore
          }, mergeOptions$1(DefaultKeyChain.generateOptions(), options.keychain));
          options.peerId = await keyChain.exportPeerId("self");
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            throw err;
          }
        }
      }
    }
    if (options.peerId == null) {
      options.peerId = await createEd25519PeerId();
    }
    return new Libp2pNode(validateConfig(options));
  }
  async function createLibp2p(options) {
    const node2 = await createLibp2pNode(options);
    if (options.start !== false) {
      await node2.start();
    }
    return node2;
  }
  var pbStream = function(duplex2, opts) {
    const lp = lpStream(duplex2, opts);
    const W = {
      read: async (proto, options) => {
        const value = await lp.read(options);
        return proto.decode(value);
      },
      write: async (data, proto, options) => {
        await lp.write(proto.encode(data), options);
      },
      pb: (proto) => {
        return {
          read: async (options) => W.read(proto, options),
          write: async (d, options) => W.write(d, proto, options),
          unwrap: () => W
        };
      },
      unwrap: () => {
        return lp.unwrap();
      }
    };
    return W;
  };
  var getCleanMultiaddr = function(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr$1(addr);
      } catch {
      }
    }
  };
  var identifyService = function(init2 = {}) {
    return (components) => new DefaultIdentifyService(components, init2);
  };
  var pingService = function(init2 = {}) {
    return (components) => new DefaultPingService(components, init2);
  };
  async function createLightNode(options) {
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery2 = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
      peerDiscovery2.push(...defaultPeerDiscoveries());
      Object.assign(libp2pOptions, { peerDiscovery: peerDiscovery2 });
    }
    const libp2p = await defaultLibp2p(undefined, libp2pOptions, options?.userAgent);
    const store = wakuStore(options);
    const lightPush = wakuLightPush(options);
    const filter2 = wakuFilter(options);
    return new WakuNode(options ?? {}, libp2p, store, lightPush, filter2);
  }
  async function createRelayNode(options) {
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery2 = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
      peerDiscovery2.push(...defaultPeerDiscoveries());
      Object.assign(libp2pOptions, { peerDiscovery: peerDiscovery2 });
    }
    const libp2p = await defaultLibp2p(wakuGossipSub(options), libp2pOptions, options?.userAgent);
    const relay = wakuRelay(options);
    return new WakuNode(options ?? {}, libp2p, undefined, undefined, undefined, relay);
  }
  async function createFullNode(options) {
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery2 = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
      peerDiscovery2.push(...defaultPeerDiscoveries());
      Object.assign(libp2pOptions, { peerDiscovery: peerDiscovery2 });
    }
    const libp2p = await defaultLibp2p(wakuGossipSub(options), libp2pOptions, options?.userAgent);
    const store = wakuStore(options);
    const lightPush = wakuLightPush(options);
    const filter2 = wakuFilter(options);
    const relay = wakuRelay(options);
    return new WakuNode(options ?? {}, libp2p, store, lightPush, filter2, relay);
  }
  var defaultPeerDiscoveries = function() {
    const discoveries = [
      wakuDnsDiscovery([enrTree["PROD"]], DEFAULT_NODE_REQUIREMENTS),
      wakuPeerExchangeDiscovery()
    ];
    return discoveries;
  };
  async function defaultLibp2p(wakuGossipSub2, options, userAgent) {
    const pubsubService = wakuGossipSub2 ? { pubsub: wakuGossipSub2 } : {};
    return createLibp2p({
      connectionManager: {
        minConnections: 1
      },
      transports: [webSockets({ filter: all })],
      streamMuxers: [mplex()],
      connectionEncryption: [noise()],
      ...options,
      services: {
        identify: identifyService({
          agentVersion: userAgent ?? DefaultUserAgent
        }),
        ping: pingService(),
        ...pubsubService,
        ...options?.services
      }
    });
  }
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _e;
  var _DefaultMultiaddr_string_1;
  var _DefaultMultiaddr_tuples_1;
  var _DefaultMultiaddr_stringTuples_1;
  var _DefaultMultiaddr_path;
  var _f;
  var _EventEmitter_listeners;
  var _g;
  var _j;
  var _l;
  var _o;
  var _EventEmitter_listeners_1;
  var _p;
  var _q;
  var _PersistentStore_instances;
  var _PersistentStore_findExistingPeer;
  var _PersistentStore_saveIfDifferent;
  var _PersistentPeerStore_instances;
  var _PersistentPeerStore_emitIfUpdated;
  var _PeerPriorityQueue_queue;
  var _r;
  var _t;
  var _Libp2pNode_instances;
  var _Libp2pNode_started;
  var _Libp2pNode_onDiscoveryPeer;
  var _DefaultIdentifyService_instances;
  var _DefaultIdentifyService_consumeIdentifyMessage;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.waku = exports.waitForRemotePeer = exports.utils = exports.utf8ToBytes = exports.relay = exports.defaultPeerDiscoveries = exports.defaultLibp2p = exports.createRelayNode = exports.createLightNode = exports.createFullNode = exports.createEncoder = exports.createDecoder = exports.bytesToUtf8 = exports.WakuNode = exports.Tags = exports.SendError = exports.Protocols = exports.PageDirection = exports.Encoder = exports.EPeersByDiscoveryEvents = exports.Decoder = exports.DecodedMessage = undefined;
  var symbol$5 = Symbol.for("@libp2p/peer-id");
  var AbortError$8 = (_e = class AbortError2 extends Error {
    constructor(message2 = "The operation was aborted") {
      super(message2);
      this.code = _e.code;
      this.type = _e.type;
    }
  }, _e.code = "ABORT_ERR", _e.type = "aborted", _e);
  var CodeError$3 = class CodeError2 extends Error {
    constructor(message2, code2, props) {
      super(message2);
      this.code = code2;
      this.name = props?.name ?? "CodeError";
      this.props = props ?? {};
    }
  };

  class UnexpectedPeerError extends Error {
    constructor(message2 = "Unexpected Peer") {
      super(message2);
      this.code = UnexpectedPeerError.code;
    }
  }
  UnexpectedPeerError.code = "ERR_UNEXPECTED_PEER";

  class InvalidCryptoExchangeError extends Error {
    constructor(message2 = "Invalid crypto exchange") {
      super(message2);
      this.code = InvalidCryptoExchangeError.code;
    }
  }
  InvalidCryptoExchangeError.code = "ERR_INVALID_CRYPTO_EXCHANGE";
  var src$e = base$f;
  var _brrp__multiformats_scope_baseX$e = src$e;
  var equals$6 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0;ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce$e = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var fromString$5 = (str) => new TextEncoder().encode(str);
  var toString$b = (b) => new TextDecoder().decode(b);
  var Encoder$g = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$g = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$f(this, decoder);
    }
  };
  var ComposedDecoder$e = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$f(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$f = (left2, right2) => new ComposedDecoder$e({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$e = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$g(name2, prefix, baseEncode);
      this.decoder = new Decoder$g(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$n = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$e(name2, prefix, encode3, decode3);
  var baseX$e = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$e(alphabet2, name2);
    return from$n({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$e(decode3(text))
    });
  };
  var decode$D = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$H = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$e = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$n({
      prefix,
      name: name2,
      encode(input) {
        return encode$H(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$D(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base58btc$d = baseX$e({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr$3 = baseX$e({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base58$3 = Object.freeze({
    __proto__: null,
    base58btc: base58btc$d,
    base58flickr: base58flickr$3
  });
  var encode_1$9 = encode$G;
  var MSB$c = 128;
  var REST$c = 127;
  var MSBALL$9 = ~REST$c;
  var INT$9 = Math.pow(2, 31);
  var decode$C = read$a;
  var MSB$1$8 = 128;
  var REST$1$8 = 127;
  var N1$a = Math.pow(2, 7);
  var N2$a = Math.pow(2, 14);
  var N3$a = Math.pow(2, 21);
  var N4$a = Math.pow(2, 28);
  var N5$a = Math.pow(2, 35);
  var N6$a = Math.pow(2, 42);
  var N7$a = Math.pow(2, 49);
  var N8$a = Math.pow(2, 56);
  var N9$a = Math.pow(2, 63);
  var length$9 = function(value) {
    return value < N1$a ? 1 : value < N2$a ? 2 : value < N3$a ? 3 : value < N4$a ? 4 : value < N5$a ? 5 : value < N6$a ? 6 : value < N7$a ? 7 : value < N8$a ? 8 : value < N9$a ? 9 : 10;
  };
  var varint$a = {
    encode: encode_1$9,
    decode: decode$C,
    encodingLength: length$9
  };
  var _brrp_varint$8 = varint$a;
  var decode$B = (data, offset = 0) => {
    const code2 = _brrp_varint$8.decode(data, offset);
    return [code2, _brrp_varint$8.decode.bytes];
  };
  var encodeTo$8 = (int, target, offset = 0) => {
    _brrp_varint$8.encode(int, target, offset);
    return target;
  };
  var encodingLength$a = (int) => {
    return _brrp_varint$8.encodingLength(int);
  };
  var create$h = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength$a(code2);
    const digestOffset = sizeOffset + encodingLength$a(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo$8(code2, bytes2, 0);
    encodeTo$8(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest$8(code2, size, digest2, bytes2);
  };
  var decode$A = (multihash) => {
    const bytes2 = coerce$e(multihash);
    const [code2, sizeOffset] = decode$B(bytes2);
    const [size, digestOffset] = decode$B(bytes2.subarray(sizeOffset));
    const digest2 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest2.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest$8(code2, size, digest2, bytes2);
  };
  var equals$5 = (a, b) => {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals$6(a.bytes, data.bytes);
    }
  };
  var Digest$8 = class Digest2 {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  };
  var base32$g = rfc4648$e({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper$3 = rfc4648$e({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad$3 = rfc4648$e({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper$3 = rfc4648$e({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex$3 = rfc4648$e({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper$3 = rfc4648$e({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad$3 = rfc4648$e({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper$3 = rfc4648$e({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z$3 = rfc4648$e({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base32$h = Object.freeze({
    __proto__: null,
    base32: base32$g,
    base32hex: base32hex$3,
    base32hexpad: base32hexpad$3,
    base32hexpadupper: base32hexpadupper$3,
    base32hexupper: base32hexupper$3,
    base32pad: base32pad$3,
    base32padupper: base32padupper$3,
    base32upper: base32upper$3,
    base32z: base32z$3
  });
  var format$5 = (link, base3) => {
    const { bytes: bytes2, version: version2 } = link;
    switch (version2) {
      case 0:
        return toStringV0$2(bytes2, baseCache$2(link), base3 || base58btc$d.encoder);
      default:
        return toStringV1$2(bytes2, baseCache$2(link), base3 || base32$g.encoder);
    }
  };
  var cache$3 = new WeakMap;
  var baseCache$2 = (cid) => {
    const baseCache2 = cache$3.get(cid);
    if (baseCache2 == null) {
      const baseCache3 = new Map;
      cache$3.set(cid, baseCache3);
      return baseCache3;
    }
    return baseCache2;
  };
  var CID$2 = class CID2 {
    constructor(version2, code2, multihash, bytes2) {
      this.code = code2;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    get asCID() {
      return this;
    }
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code2, multihash } = this;
          if (code2 !== DAG_PB_CODE$2) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE$2) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID2.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code2, digest: digest2 } = this.multihash;
          const multihash = create$h(code2, digest2);
          return CID2.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return CID2.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown && self2.code === unknown.code && self2.version === unknown.version && equals$5(self2.multihash, unknown.multihash);
    }
    toString(base3) {
      return format$5(this, base3);
    }
    toJSON() {
      return { "/": format$5(this) };
    }
    link() {
      return this;
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof CID2) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
        return new CID2(version2, code2, multihash, bytes2 || encodeCID$2(version2, code2, multihash.bytes));
      } else if (value[cidSymbol$2] === true) {
        const { version: version2, multihash, code: code2 } = value;
        const digest2 = decode$A(multihash);
        return CID2.create(version2, code2, digest2);
      } else {
        return null;
      }
    }
    static create(version2, code2, digest2) {
      if (typeof code2 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest2.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version2) {
        case 0: {
          if (code2 !== DAG_PB_CODE$2) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$2}) block encoding`);
          } else {
            return new CID2(version2, code2, digest2, digest2.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID$2(version2, code2, digest2.bytes);
          return new CID2(version2, code2, digest2, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest2) {
      return CID2.create(0, DAG_PB_CODE$2, digest2);
    }
    static createV1(code2, digest2) {
      return CID2.create(1, code2, digest2);
    }
    static decode(bytes2) {
      const [cid, remainder] = CID2.decodeFirst(bytes2);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes2) {
      const specs = CID2.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce$e(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest2 = new Digest$8(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? CID2.createV0(digest2) : CID2.createV1(specs.codec, digest2);
      return [cid, bytes2.subarray(specs.size)];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length2] = decode$B(initialBytes.subarray(offset));
        offset += length2;
        return i;
      };
      let version2 = next();
      let codec2 = DAG_PB_CODE$2;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else {
        codec2 = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version2, codec: codec2, multihashCode, digestSize, multihashSize, size };
    }
    static parse(source2, base3) {
      const [prefix, bytes2] = parseCIDtoBytes$2(source2, base3);
      const cid = CID2.decode(bytes2);
      if (cid.version === 0 && source2[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache$2(cid).set(prefix, source2);
      return cid;
    }
  };
  var parseCIDtoBytes$2 = (source2, base3) => {
    switch (source2[0]) {
      case "Q": {
        const decoder = base3 || base58btc$d;
        return [
          base58btc$d.prefix,
          decoder.decode(`${base58btc$d.prefix}${source2}`)
        ];
      }
      case base58btc$d.prefix: {
        const decoder = base3 || base58btc$d;
        return [base58btc$d.prefix, decoder.decode(source2)];
      }
      case base32$g.prefix: {
        const decoder = base3 || base32$g;
        return [base32$g.prefix, decoder.decode(source2)];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source2[0], base3.decode(source2)];
      }
    }
  };
  var toStringV0$2 = (bytes2, cache2, base3) => {
    const { prefix } = base3;
    if (prefix !== base58btc$d.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes2).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV1$2 = (bytes2, cache2, base3) => {
    const { prefix } = base3;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes2);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE$2 = 112;
  var SHA_256_CODE$2 = 18;
  var encodeCID$2 = (version2, code2, multihash) => {
    const codeOffset = encodingLength$a(version2);
    const hashOffset = codeOffset + encodingLength$a(code2);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo$8(version2, bytes2, 0);
    encodeTo$8(code2, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  };
  var cidSymbol$2 = Symbol.for("@ipld/js-cid/CID");
  var src$d = base$e;
  var _brrp__multiformats_scope_baseX$d = src$d;
  var coerce$d = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var fromString$4 = (str) => new TextEncoder().encode(str);
  var toString$a = (b) => new TextDecoder().decode(b);
  var Encoder$f = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$f = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$e(this, decoder);
    }
  };
  var ComposedDecoder$d = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$e(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$e = (left2, right2) => new ComposedDecoder$d({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$d = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$f(name2, prefix, baseEncode);
      this.decoder = new Decoder$f(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$m = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$d(name2, prefix, encode3, decode3);
  var baseX$d = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$d(alphabet2, name2);
    return from$m({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$d(decode3(text))
    });
  };
  var decode$z = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$F = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$d = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$m({
      prefix,
      name: name2,
      encode(input) {
        return encode$F(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$z(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var identity$b = from$m({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString$a(buf),
    decode: (str) => fromString$4(str)
  });
  var identityBase$3 = Object.freeze({
    __proto__: null,
    identity: identity$b
  });
  var base2$6 = rfc4648$d({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });
  var base2$7 = Object.freeze({
    __proto__: null,
    base2: base2$6
  });
  var base8$6 = rfc4648$d({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });
  var base8$7 = Object.freeze({
    __proto__: null,
    base8: base8$6
  });
  var base10$6 = baseX$d({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });
  var base10$7 = Object.freeze({
    __proto__: null,
    base10: base10$6
  });
  var base16$6 = rfc4648$d({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper$3 = rfc4648$d({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
  var base16$7 = Object.freeze({
    __proto__: null,
    base16: base16$6,
    base16upper: base16upper$3
  });
  var base32$e = rfc4648$d({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper$2 = rfc4648$d({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad$2 = rfc4648$d({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper$2 = rfc4648$d({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex$2 = rfc4648$d({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper$2 = rfc4648$d({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad$2 = rfc4648$d({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper$2 = rfc4648$d({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z$2 = rfc4648$d({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base32$f = Object.freeze({
    __proto__: null,
    base32: base32$e,
    base32hex: base32hex$2,
    base32hexpad: base32hexpad$2,
    base32hexpadupper: base32hexpadupper$2,
    base32hexupper: base32hexupper$2,
    base32pad: base32pad$2,
    base32padupper: base32padupper$2,
    base32upper: base32upper$2,
    base32z: base32z$2
  });
  var base36$6 = baseX$d({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper$3 = baseX$d({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
  var base36$7 = Object.freeze({
    __proto__: null,
    base36: base36$6,
    base36upper: base36upper$3
  });
  var base58btc$c = baseX$d({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr$2 = baseX$d({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base58$2 = Object.freeze({
    __proto__: null,
    base58btc: base58btc$c,
    base58flickr: base58flickr$2
  });
  var base64$i = rfc4648$d({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad$3 = rfc4648$d({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url$3 = rfc4648$d({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad$3 = rfc4648$d({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var base64$j = Object.freeze({
    __proto__: null,
    base64: base64$i,
    base64pad: base64pad$3,
    base64url: base64url$3,
    base64urlpad: base64urlpad$3
  });
  var alphabet$3 = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42");
  var alphabetBytesToChars$3 = alphabet$3.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes$3 = alphabet$3.reduce((p, c, i) => {
    p[c.codePointAt(0)] = i;
    return p;
  }, []);
  var base256emoji$6 = from$m({
    prefix: "\uD83D\uDE80",
    name: "base256emoji",
    encode: encode$E,
    decode: decode$y
  });
  var base256emoji$7 = Object.freeze({
    __proto__: null,
    base256emoji: base256emoji$6
  });
  new TextEncoder;
  new TextDecoder;
  var bases$3 = { ...identityBase$3, ...base2$7, ...base8$7, ...base10$7, ...base16$7, ...base32$f, ...base36$7, ...base58$2, ...base64$j, ...base256emoji$7 };
  var string$1 = createCodec$1("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder2 = new TextEncoder;
    return encoder2.encode(str.substring(1));
  });
  var ascii = createCodec$1("ascii", "a", (buf) => {
    let string2 = "a";
    for (let i = 0;i < buf.length; i++) {
      string2 += String.fromCharCode(buf[i]);
    }
    return string2;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe$2(str.length);
    for (let i = 0;i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES = {
    utf8: string$1,
    "utf-8": string$1,
    hex: bases$3.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases$3
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var encode_1$8 = encode$D;
  var MSB$b = 128;
  var REST$b = 127;
  var MSBALL$8 = ~REST$b;
  var INT$8 = Math.pow(2, 31);
  var decode$x = read$9;
  var MSB$a = 128;
  var REST$a = 127;
  var N1$9 = Math.pow(2, 7);
  var N2$9 = Math.pow(2, 14);
  var N3$9 = Math.pow(2, 21);
  var N4$9 = Math.pow(2, 28);
  var N5$9 = Math.pow(2, 35);
  var N6$9 = Math.pow(2, 42);
  var N7$9 = Math.pow(2, 49);
  var N8$9 = Math.pow(2, 56);
  var N9$9 = Math.pow(2, 63);
  var length$8 = function(value) {
    return value < N1$9 ? 1 : value < N2$9 ? 2 : value < N3$9 ? 3 : value < N4$9 ? 4 : value < N5$9 ? 5 : value < N6$9 ? 6 : value < N7$9 ? 7 : value < N8$9 ? 8 : value < N9$9 ? 9 : 10;
  };
  var varint$8 = {
    encode: encode_1$8,
    decode: decode$x,
    encodingLength: length$8
  };
  var varint$9 = getDefaultExportFromCjs(varint$8);

  class Parser2 {
    constructor() {
      this.index = 0;
      this.input = "";
    }
    new(input) {
      this.index = 0;
      this.input = input;
      return this;
    }
    readAtomically(fn) {
      const index2 = this.index;
      const result = fn();
      if (result === undefined) {
        this.index = index2;
      }
      return result;
    }
    parseWith(fn) {
      const result = fn();
      if (this.index !== this.input.length) {
        return;
      }
      return result;
    }
    peekChar() {
      if (this.index >= this.input.length) {
        return;
      }
      return this.input[this.index];
    }
    readChar() {
      if (this.index >= this.input.length) {
        return;
      }
      return this.input[this.index++];
    }
    readGivenChar(target) {
      return this.readAtomically(() => {
        const char = this.readChar();
        if (char !== target) {
          return;
        }
        return char;
      });
    }
    readSeparator(sep, index2, inner) {
      return this.readAtomically(() => {
        if (index2 > 0) {
          if (this.readGivenChar(sep) === undefined) {
            return;
          }
        }
        return inner();
      });
    }
    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
      return this.readAtomically(() => {
        let result = 0;
        let digitCount = 0;
        const leadingChar = this.peekChar();
        if (leadingChar === undefined) {
          return;
        }
        const hasLeadingZero = leadingChar === "0";
        const maxValue = 2 ** (8 * maxBytes) - 1;
        while (true) {
          const digit = this.readAtomically(() => {
            const char = this.readChar();
            if (char === undefined) {
              return;
            }
            const num = Number.parseInt(char, radix);
            if (Number.isNaN(num)) {
              return;
            }
            return num;
          });
          if (digit === undefined) {
            break;
          }
          result *= radix;
          result += digit;
          if (result > maxValue) {
            return;
          }
          digitCount += 1;
          if (maxDigits !== undefined) {
            if (digitCount > maxDigits) {
              return;
            }
          }
        }
        if (digitCount === 0) {
          return;
        } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
          return;
        } else {
          return result;
        }
      });
    }
    readIPv4Addr() {
      return this.readAtomically(() => {
        const out = new Uint8Array(4);
        for (let i = 0;i < out.length; i++) {
          const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
          if (ix === undefined) {
            return;
          }
          out[i] = ix;
        }
        return out;
      });
    }
    readIPv6Addr() {
      const readGroups = (groups) => {
        for (let i = 0;i < groups.length / 2; i++) {
          const ix = i * 2;
          if (i < groups.length - 3) {
            const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
            if (ipv4 !== undefined) {
              groups[ix] = ipv4[0];
              groups[ix + 1] = ipv4[1];
              groups[ix + 2] = ipv4[2];
              groups[ix + 3] = ipv4[3];
              return [ix + 4, true];
            }
          }
          const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
          if (group === undefined) {
            return [ix, false];
          }
          groups[ix] = group >> 8;
          groups[ix + 1] = group & 255;
        }
        return [groups.length, false];
      };
      return this.readAtomically(() => {
        const head = new Uint8Array(16);
        const [headSize, headIp4] = readGroups(head);
        if (headSize === 16) {
          return head;
        }
        if (headIp4) {
          return;
        }
        if (this.readGivenChar(":") === undefined) {
          return;
        }
        if (this.readGivenChar(":") === undefined) {
          return;
        }
        const tail = new Uint8Array(14);
        const limit = 16 - (headSize + 2);
        const [tailSize] = readGroups(tail.subarray(0, limit));
        head.set(tail.subarray(0, tailSize), 16 - tailSize);
        return head;
      });
    }
    readIPAddr() {
      return this.readIPv4Addr() ?? this.readIPv6Addr();
    }
  }
  var MAX_IPV6_LENGTH = 45;
  var MAX_IPV4_LENGTH = 15;
  var parser2 = new Parser2;
  var identity$a = from$n({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString$b(buf),
    decode: (str) => fromString$5(str)
  });
  var identityBase$2 = Object.freeze({
    __proto__: null,
    identity: identity$a
  });
  var base2$4 = rfc4648$e({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });
  var base2$5 = Object.freeze({
    __proto__: null,
    base2: base2$4
  });
  var base8$4 = rfc4648$e({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });
  var base8$5 = Object.freeze({
    __proto__: null,
    base8: base8$4
  });
  var base10$4 = baseX$e({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });
  var base10$5 = Object.freeze({
    __proto__: null,
    base10: base10$4
  });
  var base16$4 = rfc4648$e({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper$2 = rfc4648$e({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
  var base16$5 = Object.freeze({
    __proto__: null,
    base16: base16$4,
    base16upper: base16upper$2
  });
  var base36$4 = baseX$e({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper$2 = baseX$e({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
  var base36$5 = Object.freeze({
    __proto__: null,
    base36: base36$4,
    base36upper: base36upper$2
  });
  var base64$g = rfc4648$e({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad$2 = rfc4648$e({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url$2 = rfc4648$e({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad$2 = rfc4648$e({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var base64$h = Object.freeze({
    __proto__: null,
    base64: base64$g,
    base64pad: base64pad$2,
    base64url: base64url$2,
    base64urlpad: base64urlpad$2
  });
  var alphabet$2 = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42");
  var alphabetBytesToChars$2 = alphabet$2.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes$2 = alphabet$2.reduce((p, c, i) => {
    p[c.codePointAt(0)] = i;
    return p;
  }, []);
  var base256emoji$4 = from$n({
    prefix: "\uD83D\uDE80",
    name: "base256emoji",
    encode: encode$C,
    decode: decode$w
  });
  var base256emoji$5 = Object.freeze({
    __proto__: null,
    base256emoji: base256emoji$4
  });
  new TextEncoder;
  new TextDecoder;
  var bases$2 = { ...identityBase$2, ...base2$5, ...base8$5, ...base10$5, ...base16$5, ...base32$h, ...base36$5, ...base58$3, ...base64$h, ...base256emoji$5 };
  var isV4$1 = isIPv4;
  var isV6$1 = isIPv6;
  var toBytes$4 = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4$1(ip)) {
      const bytes2 = new Uint8Array(offset + 4);
      ip.split(/\./g).forEach((byte) => {
        bytes2[offset++] = parseInt(byte, 10) & 255;
      });
      return bytes2;
    }
    if (isV6$1(ip)) {
      const sections = ip.split(":", 8);
      let i;
      for (i = 0;i < sections.length; i++) {
        const isv4 = isV4$1(sections[i]);
        let v4Buffer;
        if (isv4) {
          v4Buffer = toBytes$4(sections[i]);
          sections[i] = toString$9(v4Buffer.slice(0, 2), "base16");
        }
        if (v4Buffer != null && ++i < 8) {
          sections.splice(i, 0, toString$9(v4Buffer.slice(2, 4), "base16"));
        }
      }
      if (sections[0] === "") {
        while (sections.length < 8)
          sections.unshift("0");
      } else if (sections[sections.length - 1] === "") {
        while (sections.length < 8)
          sections.push("0");
      } else if (sections.length < 8) {
        for (i = 0;i < sections.length && sections[i] !== ""; i++)
          ;
        const argv = [i, 1];
        for (i = 9 - sections.length;i > 0; i--) {
          argv.push("0");
        }
        sections.splice.apply(sections, argv);
      }
      const bytes2 = new Uint8Array(offset + 16);
      for (i = 0;i < sections.length; i++) {
        const word2 = parseInt(sections[i], 16);
        bytes2[offset++] = word2 >> 8 & 255;
        bytes2[offset++] = word2 & 255;
      }
      return bytes2;
    }
    throw new Error("invalid ip address");
  };
  var toString$8 = function(buf, offset = 0, length2) {
    offset = ~~offset;
    length2 = length2 ?? buf.length - offset;
    const view = new DataView(buf.buffer);
    if (length2 === 4) {
      const result = [];
      for (let i = 0;i < length2; i++) {
        result.push(buf[offset + i]);
      }
      return result.join(".");
    }
    if (length2 === 16) {
      const result = [];
      for (let i = 0;i < length2; i += 2) {
        result.push(view.getUint16(offset + i).toString(16));
      }
      return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
    }
    return "";
  };
  var V$1 = -1;
  var names$1 = {};
  var codes$5 = {};
  var table$1 = [
    [4, 32, "ip4"],
    [6, 16, "tcp"],
    [33, 16, "dccp"],
    [41, 128, "ip6"],
    [42, V$1, "ip6zone"],
    [43, 8, "ipcidr"],
    [53, V$1, "dns", true],
    [54, V$1, "dns4", true],
    [55, V$1, "dns6", true],
    [56, V$1, "dnsaddr", true],
    [132, 16, "sctp"],
    [273, 16, "udp"],
    [275, 0, "p2p-webrtc-star"],
    [276, 0, "p2p-webrtc-direct"],
    [277, 0, "p2p-stardust"],
    [280, 0, "webrtc-direct"],
    [281, 0, "webrtc"],
    [290, 0, "p2p-circuit"],
    [301, 0, "udt"],
    [302, 0, "utp"],
    [400, V$1, "unix", false, true],
    [421, V$1, "ipfs"],
    [421, V$1, "p2p"],
    [443, 0, "https"],
    [444, 96, "onion"],
    [445, 296, "onion3"],
    [446, V$1, "garlic64"],
    [448, 0, "tls"],
    [449, V$1, "sni"],
    [460, 0, "quic"],
    [461, 0, "quic-v1"],
    [465, 0, "webtransport"],
    [466, V$1, "certhash"],
    [477, 0, "ws"],
    [478, 0, "wss"],
    [479, 0, "p2p-websocket-star"],
    [480, 0, "http"],
    [777, V$1, "memory"]
  ];
  table$1.forEach((row) => {
    const proto = createProtocol$1(...row);
    codes$5[proto.code] = proto;
    names$1[proto.name] = proto;
  });
  getProtocol$1("ip4");
  getProtocol$1("ip6");
  getProtocol$1("ipcidr");
  var decoders$1 = Object.values(bases$2).map((c) => c.decoder);
  var anybaseDecoder$1 = function() {
    let acc = decoders$1[0].or(decoders$1[1]);
    decoders$1.slice(2).forEach((d) => acc = acc.or(d));
    return acc;
  }();
  var inspect$2 = Symbol.for("nodejs.util.inspect.custom");
  var DNS_CODES$1 = [
    getProtocol$1("dns").code,
    getProtocol$1("dns4").code,
    getProtocol$1("dns6").code,
    getProtocol$1("dnsaddr").code
  ];
  var resolvers$2 = new Map;
  var symbol$4 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
  var DefaultMultiaddr$1 = class DefaultMultiaddr2 {
    constructor(addr) {
      _DefaultMultiaddr_string_1.set(this, undefined);
      _DefaultMultiaddr_tuples_1.set(this, undefined);
      _DefaultMultiaddr_stringTuples_1.set(this, undefined);
      _DefaultMultiaddr_path.set(this, undefined);
      this[_f] = true;
      if (addr == null) {
        addr = "";
      }
      let parts;
      if (addr instanceof Uint8Array) {
        parts = bytesToMultiaddrParts(addr);
      } else if (typeof addr === "string") {
        if (addr.length > 0 && addr.charAt(0) !== "/") {
          throw new Error(`multiaddr "${addr}" must start with a "/"`);
        }
        parts = stringToMultiaddrParts(addr);
      } else if (isMultiaddr$1(addr)) {
        parts = bytesToMultiaddrParts(addr.bytes);
      } else {
        throw new Error("addr must be a string, Buffer, or another Multiaddr");
      }
      this.bytes = parts.bytes;
      __classPrivateFieldSet2(this, _DefaultMultiaddr_string_1, parts.string, "f");
      __classPrivateFieldSet2(this, _DefaultMultiaddr_tuples_1, parts.tuples, "f");
      __classPrivateFieldSet2(this, _DefaultMultiaddr_stringTuples_1, parts.stringTuples, "f");
      __classPrivateFieldSet2(this, _DefaultMultiaddr_path, parts.path, "f");
    }
    toString() {
      return __classPrivateFieldGet2(this, _DefaultMultiaddr_string_1, "f");
    }
    toJSON() {
      return this.toString();
    }
    toOptions() {
      let family;
      let transport;
      let host;
      let port;
      let zone = "";
      const tcp = getProtocol$1("tcp");
      const udp = getProtocol$1("udp");
      const ip4 = getProtocol$1("ip4");
      const ip6 = getProtocol$1("ip6");
      const dns6 = getProtocol$1("dns6");
      const ip6zone = getProtocol$1("ip6zone");
      for (const [code2, value] of this.stringTuples()) {
        if (code2 === ip6zone.code) {
          zone = `%${value ?? ""}`;
        }
        if (DNS_CODES$1.includes(code2)) {
          transport = tcp.name;
          port = 443;
          host = `${value ?? ""}${zone}`;
          family = code2 === dns6.code ? 6 : 4;
        }
        if (code2 === tcp.code || code2 === udp.code) {
          transport = getProtocol$1(code2).name;
          port = parseInt(value ?? "");
        }
        if (code2 === ip4.code || code2 === ip6.code) {
          transport = getProtocol$1(code2).name;
          host = `${value ?? ""}${zone}`;
          family = code2 === ip6.code ? 6 : 4;
        }
      }
      if (family == null || transport == null || host == null || port == null) {
        throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
      }
      const opts = {
        family,
        host,
        transport,
        port
      };
      return opts;
    }
    protos() {
      return __classPrivateFieldGet2(this, _DefaultMultiaddr_tuples_1, "f").map(([code2]) => Object.assign({}, getProtocol$1(code2)));
    }
    protoCodes() {
      return __classPrivateFieldGet2(this, _DefaultMultiaddr_tuples_1, "f").map(([code2]) => code2);
    }
    protoNames() {
      return __classPrivateFieldGet2(this, _DefaultMultiaddr_tuples_1, "f").map(([code2]) => getProtocol$1(code2).name);
    }
    tuples() {
      return __classPrivateFieldGet2(this, _DefaultMultiaddr_tuples_1, "f");
    }
    stringTuples() {
      return __classPrivateFieldGet2(this, _DefaultMultiaddr_stringTuples_1, "f");
    }
    encapsulate(addr) {
      addr = new DefaultMultiaddr2(addr);
      return new DefaultMultiaddr2(this.toString() + addr.toString());
    }
    decapsulate(addr) {
      const addrString = addr.toString();
      const s2 = this.toString();
      const i = s2.lastIndexOf(addrString);
      if (i < 0) {
        throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
      }
      return new DefaultMultiaddr2(s2.slice(0, i));
    }
    decapsulateCode(code2) {
      const tuples = this.tuples();
      for (let i = tuples.length - 1;i >= 0; i--) {
        if (tuples[i][0] === code2) {
          return new DefaultMultiaddr2(tuplesToBytes$1(tuples.slice(0, i)));
        }
      }
      return this;
    }
    getPeerId() {
      try {
        let tuples = [];
        this.stringTuples().forEach(([code2, name2]) => {
          if (code2 === names$1.p2p.code) {
            tuples.push([code2, name2]);
          }
          if (code2 === names$1["p2p-circuit"].code) {
            tuples = [];
          }
        });
        const tuple = tuples.pop();
        if (tuple?.[1] != null) {
          const peerIdStr = tuple[1];
          if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
            return toString$9(base58btc$d.decode(`z${peerIdStr}`), "base58btc");
          }
          return toString$9(CID$2.parse(peerIdStr).multihash.bytes, "base58btc");
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    getPath() {
      return __classPrivateFieldGet2(this, _DefaultMultiaddr_path, "f");
    }
    equals(addr) {
      return equals$4(this.bytes, addr.bytes);
    }
    async resolve(options) {
      const resolvableProto = this.protos().find((p) => p.resolvable);
      if (resolvableProto == null) {
        return [this];
      }
      const resolver = resolvers$2.get(resolvableProto.name);
      if (resolver == null) {
        throw new CodeError$3(`no available resolver for ${resolvableProto.name}`, "ERR_NO_AVAILABLE_RESOLVER");
      }
      const addresses = await resolver(this, options);
      return addresses.map((a) => new DefaultMultiaddr2(a));
    }
    nodeAddress() {
      const options = this.toOptions();
      if (options.transport !== "tcp" && options.transport !== "udp") {
        throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
      }
      return {
        family: options.family,
        address: options.host,
        port: options.port
      };
    }
    isThinWaistAddress(addr) {
      const protos = (addr ?? this).protos();
      if (protos.length !== 2) {
        return false;
      }
      if (protos[0].code !== 4 && protos[0].code !== 41) {
        return false;
      }
      if (protos[1].code !== 6 && protos[1].code !== 273) {
        return false;
      }
      return true;
    }
    [(_DefaultMultiaddr_string_1 = new WeakMap, _DefaultMultiaddr_tuples_1 = new WeakMap, _DefaultMultiaddr_stringTuples_1 = new WeakMap, _DefaultMultiaddr_path = new WeakMap, _f = symbol$4, inspect$2)]() {
      return `Multiaddr(${__classPrivateFieldGet2(this, _DefaultMultiaddr_string_1, "f")})`;
    }
  };
  var Protocols;
  (function(Protocols2) {
    Protocols2["Relay"] = "relay";
    Protocols2["Store"] = "store";
    Protocols2["LightPush"] = "lightpush";
    Protocols2["Filter"] = "filter";
  })(Protocols || (exports.Protocols = Protocols = {}));
  var SendError;
  (function(SendError2) {
    SendError2["GENERIC_FAIL"] = "Generic error";
    SendError2["ENCODE_FAILED"] = "Failed to encode";
    SendError2["DECODE_FAILED"] = "Failed to decode";
    SendError2["SIZE_TOO_BIG"] = "Size is too big";
    SendError2["NO_RPC_RESPONSE"] = "No RPC response";
  })(SendError || (exports.SendError = SendError = {}));
  var PageDirection$1;
  (function(PageDirection2) {
    PageDirection2["BACKWARD"] = "backward";
    PageDirection2["FORWARD"] = "forward";
  })(PageDirection$1 || (exports.PageDirection = PageDirection$1 = {}));
  var Tags;
  (function(Tags2) {
    Tags2["BOOTSTRAP"] = "bootstrap";
    Tags2["PEER_EXCHANGE"] = "peer-exchange";
  })(Tags || (exports.Tags = Tags = {}));
  var EPeersByDiscoveryEvents;
  (function(EPeersByDiscoveryEvents2) {
    EPeersByDiscoveryEvents2["PEER_DISCOVERY_BOOTSTRAP"] = "peer:discovery:bootstrap";
    EPeersByDiscoveryEvents2["PEER_DISCOVERY_PEER_EXCHANGE"] = "peer:discovery:peer-exchange";
    EPeersByDiscoveryEvents2["PEER_CONNECT_BOOTSTRAP"] = "peer:connected:bootstrap";
    EPeersByDiscoveryEvents2["PEER_CONNECT_PEER_EXCHANGE"] = "peer:connected:peer-exchange";
  })(EPeersByDiscoveryEvents || (exports.EPeersByDiscoveryEvents = EPeersByDiscoveryEvents = {}));
  var browser$2 = { exports: {} };
  var ms;
  var hasRequiredMs;
  var common = setup;
  (function(module2, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && ("env" in process)) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = common(exports2);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$2, browser$2.exports);
  var browserExports = browser$2.exports;
  var debug = getDefaultExportFromCjs(browserExports);
  var EventEmitter$3 = (_g = class EventEmitter2 extends EventTarget {
    constructor() {
      super(...arguments);
      _EventEmitter_listeners.set(this, new Map);
    }
    listenerCount(type) {
      const listeners = __classPrivateFieldGet2(this, _EventEmitter_listeners, "f").get(type);
      if (listeners == null) {
        return 0;
      }
      return listeners.length;
    }
    addEventListener(type, listener, options) {
      super.addEventListener(type, listener, options);
      let list = __classPrivateFieldGet2(this, _EventEmitter_listeners, "f").get(type);
      if (list == null) {
        list = [];
        __classPrivateFieldGet2(this, _EventEmitter_listeners, "f").set(type, list);
      }
      list.push({
        callback: listener,
        once: (options !== true && options !== false && options?.once) ?? false
      });
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type.toString(), listener ?? null, options);
      let list = __classPrivateFieldGet2(this, _EventEmitter_listeners, "f").get(type);
      if (list == null) {
        return;
      }
      list = list.filter(({ callback }) => callback !== listener);
      __classPrivateFieldGet2(this, _EventEmitter_listeners, "f").set(type, list);
    }
    dispatchEvent(event) {
      const result = super.dispatchEvent(event);
      let list = __classPrivateFieldGet2(this, _EventEmitter_listeners, "f").get(event.type);
      if (list == null) {
        return result;
      }
      list = list.filter(({ once: once2 }) => !once2);
      __classPrivateFieldGet2(this, _EventEmitter_listeners, "f").set(event.type, list);
      return result;
    }
    safeDispatchEvent(type, detail) {
      return this.dispatchEvent(new CustomEvent$1(type, detail));
    }
  }, _EventEmitter_listeners = new WeakMap, _g);
  var CustomEventPolyfill$1 = class CustomEventPolyfill2 extends Event {
    constructor(message2, data) {
      super(message2, data);
      this.detail = data?.detail;
    }
  };
  var CustomEvent$1 = globalThis.CustomEvent ?? CustomEventPolyfill$1;
  var bytesToHex$3 = (bytes2) => toString$9(bytes2, "base16");
  var bytesToUtf8 = (b) => toString$9(b, "utf8");
  exports.bytesToUtf8 = bytesToUtf8;
  var utf8ToBytes$4 = (s2) => fromString$3(s2, "utf8");
  exports.utf8ToBytes = utf8ToBytes$4;
  var minimal$1 = {};
  var aspromise;
  var hasRequiredAspromise;
  var base64$f = {};
  var hasRequiredBase64;
  var eventemitter;
  var hasRequiredEventemitter;
  var float;
  var hasRequiredFloat;
  var inquire_1;
  var hasRequiredInquire;
  var utf8$2 = {};
  var hasRequiredUtf8;
  var pool_1;
  var hasRequiredPool;
  var longbits;
  var hasRequiredLongbits;
  var hasRequiredMinimal;
  var reader$2 = Reader$1;
  var util$8 = requireMinimal();
  var BufferReader$1;
  var LongBits$2 = util$8.LongBits;
  var utf8$1 = util$8.utf8;
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer))
      return new Reader$1(buffer);
    throw Error("illegal buffer");
  } : function create_array(buffer) {
    if (Array.isArray(buffer))
      return new Reader$1(buffer);
    throw Error("illegal buffer");
  };
  var create$g = function create() {
    return util$8.Buffer ? function create_buffer_setup(buffer) {
      return (Reader$1.create = function create_buffer(buffer2) {
        return util$8.Buffer.isBuffer(buffer2) ? new BufferReader$1(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
  };
  Reader$1.create = create$g();
  Reader$1.prototype._slice = util$8.Array.prototype.subarray || util$8.Array.prototype.slice;
  Reader$1.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader$1.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader$1.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  Reader$1.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  Reader$1.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader$1.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  Reader$1.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util$8.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader$1.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util$8.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader$1.prototype.bytes = function read_bytes() {
    var length2 = this.uint32(), start = this.pos, end = this.pos + length2;
    if (end > this.len)
      throw indexOutOfRange(this, length2);
    this.pos += length2;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
  };
  Reader$1.prototype.string = function read_string() {
    var bytes2 = this.bytes();
    return utf8$1.read(bytes2, 0, bytes2.length);
  };
  Reader$1.prototype.skip = function skip(length2) {
    if (typeof length2 === "number") {
      if (this.pos + length2 > this.len)
        throw indexOutOfRange(this, length2);
      this.pos += length2;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader$1.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader$1._configure = function(BufferReader_) {
    BufferReader$1 = BufferReader_;
    Reader$1.create = create$g();
    BufferReader$1._configure();
    var fn = util$8.Long ? "toLong" : "toNumber";
    util$8.merge(Reader$1.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn](false);
      }
    });
  };
  var ReaderClass = getDefaultExportFromCjs(reader$2);
  var reader_buffer = BufferReader;
  var Reader = reader$2;
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util$7 = requireMinimal();
  BufferReader._configure = function() {
    if (util$7.Buffer)
      BufferReader.prototype._slice = util$7.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
  BufferReader._configure();
  var ReaderBufferClass = getDefaultExportFromCjs(reader_buffer);
  var minimalExports = requireMinimal();
  var util$6 = getDefaultExportFromCjs(minimalExports);
  var writer$1 = Writer$1;
  var util$5 = requireMinimal();
  var BufferWriter$1;
  var LongBits$1 = util$5.LongBits;
  var base64$e = util$5.base64;
  var utf8 = util$5.utf8;
  var create$f = function create() {
    return util$5.Buffer ? function create_buffer_setup() {
      return (Writer$1.create = function create_buffer() {
        return new BufferWriter$1;
      })();
    } : function create_array() {
      return new Writer$1;
    };
  };
  Writer$1.create = create$f();
  Writer$1.alloc = function alloc(size) {
    return new util$5.Array(size);
  };
  if (util$5.Array !== Array)
    Writer$1.alloc = util$5.pool(Writer$1.alloc, util$5.Array.prototype.subarray);
  Writer$1.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer$1.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  };
  Writer$1.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);
  };
  Writer$1.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  Writer$1.prototype.uint64 = function write_uint64(value) {
    var bits2 = LongBits$1.from(value);
    return this._push(writeVarint64, bits2.length(), bits2);
  };
  Writer$1.prototype.int64 = Writer$1.prototype.uint64;
  Writer$1.prototype.sint64 = function write_sint64(value) {
    var bits2 = LongBits$1.from(value).zzEncode();
    return this._push(writeVarint64, bits2.length(), bits2);
  };
  Writer$1.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  Writer$1.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
  Writer$1.prototype.fixed64 = function write_fixed64(value) {
    var bits2 = LongBits$1.from(value);
    return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
  };
  Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
  Writer$1.prototype.float = function write_float(value) {
    return this._push(util$5.float.writeFloatLE, 4, value);
  };
  Writer$1.prototype.double = function write_double(value) {
    return this._push(util$5.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util$5.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i = 0;i < val.length; ++i)
      buf[pos + i] = val[i];
  };
  Writer$1.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util$5.isString(value)) {
      var buf = Writer$1.alloc(len = base64$e.length(value));
      base64$e.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer$1.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer$1.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop$1, 0, 0);
    this.len = 0;
    return this;
  };
  Writer$1.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop$1, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer$1.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer$1.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer$1._configure = function(BufferWriter_) {
    BufferWriter$1 = BufferWriter_;
    Writer$1.create = create$f();
    BufferWriter$1._configure();
  };
  var WriterClass = getDefaultExportFromCjs(writer$1);
  var writer_buffer = BufferWriter;
  var Writer = writer$1;
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util$4 = requireMinimal();
  BufferWriter._configure = function() {
    BufferWriter.alloc = util$4._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util$4.Buffer && util$4.Buffer.prototype instanceof Uint8Array && util$4.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i = 0;i < val.length; )
          buf[pos++] = val[i++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util$4.isString(value))
      value = util$4._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
  };
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util$4.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
  BufferWriter._configure();
  var WriterBufferClass = getDefaultExportFromCjs(writer_buffer);
  configure();
  var methods = [
    "uint64",
    "int64",
    "sint64",
    "fixed64",
    "sfixed64"
  ];
  var CODEC_TYPES;
  (function(CODEC_TYPES2) {
    CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
    CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
    CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
    CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
  })(CODEC_TYPES || (CODEC_TYPES = {}));
  var RateLimitProof$4;
  (function(RateLimitProof2) {
    let _codec;
    RateLimitProof2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w.uint32(26);
            w.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w.uint32(34);
            w.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w.uint32(42);
            w.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w.uint32(50);
            w.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w.uint32(58);
            w.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            proof: new Uint8Array(0),
            merkleRoot: new Uint8Array(0),
            epoch: new Uint8Array(0),
            shareX: new Uint8Array(0),
            shareY: new Uint8Array(0),
            nullifier: new Uint8Array(0),
            rlnIdentifier: new Uint8Array(0)
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.proof = reader2.bytes();
                break;
              case 2:
                obj.merkleRoot = reader2.bytes();
                break;
              case 3:
                obj.epoch = reader2.bytes();
                break;
              case 4:
                obj.shareX = reader2.bytes();
                break;
              case 5:
                obj.shareY = reader2.bytes();
                break;
              case 6:
                obj.nullifier = reader2.bytes();
                break;
              case 7:
                obj.rlnIdentifier = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof2.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof2.codec());
    };
    RateLimitProof2.decode = (buf) => {
      return decodeMessage$1(buf, RateLimitProof2.codec());
    };
  })(RateLimitProof$4 || (RateLimitProof$4 = {}));
  var WakuMessage$4;
  (function(WakuMessage2) {
    let _codec;
    WakuMessage2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(18);
            w.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w.uint32(24);
            w.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w.uint32(80);
            w.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w.uint32(90);
            w.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w.uint32(170);
            RateLimitProof$4.codec().encode(obj.rateLimitProof, w);
          }
          if (obj.ephemeral != null) {
            w.uint32(248);
            w.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            payload: new Uint8Array(0),
            contentTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.payload = reader2.bytes();
                break;
              case 2:
                obj.contentTopic = reader2.string();
                break;
              case 3:
                obj.version = reader2.uint32();
                break;
              case 10:
                obj.timestamp = reader2.sint64();
                break;
              case 11:
                obj.meta = reader2.bytes();
                break;
              case 21:
                obj.rateLimitProof = RateLimitProof$4.codec().decode(reader2, reader2.uint32());
                break;
              case 31:
                obj.ephemeral = reader2.bool();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage2.encode = (obj) => {
      return encodeMessage(obj, WakuMessage2.codec());
    };
    WakuMessage2.decode = (buf) => {
      return decodeMessage$1(buf, WakuMessage2.codec());
    };
  })(WakuMessage$4 || (WakuMessage$4 = {}));
  var message = Object.freeze({
    __proto__: null,
    get RateLimitProof() {
      return RateLimitProof$4;
    },
    get WakuMessage() {
      return WakuMessage$4;
    }
  });
  var FilterRequest;
  (function(FilterRequest2) {
    (function(ContentFilter2) {
      let _codec2;
      ContentFilter2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message$1((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.contentTopic != null && obj.contentTopic !== "") {
              w.uint32(10);
              w.string(obj.contentTopic);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              contentTopic: ""
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.contentTopic = reader2.string();
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      ContentFilter2.encode = (obj) => {
        return encodeMessage(obj, ContentFilter2.codec());
      };
      ContentFilter2.decode = (buf) => {
        return decodeMessage$1(buf, ContentFilter2.codec());
      };
    })(FilterRequest2.ContentFilter || (FilterRequest2.ContentFilter = {}));
    let _codec;
    FilterRequest2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.subscribe != null && obj.subscribe !== false) {
            w.uint32(8);
            w.bool(obj.subscribe);
          }
          if (obj.topic != null && obj.topic !== "") {
            w.uint32(18);
            w.string(obj.topic);
          }
          if (obj.contentFilters != null) {
            for (const value of obj.contentFilters) {
              w.uint32(26);
              FilterRequest2.ContentFilter.codec().encode(value, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            subscribe: false,
            topic: "",
            contentFilters: []
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.subscribe = reader2.bool();
                break;
              case 2:
                obj.topic = reader2.string();
                break;
              case 3:
                obj.contentFilters.push(FilterRequest2.ContentFilter.codec().decode(reader2, reader2.uint32()));
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    FilterRequest2.encode = (obj) => {
      return encodeMessage(obj, FilterRequest2.codec());
    };
    FilterRequest2.decode = (buf) => {
      return decodeMessage$1(buf, FilterRequest2.codec());
    };
  })(FilterRequest || (FilterRequest = {}));
  var MessagePush$1;
  (function(MessagePush2) {
    let _codec;
    MessagePush2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.messages != null) {
            for (const value of obj.messages) {
              w.uint32(10);
              WakuMessage$3.codec().encode(value, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            messages: []
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.messages.push(WakuMessage$3.codec().decode(reader2, reader2.uint32()));
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    MessagePush2.encode = (obj) => {
      return encodeMessage(obj, MessagePush2.codec());
    };
    MessagePush2.decode = (buf) => {
      return decodeMessage$1(buf, MessagePush2.codec());
    };
  })(MessagePush$1 || (MessagePush$1 = {}));
  var FilterRpc;
  (function(FilterRpc2) {
    let _codec;
    FilterRpc2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w.uint32(10);
            w.string(obj.requestId);
          }
          if (obj.request != null) {
            w.uint32(18);
            FilterRequest.codec().encode(obj.request, w);
          }
          if (obj.push != null) {
            w.uint32(26);
            MessagePush$1.codec().encode(obj.push, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            requestId: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.requestId = reader2.string();
                break;
              case 2:
                obj.request = FilterRequest.codec().decode(reader2, reader2.uint32());
                break;
              case 3:
                obj.push = MessagePush$1.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    FilterRpc2.encode = (obj) => {
      return encodeMessage(obj, FilterRpc2.codec());
    };
    FilterRpc2.decode = (buf) => {
      return decodeMessage$1(buf, FilterRpc2.codec());
    };
  })(FilterRpc || (FilterRpc = {}));
  var RateLimitProof$3;
  (function(RateLimitProof2) {
    let _codec;
    RateLimitProof2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w.uint32(26);
            w.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w.uint32(34);
            w.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w.uint32(42);
            w.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w.uint32(50);
            w.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w.uint32(58);
            w.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            proof: new Uint8Array(0),
            merkleRoot: new Uint8Array(0),
            epoch: new Uint8Array(0),
            shareX: new Uint8Array(0),
            shareY: new Uint8Array(0),
            nullifier: new Uint8Array(0),
            rlnIdentifier: new Uint8Array(0)
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.proof = reader2.bytes();
                break;
              case 2:
                obj.merkleRoot = reader2.bytes();
                break;
              case 3:
                obj.epoch = reader2.bytes();
                break;
              case 4:
                obj.shareX = reader2.bytes();
                break;
              case 5:
                obj.shareY = reader2.bytes();
                break;
              case 6:
                obj.nullifier = reader2.bytes();
                break;
              case 7:
                obj.rlnIdentifier = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof2.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof2.codec());
    };
    RateLimitProof2.decode = (buf) => {
      return decodeMessage$1(buf, RateLimitProof2.codec());
    };
  })(RateLimitProof$3 || (RateLimitProof$3 = {}));
  var WakuMessage$3;
  (function(WakuMessage2) {
    let _codec;
    WakuMessage2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(18);
            w.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w.uint32(24);
            w.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w.uint32(80);
            w.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w.uint32(90);
            w.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w.uint32(170);
            RateLimitProof$3.codec().encode(obj.rateLimitProof, w);
          }
          if (obj.ephemeral != null) {
            w.uint32(248);
            w.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            payload: new Uint8Array(0),
            contentTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.payload = reader2.bytes();
                break;
              case 2:
                obj.contentTopic = reader2.string();
                break;
              case 3:
                obj.version = reader2.uint32();
                break;
              case 10:
                obj.timestamp = reader2.sint64();
                break;
              case 11:
                obj.meta = reader2.bytes();
                break;
              case 21:
                obj.rateLimitProof = RateLimitProof$3.codec().decode(reader2, reader2.uint32());
                break;
              case 31:
                obj.ephemeral = reader2.bool();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage2.encode = (obj) => {
      return encodeMessage(obj, WakuMessage2.codec());
    };
    WakuMessage2.decode = (buf) => {
      return decodeMessage$1(buf, WakuMessage2.codec());
    };
  })(WakuMessage$3 || (WakuMessage$3 = {}));
  var TopicOnlyMessage$1;
  (function(TopicOnlyMessage2) {
    let _codec;
    TopicOnlyMessage2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(18);
            w.string(obj.contentTopic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            contentTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 2:
                obj.contentTopic = reader2.string();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    TopicOnlyMessage2.encode = (obj) => {
      return encodeMessage(obj, TopicOnlyMessage2.codec());
    };
    TopicOnlyMessage2.decode = (buf) => {
      return decodeMessage$1(buf, TopicOnlyMessage2.codec());
    };
  })(TopicOnlyMessage$1 || (TopicOnlyMessage$1 = {}));
  var FilterSubscribeRequest;
  (function(FilterSubscribeRequest2) {
    let FilterSubscribeType;
    (function(FilterSubscribeType2) {
      FilterSubscribeType2["SUBSCRIBER_PING"] = "SUBSCRIBER_PING";
      FilterSubscribeType2["SUBSCRIBE"] = "SUBSCRIBE";
      FilterSubscribeType2["UNSUBSCRIBE"] = "UNSUBSCRIBE";
      FilterSubscribeType2["UNSUBSCRIBE_ALL"] = "UNSUBSCRIBE_ALL";
    })(FilterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType || (FilterSubscribeRequest2.FilterSubscribeType = {}));
    let __FilterSubscribeTypeValues;
    (function(__FilterSubscribeTypeValues2) {
      __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["SUBSCRIBER_PING"] = 0] = "SUBSCRIBER_PING";
      __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["SUBSCRIBE"] = 1] = "SUBSCRIBE";
      __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["UNSUBSCRIBE"] = 2] = "UNSUBSCRIBE";
      __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["UNSUBSCRIBE_ALL"] = 3] = "UNSUBSCRIBE_ALL";
    })(__FilterSubscribeTypeValues || (__FilterSubscribeTypeValues = {}));
    (function(FilterSubscribeType2) {
      FilterSubscribeType2.codec = () => {
        return enumeration(__FilterSubscribeTypeValues);
      };
    })(FilterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType || (FilterSubscribeRequest2.FilterSubscribeType = {}));
    let _codec;
    FilterSubscribeRequest2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w.uint32(10);
            w.string(obj.requestId);
          }
          if (obj.filterSubscribeType != null && __FilterSubscribeTypeValues[obj.filterSubscribeType] !== 0) {
            w.uint32(16);
            FilterSubscribeRequest2.FilterSubscribeType.codec().encode(obj.filterSubscribeType, w);
          }
          if (obj.pubsubTopic != null) {
            w.uint32(82);
            w.string(obj.pubsubTopic);
          }
          if (obj.contentTopics != null) {
            for (const value of obj.contentTopics) {
              w.uint32(90);
              w.string(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            requestId: "",
            filterSubscribeType: FilterSubscribeType.SUBSCRIBER_PING,
            contentTopics: []
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.requestId = reader2.string();
                break;
              case 2:
                obj.filterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType.codec().decode(reader2);
                break;
              case 10:
                obj.pubsubTopic = reader2.string();
                break;
              case 11:
                obj.contentTopics.push(reader2.string());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    FilterSubscribeRequest2.encode = (obj) => {
      return encodeMessage(obj, FilterSubscribeRequest2.codec());
    };
    FilterSubscribeRequest2.decode = (buf) => {
      return decodeMessage$1(buf, FilterSubscribeRequest2.codec());
    };
  })(FilterSubscribeRequest || (FilterSubscribeRequest = {}));
  var FilterSubscribeResponse$1;
  (function(FilterSubscribeResponse2) {
    let _codec;
    FilterSubscribeResponse2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w.uint32(10);
            w.string(obj.requestId);
          }
          if (obj.statusCode != null && obj.statusCode !== 0) {
            w.uint32(80);
            w.uint32(obj.statusCode);
          }
          if (obj.statusDesc != null) {
            w.uint32(90);
            w.string(obj.statusDesc);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            requestId: "",
            statusCode: 0
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.requestId = reader2.string();
                break;
              case 10:
                obj.statusCode = reader2.uint32();
                break;
              case 11:
                obj.statusDesc = reader2.string();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    FilterSubscribeResponse2.encode = (obj) => {
      return encodeMessage(obj, FilterSubscribeResponse2.codec());
    };
    FilterSubscribeResponse2.decode = (buf) => {
      return decodeMessage$1(buf, FilterSubscribeResponse2.codec());
    };
  })(FilterSubscribeResponse$1 || (FilterSubscribeResponse$1 = {}));
  var MessagePush;
  (function(MessagePush2) {
    let _codec;
    MessagePush2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.wakuMessage != null) {
            w.uint32(10);
            WakuMessage$2.codec().encode(obj.wakuMessage, w);
          }
          if (obj.pubsubTopic != null) {
            w.uint32(18);
            w.string(obj.pubsubTopic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.wakuMessage = WakuMessage$2.codec().decode(reader2, reader2.uint32());
                break;
              case 2:
                obj.pubsubTopic = reader2.string();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    MessagePush2.encode = (obj) => {
      return encodeMessage(obj, MessagePush2.codec());
    };
    MessagePush2.decode = (buf) => {
      return decodeMessage$1(buf, MessagePush2.codec());
    };
  })(MessagePush || (MessagePush = {}));
  var RateLimitProof$2;
  (function(RateLimitProof2) {
    let _codec;
    RateLimitProof2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w.uint32(26);
            w.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w.uint32(34);
            w.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w.uint32(42);
            w.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w.uint32(50);
            w.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w.uint32(58);
            w.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            proof: new Uint8Array(0),
            merkleRoot: new Uint8Array(0),
            epoch: new Uint8Array(0),
            shareX: new Uint8Array(0),
            shareY: new Uint8Array(0),
            nullifier: new Uint8Array(0),
            rlnIdentifier: new Uint8Array(0)
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.proof = reader2.bytes();
                break;
              case 2:
                obj.merkleRoot = reader2.bytes();
                break;
              case 3:
                obj.epoch = reader2.bytes();
                break;
              case 4:
                obj.shareX = reader2.bytes();
                break;
              case 5:
                obj.shareY = reader2.bytes();
                break;
              case 6:
                obj.nullifier = reader2.bytes();
                break;
              case 7:
                obj.rlnIdentifier = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof2.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof2.codec());
    };
    RateLimitProof2.decode = (buf) => {
      return decodeMessage$1(buf, RateLimitProof2.codec());
    };
  })(RateLimitProof$2 || (RateLimitProof$2 = {}));
  var WakuMessage$2;
  (function(WakuMessage2) {
    let _codec;
    WakuMessage2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(18);
            w.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w.uint32(24);
            w.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w.uint32(80);
            w.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w.uint32(90);
            w.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w.uint32(170);
            RateLimitProof$2.codec().encode(obj.rateLimitProof, w);
          }
          if (obj.ephemeral != null) {
            w.uint32(248);
            w.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            payload: new Uint8Array(0),
            contentTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.payload = reader2.bytes();
                break;
              case 2:
                obj.contentTopic = reader2.string();
                break;
              case 3:
                obj.version = reader2.uint32();
                break;
              case 10:
                obj.timestamp = reader2.sint64();
                break;
              case 11:
                obj.meta = reader2.bytes();
                break;
              case 21:
                obj.rateLimitProof = RateLimitProof$2.codec().decode(reader2, reader2.uint32());
                break;
              case 31:
                obj.ephemeral = reader2.bool();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage2.encode = (obj) => {
      return encodeMessage(obj, WakuMessage2.codec());
    };
    WakuMessage2.decode = (buf) => {
      return decodeMessage$1(buf, WakuMessage2.codec());
    };
  })(WakuMessage$2 || (WakuMessage$2 = {}));
  var PushRequest;
  (function(PushRequest2) {
    let _codec;
    PushRequest2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.pubsubTopic != null && obj.pubsubTopic !== "") {
            w.uint32(10);
            w.string(obj.pubsubTopic);
          }
          if (obj.message != null) {
            w.uint32(18);
            WakuMessage$1.codec().encode(obj.message, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            pubsubTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.pubsubTopic = reader2.string();
                break;
              case 2:
                obj.message = WakuMessage$1.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PushRequest2.encode = (obj) => {
      return encodeMessage(obj, PushRequest2.codec());
    };
    PushRequest2.decode = (buf) => {
      return decodeMessage$1(buf, PushRequest2.codec());
    };
  })(PushRequest || (PushRequest = {}));
  var PushResponse;
  (function(PushResponse2) {
    let _codec;
    PushResponse2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.isSuccess != null && obj.isSuccess !== false) {
            w.uint32(8);
            w.bool(obj.isSuccess);
          }
          if (obj.info != null) {
            w.uint32(18);
            w.string(obj.info);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            isSuccess: false
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.isSuccess = reader2.bool();
                break;
              case 2:
                obj.info = reader2.string();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PushResponse2.encode = (obj) => {
      return encodeMessage(obj, PushResponse2.codec());
    };
    PushResponse2.decode = (buf) => {
      return decodeMessage$1(buf, PushResponse2.codec());
    };
  })(PushResponse || (PushResponse = {}));
  var PushRpc$1;
  (function(PushRpc2) {
    let _codec;
    PushRpc2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w.uint32(10);
            w.string(obj.requestId);
          }
          if (obj.request != null) {
            w.uint32(18);
            PushRequest.codec().encode(obj.request, w);
          }
          if (obj.response != null) {
            w.uint32(26);
            PushResponse.codec().encode(obj.response, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            requestId: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.requestId = reader2.string();
                break;
              case 2:
                obj.request = PushRequest.codec().decode(reader2, reader2.uint32());
                break;
              case 3:
                obj.response = PushResponse.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PushRpc2.encode = (obj) => {
      return encodeMessage(obj, PushRpc2.codec());
    };
    PushRpc2.decode = (buf) => {
      return decodeMessage$1(buf, PushRpc2.codec());
    };
  })(PushRpc$1 || (PushRpc$1 = {}));
  var RateLimitProof$1;
  (function(RateLimitProof2) {
    let _codec;
    RateLimitProof2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w.uint32(26);
            w.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w.uint32(34);
            w.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w.uint32(42);
            w.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w.uint32(50);
            w.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w.uint32(58);
            w.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            proof: new Uint8Array(0),
            merkleRoot: new Uint8Array(0),
            epoch: new Uint8Array(0),
            shareX: new Uint8Array(0),
            shareY: new Uint8Array(0),
            nullifier: new Uint8Array(0),
            rlnIdentifier: new Uint8Array(0)
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.proof = reader2.bytes();
                break;
              case 2:
                obj.merkleRoot = reader2.bytes();
                break;
              case 3:
                obj.epoch = reader2.bytes();
                break;
              case 4:
                obj.shareX = reader2.bytes();
                break;
              case 5:
                obj.shareY = reader2.bytes();
                break;
              case 6:
                obj.nullifier = reader2.bytes();
                break;
              case 7:
                obj.rlnIdentifier = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof2.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof2.codec());
    };
    RateLimitProof2.decode = (buf) => {
      return decodeMessage$1(buf, RateLimitProof2.codec());
    };
  })(RateLimitProof$1 || (RateLimitProof$1 = {}));
  var WakuMessage$1;
  (function(WakuMessage2) {
    let _codec;
    WakuMessage2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(18);
            w.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w.uint32(24);
            w.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w.uint32(80);
            w.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w.uint32(90);
            w.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w.uint32(170);
            RateLimitProof$1.codec().encode(obj.rateLimitProof, w);
          }
          if (obj.ephemeral != null) {
            w.uint32(248);
            w.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            payload: new Uint8Array(0),
            contentTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.payload = reader2.bytes();
                break;
              case 2:
                obj.contentTopic = reader2.string();
                break;
              case 3:
                obj.version = reader2.uint32();
                break;
              case 10:
                obj.timestamp = reader2.sint64();
                break;
              case 11:
                obj.meta = reader2.bytes();
                break;
              case 21:
                obj.rateLimitProof = RateLimitProof$1.codec().decode(reader2, reader2.uint32());
                break;
              case 31:
                obj.ephemeral = reader2.bool();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage2.encode = (obj) => {
      return encodeMessage(obj, WakuMessage2.codec());
    };
    WakuMessage2.decode = (buf) => {
      return decodeMessage$1(buf, WakuMessage2.codec());
    };
  })(WakuMessage$1 || (WakuMessage$1 = {}));
  var Index;
  (function(Index2) {
    let _codec;
    Index2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.digest != null && obj.digest.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.digest);
          }
          if (obj.receiverTime != null && obj.receiverTime !== 0n) {
            w.uint32(16);
            w.sint64(obj.receiverTime);
          }
          if (obj.senderTime != null && obj.senderTime !== 0n) {
            w.uint32(24);
            w.sint64(obj.senderTime);
          }
          if (obj.pubsubTopic != null && obj.pubsubTopic !== "") {
            w.uint32(34);
            w.string(obj.pubsubTopic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            digest: new Uint8Array(0),
            receiverTime: 0n,
            senderTime: 0n,
            pubsubTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.digest = reader2.bytes();
                break;
              case 2:
                obj.receiverTime = reader2.sint64();
                break;
              case 3:
                obj.senderTime = reader2.sint64();
                break;
              case 4:
                obj.pubsubTopic = reader2.string();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Index2.encode = (obj) => {
      return encodeMessage(obj, Index2.codec());
    };
    Index2.decode = (buf) => {
      return decodeMessage$1(buf, Index2.codec());
    };
  })(Index || (Index = {}));
  var PagingInfo;
  (function(PagingInfo2) {
    (function(Direction) {
      Direction["BACKWARD"] = "BACKWARD";
      Direction["FORWARD"] = "FORWARD";
    })(PagingInfo2.Direction || (PagingInfo2.Direction = {}));
    let __DirectionValues;
    (function(__DirectionValues2) {
      __DirectionValues2[__DirectionValues2["BACKWARD"] = 0] = "BACKWARD";
      __DirectionValues2[__DirectionValues2["FORWARD"] = 1] = "FORWARD";
    })(__DirectionValues || (__DirectionValues = {}));
    (function(Direction) {
      Direction.codec = () => {
        return enumeration(__DirectionValues);
      };
    })(PagingInfo2.Direction || (PagingInfo2.Direction = {}));
    let _codec;
    PagingInfo2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.pageSize != null) {
            w.uint32(8);
            w.uint64(obj.pageSize);
          }
          if (obj.cursor != null) {
            w.uint32(18);
            Index.codec().encode(obj.cursor, w);
          }
          if (obj.direction != null) {
            w.uint32(24);
            PagingInfo2.Direction.codec().encode(obj.direction, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.pageSize = reader2.uint64();
                break;
              case 2:
                obj.cursor = Index.codec().decode(reader2, reader2.uint32());
                break;
              case 3:
                obj.direction = PagingInfo2.Direction.codec().decode(reader2);
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PagingInfo2.encode = (obj) => {
      return encodeMessage(obj, PagingInfo2.codec());
    };
    PagingInfo2.decode = (buf) => {
      return decodeMessage$1(buf, PagingInfo2.codec());
    };
  })(PagingInfo || (PagingInfo = {}));
  var ContentFilter;
  (function(ContentFilter2) {
    let _codec;
    ContentFilter2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(10);
            w.string(obj.contentTopic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            contentTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.contentTopic = reader2.string();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    ContentFilter2.encode = (obj) => {
      return encodeMessage(obj, ContentFilter2.codec());
    };
    ContentFilter2.decode = (buf) => {
      return decodeMessage$1(buf, ContentFilter2.codec());
    };
  })(ContentFilter || (ContentFilter = {}));
  var HistoryQuery;
  (function(HistoryQuery2) {
    let _codec;
    HistoryQuery2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.pubsubTopic != null) {
            w.uint32(18);
            w.string(obj.pubsubTopic);
          }
          if (obj.contentFilters != null) {
            for (const value of obj.contentFilters) {
              w.uint32(26);
              ContentFilter.codec().encode(value, w);
            }
          }
          if (obj.pagingInfo != null) {
            w.uint32(34);
            PagingInfo.codec().encode(obj.pagingInfo, w);
          }
          if (obj.startTime != null) {
            w.uint32(40);
            w.sint64(obj.startTime);
          }
          if (obj.endTime != null) {
            w.uint32(48);
            w.sint64(obj.endTime);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            contentFilters: []
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 2:
                obj.pubsubTopic = reader2.string();
                break;
              case 3:
                obj.contentFilters.push(ContentFilter.codec().decode(reader2, reader2.uint32()));
                break;
              case 4:
                obj.pagingInfo = PagingInfo.codec().decode(reader2, reader2.uint32());
                break;
              case 5:
                obj.startTime = reader2.sint64();
                break;
              case 6:
                obj.endTime = reader2.sint64();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    HistoryQuery2.encode = (obj) => {
      return encodeMessage(obj, HistoryQuery2.codec());
    };
    HistoryQuery2.decode = (buf) => {
      return decodeMessage$1(buf, HistoryQuery2.codec());
    };
  })(HistoryQuery || (HistoryQuery = {}));
  var HistoryResponse;
  (function(HistoryResponse2) {
    let HistoryError2;
    (function(HistoryError3) {
      HistoryError3["NONE"] = "NONE";
      HistoryError3["INVALID_CURSOR"] = "INVALID_CURSOR";
    })(HistoryError2 = HistoryResponse2.HistoryError || (HistoryResponse2.HistoryError = {}));
    let __HistoryErrorValues;
    (function(__HistoryErrorValues2) {
      __HistoryErrorValues2[__HistoryErrorValues2["NONE"] = 0] = "NONE";
      __HistoryErrorValues2[__HistoryErrorValues2["INVALID_CURSOR"] = 1] = "INVALID_CURSOR";
    })(__HistoryErrorValues || (__HistoryErrorValues = {}));
    (function(HistoryError3) {
      HistoryError3.codec = () => {
        return enumeration(__HistoryErrorValues);
      };
    })(HistoryError2 = HistoryResponse2.HistoryError || (HistoryResponse2.HistoryError = {}));
    let _codec;
    HistoryResponse2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.messages != null) {
            for (const value of obj.messages) {
              w.uint32(18);
              WakuMessage.codec().encode(value, w);
            }
          }
          if (obj.pagingInfo != null) {
            w.uint32(26);
            PagingInfo.codec().encode(obj.pagingInfo, w);
          }
          if (obj.error != null && __HistoryErrorValues[obj.error] !== 0) {
            w.uint32(32);
            HistoryResponse2.HistoryError.codec().encode(obj.error, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            messages: [],
            error: HistoryError2.NONE
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 2:
                obj.messages.push(WakuMessage.codec().decode(reader2, reader2.uint32()));
                break;
              case 3:
                obj.pagingInfo = PagingInfo.codec().decode(reader2, reader2.uint32());
                break;
              case 4:
                obj.error = HistoryResponse2.HistoryError.codec().decode(reader2);
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    HistoryResponse2.encode = (obj) => {
      return encodeMessage(obj, HistoryResponse2.codec());
    };
    HistoryResponse2.decode = (buf) => {
      return decodeMessage$1(buf, HistoryResponse2.codec());
    };
  })(HistoryResponse || (HistoryResponse = {}));
  var HistoryRpc$1;
  (function(HistoryRpc2) {
    let _codec;
    HistoryRpc2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.requestId != null && obj.requestId !== "") {
            w.uint32(10);
            w.string(obj.requestId);
          }
          if (obj.query != null) {
            w.uint32(18);
            HistoryQuery.codec().encode(obj.query, w);
          }
          if (obj.response != null) {
            w.uint32(26);
            HistoryResponse.codec().encode(obj.response, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            requestId: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.requestId = reader2.string();
                break;
              case 2:
                obj.query = HistoryQuery.codec().decode(reader2, reader2.uint32());
                break;
              case 3:
                obj.response = HistoryResponse.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    HistoryRpc2.encode = (obj) => {
      return encodeMessage(obj, HistoryRpc2.codec());
    };
    HistoryRpc2.decode = (buf) => {
      return decodeMessage$1(buf, HistoryRpc2.codec());
    };
  })(HistoryRpc$1 || (HistoryRpc$1 = {}));
  var RateLimitProof;
  (function(RateLimitProof2) {
    let _codec;
    RateLimitProof2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.proof != null && obj.proof.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.proof);
          }
          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.merkleRoot);
          }
          if (obj.epoch != null && obj.epoch.byteLength > 0) {
            w.uint32(26);
            w.bytes(obj.epoch);
          }
          if (obj.shareX != null && obj.shareX.byteLength > 0) {
            w.uint32(34);
            w.bytes(obj.shareX);
          }
          if (obj.shareY != null && obj.shareY.byteLength > 0) {
            w.uint32(42);
            w.bytes(obj.shareY);
          }
          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
            w.uint32(50);
            w.bytes(obj.nullifier);
          }
          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
            w.uint32(58);
            w.bytes(obj.rlnIdentifier);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            proof: new Uint8Array(0),
            merkleRoot: new Uint8Array(0),
            epoch: new Uint8Array(0),
            shareX: new Uint8Array(0),
            shareY: new Uint8Array(0),
            nullifier: new Uint8Array(0),
            rlnIdentifier: new Uint8Array(0)
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.proof = reader2.bytes();
                break;
              case 2:
                obj.merkleRoot = reader2.bytes();
                break;
              case 3:
                obj.epoch = reader2.bytes();
                break;
              case 4:
                obj.shareX = reader2.bytes();
                break;
              case 5:
                obj.shareY = reader2.bytes();
                break;
              case 6:
                obj.nullifier = reader2.bytes();
                break;
              case 7:
                obj.rlnIdentifier = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RateLimitProof2.encode = (obj) => {
      return encodeMessage(obj, RateLimitProof2.codec());
    };
    RateLimitProof2.decode = (buf) => {
      return decodeMessage$1(buf, RateLimitProof2.codec());
    };
  })(RateLimitProof || (RateLimitProof = {}));
  var WakuMessage;
  (function(WakuMessage2) {
    let _codec;
    WakuMessage2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.payload);
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(18);
            w.string(obj.contentTopic);
          }
          if (obj.version != null) {
            w.uint32(24);
            w.uint32(obj.version);
          }
          if (obj.timestamp != null) {
            w.uint32(80);
            w.sint64(obj.timestamp);
          }
          if (obj.meta != null) {
            w.uint32(90);
            w.bytes(obj.meta);
          }
          if (obj.rateLimitProof != null) {
            w.uint32(170);
            RateLimitProof.codec().encode(obj.rateLimitProof, w);
          }
          if (obj.ephemeral != null) {
            w.uint32(248);
            w.bool(obj.ephemeral);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            payload: new Uint8Array(0),
            contentTopic: ""
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.payload = reader2.bytes();
                break;
              case 2:
                obj.contentTopic = reader2.string();
                break;
              case 3:
                obj.version = reader2.uint32();
                break;
              case 10:
                obj.timestamp = reader2.sint64();
                break;
              case 11:
                obj.meta = reader2.bytes();
                break;
              case 21:
                obj.rateLimitProof = RateLimitProof.codec().decode(reader2, reader2.uint32());
                break;
              case 31:
                obj.ephemeral = reader2.bool();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WakuMessage2.encode = (obj) => {
      return encodeMessage(obj, WakuMessage2.codec());
    };
    WakuMessage2.decode = (buf) => {
      return decodeMessage$1(buf, WakuMessage2.codec());
    };
  })(WakuMessage || (WakuMessage = {}));
  var PeerInfo;
  (function(PeerInfo2) {
    let _codec;
    PeerInfo2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.enr != null) {
            w.uint32(10);
            w.bytes(obj.enr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.enr = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerInfo2.encode = (obj) => {
      return encodeMessage(obj, PeerInfo2.codec());
    };
    PeerInfo2.decode = (buf) => {
      return decodeMessage$1(buf, PeerInfo2.codec());
    };
  })(PeerInfo || (PeerInfo = {}));
  var PeerExchangeQuery;
  (function(PeerExchangeQuery2) {
    let _codec;
    PeerExchangeQuery2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.numPeers != null) {
            w.uint32(8);
            w.uint64(obj.numPeers);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.numPeers = reader2.uint64();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerExchangeQuery2.encode = (obj) => {
      return encodeMessage(obj, PeerExchangeQuery2.codec());
    };
    PeerExchangeQuery2.decode = (buf) => {
      return decodeMessage$1(buf, PeerExchangeQuery2.codec());
    };
  })(PeerExchangeQuery || (PeerExchangeQuery = {}));
  var PeerExchangeResponse;
  (function(PeerExchangeResponse2) {
    let _codec;
    PeerExchangeResponse2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.peerInfos != null) {
            for (const value of obj.peerInfos) {
              w.uint32(10);
              PeerInfo.codec().encode(value, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            peerInfos: []
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.peerInfos.push(PeerInfo.codec().decode(reader2, reader2.uint32()));
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerExchangeResponse2.encode = (obj) => {
      return encodeMessage(obj, PeerExchangeResponse2.codec());
    };
    PeerExchangeResponse2.decode = (buf) => {
      return decodeMessage$1(buf, PeerExchangeResponse2.codec());
    };
  })(PeerExchangeResponse || (PeerExchangeResponse = {}));
  var PeerExchangeRPC$1;
  (function(PeerExchangeRPC2) {
    let _codec;
    PeerExchangeRPC2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.query != null) {
            w.uint32(10);
            PeerExchangeQuery.codec().encode(obj.query, w);
          }
          if (obj.response != null) {
            w.uint32(18);
            PeerExchangeResponse.codec().encode(obj.response, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.query = PeerExchangeQuery.codec().decode(reader2, reader2.uint32());
                break;
              case 2:
                obj.response = PeerExchangeResponse.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerExchangeRPC2.encode = (obj) => {
      return encodeMessage(obj, PeerExchangeRPC2.codec());
    };
    PeerExchangeRPC2.decode = (buf) => {
      return decodeMessage$1(buf, PeerExchangeRPC2.codec());
    };
  })(PeerExchangeRPC$1 || (PeerExchangeRPC$1 = {}));
  var log$I = debug("waku:message:version-0");
  var OneMillion$1 = BigInt(1e6);
  var Version = 0;

  class DecodedMessage {
    constructor(pubSubTopic, proto) {
      this.pubSubTopic = pubSubTopic;
      this.proto = proto;
    }
    get ephemeral() {
      return Boolean(this.proto.ephemeral);
    }
    get payload() {
      return this.proto.payload;
    }
    get contentTopic() {
      return this.proto.contentTopic;
    }
    get _rawTimestamp() {
      return this.proto.timestamp;
    }
    get timestamp() {
      try {
        if (this.proto.timestamp) {
          const timestamp = this.proto.timestamp / OneMillion$1;
          return new Date(Number(timestamp));
        }
        return;
      } catch (e) {
        return;
      }
    }
    get meta() {
      return this.proto.meta;
    }
    get version() {
      return this.proto.version ?? 0;
    }
    get rateLimitProof() {
      return this.proto.rateLimitProof;
    }
  }
  exports.DecodedMessage = DecodedMessage;
  var Encoder$e = class Encoder2 {
    constructor(contentTopic, ephemeral = false, metaSetter) {
      this.contentTopic = contentTopic;
      this.ephemeral = ephemeral;
      this.metaSetter = metaSetter;
      if (!contentTopic || contentTopic === "") {
        throw new Error("Content topic must be specified");
      }
    }
    async toWire(message$12) {
      return WakuMessage$4.encode(await this.toProtoObj(message$12));
    }
    async toProtoObj(message2) {
      const timestamp = message2.timestamp ?? new Date;
      const protoMessage = {
        payload: message2.payload,
        version: Version,
        contentTopic: this.contentTopic,
        timestamp: BigInt(timestamp.valueOf()) * OneMillion$1,
        meta: undefined,
        rateLimitProof: message2.rateLimitProof,
        ephemeral: this.ephemeral
      };
      if (this.metaSetter) {
        const meta = this.metaSetter(protoMessage);
        return { ...protoMessage, meta };
      }
      return protoMessage;
    }
  };
  exports.Encoder = Encoder$e;
  exports.createEncoder = createEncoder;
  var Decoder$e = class Decoder2 {
    constructor(contentTopic) {
      this.contentTopic = contentTopic;
      if (!contentTopic || contentTopic === "") {
        throw new Error("Content topic must be specified");
      }
    }
    fromWireToProtoObj(bytes2) {
      const protoMessage = WakuMessage$4.decode(bytes2);
      log$I("Message decoded", protoMessage);
      return Promise.resolve({
        payload: protoMessage.payload,
        contentTopic: protoMessage.contentTopic,
        version: protoMessage.version ?? undefined,
        timestamp: protoMessage.timestamp ?? undefined,
        meta: protoMessage.meta ?? undefined,
        rateLimitProof: protoMessage.rateLimitProof ?? undefined,
        ephemeral: protoMessage.ephemeral ?? false
      });
    }
    async fromProtoObj(pubSubTopic, proto) {
      if (proto.version ?? Version !== 0) {
        log$I("Failed to decode due to incorrect version, expected:", Version, ", actual:", proto.version);
        return Promise.resolve(undefined);
      }
      return new DecodedMessage(pubSubTopic, proto);
    }
  };
  exports.Decoder = Decoder$e;
  exports.createDecoder = createDecoder;
  var version_0 = Object.freeze({
    __proto__: null,
    DecodedMessage,
    Decoder: Decoder$e,
    Encoder: Encoder$e,
    Version,
    createDecoder,
    createEncoder,
    proto: message
  });
  var RelayPingContentTopic = "/relay-ping/1/ping/null";
  var log$H = debug("waku:keep-alive");

  class KeepAliveManager {
    constructor(options, relay) {
      this.pingKeepAliveTimers = new Map;
      this.relayKeepAliveTimers = new Map;
      this.options = options;
      this.relay = relay;
    }
    start(peerId, libp2pPing, peerStore) {
      this.stop(peerId);
      const { pingKeepAlive: pingPeriodSecs, relayKeepAlive: relayPeriodSecs } = this.options;
      const peerIdStr = peerId.toString();
      if (pingPeriodSecs !== 0) {
        const interval = setInterval(() => {
          (async () => {
            try {
              const ping = await libp2pPing.ping(peerId);
              log$H(`Ping succeeded (${peerIdStr})`, ping);
              try {
                await peerStore.patch(peerId, {
                  metadata: {
                    ping: utf8ToBytes$4(ping.toString())
                  }
                });
              } catch (e) {
                log$H("Failed to update ping", e);
              }
            } catch (e) {
              log$H(`Ping failed (${peerIdStr})`, e);
            }
          })();
        }, pingPeriodSecs * 1000);
        this.pingKeepAliveTimers.set(peerIdStr, interval);
      }
      const relay = this.relay;
      if (relay && relayPeriodSecs !== 0) {
        const encoder2 = createEncoder({
          contentTopic: RelayPingContentTopic,
          ephemeral: true
        });
        const interval = setInterval(() => {
          log$H("Sending Waku Relay ping message");
          relay.send(encoder2, { payload: new Uint8Array([1]) }).catch((e) => log$H("Failed to send relay ping", e));
        }, relayPeriodSecs * 1000);
        this.relayKeepAliveTimers.set(peerId, interval);
      }
    }
    stop(peerId) {
      const peerIdStr = peerId.toString();
      if (this.pingKeepAliveTimers.has(peerIdStr)) {
        clearInterval(this.pingKeepAliveTimers.get(peerIdStr));
        this.pingKeepAliveTimers.delete(peerIdStr);
      }
      if (this.relayKeepAliveTimers.has(peerId)) {
        clearInterval(this.relayKeepAliveTimers.get(peerId));
        this.relayKeepAliveTimers.delete(peerId);
      }
    }
    stopAll() {
      for (const timer of [
        ...Object.values(this.pingKeepAliveTimers),
        ...Object.values(this.relayKeepAliveTimers)
      ]) {
        clearInterval(timer);
      }
      this.pingKeepAliveTimers.clear();
      this.relayKeepAliveTimers.clear();
    }
  }
  var log$G = debug("waku:connection-manager");
  var DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED = 1;
  var DEFAULT_MAX_DIAL_ATTEMPTS_FOR_PEER = 3;
  var DEFAULT_MAX_PARALLEL_DIALS = 3;

  class ConnectionManager extends EventEmitter$3 {
    static create(peerId, libp2p, keepAliveOptions, relay, options) {
      let instance = ConnectionManager.instances.get(peerId);
      if (!instance) {
        instance = new ConnectionManager(libp2p, keepAliveOptions, relay, options);
        ConnectionManager.instances.set(peerId, instance);
      }
      return instance;
    }
    async getPeersByDiscovery() {
      const peersDiscovered = await this.libp2p.peerStore.all();
      const peersConnected = this.libp2p.getConnections().map((conn) => conn.remotePeer);
      const peersDiscoveredByBootstrap = [];
      const peersDiscoveredByPeerExchange = [];
      const peersConnectedByBootstrap = [];
      const peersConnectedByPeerExchange = [];
      for (const peer of peersDiscovered) {
        const tags = await this.getTagNamesForPeer(peer.id);
        if (tags.includes(Tags.BOOTSTRAP)) {
          peersDiscoveredByBootstrap.push(peer);
        } else if (tags.includes(Tags.PEER_EXCHANGE)) {
          peersDiscoveredByPeerExchange.push(peer);
        }
      }
      for (const peerId of peersConnected) {
        const peer = await this.libp2p.peerStore.get(peerId);
        const tags = await this.getTagNamesForPeer(peerId);
        if (tags.includes(Tags.BOOTSTRAP)) {
          peersConnectedByBootstrap.push(peer);
        } else if (tags.includes(Tags.PEER_EXCHANGE)) {
          peersConnectedByPeerExchange.push(peer);
        }
      }
      return {
        DISCOVERED: {
          [Tags.BOOTSTRAP]: peersDiscoveredByBootstrap,
          [Tags.PEER_EXCHANGE]: peersDiscoveredByPeerExchange
        },
        CONNECTED: {
          [Tags.BOOTSTRAP]: peersConnectedByBootstrap,
          [Tags.PEER_EXCHANGE]: peersConnectedByPeerExchange
        }
      };
    }
    constructor(libp2p, keepAliveOptions, relay, options) {
      super();
      this.dialAttemptsForPeer = new Map;
      this.dialErrorsForPeer = new Map;
      this.currentActiveDialCount = 0;
      this.pendingPeerDialQueue = [];
      this.onEventHandlers = {
        "peer:discovery": (evt) => {
          (async () => {
            const { id: peerId } = evt.detail;
            const isBootstrap = (await this.getTagNamesForPeer(peerId)).includes(Tags.BOOTSTRAP);
            this.dispatchEvent(new CustomEvent$1(isBootstrap ? EPeersByDiscoveryEvents.PEER_DISCOVERY_BOOTSTRAP : EPeersByDiscoveryEvents.PEER_DISCOVERY_PEER_EXCHANGE, {
              detail: peerId
            }));
            try {
              await this.attemptDial(peerId);
            } catch (error) {
              log$G(`Error dialing peer ${peerId.toString()} : ${error}`);
            }
          })();
        },
        "peer:connect": (evt) => {
          (async () => {
            const peerId = evt.detail;
            this.keepAliveManager.start(peerId, this.libp2p.services.ping, this.libp2p.peerStore);
            const isBootstrap = (await this.getTagNamesForPeer(peerId)).includes(Tags.BOOTSTRAP);
            if (isBootstrap) {
              const bootstrapConnections = this.libp2p.getConnections().filter((conn) => conn.tags.includes(Tags.BOOTSTRAP));
              if (bootstrapConnections.length > this.options.maxBootstrapPeersAllowed) {
                await this.dropConnection(peerId);
              } else {
                this.dispatchEvent(new CustomEvent$1(EPeersByDiscoveryEvents.PEER_CONNECT_BOOTSTRAP, {
                  detail: peerId
                }));
              }
            } else {
              this.dispatchEvent(new CustomEvent$1(EPeersByDiscoveryEvents.PEER_CONNECT_PEER_EXCHANGE, {
                detail: peerId
              }));
            }
          })();
        },
        "peer:disconnect": () => {
          return (evt) => {
            this.keepAliveManager.stop(evt.detail);
          };
        }
      };
      this.libp2p = libp2p;
      this.options = {
        maxDialAttemptsForPeer: DEFAULT_MAX_DIAL_ATTEMPTS_FOR_PEER,
        maxBootstrapPeersAllowed: DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED,
        maxParallelDials: DEFAULT_MAX_PARALLEL_DIALS,
        ...options
      };
      this.keepAliveManager = new KeepAliveManager(keepAliveOptions, relay);
      this.run().then(() => log$G(`Connection Manager is now running`)).catch((error) => log$G(`Unexpected error while running service`, error));
      this.dialPeerStorePeers().catch((error) => log$G(`Unexpected error while dialing peer store peers`, error));
    }
    async dialPeerStorePeers() {
      const peerInfos = await this.libp2p.peerStore.all();
      const dialPromises = [];
      for (const peerInfo of peerInfos) {
        if (this.libp2p.getConnections().find((c) => c.remotePeer === peerInfo.id))
          continue;
        dialPromises.push(this.attemptDial(peerInfo.id));
      }
      try {
        await Promise.all(dialPromises);
      } catch (error) {
        log$G(`Unexpected error while dialing peer store peers`, error);
      }
    }
    async run() {
      this.startPeerDiscoveryListener();
      this.startPeerConnectionListener();
      this.startPeerDisconnectionListener();
    }
    stop() {
      this.keepAliveManager.stopAll();
      this.libp2p.removeEventListener("peer:connect", this.onEventHandlers["peer:connect"]);
      this.libp2p.removeEventListener("peer:disconnect", this.onEventHandlers["peer:disconnect"]);
      this.libp2p.removeEventListener("peer:discovery", this.onEventHandlers["peer:discovery"]);
    }
    async dialPeer(peerId) {
      this.currentActiveDialCount += 1;
      let dialAttempt = 0;
      while (dialAttempt < this.options.maxDialAttemptsForPeer) {
        try {
          log$G(`Dialing peer ${peerId.toString()} on attempt ${dialAttempt + 1}`);
          await this.libp2p.dial(peerId);
          const tags = await this.getTagNamesForPeer(peerId);
          this.libp2p.getConnections(peerId).forEach((conn) => {
            conn.tags = Array.from(new Set([...conn.tags, ...tags]));
          });
          this.dialAttemptsForPeer.delete(peerId.toString());
          break;
        } catch (error) {
          if (error instanceof AggregateError) {
            log$G(`Error dialing peer ${peerId.toString()} - ${error.errors}`);
          } else {
            log$G(`Error dialing peer ${peerId.toString()} - ${error.message}`);
          }
          this.dialErrorsForPeer.set(peerId.toString(), error);
          dialAttempt++;
          this.dialAttemptsForPeer.set(peerId.toString(), dialAttempt);
        }
      }
      this.currentActiveDialCount--;
      this.processDialQueue();
      if (dialAttempt === this.options.maxDialAttemptsForPeer) {
        try {
          const error = this.dialErrorsForPeer.get(peerId.toString());
          let errorMessage;
          if (error instanceof AggregateError) {
            errorMessage = JSON.stringify(error.errors[0]);
          } else {
            errorMessage = error.message;
          }
          log$G(`Deleting undialable peer ${peerId.toString()} from peer store. Error: ${errorMessage}`);
          this.dialErrorsForPeer.delete(peerId.toString());
          await this.libp2p.peerStore.delete(peerId);
        } catch (error) {
          throw new Error(`Error deleting undialable peer ${peerId.toString()} from peer store - ${error}`);
        }
      }
    }
    async dropConnection(peerId) {
      try {
        this.keepAliveManager.stop(peerId);
        await this.libp2p.hangUp(peerId);
        log$G(`Dropped connection with peer ${peerId.toString()}`);
      } catch (error) {
        log$G(`Error dropping connection with peer ${peerId.toString()} - ${error}`);
      }
    }
    processDialQueue() {
      if (this.pendingPeerDialQueue.length > 0 && this.currentActiveDialCount < this.options.maxParallelDials) {
        const peerId = this.pendingPeerDialQueue.shift();
        if (!peerId)
          return;
        this.attemptDial(peerId).catch((error) => {
          log$G(error);
        });
      }
    }
    startPeerDiscoveryListener() {
      this.libp2p.addEventListener("peer:discovery", this.onEventHandlers["peer:discovery"]);
    }
    startPeerConnectionListener() {
      this.libp2p.addEventListener("peer:connect", this.onEventHandlers["peer:connect"]);
    }
    startPeerDisconnectionListener() {
      this.libp2p.addEventListener("peer:disconnect", this.onEventHandlers["peer:disconnect"]);
    }
    async attemptDial(peerId) {
      if (this.currentActiveDialCount >= this.options.maxParallelDials) {
        this.pendingPeerDialQueue.push(peerId);
        return;
      }
      if (!await this.shouldDialPeer(peerId))
        return;
      this.dialPeer(peerId).catch((err) => {
        throw `Error dialing peer ${peerId.toString()} : ${err}`;
      });
    }
    async shouldDialPeer(peerId) {
      const isConnected = this.libp2p.getConnections(peerId).length > 0;
      if (isConnected)
        return false;
      const tagNames = await this.getTagNamesForPeer(peerId);
      const isBootstrap = tagNames.some((tagName) => tagName === Tags.BOOTSTRAP);
      if (isBootstrap) {
        const currentBootstrapConnections = this.libp2p.getConnections().filter((conn) => {
          return conn.tags.find((name2) => name2 === Tags.BOOTSTRAP);
        }).length;
        if (currentBootstrapConnections < this.options.maxBootstrapPeersAllowed)
          return true;
      } else {
        return true;
      }
      return false;
    }
    async getTagNamesForPeer(peerId) {
      try {
        const peer = await this.libp2p.peerStore.get(peerId);
        return Array.from(peer.tags.keys());
      } catch (error) {
        log$G(`Failed to get peer ${peerId}, error: ${error}`);
        return [];
      }
    }
  }
  ConnectionManager.instances = new Map;
  var DefaultPingKeepAliveValueSecs = 0;
  var DefaultRelayKeepAliveValueSecs = 5 * 60;
  var DefaultUserAgent = "js-waku";
  var log$F = debug("waku:waku");

  class WakuNode {
    constructor(options, libp2p, store, lightPush, filter2, relay) {
      this.libp2p = libp2p;
      if (store) {
        this.store = store(libp2p);
      }
      if (filter2) {
        this.filter = filter2(libp2p);
      }
      if (lightPush) {
        this.lightPush = lightPush(libp2p);
      }
      if (relay) {
        this.relay = relay(libp2p);
      }
      const pingKeepAlive = options.pingKeepAlive || DefaultPingKeepAliveValueSecs;
      const relayKeepAlive = this.relay ? options.relayKeepAlive || DefaultRelayKeepAliveValueSecs : 0;
      const peerId = this.libp2p.peerId.toString();
      this.connectionManager = ConnectionManager.create(peerId, libp2p, { pingKeepAlive, relayKeepAlive }, this.relay);
      log$F("Waku node created", peerId, `relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this.lightPush}, filter: ${!!this.filter}`);
    }
    async dial(peer, protocols) {
      const _protocols = protocols ?? [];
      const peerId = mapToPeerIdOrMultiaddr(peer);
      if (typeof protocols === "undefined") {
        this.relay && _protocols.push(Protocols.Relay);
        this.store && _protocols.push(Protocols.Store);
        this.filter && _protocols.push(Protocols.Filter);
        this.lightPush && _protocols.push(Protocols.LightPush);
      }
      const codecs = [];
      if (_protocols.includes(Protocols.Relay)) {
        if (this.relay) {
          this.relay.gossipSub.multicodecs.forEach((codec2) => codecs.push(codec2));
        } else {
          log$F("Relay codec not included in dial codec: protocol not mounted locally");
        }
      }
      if (_protocols.includes(Protocols.Store)) {
        if (this.store) {
          codecs.push(this.store.multicodec);
        } else {
          log$F("Store codec not included in dial codec: protocol not mounted locally");
        }
      }
      if (_protocols.includes(Protocols.LightPush)) {
        if (this.lightPush) {
          codecs.push(this.lightPush.multicodec);
        } else {
          log$F("Light Push codec not included in dial codec: protocol not mounted locally");
        }
      }
      if (_protocols.includes(Protocols.Filter)) {
        if (this.filter) {
          codecs.push(this.filter.multicodec);
        } else {
          log$F("Filter codec not included in dial codec: protocol not mounted locally");
        }
      }
      log$F(`Dialing to ${peerId.toString()} with protocols ${_protocols}`);
      return this.libp2p.dialProtocol(peerId, codecs);
    }
    async start() {
      await this.libp2p.start();
    }
    async stop() {
      this.connectionManager.stop();
      await this.libp2p.stop();
    }
    isStarted() {
      return this.libp2p.isStarted();
    }
    getLocalMultiaddrWithID() {
      const localMultiaddr = this.libp2p.getMultiaddrs().find((addr) => addr.toString().match(/127\.0\.0\.1/));
      if (!localMultiaddr || localMultiaddr.toString() === "") {
        throw "Not listening on localhost";
      }
      return localMultiaddr + "/p2p/" + this.libp2p.peerId.toString();
    }
  }
  exports.WakuNode = WakuNode;
  var waku = Object.freeze({
    __proto__: null,
    DefaultPingKeepAliveValueSecs,
    DefaultRelayKeepAliveValueSecs,
    DefaultUserAgent,
    WakuNode
  });
  var DefaultPubSubTopic = "/waku/2/default-waku/proto";
  var index$6 = Object.freeze({
    __proto__: null,
    version_0
  });
  var FRAME_RATE = 60;
  var MB = 1024 ** 2;
  var SIZE_CAP = 1;
  var isSizeValid = (payload) => {
    if (payload.length / MB > SIZE_CAP) {
      return false;
    }
    return true;
  };
  var index$5 = Object.freeze({
    __proto__: null,
    getPseudoRandomSubset,
    groupByContentTopic,
    isDefined,
    isSizeValid,
    removeItemFromArray,
    toAsyncIterator
  });
  exports.utils = index$5;
  var symbol$3 = Symbol.for("@achingbrain/uint8arraylist");

  class Uint8ArrayList {
    constructor(...data) {
      Object.defineProperty(this, symbol$3, { value: true });
      this.bufs = [];
      this.length = 0;
      if (data.length > 0) {
        this.appendAll(data);
      }
    }
    *[Symbol.iterator]() {
      yield* this.bufs;
    }
    get byteLength() {
      return this.length;
    }
    append(...bufs) {
      this.appendAll(bufs);
    }
    appendAll(bufs) {
      let length2 = 0;
      for (const buf of bufs) {
        if (buf instanceof Uint8Array) {
          length2 += buf.byteLength;
          this.bufs.push(buf);
        } else if (isUint8ArrayList(buf)) {
          length2 += buf.byteLength;
          this.bufs.push(...buf.bufs);
        } else {
          throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      this.length += length2;
    }
    prepend(...bufs) {
      this.prependAll(bufs);
    }
    prependAll(bufs) {
      let length2 = 0;
      for (const buf of bufs.reverse()) {
        if (buf instanceof Uint8Array) {
          length2 += buf.byteLength;
          this.bufs.unshift(buf);
        } else if (isUint8ArrayList(buf)) {
          length2 += buf.byteLength;
          this.bufs.unshift(...buf.bufs);
        } else {
          throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      this.length += length2;
    }
    get(index2) {
      const res = findBufAndOffset(this.bufs, index2);
      return res.buf[res.index];
    }
    set(index2, value) {
      const res = findBufAndOffset(this.bufs, index2);
      res.buf[res.index] = value;
    }
    write(buf, offset = 0) {
      if (buf instanceof Uint8Array) {
        for (let i = 0;i < buf.length; i++) {
          this.set(offset + i, buf[i]);
        }
      } else if (isUint8ArrayList(buf)) {
        for (let i = 0;i < buf.length; i++) {
          this.set(offset + i, buf.get(i));
        }
      } else {
        throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    consume(bytes2) {
      bytes2 = Math.trunc(bytes2);
      if (Number.isNaN(bytes2) || bytes2 <= 0) {
        return;
      }
      if (bytes2 === this.byteLength) {
        this.bufs = [];
        this.length = 0;
        return;
      }
      while (this.bufs.length > 0) {
        if (bytes2 >= this.bufs[0].byteLength) {
          bytes2 -= this.bufs[0].byteLength;
          this.length -= this.bufs[0].byteLength;
          this.bufs.shift();
        } else {
          this.bufs[0] = this.bufs[0].subarray(bytes2);
          this.length -= bytes2;
          break;
        }
      }
    }
    slice(beginInclusive, endExclusive) {
      const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
      return concat$1(bufs, length2);
    }
    subarray(beginInclusive, endExclusive) {
      const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
      if (bufs.length === 1) {
        return bufs[0];
      }
      return concat$1(bufs, length2);
    }
    sublist(beginInclusive, endExclusive) {
      const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
      const list = new Uint8ArrayList;
      list.length = length2;
      list.bufs = bufs;
      return list;
    }
    _subList(beginInclusive, endExclusive) {
      beginInclusive = beginInclusive ?? 0;
      endExclusive = endExclusive ?? this.length;
      if (beginInclusive < 0) {
        beginInclusive = this.length + beginInclusive;
      }
      if (endExclusive < 0) {
        endExclusive = this.length + endExclusive;
      }
      if (beginInclusive < 0 || endExclusive > this.length) {
        throw new RangeError("index is out of bounds");
      }
      if (beginInclusive === endExclusive) {
        return { bufs: [], length: 0 };
      }
      if (beginInclusive === 0 && endExclusive === this.length) {
        return { bufs: [...this.bufs], length: this.length };
      }
      const bufs = [];
      let offset = 0;
      for (let i = 0;i < this.bufs.length; i++) {
        const buf = this.bufs[i];
        const bufStart = offset;
        const bufEnd = bufStart + buf.byteLength;
        offset = bufEnd;
        if (beginInclusive >= bufEnd) {
          continue;
        }
        const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
        const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
        if (sliceStartInBuf && sliceEndsInBuf) {
          if (beginInclusive === bufStart && endExclusive === bufEnd) {
            bufs.push(buf);
            break;
          }
          const start = beginInclusive - bufStart;
          bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));
          break;
        }
        if (sliceStartInBuf) {
          if (beginInclusive === 0) {
            bufs.push(buf);
            continue;
          }
          bufs.push(buf.subarray(beginInclusive - bufStart));
          continue;
        }
        if (sliceEndsInBuf) {
          if (endExclusive === bufEnd) {
            bufs.push(buf);
            break;
          }
          bufs.push(buf.subarray(0, endExclusive - bufStart));
          break;
        }
        bufs.push(buf);
      }
      return { bufs, length: endExclusive - beginInclusive };
    }
    indexOf(search, offset = 0) {
      if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
        throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
      }
      const needle = search instanceof Uint8Array ? search : search.subarray();
      offset = Number(offset ?? 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const M = needle.byteLength;
      if (M === 0) {
        throw new TypeError("search must be at least 1 byte long");
      }
      const radix = 256;
      const rightmostPositions = new Int32Array(radix);
      for (let c = 0;c < radix; c++) {
        rightmostPositions[c] = -1;
      }
      for (let j = 0;j < M; j++) {
        rightmostPositions[needle[j]] = j;
      }
      const right2 = rightmostPositions;
      const lastIndex = this.byteLength - needle.byteLength;
      const lastPatIndex = needle.byteLength - 1;
      let skip;
      for (let i = offset;i <= lastIndex; i += skip) {
        skip = 0;
        for (let j = lastPatIndex;j >= 0; j--) {
          const char = this.get(i + j);
          if (needle[j] !== char) {
            skip = Math.max(1, j - right2[char]);
            break;
          }
        }
        if (skip === 0) {
          return i;
        }
      }
      return -1;
    }
    getInt8(byteOffset) {
      const buf = this.subarray(byteOffset, byteOffset + 1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt8(0);
    }
    setInt8(byteOffset, value) {
      const buf = allocUnsafe$2(1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt8(0, value);
      this.write(buf, byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt16(0, littleEndian);
    }
    setInt16(byteOffset, value, littleEndian) {
      const buf = alloc$1(2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt16(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getInt32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt32(0, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
      const buf = alloc$1(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getBigInt64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getBigInt64(0, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
      const buf = alloc$1(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setBigInt64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getUint8(byteOffset) {
      const buf = this.subarray(byteOffset, byteOffset + 1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint8(0);
    }
    setUint8(byteOffset, value) {
      const buf = allocUnsafe$2(1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint8(0, value);
      this.write(buf, byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint16(0, littleEndian);
    }
    setUint16(byteOffset, value, littleEndian) {
      const buf = alloc$1(2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint16(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getUint32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint32(0, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
      const buf = alloc$1(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getBigUint64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getBigUint64(0, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
      const buf = alloc$1(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setBigUint64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getFloat32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getFloat32(0, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
      const buf = alloc$1(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setFloat32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getFloat64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getFloat64(0, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
      const buf = alloc$1(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setFloat64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    equals(other) {
      if (other == null) {
        return false;
      }
      if (!(other instanceof Uint8ArrayList)) {
        return false;
      }
      if (other.bufs.length !== this.bufs.length) {
        return false;
      }
      for (let i = 0;i < this.bufs.length; i++) {
        if (!equals$4(this.bufs[i], other.bufs[i])) {
          return false;
        }
      }
      return true;
    }
    static fromUint8Arrays(bufs, length2) {
      const list = new Uint8ArrayList;
      list.bufs = bufs;
      if (length2 == null) {
        length2 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
      }
      list.length = length2;
      return list;
    }
  }
  var TWO_32 = 4294967296;

  class LongBits {
    constructor(hi = 0, lo = 0) {
      this.hi = hi;
      this.lo = lo;
    }
    toBigInt(unsigned2) {
      if (unsigned2 === true) {
        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
      }
      if (this.hi >>> 31 !== 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(BigInt(lo) + (BigInt(hi) << 32n));
      }
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    toNumber(unsigned2) {
      return Number(this.toBigInt(unsigned2));
    }
    zzDecode() {
      const mask = -(this.lo & 1);
      const lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      const hi = (this.hi >>> 1 ^ mask) >>> 0;
      return new LongBits(hi, lo);
    }
    zzEncode() {
      const mask = this.hi >> 31;
      const hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      const lo = (this.lo << 1 ^ mask) >>> 0;
      return new LongBits(hi, lo);
    }
    toBytes(buf, offset = 0) {
      const access = accessor(buf);
      while (this.hi > 0) {
        access.set(offset++, this.lo & 127 | 128);
        this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0;
        this.hi >>>= 7;
      }
      while (this.lo > 127) {
        access.set(offset++, this.lo & 127 | 128);
        this.lo = this.lo >>> 7;
      }
      access.set(offset++, this.lo);
    }
    static fromBigInt(value) {
      if (value === 0n) {
        return new LongBits;
      }
      const negative = value < 0;
      if (negative) {
        value = -value;
      }
      let hi = Number(value >> 32n) | 0;
      let lo = Number(value - (BigInt(hi) << 32n)) | 0;
      if (negative) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > TWO_32) {
          lo = 0;
          if (++hi > TWO_32) {
            hi = 0;
          }
        }
      }
      return new LongBits(hi, lo);
    }
    static fromNumber(value) {
      if (value === 0) {
        return new LongBits;
      }
      const sign2 = value < 0;
      if (sign2) {
        value = -value;
      }
      let lo = value >>> 0;
      let hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295) {
            hi = 0;
          }
        }
      }
      return new LongBits(hi, lo);
    }
    static fromBytes(buf, offset = 0) {
      const access = accessor(buf);
      const bits2 = new LongBits;
      let i = 0;
      if (buf.length - offset > 4) {
        for (;i < 4; ++i) {
          bits2.lo = (bits2.lo | (access.get(offset) & 127) << i * 7) >>> 0;
          if (access.get(offset++) < 128) {
            return bits2;
          }
        }
        bits2.lo = (bits2.lo | (access.get(offset) & 127) << 28) >>> 0;
        bits2.hi = (bits2.hi | (access.get(offset) & 127) >> 4) >>> 0;
        if (access.get(offset++) < 128) {
          return bits2;
        }
        i = 0;
      } else {
        for (;i < 4; ++i) {
          if (offset >= buf.length) {
            throw RangeError(`index out of range: ${offset} > ${buf.length}`);
          }
          bits2.lo = (bits2.lo | (access.get(offset) & 127) << i * 7) >>> 0;
          if (access.get(offset++) < 128) {
            return bits2;
          }
        }
      }
      if (buf.length - offset > 4) {
        for (;i < 5; ++i) {
          bits2.hi = (bits2.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;
          if (access.get(offset++) < 128) {
            return bits2;
          }
        }
      } else if (offset < buf.byteLength) {
        for (;i < 5; ++i) {
          if (offset >= buf.length) {
            throw RangeError(`index out of range: ${offset} > ${buf.length}`);
          }
          bits2.hi = (bits2.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;
          if (access.get(offset++) < 128) {
            return bits2;
          }
        }
      }
      throw RangeError("invalid varint encoding");
    }
  }
  var N1$8 = Math.pow(2, 7);
  var N2$8 = Math.pow(2, 14);
  var N3$8 = Math.pow(2, 21);
  var N4$8 = Math.pow(2, 28);
  var N5$8 = Math.pow(2, 35);
  var N6$8 = Math.pow(2, 42);
  var N7$8 = Math.pow(2, 49);
  var N8$8 = Math.pow(2, 56);
  var N9$8 = Math.pow(2, 63);
  var unsigned = {
    encodingLength(value) {
      if (value < N1$8) {
        return 1;
      }
      if (value < N2$8) {
        return 2;
      }
      if (value < N3$8) {
        return 3;
      }
      if (value < N4$8) {
        return 4;
      }
      if (value < N5$8) {
        return 5;
      }
      if (value < N6$8) {
        return 6;
      }
      if (value < N7$8) {
        return 7;
      }
      if (value < N8$8) {
        return 8;
      }
      if (value < N9$8) {
        return 9;
      }
      return 10;
    },
    encode(value, buf, offset = 0) {
      if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
        throw new RangeError("Could not encode varint");
      }
      if (buf == null) {
        buf = allocUnsafe$2(unsigned.encodingLength(value));
      }
      LongBits.fromNumber(value).toBytes(buf, offset);
      return buf;
    },
    decode(buf, offset = 0) {
      return LongBits.fromBytes(buf, offset).toNumber(true);
    }
  };
  var defaultEncoder = (length2) => {
    const lengthLength = unsigned.encodingLength(length2);
    const lengthBuf = allocUnsafe$2(lengthLength);
    unsigned.encode(length2, lengthBuf);
    defaultEncoder.bytes = lengthLength;
    return lengthBuf;
  };
  defaultEncoder.bytes = 0;
  encode$B.single = (chunk, options) => {
    options = options ?? {};
    const encodeLength = options.lengthEncoder ?? defaultEncoder;
    return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
  };
  var errCode = createError;
  var errCode$1 = getDefaultExportFromCjs(errCode);
  var MAX_LENGTH_LENGTH = 8;
  var MAX_DATA_LENGTH = 1024 * 1024 * 4;
  var ReadMode;
  (function(ReadMode2) {
    ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
    ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
  })(ReadMode || (ReadMode = {}));
  var defaultDecoder = (buf) => {
    const length2 = unsigned.decode(buf);
    defaultDecoder.bytes = unsigned.encodingLength(length2);
    return length2;
  };
  defaultDecoder.bytes = 0;
  decode$v.fromReader = (reader2, options) => {
    let byteLength = 1;
    const varByteSource = async function* () {
      while (true) {
        try {
          const { done, value } = await reader2.next(byteLength);
          if (done === true) {
            return;
          }
          if (value != null) {
            yield value;
          }
        } catch (err) {
          if (err.code === "ERR_UNDER_READ") {
            return { done: true, value: null };
          }
          throw err;
        } finally {
          byteLength = 1;
        }
      }
    }();
    const onLength = (l) => {
      byteLength = l;
    };
    return decode$v(varByteSource, {
      ...options ?? {},
      onLength
    });
  };

  class FixedFIFO {
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
        throw new Error("Max size for a FixedFIFO should be a power of two");
      }
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    push(data) {
      if (this.buffer[this.top] !== undefined) {
        return false;
      }
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last = this.buffer[this.btm];
      if (last === undefined) {
        return;
      }
      this.buffer[this.btm] = undefined;
      this.btm = this.btm + 1 & this.mask;
      return last;
    }
    isEmpty() {
      return this.buffer[this.btm] === undefined;
    }
  }

  class FIFO {
    constructor(options = {}) {
      this.hwm = options.splitLimit ?? 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
      this.size = 0;
    }
    calculateSize(obj) {
      if (obj?.byteLength != null) {
        return obj.byteLength;
      }
      return 1;
    }
    push(val) {
      if (val?.value != null) {
        this.size += this.calculateSize(val.value);
      }
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      let val = this.tail.shift();
      if (val === undefined && this.tail.next != null) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        val = this.tail.shift();
      }
      if (val?.value != null) {
        this.size -= this.calculateSize(val.value);
      }
      return val;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
  }
  var AbortError$7 = class AbortError2 extends Error {
    constructor(message2, code2) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.code = code2 ?? "ABORT_ERR";
    }
  };
  var rawPipe = (...fns) => {
    let res;
    while (fns.length > 0) {
      res = fns.shift()(res);
    }
    return res;
  };
  var isAsyncIterable$8 = (obj) => {
    return obj?.[Symbol.asyncIterator] != null;
  };
  var isIterable = (obj) => {
    return obj?.[Symbol.iterator] != null;
  };
  var isDuplex = (obj) => {
    if (obj == null) {
      return false;
    }
    return obj.sink != null && obj.source != null;
  };
  var duplexPipelineFn = (duplex2) => {
    return (source2) => {
      const p = duplex2.sink(source2);
      if (p?.then != null) {
        const stream = pushable({
          objectMode: true
        });
        p.then(() => {
          stream.end();
        }, (err) => {
          stream.end(err);
        });
        let sourceWrap;
        const source3 = duplex2.source;
        if (isAsyncIterable$8(source3)) {
          sourceWrap = async function* () {
            yield* source3;
            stream.end();
          };
        } else if (isIterable(source3)) {
          sourceWrap = function* () {
            yield* source3;
            stream.end();
          };
        } else {
          throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
        }
        return merge$1(stream, sourceWrap());
      }
      return duplex2.source;
    };
  };
  var log$E = debug("waku:libp2p-utils");

  class StreamManager {
    constructor(multicodec, getConnections, addEventListener) {
      this.handlePeerUpdateStreamPool = (evt) => {
        const peer = evt.detail.peer;
        if (peer.protocols.includes(this.multicodec)) {
          this.log(`Preemptively opening a stream to ${peer.id.toString()}`);
          this.prepareNewStream(peer);
        }
      };
      this.multicodec = multicodec;
      this.getConnections = getConnections;
      this.addEventListener = addEventListener;
      this.log = debug(`waku:stream-manager:${multicodec}`);
      this.addEventListener("peer:update", this.handlePeerUpdateStreamPool.bind(this));
      this.getStream = this.getStream.bind(this);
      this.streamPool = new Map;
    }
    async getStream(peer) {
      const peerIdStr = peer.id.toString();
      const streamPromise = this.streamPool.get(peerIdStr);
      if (!streamPromise) {
        return this.newStream(peer);
      }
      this.streamPool.delete(peerIdStr);
      this.prepareNewStream(peer);
      const stream = await streamPromise;
      if (stream.status === "closed") {
        return this.newStream(peer);
      }
      return stream;
    }
    async newStream(peer) {
      const connections = this.getConnections(peer.id);
      const connection = selectConnection(connections);
      if (!connection) {
        throw new Error("Failed to get a connection to the peer");
      }
      return connection.newStream(this.multicodec);
    }
    prepareNewStream(peer) {
      const streamPromise = this.newStream(peer);
      this.streamPool.set(peer.id.toString(), streamPromise);
    }
  }

  class BaseProtocol {
    constructor(multicodec, components) {
      this.multicodec = multicodec;
      this.components = components;
      this.addLibp2pEventListener = components.events.addEventListener.bind(components.events);
      this.removeLibp2pEventListener = components.events.removeEventListener.bind(components.events);
      this.streamManager = new StreamManager(multicodec, components.connectionManager.getConnections.bind(components.connectionManager), this.addLibp2pEventListener);
    }
    async getStream(peer) {
      return this.streamManager.getStream(peer);
    }
    get peerStore() {
      return this.components.peerStore;
    }
    async peers() {
      return getPeersForProtocol(this.peerStore, [this.multicodec]);
    }
    async getPeer(peerId) {
      const { peer } = await selectPeerForProtocol(this.peerStore, [this.multicodec], peerId);
      return peer;
    }
    async getPeers({ numPeers, maxBootstrapPeers } = {
      maxBootstrapPeers: 1,
      numPeers: 0
    }) {
      const allPeersForProtocol = await getPeersForProtocol(this.peerStore, [
        this.multicodec
      ]);
      return filterPeers(allPeersForProtocol, numPeers, maxBootstrapPeers);
    }
  }
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native = {
    randomUUID
  };

  class FilterPushRpc {
    constructor(proto) {
      this.proto = proto;
    }
    static decode(bytes2) {
      const res = MessagePush.decode(bytes2);
      return new FilterPushRpc(res);
    }
    encode() {
      return MessagePush.encode(this.proto);
    }
    get wakuMessage() {
      return this.proto.wakuMessage;
    }
    get pubsubTopic() {
      return this.proto.pubsubTopic;
    }
  }

  class FilterSubscribeRpc {
    constructor(proto) {
      this.proto = proto;
    }
    static createSubscribeRequest(pubsubTopic, contentTopics) {
      return new FilterSubscribeRpc({
        requestId: v4$2(),
        filterSubscribeType: FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBE,
        pubsubTopic,
        contentTopics
      });
    }
    static createUnsubscribeRequest(pubsubTopic, contentTopics) {
      return new FilterSubscribeRpc({
        requestId: v4$2(),
        filterSubscribeType: FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE,
        pubsubTopic,
        contentTopics
      });
    }
    static createUnsubscribeAllRequest(pubsubTopic) {
      return new FilterSubscribeRpc({
        requestId: v4$2(),
        filterSubscribeType: FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE_ALL,
        pubsubTopic,
        contentTopics: []
      });
    }
    static createSubscriberPingRequest() {
      return new FilterSubscribeRpc({
        requestId: v4$2(),
        filterSubscribeType: FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBER_PING,
        pubsubTopic: "",
        contentTopics: []
      });
    }
    static decode(bytes2) {
      const res = FilterSubscribeRequest.decode(bytes2);
      return new FilterSubscribeRpc(res);
    }
    encode() {
      return FilterSubscribeRequest.encode(this.proto);
    }
    get filterSubscribeType() {
      return this.proto.filterSubscribeType;
    }
    get requestId() {
      return this.proto.requestId;
    }
    get pubsubTopic() {
      return this.proto.pubsubTopic;
    }
    get contentTopics() {
      return this.proto.contentTopics;
    }
  }

  class FilterSubscribeResponse {
    constructor(proto) {
      this.proto = proto;
    }
    static decode(bytes2) {
      const res = FilterSubscribeResponse$1.decode(bytes2);
      return new FilterSubscribeResponse(res);
    }
    encode() {
      return FilterSubscribeResponse$1.encode(this.proto);
    }
    get statusCode() {
      return this.proto.statusCode;
    }
    get statusDesc() {
      return this.proto.statusDesc;
    }
    get requestId() {
      return this.proto.requestId;
    }
  }
  var log$D = debug("waku:filter:v2");
  var FilterCodecs = {
    SUBSCRIBE: "/vac/waku/filter-subscribe/2.0.0-beta1",
    PUSH: "/vac/waku/filter-push/2.0.0-beta1"
  };

  class Subscription {
    constructor(pubSubTopic, remotePeer, newStream) {
      this.peer = remotePeer;
      this.pubSubTopic = pubSubTopic;
      this.newStream = newStream;
      this.subscriptionCallbacks = new Map;
    }
    async subscribe(decoders2, callback) {
      const decodersArray = Array.isArray(decoders2) ? decoders2 : [decoders2];
      const decodersGroupedByCT = groupByContentTopic(decodersArray);
      const contentTopics = Array.from(decodersGroupedByCT.keys());
      const stream = await this.newStream(this.peer);
      const request2 = FilterSubscribeRpc.createSubscribeRequest(this.pubSubTopic, contentTopics);
      try {
        const res = await pipe([request2.encode()], encode$B, stream, decode$v, async (source2) => await all$1(source2));
        const { statusCode, requestId, statusDesc } = FilterSubscribeResponse.decode(res[0].slice());
        if (statusCode < 200 || statusCode >= 300) {
          throw new Error(`Filter subscribe request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
        }
        log$D("Subscribed to peer ", this.peer.id.toString(), "for content topics", contentTopics);
      } catch (e) {
        throw new Error("Error subscribing to peer: " + this.peer.id.toString() + " for content topics: " + contentTopics + ": " + e);
      }
      decodersGroupedByCT.forEach((decoders3, contentTopic) => {
        const subscriptionCallback = {
          decoders: decoders3,
          callback
        };
        this.subscriptionCallbacks.set(contentTopic, subscriptionCallback);
      });
    }
    async unsubscribe(contentTopics) {
      const stream = await this.newStream(this.peer);
      const unsubscribeRequest = FilterSubscribeRpc.createUnsubscribeRequest(this.pubSubTopic, contentTopics);
      try {
        await pipe([unsubscribeRequest.encode()], encode$B, stream.sink);
      } catch (error) {
        throw new Error("Error subscribing: " + error);
      }
      contentTopics.forEach((contentTopic) => {
        this.subscriptionCallbacks.delete(contentTopic);
      });
    }
    async ping() {
      const stream = await this.newStream(this.peer);
      const request2 = FilterSubscribeRpc.createSubscriberPingRequest();
      try {
        const res = await pipe([request2.encode()], encode$B, stream, decode$v, async (source2) => await all$1(source2));
        const { statusCode, requestId, statusDesc } = FilterSubscribeResponse.decode(res[0].slice());
        if (statusCode < 200 || statusCode >= 300) {
          throw new Error(`Filter ping request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
        }
        log$D("Ping successful");
      } catch (error) {
        log$D("Error pinging: ", error);
        throw new Error("Error pinging: " + error);
      }
    }
    async unsubscribeAll() {
      const stream = await this.newStream(this.peer);
      const request2 = FilterSubscribeRpc.createUnsubscribeAllRequest(this.pubSubTopic);
      try {
        const res = await pipe([request2.encode()], encode$B, stream, decode$v, async (source2) => await all$1(source2));
        const { statusCode, requestId, statusDesc } = FilterSubscribeResponse.decode(res[0].slice());
        if (statusCode < 200 || statusCode >= 300) {
          throw new Error(`Filter unsubscribe all request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
        }
        this.subscriptionCallbacks.clear();
        log$D("Unsubscribed from all content topics");
      } catch (error) {
        throw new Error("Error unsubscribing from all content topics: " + error);
      }
    }
    async processMessage(message2) {
      const contentTopic = message2.contentTopic;
      const subscriptionCallback = this.subscriptionCallbacks.get(contentTopic);
      if (!subscriptionCallback) {
        log$D("No subscription callback available for ", contentTopic);
        return;
      }
      await pushMessage(subscriptionCallback, this.pubSubTopic, message2);
    }
  }

  class Filter extends BaseProtocol {
    getActiveSubscription(pubSubTopic, peerIdStr) {
      return this.activeSubscriptions.get(`${pubSubTopic}_${peerIdStr}`);
    }
    setActiveSubscription(pubSubTopic, peerIdStr, subscription) {
      this.activeSubscriptions.set(`${pubSubTopic}_${peerIdStr}`, subscription);
      return subscription;
    }
    constructor(libp2p, options) {
      super(FilterCodecs.SUBSCRIBE, libp2p.components);
      this.activeSubscriptions = new Map;
      this.NUM_PEERS_PROTOCOL = 1;
      libp2p.handle(FilterCodecs.PUSH, this.onRequest.bind(this)).catch((e) => {
        log$D("Failed to register ", FilterCodecs.PUSH, e);
      });
      this.activeSubscriptions = new Map;
      this.options = options ?? {};
    }
    async createSubscription(pubSubTopic) {
      const _pubSubTopic = pubSubTopic ?? this.options.pubSubTopic ?? DefaultPubSubTopic;
      const peer = (await this.getPeers({
        maxBootstrapPeers: 1,
        numPeers: this.NUM_PEERS_PROTOCOL
      }))[0];
      const subscription = this.getActiveSubscription(_pubSubTopic, peer.id.toString()) ?? this.setActiveSubscription(_pubSubTopic, peer.id.toString(), new Subscription(_pubSubTopic, peer, this.getStream.bind(this, peer)));
      return subscription;
    }
    toSubscriptionIterator(decoders2) {
      return toAsyncIterator(this, decoders2);
    }
    async subscribe(decoders2, callback) {
      const subscription = await this.createSubscription();
      await subscription.subscribe(decoders2, callback);
      const contentTopics = Array.from(groupByContentTopic(Array.isArray(decoders2) ? decoders2 : [decoders2]).keys());
      return async () => {
        await subscription.unsubscribe(contentTopics);
      };
    }
    onRequest(streamData) {
      log$D("Receiving message push");
      try {
        pipe(streamData.stream, decode$v, async (source2) => {
          for await (const bytes2 of source2) {
            const response = FilterPushRpc.decode(bytes2.slice());
            const { pubsubTopic, wakuMessage } = response;
            if (!wakuMessage) {
              log$D("Received empty message");
              return;
            }
            if (!pubsubTopic) {
              log$D("PubSub topic missing from push message");
              return;
            }
            const peerIdStr = streamData.connection.remotePeer.toString();
            const subscription = this.getActiveSubscription(pubsubTopic, peerIdStr);
            if (!subscription) {
              log$D(`No subscription locally registered for topic ${pubsubTopic}`);
              return;
            }
            await subscription.processMessage(wakuMessage);
          }
        }).then(() => {
          log$D("Receiving pipe closed.");
        }, (e) => {
          log$D("Error with receiving pipe", e);
        });
      } catch (e) {
        log$D("Error decoding message", e);
      }
    }
  }
  var index$4 = Object.freeze({
    __proto__: null,
    FilterCodecs,
    wakuFilter
  });

  class PushRpc {
    constructor(proto) {
      this.proto = proto;
    }
    static createRequest(message2, pubSubTopic) {
      return new PushRpc({
        requestId: v4$2(),
        request: {
          message: message2,
          pubsubTopic: pubSubTopic
        },
        response: undefined
      });
    }
    static decode(bytes2) {
      const res = PushRpc$1.decode(bytes2);
      return new PushRpc(res);
    }
    encode() {
      return PushRpc$1.encode(this.proto);
    }
    get query() {
      return this.proto.request;
    }
    get response() {
      return this.proto.response;
    }
  }
  var log$C = debug("waku:light-push");
  var LightPushCodec = "/vac/waku/lightpush/2.0.0-beta1";

  class LightPush extends BaseProtocol {
    constructor(libp2p, options) {
      super(LightPushCodec, libp2p.components);
      this.NUM_PEERS_PROTOCOL = 1;
      this.options = options || {};
    }
    async preparePushMessage(encoder2, message2, pubSubTopic) {
      try {
        if (!isSizeValid(message2.payload)) {
          log$C("Failed to send waku light push: message is bigger than 1MB");
          return { query: null, error: SendError.SIZE_TOO_BIG };
        }
        const protoMessage = await encoder2.toProtoObj(message2);
        if (!protoMessage) {
          log$C("Failed to encode to protoMessage, aborting push");
          return {
            query: null,
            error: SendError.ENCODE_FAILED
          };
        }
        const query2 = PushRpc.createRequest(protoMessage, pubSubTopic);
        return { query: query2, error: null };
      } catch (error) {
        log$C("Failed to prepare push message", error);
        return {
          query: null,
          error: SendError.GENERIC_FAIL
        };
      }
    }
    async send(encoder2, message2) {
      const { pubSubTopic = DefaultPubSubTopic } = this.options;
      const recipients = [];
      const { query: query2, error: preparationError } = await this.preparePushMessage(encoder2, message2, pubSubTopic);
      if (preparationError || !query2) {
        return {
          recipients,
          errors: [preparationError]
        };
      }
      const peers = await this.getPeers({
        maxBootstrapPeers: 1,
        numPeers: this.NUM_PEERS_PROTOCOL
      });
      const promises = peers.map(async (peer) => {
        let error;
        const stream = await this.getStream(peer);
        try {
          const res = await pipe([query2.encode()], encode$B, stream, decode$v, async (source2) => await all$1(source2));
          try {
            const bytes2 = new Uint8ArrayList;
            res.forEach((chunk) => {
              bytes2.append(chunk);
            });
            const response = PushRpc.decode(bytes2).response;
            if (response?.isSuccess) {
              recipients.some((recipient) => recipient.equals(peer.id)) || recipients.push(peer.id);
            } else {
              log$C("No response in PushRPC");
              error = SendError.NO_RPC_RESPONSE;
            }
          } catch (err) {
            log$C("Failed to decode push reply", err);
            error = SendError.DECODE_FAILED;
          }
        } catch (err) {
          log$C("Failed to send waku light push request", err);
          error = SendError.GENERIC_FAIL;
        }
        return { recipients, error };
      });
      const results = await Promise.allSettled(promises);
      const errors = results.filter((result) => result.status === "fulfilled").map((result) => result.value.error).filter((error) => error !== undefined);
      return {
        recipients,
        errors
      };
    }
  }
  var index$3 = Object.freeze({
    __proto__: null,
    LightPushCodec,
    get PushResponse() {
      return PushResponse;
    },
    wakuLightPush
  });
  var crypto$7 = typeof globalThis === "object" && ("crypto" in globalThis) ? globalThis.crypto : undefined;
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var u8a$3 = (a) => a instanceof Uint8Array;
  var createView$2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr$1 = (word2, shift) => word2 << 32 - shift | word2 >>> shift;
  var isLE$2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE$2)
    throw new Error("Non little-endian hardware is not supported");
  var Hash$1 = class Hash2 {
    clone() {
      return this._cloneInto();
    }
  };
  var SHA2$1 = class SHA22 extends Hash$1 {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView$2(this.buffer);
    }
    update(data) {
      exists$2(this);
      const { view, buffer, blockLen } = this;
      data = toBytes$3(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          const dataView = createView$2(data);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists$2(this);
      output$2(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64$2(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView$2(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
      to.length = length2;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length2 % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };
  var Chi$1 = (a, b, c) => a & b ^ ~a & c;
  var Maj$1 = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K$1 = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV$1 = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W$1 = new Uint32Array(64);
  var SHA256$1 = class SHA2562 extends SHA2$1 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV$1[0] | 0;
      this.B = IV$1[1] | 0;
      this.C = IV$1[2] | 0;
      this.D = IV$1[3] | 0;
      this.E = IV$1[4] | 0;
      this.F = IV$1[5] | 0;
      this.G = IV$1[6] | 0;
      this.H = IV$1[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W$1[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W$1[i - 15];
        const W2 = SHA256_W$1[i - 2];
        const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
        const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ W2 >>> 10;
        SHA256_W$1[i] = s1 + SHA256_W$1[i - 7] + s0 + SHA256_W$1[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = rotr$1(E, 6) ^ rotr$1(E, 11) ^ rotr$1(E, 25);
        const T1 = H + sigma1 + Chi$1(E, F, G) + SHA256_K$1[i] + SHA256_W$1[i] | 0;
        const sigma0 = rotr$1(A, 2) ^ rotr$1(A, 13) ^ rotr$1(A, 22);
        const T2 = sigma0 + Maj$1(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W$1.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256$a = wrapConstructor$1(() => new SHA256$1);
  var EmptyMessage = {
    payload: new Uint8Array,
    contentTopic: "",
    version: undefined,
    timestamp: undefined,
    meta: undefined,
    rateLimitProof: undefined,
    ephemeral: undefined
  };
  var OneMillion = BigInt(1e6);
  var PageDirection;
  (function(PageDirection2) {
    PageDirection2["BACKWARD"] = "backward";
    PageDirection2["FORWARD"] = "forward";
  })(PageDirection || (PageDirection = {}));

  class HistoryRpc {
    constructor(proto) {
      this.proto = proto;
    }
    get query() {
      return this.proto.query;
    }
    get response() {
      return this.proto.response;
    }
    static createQuery(params) {
      const contentFilters = params.contentTopics.map((contentTopic) => {
        return { contentTopic };
      });
      const direction = directionToProto(params.pageDirection);
      const pagingInfo = {
        pageSize: BigInt(params.pageSize),
        cursor: params.cursor,
        direction
      };
      let startTime, endTime;
      if (params.startTime) {
        startTime = BigInt(params.startTime.valueOf()) * OneMillion;
      }
      if (params.endTime) {
        endTime = BigInt(params.endTime.valueOf()) * OneMillion;
      }
      return new HistoryRpc({
        requestId: v4$2(),
        query: {
          pubsubTopic: params.pubSubTopic,
          contentFilters,
          pagingInfo,
          startTime,
          endTime
        },
        response: undefined
      });
    }
    decode(bytes2) {
      const res = HistoryRpc$1.decode(bytes2);
      return new HistoryRpc(res);
    }
    encode() {
      return HistoryRpc$1.encode(this.proto);
    }
  }
  var HistoryError = HistoryResponse.HistoryError;
  var log$B = debug("waku:store");
  var StoreCodec = "/vac/waku/store/2.0.0-beta4";
  var DefaultPageSize = 10;

  class Store extends BaseProtocol {
    constructor(libp2p, options) {
      super(StoreCodec, libp2p.components);
      this.NUM_PEERS_PROTOCOL = 1;
      this.queryOrderedCallback = this.queryWithOrderedCallback;
      this.options = options ?? {};
    }
    async processMessages(messages2, callback, options) {
      let abort = false;
      const messagesOrUndef = await Promise.all(messages2);
      let processedMessages = messagesOrUndef.filter(isDefined);
      if (this.shouldReverseOrder(options)) {
        processedMessages = processedMessages.reverse();
      }
      await Promise.all(processedMessages.map(async (msg) => {
        if (msg && !abort) {
          abort = Boolean(await callback(msg));
        }
      }));
      return abort;
    }
    shouldReverseOrder(options) {
      return typeof options?.pageDirection === "undefined" || options?.pageDirection === PageDirection.BACKWARD;
    }
    async queryWithOrderedCallback(decoders2, callback, options) {
      for await (const promises of this.queryGenerator(decoders2, options)) {
        if (await this.processMessages(promises, callback, options))
          break;
      }
    }
    async queryWithPromiseCallback(decoders2, callback, options) {
      let abort = false;
      for await (const page of this.queryGenerator(decoders2, options)) {
        const _promises = page.map(async (msgPromise) => {
          if (abort)
            return;
          abort = Boolean(await callback(msgPromise));
        });
        await Promise.all(_promises);
        if (abort)
          break;
      }
    }
    async* queryGenerator(decoders2, options) {
      const { pubSubTopic = DefaultPubSubTopic } = this.options;
      let startTime, endTime;
      if (options?.timeFilter) {
        startTime = options.timeFilter.startTime;
        endTime = options.timeFilter.endTime;
      }
      const decodersAsMap = new Map;
      decoders2.forEach((dec) => {
        if (decodersAsMap.has(dec.contentTopic)) {
          throw new Error("API does not support different decoder per content topic");
        }
        decodersAsMap.set(dec.contentTopic, dec);
      });
      const contentTopics = decoders2.map((dec) => dec.contentTopic);
      const queryOpts = Object.assign({
        pubSubTopic,
        pageDirection: PageDirection.BACKWARD,
        pageSize: DefaultPageSize
      }, options, { contentTopics, startTime, endTime });
      log$B("Querying history with the following options", options);
      const peer = (await this.getPeers({
        numPeers: this.NUM_PEERS_PROTOCOL,
        maxBootstrapPeers: 1
      }))[0];
      for await (const messages2 of paginate(this.getStream.bind(this, peer), queryOpts, decodersAsMap, options?.cursor)) {
        yield messages2;
      }
    }
  }
  var index$2 = Object.freeze({
    __proto__: null,
    DefaultPageSize,
    get PageDirection() {
      return PageDirection;
    },
    StoreCodec,
    createCursor,
    wakuStore
  });
  var TimeoutError$3 = class TimeoutError2 extends Error {
    constructor(message2) {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var AbortError$6 = class AbortError2 extends Error {
    constructor(message2) {
      super();
      this.name = "AbortError";
      this.message = message2;
    }
  };
  var getDOMException$2 = (errorMessage) => globalThis.DOMException === undefined ? new AbortError$6(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason$2 = (signal) => {
    const reason = signal.reason === undefined ? getDOMException$2("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException$2(reason);
  };
  var normalizeEmitter = (emitter) => {
    const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
    const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
    if (!addListener || !removeListener) {
      throw new TypeError("Emitter is not compatible");
    }
    return {
      addListener: addListener.bind(emitter),
      removeListener: removeListener.bind(emitter)
    };
  };
  var log$A = debug("waku:wait-for-remote-peer");
  exports.waitForRemotePeer = waitForRemotePeer;
  var awaitTimeout = (ms2, rejectReason) => new Promise((_resolve, reject) => setTimeout(() => reject(rejectReason), ms2));
  var index$1 = Object.freeze({
    __proto__: null,
    ConnectionManager,
    DefaultPubSubTopic,
    DefaultUserAgent,
    FilterCodecs,
    KeepAliveManager,
    get PageDirection() {
      return PageDirection;
    },
    StreamManager,
    WakuNode,
    createCursor,
    createDecoder,
    createEncoder,
    message: index$6,
    waitForRemotePeer,
    waku,
    wakuFilter,
    wakuLightPush,
    wakuStore,
    waku_filter: index$4,
    waku_light_push: index$3,
    waku_store: index$2
  });
  exports.waku = index$1;
  var CodeError$2 = class CodeError2 extends Error {
    constructor(message2, code2) {
      super(message2);
      this.code = code2;
    }
  };
  var AbortError$5 = class AbortError2 extends CodeError$2 {
    constructor(message2) {
      super(message2, "ABORT_ERR");
      this.type = "aborted";
    }
  };
  var CodeError$1 = class CodeError2 extends Error {
    constructor(message2, code2) {
      super(message2);
      this.code = code2;
    }
  };
  var defaultLengthDecoder = (buf) => {
    return unsigned.decode(buf);
  };
  defaultLengthDecoder.bytes = 0;
  var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
  var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
  var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);
  /*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
  var u8a$2 = (a) => a instanceof Uint8Array;
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE$1)
    throw new Error("Non little-endian hardware is not supported");
  var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
  var assert$1 = { number: number$1, bool: bool$1, bytes: bytes$1, hash: hash$2, exists: exists$1, output: output$1 };
  var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;

  class Poly1305 {
    constructor(key) {
      this.blockLen = 16;
      this.outputLen = 16;
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.pos = 0;
      this.finished = false;
      key = toBytes$2(key);
      ensureBytes$3(key, 32);
      const t0 = u8to16(key, 0);
      const t1 = u8to16(key, 2);
      const t2 = u8to16(key, 4);
      const t3 = u8to16(key, 6);
      const t4 = u8to16(key, 8);
      const t5 = u8to16(key, 10);
      const t6 = u8to16(key, 12);
      const t7 = u8to16(key, 14);
      this.r[0] = t0 & 8191;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      for (let i = 0;i < 8; i++)
        this.pad[i] = u8to16(key, 16 + 2 * i);
    }
    process(data, offset, isLast = false) {
      const hibit = isLast ? 0 : 1 << 11;
      const { h, r } = this;
      const r0 = r[0];
      const r1 = r[1];
      const r2 = r[2];
      const r3 = r[3];
      const r4 = r[4];
      const r5 = r[5];
      const r6 = r[6];
      const r7 = r[7];
      const r8 = r[8];
      const r9 = r[9];
      const t0 = u8to16(data, offset + 0);
      const t1 = u8to16(data, offset + 2);
      const t2 = u8to16(data, offset + 4);
      const t3 = u8to16(data, offset + 6);
      const t4 = u8to16(data, offset + 8);
      const t5 = u8to16(data, offset + 10);
      const t6 = u8to16(data, offset + 12);
      const t7 = u8to16(data, offset + 14);
      let h0 = h[0] + (t0 & 8191);
      let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
      let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
      let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
      let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
      let h5 = h[5] + (t4 >>> 1 & 8191);
      let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
      let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
      let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
      let h9 = h[9] + (t7 >>> 5 | hibit);
      let c = 0;
      let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
      c = d0 >>> 13;
      d0 &= 8191;
      d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
      c += d0 >>> 13;
      d0 &= 8191;
      let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
      c = d1 >>> 13;
      d1 &= 8191;
      d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
      c += d1 >>> 13;
      d1 &= 8191;
      let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
      c = d2 >>> 13;
      d2 &= 8191;
      d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
      c += d2 >>> 13;
      d2 &= 8191;
      let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
      c = d3 >>> 13;
      d3 &= 8191;
      d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
      c += d3 >>> 13;
      d3 &= 8191;
      let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
      c = d4 >>> 13;
      d4 &= 8191;
      d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
      c += d4 >>> 13;
      d4 &= 8191;
      let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
      c = d5 >>> 13;
      d5 &= 8191;
      d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
      c += d5 >>> 13;
      d5 &= 8191;
      let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
      c = d6 >>> 13;
      d6 &= 8191;
      d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
      c += d6 >>> 13;
      d6 &= 8191;
      let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
      c = d7 >>> 13;
      d7 &= 8191;
      d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
      c += d7 >>> 13;
      d7 &= 8191;
      let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
      c = d8 >>> 13;
      d8 &= 8191;
      d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
      c += d8 >>> 13;
      d8 &= 8191;
      let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
      c = d9 >>> 13;
      d9 &= 8191;
      d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
      c += d9 >>> 13;
      d9 &= 8191;
      c = (c << 2) + c | 0;
      c = c + d0 | 0;
      d0 = c & 8191;
      c = c >>> 13;
      d1 += c;
      h[0] = d0;
      h[1] = d1;
      h[2] = d2;
      h[3] = d3;
      h[4] = d4;
      h[5] = d5;
      h[6] = d6;
      h[7] = d7;
      h[8] = d8;
      h[9] = d9;
    }
    finalize() {
      const { h, pad } = this;
      const g = new Uint16Array(10);
      let c = h[1] >>> 13;
      h[1] &= 8191;
      for (let i = 2;i < 10; i++) {
        h[i] += c;
        c = h[i] >>> 13;
        h[i] &= 8191;
      }
      h[0] += c * 5;
      c = h[0] >>> 13;
      h[0] &= 8191;
      h[1] += c;
      c = h[1] >>> 13;
      h[1] &= 8191;
      h[2] += c;
      g[0] = h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (let i = 1;i < 10; i++) {
        g[i] = h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      let mask = (c ^ 1) - 1;
      for (let i = 0;i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (let i = 0;i < 10; i++)
        h[i] = h[i] & mask | g[i];
      h[0] = (h[0] | h[1] << 13) & 65535;
      h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
      h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
      h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
      h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
      h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
      h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
      h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
      let f = h[0] + pad[0];
      h[0] = f & 65535;
      for (let i = 1;i < 8; i++) {
        f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
        h[i] = f & 65535;
      }
    }
    update(data) {
      assert$1.exists(this);
      const { buffer, blockLen } = this;
      data = toBytes$2(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(data, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(buffer, 0, false);
          this.pos = 0;
        }
      }
      return this;
    }
    destroy() {
      this.h.fill(0);
      this.r.fill(0);
      this.buffer.fill(0);
      this.pad.fill(0);
    }
    digestInto(out) {
      assert$1.exists(this);
      assert$1.output(out, this);
      this.finished = true;
      const { buffer, h } = this;
      let { pos } = this;
      if (pos) {
        buffer[pos++] = 1;
        for (;pos < 16; pos++)
          buffer[pos] = 0;
        this.process(buffer, 0, true);
      }
      this.finalize();
      let opos = 0;
      for (let i = 0;i < 8; i++) {
        out[opos++] = h[i] >>> 0;
        out[opos++] = h[i] >>> 8;
      }
      return out;
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  }
  var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));
  var sigma16 = utf8ToBytes$2("expand 16-byte k");
  var sigma32 = utf8ToBytes$2("expand 32-byte k");
  var sigma16_32 = u32(sigma16);
  var sigma32_32 = u32(sigma32);
  var isAligned32 = (b) => !(b.byteOffset % 4);
  var salsaBasic = (opts) => {
    const { core, rounds, counterRight, counterLen, allow128bitKeys, extendNonceFn, blockLen } = checkOpts({ rounds: 20, counterRight: false, counterLen: 8, allow128bitKeys: true, blockLen: 64 }, opts);
    assert$1.number(counterLen);
    assert$1.number(rounds);
    assert$1.number(blockLen);
    assert$1.bool(counterRight);
    assert$1.bool(allow128bitKeys);
    const blockLen32 = blockLen / 4;
    if (blockLen % 4 !== 0)
      throw new Error("Salsa/ChaCha: blockLen should be aligned to 4 bytes");
    return (key, nonce, data, output2, counter2 = 0) => {
      assert$1.bytes(key);
      assert$1.bytes(nonce);
      assert$1.bytes(data);
      if (!output2)
        output2 = new Uint8Array(data.length);
      assert$1.bytes(output2);
      assert$1.number(counter2);
      if (counter2 < 0 || counter2 >= 2 ** 32 - 1)
        throw new Error("Salsa/ChaCha: counter overflow");
      if (output2.length < data.length) {
        throw new Error(`Salsa/ChaCha: output (${output2.length}) is shorter than data (${data.length})`);
      }
      const toClean = [];
      let k, sigma;
      if (key.length === 32) {
        k = key;
        sigma = sigma32_32;
      } else if (key.length === 16 && allow128bitKeys) {
        k = new Uint8Array(32);
        k.set(key);
        k.set(key, 16);
        sigma = sigma16_32;
        toClean.push(k);
      } else
        throw new Error(`Salsa/ChaCha: wrong key length=${key.length}, expected`);
      if (extendNonceFn) {
        if (nonce.length <= 16)
          throw new Error(`Salsa/ChaCha: extended nonce should be bigger than 16 bytes`);
        k = extendNonceFn(sigma, k, nonce.subarray(0, 16), new Uint8Array(32));
        toClean.push(k);
        nonce = nonce.subarray(16);
      }
      const nonceLen = 16 - counterLen;
      if (nonce.length !== nonceLen)
        throw new Error(`Salsa/ChaCha: nonce should be ${nonceLen} or 16 bytes`);
      if (nonceLen !== 12) {
        const nc = new Uint8Array(12);
        nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
        toClean.push(nonce = nc);
      }
      const block = new Uint8Array(blockLen);
      const b32 = u32(block);
      const k32 = u32(k);
      const n32 = u32(nonce);
      const d32 = isAligned32(data) && u32(data);
      const o32 = isAligned32(output2) && u32(output2);
      toClean.push(b32);
      const len = data.length;
      for (let pos = 0, ctr = counter2;pos < len; ctr++) {
        core(sigma, k32, n32, b32, ctr, rounds);
        if (ctr >= 2 ** 32 - 1)
          throw new Error("Salsa/ChaCha: counter overflow");
        const take2 = Math.min(blockLen, len - pos);
        if (take2 === blockLen && o32 && d32) {
          const pos32 = pos / 4;
          if (pos % 4 !== 0)
            throw new Error("Salsa/ChaCha: wrong block position");
          for (let j = 0;j < blockLen32; j++)
            o32[pos32 + j] = d32[pos32 + j] ^ b32[j];
          pos += blockLen;
          continue;
        }
        for (let j = 0;j < take2; j++)
          output2[pos + j] = data[pos + j] ^ block[j];
        pos += take2;
      }
      for (let i = 0;i < toClean.length; i++)
        toClean[i].fill(0);
      return output2;
    };
  };
  var rotl = (a, b) => a << b | a >>> 32 - b;
  salsaBasic({ core: chachaCore, counterRight: false, counterLen: 8 });
  var chacha20 = salsaBasic({
    core: chachaCore,
    counterRight: false,
    counterLen: 4,
    allow128bitKeys: false
  });
  salsaBasic({
    core: chachaCore,
    counterRight: false,
    counterLen: 8,
    extendNonceFn: hchacha,
    allow128bitKeys: false
  });
  salsaBasic({
    core: chachaCore,
    counterRight: false,
    counterLen: 4,
    rounds: 8
  });
  salsaBasic({
    core: chachaCore,
    counterRight: false,
    counterLen: 4,
    rounds: 12
  });
  var ZERO = new Uint8Array(16);
  var updatePadded = (h, msg) => {
    h.update(msg);
    const left2 = msg.length % 16;
    if (left2)
      h.update(ZERO.subarray(left2));
  };
  var computeTag = (fn, key, nonce, data, AAD) => {
    const authKey = fn(key, nonce, new Uint8Array(32));
    const h = poly1305.create(authKey);
    if (AAD)
      updatePadded(h, AAD);
    updatePadded(h, data);
    const num = new Uint8Array(16);
    const view = createView$1(num);
    setBigUint64$1(view, 0, BigInt(AAD ? AAD.length : 0), true);
    setBigUint64$1(view, 8, BigInt(data.length), true);
    h.update(num);
    const res = h.digest();
    authKey.fill(0);
    return res;
  };
  var _poly1305_aead = (fn) => (key, nonce, AAD) => {
    const tagLength = 16;
    ensureBytes$3(key, 32);
    ensureBytes$3(nonce);
    return {
      tagLength,
      encrypt: (plaintext) => {
        const res = new Uint8Array(plaintext.length + tagLength);
        fn(key, nonce, plaintext, res, 1);
        const tag = computeTag(fn, key, nonce, res.subarray(0, -tagLength), AAD);
        res.set(tag, plaintext.length);
        return res;
      },
      decrypt: (ciphertext) => {
        if (ciphertext.length < tagLength)
          throw new Error(`Encrypted data should be at least ${tagLength}`);
        const realTag = ciphertext.subarray(-tagLength);
        const data = ciphertext.subarray(0, -tagLength);
        const tag = computeTag(fn, key, nonce, data, AAD);
        if (!equalBytes$2(realTag, tag))
          throw new Error("Wrong tag");
        return fn(key, nonce, data, undefined, 1);
      }
    };
  };
  var chacha20_poly1305 = _poly1305_aead(chacha20);
  var assert = {
    number,
    bool,
    bytes,
    hash: hash$1,
    exists,
    output
  };
  var crypto$6 = typeof globalThis === "object" && ("crypto" in globalThis) ? globalThis.crypto : undefined;
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var u8a$1 = (a) => a instanceof Uint8Array;
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word2, shift) => word2 << 32 - shift | word2 >>> shift;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));

  class Hash {
    clone() {
      return this._cloneInto();
    }
  }

  class SHA2 extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      assert.exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes$1(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          const dataView = createView(data);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      assert.exists(this);
      assert.output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
      to.length = length2;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length2 % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  }
  var U32_MASK64 = BigInt(2 ** 32 - 1);
  var _32n = BigInt(32);
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  var shrSH = (h, l, s2) => h >>> s2;
  var shrSL = (h, l, s2) => h << 32 - s2 | l >>> s2;
  var rotrSH = (h, l, s2) => h >>> s2 | l << 32 - s2;
  var rotrSL = (h, l, s2) => h << 32 - s2 | l >>> s2;
  var rotrBH = (h, l, s2) => h << 64 - s2 | l >>> s2 - 32;
  var rotrBL = (h, l, s2) => h >>> s2 - 32 | l << 64 - s2;
  var rotr32H = (h, l) => l;
  var rotr32L = (h, l) => h;
  var rotlSH = (h, l, s2) => h << s2 | l >>> 32 - s2;
  var rotlSL = (h, l, s2) => l << s2 | h >>> 32 - s2;
  var rotlBH = (h, l, s2) => l << s2 - 32 | h >>> 64 - s2;
  var rotlBL = (h, l, s2) => h << s2 - 32 | l >>> 64 - s2;
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var [SHA512_Kh, SHA512_Kl] = u64.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n)));
  var SHA512_W_H = new Uint32Array(80);
  var SHA512_W_L = new Uint32Array(80);

  class SHA512 extends SHA2 {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16;i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
        const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
        const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
        const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0;i < 80; i++) {
        const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
        const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
        const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64.add3L(T1l, sigma0l, MAJl);
        Ah = u64.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }

  class SHA512_224 extends SHA512 {
    constructor() {
      super();
      this.Ah = 2352822216 | 0;
      this.Al = 424955298 | 0;
      this.Bh = 1944164710 | 0;
      this.Bl = 2312950998 | 0;
      this.Ch = 502970286 | 0;
      this.Cl = 855612546 | 0;
      this.Dh = 1738396948 | 0;
      this.Dl = 1479516111 | 0;
      this.Eh = 258812777 | 0;
      this.El = 2077511080 | 0;
      this.Fh = 2011393907 | 0;
      this.Fl = 79989058 | 0;
      this.Gh = 1067287976 | 0;
      this.Gl = 1780299464 | 0;
      this.Hh = 286451373 | 0;
      this.Hl = 2446758561 | 0;
      this.outputLen = 28;
    }
  }

  class SHA512_256 extends SHA512 {
    constructor() {
      super();
      this.Ah = 573645204 | 0;
      this.Al = 4230739756 | 0;
      this.Bh = 2673172387 | 0;
      this.Bl = 3360449730 | 0;
      this.Ch = 596883563 | 0;
      this.Cl = 1867755857 | 0;
      this.Dh = 2520282905 | 0;
      this.Dl = 1497426621 | 0;
      this.Eh = 2519219938 | 0;
      this.El = 2827943907 | 0;
      this.Fh = 3193839141 | 0;
      this.Fl = 1401305490 | 0;
      this.Gh = 721525244 | 0;
      this.Gl = 746961066 | 0;
      this.Hh = 246885852 | 0;
      this.Hl = 2177182882 | 0;
      this.outputLen = 32;
    }
  }

  class SHA384 extends SHA512 {
    constructor() {
      super();
      this.Ah = 3418070365 | 0;
      this.Al = 3238371032 | 0;
      this.Bh = 1654270250 | 0;
      this.Bl = 914150663 | 0;
      this.Ch = 2438529370 | 0;
      this.Cl = 812702999 | 0;
      this.Dh = 355462360 | 0;
      this.Dl = 4144912697 | 0;
      this.Eh = 1731405415 | 0;
      this.El = 4290775857 | 0;
      this.Fh = 2394180231 | 0;
      this.Fl = 1750603025 | 0;
      this.Gh = 3675008525 | 0;
      this.Gl = 1694076839 | 0;
      this.Hh = 1203062813 | 0;
      this.Hl = 3204075428 | 0;
      this.outputLen = 48;
    }
  }
  var sha512$1 = wrapConstructor(() => new SHA512);
  wrapConstructor(() => new SHA512_224);
  wrapConstructor(() => new SHA512_256);
  wrapConstructor(() => new SHA384);
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var _0n$7 = BigInt(0);
  var _1n$9 = BigInt(1);
  var _2n$6 = BigInt(2);
  var u8a = (a) => a instanceof Uint8Array;
  var hexes$2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  var bitSet = (n, pos, value) => {
    return n | (value ? _1n$9 : _0n$7) << BigInt(pos);
  };
  var bitMask = (n) => (_2n$6 << BigInt(n - 1)) - _1n$9;
  var u8n = (data) => new Uint8Array(data);
  var u8fr = (arr) => Uint8Array.from(arr);
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  var ut = Object.freeze({
    __proto__: null,
    bitGet,
    bitLen,
    bitMask,
    bitSet,
    bytesToHex: bytesToHex$2,
    bytesToNumberBE,
    bytesToNumberLE: bytesToNumberLE$1,
    concatBytes: concatBytes$2,
    createHmacDrbg,
    ensureBytes: ensureBytes$2,
    equalBytes: equalBytes$1,
    hexToBytes: hexToBytes$2,
    hexToNumber: hexToNumber$1,
    numberToBytesBE,
    numberToBytesLE,
    numberToHexUnpadded: numberToHexUnpadded$1,
    numberToVarBytesBE,
    utf8ToBytes,
    validateObject
  });
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var _0n$6 = BigInt(0);
  var _1n$8 = BigInt(1);
  var _2n$5 = BigInt(2);
  var _3n$2 = BigInt(3);
  var _4n = BigInt(4);
  var _5n$1 = BigInt(5);
  var _8n$3 = BigInt(8);
  BigInt(9);
  BigInt(16);
  var isNegativeLE = (num, modulo) => (mod$2(num, modulo) & _1n$8) === _1n$8;
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var _0n$5 = BigInt(0);
  var _1n$7 = BigInt(1);
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var _0n$4 = BigInt(0);
  var _1n$6 = BigInt(1);
  var _2n$4 = BigInt(2);
  var _8n$2 = BigInt(8);
  var VERIFY_DEFAULT = { zip215: true };
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var _0n$3 = BigInt(0);
  var _1n$5 = BigInt(1);
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
  var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  BigInt(0);
  var _1n$4 = BigInt(1);
  var _2n$3 = BigInt(2);
  var _5n = BigInt(5);
  var _10n = BigInt(10);
  var _20n = BigInt(20);
  var _40n = BigInt(40);
  var _80n = BigInt(80);
  var Fp$1 = Field(ED25519_P, undefined, true);
  var ed25519Defaults = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: Fp$1,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: BigInt(8),
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha512$1,
    randomBytes: randomBytes$7,
    adjustScalarBytes,
    uvRatio: uvRatio$1
  };
  var ed25519 = twistedEdwards(ed25519Defaults);
  twistedEdwards({ ...ed25519Defaults, domain: ed25519_domain });
  twistedEdwards({
    ...ed25519Defaults,
    domain: ed25519_domain,
    prehash: sha512$1
  });
  var x25519 = (() => montgomery({
    P: ED25519_P,
    a: BigInt(486662),
    montgomeryBits: 255,
    nByteLength: 32,
    Gu: BigInt(9),
    powPminus2: (x) => {
      const P = ED25519_P;
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return mod$2(pow2$2(pow_p_5_8, BigInt(3), P) * b2, P);
    },
    adjustScalarBytes,
    randomBytes: randomBytes$7
  }))();
  var ELL2_C1 = (Fp$1.ORDER + BigInt(3)) / BigInt(8);
  Fp$1.pow(_2n$3, ELL2_C1);
  Fp$1.sqrt(Fp$1.neg(Fp$1.ONE));
  (Fp$1.ORDER - BigInt(5)) / BigInt(8);
  BigInt(486662);
  FpSqrtEven(Fp$1, Fp$1.neg(BigInt(486664)));
  BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var HMAC$1 = class HMAC2 extends Hash$1 {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash$3(hash2);
      const key = toBytes$3(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0;i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i = 0;i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      exists$2(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists$2(this);
      bytes$2(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac$2 = (hash2, key, message2) => new HMAC$1(hash2, key).update(message2).digest();
  hmac$2.create = (hash2, key) => new HMAC$1(hash2, key);
  var HKDF_COUNTER = new Uint8Array([0]);
  var EMPTY_BUFFER = new Uint8Array;
  var pureJsCrypto = {
    hashSHA256(data) {
      return sha256$a(data);
    },
    getHKDF(ck, ikm) {
      const prk = extract(sha256$a, ikm, ck);
      const okmU8Array = expand(sha256$a, prk, undefined, 96);
      const okm = okmU8Array;
      const k1 = okm.subarray(0, 32);
      const k2 = okm.subarray(32, 64);
      const k3 = okm.subarray(64, 96);
      return [k1, k2, k3];
    },
    generateX25519KeyPair() {
      const secretKey = x25519.utils.randomPrivateKey();
      const publicKey = x25519.getPublicKey(secretKey);
      return {
        publicKey,
        privateKey: secretKey
      };
    },
    generateX25519KeyPairFromSeed(seed) {
      const publicKey = x25519.getPublicKey(seed);
      return {
        publicKey,
        privateKey: seed
      };
    },
    generateX25519SharedKey(privateKey, publicKey) {
      return x25519.getSharedSecret(privateKey, publicKey);
    },
    chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
      return chacha20_poly1305(k, nonce, ad).encrypt(plaintext);
    },
    chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
      const result = chacha20_poly1305(k, nonce, ad).decrypt(ciphertext);
      if (dst) {
        dst.set(result);
        return result;
      }
      return result;
    }
  };
  var allocUnsafe$1 = (len) => {
    if (globalThis.Buffer) {
      return globalThis.Buffer.allocUnsafe(len);
    }
    return new Uint8Array(len);
  };
  var uint16BEEncode = (value) => {
    const target = allocUnsafe$1(2);
    new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false);
    return target;
  };
  uint16BEEncode.bytes = 2;
  var uint16BEDecode = (data) => {
    if (data.length < 2)
      throw RangeError("Could not decode int16BE");
    if (data instanceof Uint8Array) {
      return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
    }
    return data.getUint16(0);
  };
  uint16BEDecode.bytes = 2;
  var CHACHA_TAG_LENGTH = 16;
  var forge$m = {
    options: {
      usePureJavaScript: false
    }
  };
  var forge$n = getDefaultExportFromCjs(forge$m);
  var util$3 = { exports: {} };
  var api = {};
  var baseN$1 = api;
  var _reverseAlphabets = {};
  api.encode = function(input, alphabet2, maxline) {
    if (typeof alphabet2 !== "string") {
      throw new TypeError('"alphabet" must be a string.');
    }
    if (maxline !== undefined && typeof maxline !== "number") {
      throw new TypeError('"maxline" must be a number.');
    }
    var output2 = "";
    if (!(input instanceof Uint8Array)) {
      output2 = _encodeWithByteBuffer(input, alphabet2);
    } else {
      var i = 0;
      var base3 = alphabet2.length;
      var first2 = alphabet2.charAt(0);
      var digits = [0];
      for (i = 0;i < input.length; ++i) {
        for (var j = 0, carry = input[i];j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base3;
          carry = carry / base3 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base3);
          carry = carry / base3 | 0;
        }
      }
      for (i = 0;input[i] === 0 && i < input.length - 1; ++i) {
        output2 += first2;
      }
      for (i = digits.length - 1;i >= 0; --i) {
        output2 += alphabet2[digits[i]];
      }
    }
    if (maxline) {
      var regex = new RegExp(".{1," + maxline + "}", "g");
      output2 = output2.match(regex).join("\r\n");
    }
    return output2;
  };
  api.decode = function(input, alphabet2) {
    if (typeof input !== "string") {
      throw new TypeError('"input" must be a string.');
    }
    if (typeof alphabet2 !== "string") {
      throw new TypeError('"alphabet" must be a string.');
    }
    var table2 = _reverseAlphabets[alphabet2];
    if (!table2) {
      table2 = _reverseAlphabets[alphabet2] = [];
      for (var i = 0;i < alphabet2.length; ++i) {
        table2[alphabet2.charCodeAt(i)] = i;
      }
    }
    input = input.replace(/\s/g, "");
    var base3 = alphabet2.length;
    var first2 = alphabet2.charAt(0);
    var bytes2 = [0];
    for (var i = 0;i < input.length; i++) {
      var value = table2[input.charCodeAt(i)];
      if (value === undefined) {
        return;
      }
      for (var j = 0, carry = value;j < bytes2.length; ++j) {
        carry += bytes2[j] * base3;
        bytes2[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes2.push(carry & 255);
        carry >>= 8;
      }
    }
    for (var k = 0;input[k] === first2 && k < input.length - 1; ++k) {
      bytes2.push(0);
    }
    if (typeof Buffer !== "undefined") {
      return Buffer.from(bytes2.reverse());
    }
    return new Uint8Array(bytes2.reverse());
  };
  var forge$l = forge$m;
  var baseN = baseN$1;
  var util$2 = util$3.exports = forge$l.util = forge$l.util || {};
  (function() {
    if (typeof process !== "undefined" && process.nextTick && true) {
      util$2.nextTick = process.nextTick;
      if (typeof setImmediate === "function") {
        util$2.setImmediate = setImmediate;
      } else {
        util$2.setImmediate = util$2.nextTick;
      }
      return;
    }
    if (typeof setImmediate === "function") {
      util$2.setImmediate = function() {
        return setImmediate.apply(undefined, arguments);
      };
      util$2.nextTick = function(callback) {
        return setImmediate(callback);
      };
      return;
    }
    util$2.setImmediate = function(callback) {
      setTimeout(callback, 0);
    };
    if (typeof window !== "undefined" && typeof window.postMessage === "function") {
      let handler = function(event) {
        if (event.source === window && event.data === msg) {
          event.stopPropagation();
          var copy2 = callbacks.slice();
          callbacks.length = 0;
          copy2.forEach(function(callback) {
            callback();
          });
        }
      };
      var msg = "forge.setImmediate";
      var callbacks = [];
      util$2.setImmediate = function(callback) {
        callbacks.push(callback);
        if (callbacks.length === 1) {
          window.postMessage(msg, "*");
        }
      };
      window.addEventListener("message", handler, true);
    }
    if (typeof MutationObserver !== "undefined") {
      var now = Date.now();
      var attr = true;
      var div = document.createElement("div");
      var callbacks = [];
      new MutationObserver(function() {
        var copy2 = callbacks.slice();
        callbacks.length = 0;
        copy2.forEach(function(callback) {
          callback();
        });
      }).observe(div, { attributes: true });
      var oldSetImmediate = util$2.setImmediate;
      util$2.setImmediate = function(callback) {
        if (Date.now() - now > 15) {
          now = Date.now();
          oldSetImmediate(callback);
        } else {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            div.setAttribute("a", attr = !attr);
          }
        }
      };
    }
    util$2.nextTick = util$2.setImmediate;
  })();
  util$2.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
  util$2.globalScope = function() {
    if (util$2.isNodejs) {
      return commonjsGlobal;
    }
    return typeof self === "undefined" ? window : self;
  }();
  util$2.isArray = Array.isArray || function(x) {
    return Object.prototype.toString.call(x) === "[object Array]";
  };
  util$2.isArrayBuffer = function(x) {
    return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
  };
  util$2.isArrayBufferView = function(x) {
    return x && util$2.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
  };
  util$2.ByteBuffer = ByteStringBuffer;
  util$2.ByteStringBuffer = ByteStringBuffer;
  var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
  util$2.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
    this._constructedStringLength += x;
    if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
      this.data.substr(0, 1);
      this._constructedStringLength = 0;
    }
  };
  util$2.ByteStringBuffer.prototype.length = function() {
    return this.data.length - this.read;
  };
  util$2.ByteStringBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  };
  util$2.ByteStringBuffer.prototype.putByte = function(b) {
    return this.putBytes(String.fromCharCode(b));
  };
  util$2.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
    b = String.fromCharCode(b);
    var d = this.data;
    while (n > 0) {
      if (n & 1) {
        d += b;
      }
      n >>>= 1;
      if (n > 0) {
        b += b;
      }
    }
    this.data = d;
    this._optimizeConstructedString(n);
    return this;
  };
  util$2.ByteStringBuffer.prototype.putBytes = function(bytes2) {
    this.data += bytes2;
    this._optimizeConstructedString(bytes2.length);
    return this;
  };
  util$2.ByteStringBuffer.prototype.putString = function(str) {
    return this.putBytes(util$2.encodeUtf8(str));
  };
  util$2.ByteStringBuffer.prototype.putInt16 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util$2.ByteStringBuffer.prototype.putInt24 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util$2.ByteStringBuffer.prototype.putInt32 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util$2.ByteStringBuffer.prototype.putInt16Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
  };
  util$2.ByteStringBuffer.prototype.putInt24Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
  };
  util$2.ByteStringBuffer.prototype.putInt32Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
  };
  util$2.ByteStringBuffer.prototype.putInt = function(i, n) {
    _checkBitsParam(n);
    var bytes2 = "";
    do {
      n -= 8;
      bytes2 += String.fromCharCode(i >> n & 255);
    } while (n > 0);
    return this.putBytes(bytes2);
  };
  util$2.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
    if (i < 0) {
      i += 2 << n - 1;
    }
    return this.putInt(i, n);
  };
  util$2.ByteStringBuffer.prototype.putBuffer = function(buffer) {
    return this.putBytes(buffer.getBytes());
  };
  util$2.ByteStringBuffer.prototype.getByte = function() {
    return this.data.charCodeAt(this.read++);
  };
  util$2.ByteStringBuffer.prototype.getInt16 = function() {
    var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
    this.read += 2;
    return rval;
  };
  util$2.ByteStringBuffer.prototype.getInt24 = function() {
    var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
    this.read += 3;
    return rval;
  };
  util$2.ByteStringBuffer.prototype.getInt32 = function() {
    var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
    this.read += 4;
    return rval;
  };
  util$2.ByteStringBuffer.prototype.getInt16Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
    this.read += 2;
    return rval;
  };
  util$2.ByteStringBuffer.prototype.getInt24Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
    this.read += 3;
    return rval;
  };
  util$2.ByteStringBuffer.prototype.getInt32Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
    this.read += 4;
    return rval;
  };
  util$2.ByteStringBuffer.prototype.getInt = function(n) {
    _checkBitsParam(n);
    var rval = 0;
    do {
      rval = (rval << 8) + this.data.charCodeAt(this.read++);
      n -= 8;
    } while (n > 0);
    return rval;
  };
  util$2.ByteStringBuffer.prototype.getSignedInt = function(n) {
    var x = this.getInt(n);
    var max = 2 << n - 2;
    if (x >= max) {
      x -= max << 1;
    }
    return x;
  };
  util$2.ByteStringBuffer.prototype.getBytes = function(count) {
    var rval;
    if (count) {
      count = Math.min(this.length(), count);
      rval = this.data.slice(this.read, this.read + count);
      this.read += count;
    } else if (count === 0) {
      rval = "";
    } else {
      rval = this.read === 0 ? this.data : this.data.slice(this.read);
      this.clear();
    }
    return rval;
  };
  util$2.ByteStringBuffer.prototype.bytes = function(count) {
    return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
  };
  util$2.ByteStringBuffer.prototype.at = function(i) {
    return this.data.charCodeAt(this.read + i);
  };
  util$2.ByteStringBuffer.prototype.setAt = function(i, b) {
    this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
    return this;
  };
  util$2.ByteStringBuffer.prototype.last = function() {
    return this.data.charCodeAt(this.data.length - 1);
  };
  util$2.ByteStringBuffer.prototype.copy = function() {
    var c = util$2.createBuffer(this.data);
    c.read = this.read;
    return c;
  };
  util$2.ByteStringBuffer.prototype.compact = function() {
    if (this.read > 0) {
      this.data = this.data.slice(this.read);
      this.read = 0;
    }
    return this;
  };
  util$2.ByteStringBuffer.prototype.clear = function() {
    this.data = "";
    this.read = 0;
    return this;
  };
  util$2.ByteStringBuffer.prototype.truncate = function(count) {
    var len = Math.max(0, this.length() - count);
    this.data = this.data.substr(this.read, len);
    this.read = 0;
    return this;
  };
  util$2.ByteStringBuffer.prototype.toHex = function() {
    var rval = "";
    for (var i = this.read;i < this.data.length; ++i) {
      var b = this.data.charCodeAt(i);
      if (b < 16) {
        rval += "0";
      }
      rval += b.toString(16);
    }
    return rval;
  };
  util$2.ByteStringBuffer.prototype.toString = function() {
    return util$2.decodeUtf8(this.bytes());
  };
  util$2.DataBuffer = DataBuffer;
  util$2.DataBuffer.prototype.length = function() {
    return this.write - this.read;
  };
  util$2.DataBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  };
  util$2.DataBuffer.prototype.accommodate = function(amount, growSize) {
    if (this.length() >= amount) {
      return this;
    }
    growSize = Math.max(growSize || this.growSize, amount);
    var src2 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
    var dst = new Uint8Array(this.length() + growSize);
    dst.set(src2);
    this.data = new DataView(dst.buffer);
    return this;
  };
  util$2.DataBuffer.prototype.putByte = function(b) {
    this.accommodate(1);
    this.data.setUint8(this.write++, b);
    return this;
  };
  util$2.DataBuffer.prototype.fillWithByte = function(b, n) {
    this.accommodate(n);
    for (var i = 0;i < n; ++i) {
      this.data.setUint8(b);
    }
    return this;
  };
  util$2.DataBuffer.prototype.putBytes = function(bytes2, encoding) {
    if (util$2.isArrayBufferView(bytes2)) {
      var src2 = new Uint8Array(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
      var len = src2.byteLength - src2.byteOffset;
      this.accommodate(len);
      var dst = new Uint8Array(this.data.buffer, this.write);
      dst.set(src2);
      this.write += len;
      return this;
    }
    if (util$2.isArrayBuffer(bytes2)) {
      var src2 = new Uint8Array(bytes2);
      this.accommodate(src2.byteLength);
      var dst = new Uint8Array(this.data.buffer);
      dst.set(src2, this.write);
      this.write += src2.byteLength;
      return this;
    }
    if (bytes2 instanceof util$2.DataBuffer || typeof bytes2 === "object" && typeof bytes2.read === "number" && typeof bytes2.write === "number" && util$2.isArrayBufferView(bytes2.data)) {
      var src2 = new Uint8Array(bytes2.data.byteLength, bytes2.read, bytes2.length());
      this.accommodate(src2.byteLength);
      var dst = new Uint8Array(bytes2.data.byteLength, this.write);
      dst.set(src2);
      this.write += src2.byteLength;
      return this;
    }
    if (bytes2 instanceof util$2.ByteStringBuffer) {
      bytes2 = bytes2.data;
      encoding = "binary";
    }
    encoding = encoding || "binary";
    if (typeof bytes2 === "string") {
      var view;
      if (encoding === "hex") {
        this.accommodate(Math.ceil(bytes2.length / 2));
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util$2.binary.hex.decode(bytes2, view, this.write);
        return this;
      }
      if (encoding === "base64") {
        this.accommodate(Math.ceil(bytes2.length / 4) * 3);
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util$2.binary.base64.decode(bytes2, view, this.write);
        return this;
      }
      if (encoding === "utf8") {
        bytes2 = util$2.encodeUtf8(bytes2);
        encoding = "binary";
      }
      if (encoding === "binary" || encoding === "raw") {
        this.accommodate(bytes2.length);
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util$2.binary.raw.decode(view);
        return this;
      }
      if (encoding === "utf16") {
        this.accommodate(bytes2.length * 2);
        view = new Uint16Array(this.data.buffer, this.write);
        this.write += util$2.text.utf16.encode(view);
        return this;
      }
      throw new Error("Invalid encoding: " + encoding);
    }
    throw Error("Invalid parameter: " + bytes2);
  };
  util$2.DataBuffer.prototype.putBuffer = function(buffer) {
    this.putBytes(buffer);
    buffer.clear();
    return this;
  };
  util$2.DataBuffer.prototype.putString = function(str) {
    return this.putBytes(str, "utf16");
  };
  util$2.DataBuffer.prototype.putInt16 = function(i) {
    this.accommodate(2);
    this.data.setInt16(this.write, i);
    this.write += 2;
    return this;
  };
  util$2.DataBuffer.prototype.putInt24 = function(i) {
    this.accommodate(3);
    this.data.setInt16(this.write, i >> 8 & 65535);
    this.data.setInt8(this.write, i >> 16 & 255);
    this.write += 3;
    return this;
  };
  util$2.DataBuffer.prototype.putInt32 = function(i) {
    this.accommodate(4);
    this.data.setInt32(this.write, i);
    this.write += 4;
    return this;
  };
  util$2.DataBuffer.prototype.putInt16Le = function(i) {
    this.accommodate(2);
    this.data.setInt16(this.write, i, true);
    this.write += 2;
    return this;
  };
  util$2.DataBuffer.prototype.putInt24Le = function(i) {
    this.accommodate(3);
    this.data.setInt8(this.write, i >> 16 & 255);
    this.data.setInt16(this.write, i >> 8 & 65535, true);
    this.write += 3;
    return this;
  };
  util$2.DataBuffer.prototype.putInt32Le = function(i) {
    this.accommodate(4);
    this.data.setInt32(this.write, i, true);
    this.write += 4;
    return this;
  };
  util$2.DataBuffer.prototype.putInt = function(i, n) {
    _checkBitsParam(n);
    this.accommodate(n / 8);
    do {
      n -= 8;
      this.data.setInt8(this.write++, i >> n & 255);
    } while (n > 0);
    return this;
  };
  util$2.DataBuffer.prototype.putSignedInt = function(i, n) {
    _checkBitsParam(n);
    this.accommodate(n / 8);
    if (i < 0) {
      i += 2 << n - 1;
    }
    return this.putInt(i, n);
  };
  util$2.DataBuffer.prototype.getByte = function() {
    return this.data.getInt8(this.read++);
  };
  util$2.DataBuffer.prototype.getInt16 = function() {
    var rval = this.data.getInt16(this.read);
    this.read += 2;
    return rval;
  };
  util$2.DataBuffer.prototype.getInt24 = function() {
    var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
    this.read += 3;
    return rval;
  };
  util$2.DataBuffer.prototype.getInt32 = function() {
    var rval = this.data.getInt32(this.read);
    this.read += 4;
    return rval;
  };
  util$2.DataBuffer.prototype.getInt16Le = function() {
    var rval = this.data.getInt16(this.read, true);
    this.read += 2;
    return rval;
  };
  util$2.DataBuffer.prototype.getInt24Le = function() {
    var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
    this.read += 3;
    return rval;
  };
  util$2.DataBuffer.prototype.getInt32Le = function() {
    var rval = this.data.getInt32(this.read, true);
    this.read += 4;
    return rval;
  };
  util$2.DataBuffer.prototype.getInt = function(n) {
    _checkBitsParam(n);
    var rval = 0;
    do {
      rval = (rval << 8) + this.data.getInt8(this.read++);
      n -= 8;
    } while (n > 0);
    return rval;
  };
  util$2.DataBuffer.prototype.getSignedInt = function(n) {
    var x = this.getInt(n);
    var max = 2 << n - 2;
    if (x >= max) {
      x -= max << 1;
    }
    return x;
  };
  util$2.DataBuffer.prototype.getBytes = function(count) {
    var rval;
    if (count) {
      count = Math.min(this.length(), count);
      rval = this.data.slice(this.read, this.read + count);
      this.read += count;
    } else if (count === 0) {
      rval = "";
    } else {
      rval = this.read === 0 ? this.data : this.data.slice(this.read);
      this.clear();
    }
    return rval;
  };
  util$2.DataBuffer.prototype.bytes = function(count) {
    return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
  };
  util$2.DataBuffer.prototype.at = function(i) {
    return this.data.getUint8(this.read + i);
  };
  util$2.DataBuffer.prototype.setAt = function(i, b) {
    this.data.setUint8(i, b);
    return this;
  };
  util$2.DataBuffer.prototype.last = function() {
    return this.data.getUint8(this.write - 1);
  };
  util$2.DataBuffer.prototype.copy = function() {
    return new util$2.DataBuffer(this);
  };
  util$2.DataBuffer.prototype.compact = function() {
    if (this.read > 0) {
      var src2 = new Uint8Array(this.data.buffer, this.read);
      var dst = new Uint8Array(src2.byteLength);
      dst.set(src2);
      this.data = new DataView(dst);
      this.write -= this.read;
      this.read = 0;
    }
    return this;
  };
  util$2.DataBuffer.prototype.clear = function() {
    this.data = new DataView(new ArrayBuffer(0));
    this.read = this.write = 0;
    return this;
  };
  util$2.DataBuffer.prototype.truncate = function(count) {
    this.write = Math.max(0, this.length() - count);
    this.read = Math.min(this.read, this.write);
    return this;
  };
  util$2.DataBuffer.prototype.toHex = function() {
    var rval = "";
    for (var i = this.read;i < this.data.byteLength; ++i) {
      var b = this.data.getUint8(i);
      if (b < 16) {
        rval += "0";
      }
      rval += b.toString(16);
    }
    return rval;
  };
  util$2.DataBuffer.prototype.toString = function(encoding) {
    var view = new Uint8Array(this.data, this.read, this.length());
    encoding = encoding || "utf8";
    if (encoding === "binary" || encoding === "raw") {
      return util$2.binary.raw.encode(view);
    }
    if (encoding === "hex") {
      return util$2.binary.hex.encode(view);
    }
    if (encoding === "base64") {
      return util$2.binary.base64.encode(view);
    }
    if (encoding === "utf8") {
      return util$2.text.utf8.decode(view);
    }
    if (encoding === "utf16") {
      return util$2.text.utf16.decode(view);
    }
    throw new Error("Invalid encoding: " + encoding);
  };
  util$2.createBuffer = function(input, encoding) {
    encoding = encoding || "raw";
    if (input !== undefined && encoding === "utf8") {
      input = util$2.encodeUtf8(input);
    }
    return new util$2.ByteBuffer(input);
  };
  util$2.fillString = function(c, n) {
    var s2 = "";
    while (n > 0) {
      if (n & 1) {
        s2 += c;
      }
      n >>>= 1;
      if (n > 0) {
        c += c;
      }
    }
    return s2;
  };
  util$2.xorBytes = function(s1, s2, n) {
    var s3 = "";
    var b = "";
    var t = "";
    var i = 0;
    var c = 0;
    for (;n > 0; --n, ++i) {
      b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
      if (c >= 10) {
        s3 += t;
        t = "";
        c = 0;
      }
      t += String.fromCharCode(b);
      ++c;
    }
    s3 += t;
    return s3;
  };
  util$2.hexToBytes = function(hex) {
    var rval = "";
    var i = 0;
    if (hex.length & true) {
      i = 1;
      rval += String.fromCharCode(parseInt(hex[0], 16));
    }
    for (;i < hex.length; i += 2) {
      rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return rval;
  };
  util$2.bytesToHex = function(bytes2) {
    return util$2.createBuffer(bytes2).toHex();
  };
  util$2.int32ToBytes = function(i) {
    return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
  };
  var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var _base64Idx = [
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    64,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
  ];
  var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  util$2.encode64 = function(input, maxline) {
    var line = "";
    var output2 = "";
    var chr1, chr2, chr3;
    var i = 0;
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      line += _base64.charAt(chr1 >> 2);
      line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
      if (isNaN(chr2)) {
        line += "==";
      } else {
        line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
        line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
      }
      if (maxline && line.length > maxline) {
        output2 += line.substr(0, maxline) + "\r\n";
        line = line.substr(maxline);
      }
    }
    output2 += line;
    return output2;
  };
  util$2.decode64 = function(input) {
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    var output2 = "";
    var enc1, enc2, enc3, enc4;
    var i = 0;
    while (i < input.length) {
      enc1 = _base64Idx[input.charCodeAt(i++) - 43];
      enc2 = _base64Idx[input.charCodeAt(i++) - 43];
      enc3 = _base64Idx[input.charCodeAt(i++) - 43];
      enc4 = _base64Idx[input.charCodeAt(i++) - 43];
      output2 += String.fromCharCode(enc1 << 2 | enc2 >> 4);
      if (enc3 !== 64) {
        output2 += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
        if (enc4 !== 64) {
          output2 += String.fromCharCode((enc3 & 3) << 6 | enc4);
        }
      }
    }
    return output2;
  };
  util$2.encodeUtf8 = function(str) {
    return unescape(encodeURIComponent(str));
  };
  util$2.decodeUtf8 = function(str) {
    return decodeURIComponent(escape(str));
  };
  util$2.binary = {
    raw: {},
    hex: {},
    base64: {},
    base58: {},
    baseN: {
      encode: baseN.encode,
      decode: baseN.decode
    }
  };
  util$2.binary.raw.encode = function(bytes2) {
    return String.fromCharCode.apply(null, bytes2);
  };
  util$2.binary.raw.decode = function(str, output2, offset) {
    var out = output2;
    if (!out) {
      out = new Uint8Array(str.length);
    }
    offset = offset || 0;
    var j = offset;
    for (var i = 0;i < str.length; ++i) {
      out[j++] = str.charCodeAt(i);
    }
    return output2 ? j - offset : out;
  };
  util$2.binary.hex.encode = util$2.bytesToHex;
  util$2.binary.hex.decode = function(hex, output2, offset) {
    var out = output2;
    if (!out) {
      out = new Uint8Array(Math.ceil(hex.length / 2));
    }
    offset = offset || 0;
    var i = 0, j = offset;
    if (hex.length & 1) {
      i = 1;
      out[j++] = parseInt(hex[0], 16);
    }
    for (;i < hex.length; i += 2) {
      out[j++] = parseInt(hex.substr(i, 2), 16);
    }
    return output2 ? j - offset : out;
  };
  util$2.binary.base64.encode = function(input, maxline) {
    var line = "";
    var output2 = "";
    var chr1, chr2, chr3;
    var i = 0;
    while (i < input.byteLength) {
      chr1 = input[i++];
      chr2 = input[i++];
      chr3 = input[i++];
      line += _base64.charAt(chr1 >> 2);
      line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
      if (isNaN(chr2)) {
        line += "==";
      } else {
        line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
        line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
      }
      if (maxline && line.length > maxline) {
        output2 += line.substr(0, maxline) + "\r\n";
        line = line.substr(maxline);
      }
    }
    output2 += line;
    return output2;
  };
  util$2.binary.base64.decode = function(input, output2, offset) {
    var out = output2;
    if (!out) {
      out = new Uint8Array(Math.ceil(input.length / 4) * 3);
    }
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    offset = offset || 0;
    var enc1, enc2, enc3, enc4;
    var i = 0, j = offset;
    while (i < input.length) {
      enc1 = _base64Idx[input.charCodeAt(i++) - 43];
      enc2 = _base64Idx[input.charCodeAt(i++) - 43];
      enc3 = _base64Idx[input.charCodeAt(i++) - 43];
      enc4 = _base64Idx[input.charCodeAt(i++) - 43];
      out[j++] = enc1 << 2 | enc2 >> 4;
      if (enc3 !== 64) {
        out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
        if (enc4 !== 64) {
          out[j++] = (enc3 & 3) << 6 | enc4;
        }
      }
    }
    return output2 ? j - offset : out.subarray(0, j);
  };
  util$2.binary.base58.encode = function(input, maxline) {
    return util$2.binary.baseN.encode(input, _base58, maxline);
  };
  util$2.binary.base58.decode = function(input, maxline) {
    return util$2.binary.baseN.decode(input, _base58, maxline);
  };
  util$2.text = {
    utf8: {},
    utf16: {}
  };
  util$2.text.utf8.encode = function(str, output2, offset) {
    str = util$2.encodeUtf8(str);
    var out = output2;
    if (!out) {
      out = new Uint8Array(str.length);
    }
    offset = offset || 0;
    var j = offset;
    for (var i = 0;i < str.length; ++i) {
      out[j++] = str.charCodeAt(i);
    }
    return output2 ? j - offset : out;
  };
  util$2.text.utf8.decode = function(bytes2) {
    return util$2.decodeUtf8(String.fromCharCode.apply(null, bytes2));
  };
  util$2.text.utf16.encode = function(str, output2, offset) {
    var out = output2;
    if (!out) {
      out = new Uint8Array(str.length * 2);
    }
    var view = new Uint16Array(out.buffer);
    offset = offset || 0;
    var j = offset;
    var k = offset;
    for (var i = 0;i < str.length; ++i) {
      view[k++] = str.charCodeAt(i);
      j += 2;
    }
    return output2 ? j - offset : out;
  };
  util$2.text.utf16.decode = function(bytes2) {
    return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
  };
  util$2.deflate = function(api2, bytes2, raw) {
    bytes2 = util$2.decode64(api2.deflate(util$2.encode64(bytes2)).rval);
    if (raw) {
      var start = 2;
      var flg = bytes2.charCodeAt(1);
      if (flg & 32) {
        start = 6;
      }
      bytes2 = bytes2.substring(start, bytes2.length - 4);
    }
    return bytes2;
  };
  util$2.inflate = function(api2, bytes2, raw) {
    var rval = api2.inflate(util$2.encode64(bytes2)).rval;
    return rval === null ? null : util$2.decode64(rval);
  };
  var _setStorageObject = function(api2, id, obj) {
    if (!api2) {
      throw new Error("WebStorage not available.");
    }
    var rval;
    if (obj === null) {
      rval = api2.removeItem(id);
    } else {
      obj = util$2.encode64(JSON.stringify(obj));
      rval = api2.setItem(id, obj);
    }
    if (typeof rval !== "undefined" && rval.rval !== true) {
      var error = new Error(rval.error.message);
      error.id = rval.error.id;
      error.name = rval.error.name;
      throw error;
    }
  };
  var _getStorageObject = function(api2, id) {
    if (!api2) {
      throw new Error("WebStorage not available.");
    }
    var rval = api2.getItem(id);
    if (api2.init) {
      if (rval.rval === null) {
        if (rval.error) {
          var error = new Error(rval.error.message);
          error.id = rval.error.id;
          error.name = rval.error.name;
          throw error;
        }
        rval = null;
      } else {
        rval = rval.rval;
      }
    }
    if (rval !== null) {
      rval = JSON.parse(util$2.decode64(rval));
    }
    return rval;
  };
  var _setItem = function(api2, id, key, data) {
    var obj = _getStorageObject(api2, id);
    if (obj === null) {
      obj = {};
    }
    obj[key] = data;
    _setStorageObject(api2, id, obj);
  };
  var _getItem = function(api2, id, key) {
    var rval = _getStorageObject(api2, id);
    if (rval !== null) {
      rval = (key in rval) ? rval[key] : null;
    }
    return rval;
  };
  var _removeItem = function(api2, id, key) {
    var obj = _getStorageObject(api2, id);
    if (obj !== null && (key in obj)) {
      delete obj[key];
      var empty = true;
      for (var prop in obj) {
        empty = false;
        break;
      }
      if (empty) {
        obj = null;
      }
      _setStorageObject(api2, id, obj);
    }
  };
  var _clearItems = function(api2, id) {
    _setStorageObject(api2, id, null);
  };
  var _callStorageFunction = function(func, args, location) {
    var rval = null;
    if (typeof location === "undefined") {
      location = ["web", "flash"];
    }
    var type;
    var done = false;
    var exception = null;
    for (var idx in location) {
      type = location[idx];
      try {
        if (type === "flash" || type === "both") {
          if (args[0] === null) {
            throw new Error("Flash local storage not available.");
          }
          rval = func.apply(this, args);
          done = type === "flash";
        }
        if (type === "web" || type === "both") {
          args[0] = localStorage;
          rval = func.apply(this, args);
          done = true;
        }
      } catch (ex) {
        exception = ex;
      }
      if (done) {
        break;
      }
    }
    if (!done) {
      throw exception;
    }
    return rval;
  };
  util$2.setItem = function(api2, id, key, data, location) {
    _callStorageFunction(_setItem, arguments, location);
  };
  util$2.getItem = function(api2, id, key, location) {
    return _callStorageFunction(_getItem, arguments, location);
  };
  util$2.removeItem = function(api2, id, key, location) {
    _callStorageFunction(_removeItem, arguments, location);
  };
  util$2.clearItems = function(api2, id, location) {
    _callStorageFunction(_clearItems, arguments, location);
  };
  util$2.isEmpty = function(obj) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        return false;
      }
    }
    return true;
  };
  util$2.format = function(format4) {
    var re = /%./g;
    var match;
    var part;
    var argi = 0;
    var parts = [];
    var last = 0;
    while (match = re.exec(format4)) {
      part = format4.substring(last, re.lastIndex - 2);
      if (part.length > 0) {
        parts.push(part);
      }
      last = re.lastIndex;
      var code2 = match[0][1];
      switch (code2) {
        case "s":
        case "o":
          if (argi < arguments.length) {
            parts.push(arguments[argi++ + 1]);
          } else {
            parts.push("<?>");
          }
          break;
        case "%":
          parts.push("%");
          break;
        default:
          parts.push("<%" + code2 + "?>");
      }
    }
    parts.push(format4.substring(last));
    return parts.join("");
  };
  util$2.formatNumber = function(number2, decimals, dec_point, thousands_sep) {
    var n = number2, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
    var d = dec_point === undefined ? "," : dec_point;
    var t = thousands_sep === undefined ? "." : thousands_sep, s2 = n < 0 ? "-" : "";
    var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
    var j = i.length > 3 ? i.length % 3 : 0;
    return s2 + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
  };
  util$2.formatSize = function(size) {
    if (size >= 1073741824) {
      size = util$2.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
    } else if (size >= 1048576) {
      size = util$2.formatNumber(size / 1048576, 2, ".", "") + " MiB";
    } else if (size >= 1024) {
      size = util$2.formatNumber(size / 1024, 0) + " KiB";
    } else {
      size = util$2.formatNumber(size, 0) + " bytes";
    }
    return size;
  };
  util$2.bytesFromIP = function(ip) {
    if (ip.indexOf(".") !== -1) {
      return util$2.bytesFromIPv4(ip);
    }
    if (ip.indexOf(":") !== -1) {
      return util$2.bytesFromIPv6(ip);
    }
    return null;
  };
  util$2.bytesFromIPv4 = function(ip) {
    ip = ip.split(".");
    if (ip.length !== 4) {
      return null;
    }
    var b = util$2.createBuffer();
    for (var i = 0;i < ip.length; ++i) {
      var num = parseInt(ip[i], 10);
      if (isNaN(num)) {
        return null;
      }
      b.putByte(num);
    }
    return b.getBytes();
  };
  util$2.bytesFromIPv6 = function(ip) {
    var blanks = 0;
    ip = ip.split(":").filter(function(e) {
      if (e.length === 0)
        ++blanks;
      return true;
    });
    var zeros = (8 - ip.length + blanks) * 2;
    var b = util$2.createBuffer();
    for (var i = 0;i < 8; ++i) {
      if (!ip[i] || ip[i].length === 0) {
        b.fillWithByte(0, zeros);
        zeros = 0;
        continue;
      }
      var bytes2 = util$2.hexToBytes(ip[i]);
      if (bytes2.length < 2) {
        b.putByte(0);
      }
      b.putBytes(bytes2);
    }
    return b.getBytes();
  };
  util$2.bytesToIP = function(bytes2) {
    if (bytes2.length === 4) {
      return util$2.bytesToIPv4(bytes2);
    }
    if (bytes2.length === 16) {
      return util$2.bytesToIPv6(bytes2);
    }
    return null;
  };
  util$2.bytesToIPv4 = function(bytes2) {
    if (bytes2.length !== 4) {
      return null;
    }
    var ip = [];
    for (var i = 0;i < bytes2.length; ++i) {
      ip.push(bytes2.charCodeAt(i));
    }
    return ip.join(".");
  };
  util$2.bytesToIPv6 = function(bytes2) {
    if (bytes2.length !== 16) {
      return null;
    }
    var ip = [];
    var zeroGroups = [];
    var zeroMaxGroup = 0;
    for (var i = 0;i < bytes2.length; i += 2) {
      var hex = util$2.bytesToHex(bytes2[i] + bytes2[i + 1]);
      while (hex[0] === "0" && hex !== "0") {
        hex = hex.substr(1);
      }
      if (hex === "0") {
        var last = zeroGroups[zeroGroups.length - 1];
        var idx = ip.length;
        if (!last || idx !== last.end + 1) {
          zeroGroups.push({ start: idx, end: idx });
        } else {
          last.end = idx;
          if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
            zeroMaxGroup = zeroGroups.length - 1;
          }
        }
      }
      ip.push(hex);
    }
    if (zeroGroups.length > 0) {
      var group = zeroGroups[zeroMaxGroup];
      if (group.end - group.start > 0) {
        ip.splice(group.start, group.end - group.start + 1, "");
        if (group.start === 0) {
          ip.unshift("");
        }
        if (group.end === 7) {
          ip.push("");
        }
      }
    }
    return ip.join(":");
  };
  util$2.estimateCores = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    if (("cores" in util$2) && !options.update) {
      return callback(null, util$2.cores);
    }
    if (typeof navigator !== "undefined" && ("hardwareConcurrency" in navigator) && navigator.hardwareConcurrency > 0) {
      util$2.cores = navigator.hardwareConcurrency;
      return callback(null, util$2.cores);
    }
    if (typeof Worker === "undefined") {
      util$2.cores = 1;
      return callback(null, util$2.cores);
    }
    if (typeof Blob === "undefined") {
      util$2.cores = 2;
      return callback(null, util$2.cores);
    }
    var blobUrl = URL.createObjectURL(new Blob([
      "(",
      function() {
        self.addEventListener("message", function(e) {
          var st = Date.now();
          var et = st + 4;
          self.postMessage({ st, et });
        });
      }.toString(),
      ")()"
    ], { type: "application/javascript" }));
    sample([], 5, 16);
    function sample(max, samples, numWorkers) {
      if (samples === 0) {
        var avg = Math.floor(max.reduce(function(avg2, x) {
          return avg2 + x;
        }, 0) / max.length);
        util$2.cores = Math.max(1, avg);
        URL.revokeObjectURL(blobUrl);
        return callback(null, util$2.cores);
      }
      map2(numWorkers, function(err, results) {
        max.push(reduce(numWorkers, results));
        sample(max, samples - 1, numWorkers);
      });
    }
    function map2(numWorkers, callback2) {
      var workers = [];
      var results = [];
      for (var i = 0;i < numWorkers; ++i) {
        var worker = new Worker(blobUrl);
        worker.addEventListener("message", function(e) {
          results.push(e.data);
          if (results.length === numWorkers) {
            for (var i2 = 0;i2 < numWorkers; ++i2) {
              workers[i2].terminate();
            }
            callback2(null, results);
          }
        });
        workers.push(worker);
      }
      for (var i = 0;i < numWorkers; ++i) {
        workers[i].postMessage(i);
      }
    }
    function reduce(numWorkers, results) {
      var overlaps = [];
      for (var n = 0;n < numWorkers; ++n) {
        var r1 = results[n];
        var overlap = overlaps[n] = [];
        for (var i = 0;i < numWorkers; ++i) {
          if (n === i) {
            continue;
          }
          var r2 = results[i];
          if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
            overlap.push(i);
          }
        }
      }
      return overlaps.reduce(function(max, overlap2) {
        return Math.max(max, overlap2.length);
      }, 0);
    }
  };
  var utilExports = util$3.exports;
  var forgeUtil = getDefaultExportFromCjs(utilExports);
  var forge$k = forge$m;
  forge$k.pki = forge$k.pki || {};
  var oids$1 = forge$k.pki.oids = forge$k.oids = forge$k.oids || {};
  _IN("1.2.840.113549.1.1.1", "rsaEncryption");
  _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
  _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
  _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
  _IN("1.2.840.113549.1.1.8", "mgf1");
  _IN("1.2.840.113549.1.1.9", "pSpecified");
  _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
  _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
  _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
  _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
  _IN("1.3.101.112", "EdDSA25519");
  _IN("1.2.840.10040.4.3", "dsa-with-sha1");
  _IN("1.3.14.3.2.7", "desCBC");
  _IN("1.3.14.3.2.26", "sha1");
  _IN("1.3.14.3.2.29", "sha1WithRSASignature");
  _IN("2.16.840.1.101.3.4.2.1", "sha256");
  _IN("2.16.840.1.101.3.4.2.2", "sha384");
  _IN("2.16.840.1.101.3.4.2.3", "sha512");
  _IN("2.16.840.1.101.3.4.2.4", "sha224");
  _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
  _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
  _IN("1.2.840.113549.2.2", "md2");
  _IN("1.2.840.113549.2.5", "md5");
  _IN("1.2.840.113549.1.7.1", "data");
  _IN("1.2.840.113549.1.7.2", "signedData");
  _IN("1.2.840.113549.1.7.3", "envelopedData");
  _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
  _IN("1.2.840.113549.1.7.5", "digestedData");
  _IN("1.2.840.113549.1.7.6", "encryptedData");
  _IN("1.2.840.113549.1.9.1", "emailAddress");
  _IN("1.2.840.113549.1.9.2", "unstructuredName");
  _IN("1.2.840.113549.1.9.3", "contentType");
  _IN("1.2.840.113549.1.9.4", "messageDigest");
  _IN("1.2.840.113549.1.9.5", "signingTime");
  _IN("1.2.840.113549.1.9.6", "counterSignature");
  _IN("1.2.840.113549.1.9.7", "challengePassword");
  _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
  _IN("1.2.840.113549.1.9.14", "extensionRequest");
  _IN("1.2.840.113549.1.9.20", "friendlyName");
  _IN("1.2.840.113549.1.9.21", "localKeyId");
  _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
  _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
  _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
  _IN("1.2.840.113549.1.12.10.1.3", "certBag");
  _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
  _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
  _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
  _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
  _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
  _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
  _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
  _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
  _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
  _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
  _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
  _IN("1.2.840.113549.2.7", "hmacWithSHA1");
  _IN("1.2.840.113549.2.8", "hmacWithSHA224");
  _IN("1.2.840.113549.2.9", "hmacWithSHA256");
  _IN("1.2.840.113549.2.10", "hmacWithSHA384");
  _IN("1.2.840.113549.2.11", "hmacWithSHA512");
  _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
  _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
  _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
  _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
  _IN("2.5.4.3", "commonName");
  _IN("2.5.4.4", "surname");
  _IN("2.5.4.5", "serialNumber");
  _IN("2.5.4.6", "countryName");
  _IN("2.5.4.7", "localityName");
  _IN("2.5.4.8", "stateOrProvinceName");
  _IN("2.5.4.9", "streetAddress");
  _IN("2.5.4.10", "organizationName");
  _IN("2.5.4.11", "organizationalUnitName");
  _IN("2.5.4.12", "title");
  _IN("2.5.4.13", "description");
  _IN("2.5.4.15", "businessCategory");
  _IN("2.5.4.17", "postalCode");
  _IN("2.5.4.42", "givenName");
  _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
  _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
  _IN("2.16.840.1.113730.1.1", "nsCertType");
  _IN("2.16.840.1.113730.1.13", "nsComment");
  _I_("2.5.29.1", "authorityKeyIdentifier");
  _I_("2.5.29.2", "keyAttributes");
  _I_("2.5.29.3", "certificatePolicies");
  _I_("2.5.29.4", "keyUsageRestriction");
  _I_("2.5.29.5", "policyMapping");
  _I_("2.5.29.6", "subtreesConstraint");
  _I_("2.5.29.7", "subjectAltName");
  _I_("2.5.29.8", "issuerAltName");
  _I_("2.5.29.9", "subjectDirectoryAttributes");
  _I_("2.5.29.10", "basicConstraints");
  _I_("2.5.29.11", "nameConstraints");
  _I_("2.5.29.12", "policyConstraints");
  _I_("2.5.29.13", "basicConstraints");
  _IN("2.5.29.14", "subjectKeyIdentifier");
  _IN("2.5.29.15", "keyUsage");
  _I_("2.5.29.16", "privateKeyUsagePeriod");
  _IN("2.5.29.17", "subjectAltName");
  _IN("2.5.29.18", "issuerAltName");
  _IN("2.5.29.19", "basicConstraints");
  _I_("2.5.29.20", "cRLNumber");
  _I_("2.5.29.21", "cRLReason");
  _I_("2.5.29.22", "expirationDate");
  _I_("2.5.29.23", "instructionCode");
  _I_("2.5.29.24", "invalidityDate");
  _I_("2.5.29.25", "cRLDistributionPoints");
  _I_("2.5.29.26", "issuingDistributionPoint");
  _I_("2.5.29.27", "deltaCRLIndicator");
  _I_("2.5.29.28", "issuingDistributionPoint");
  _I_("2.5.29.29", "certificateIssuer");
  _I_("2.5.29.30", "nameConstraints");
  _IN("2.5.29.31", "cRLDistributionPoints");
  _IN("2.5.29.32", "certificatePolicies");
  _I_("2.5.29.33", "policyMappings");
  _I_("2.5.29.34", "policyConstraints");
  _IN("2.5.29.35", "authorityKeyIdentifier");
  _I_("2.5.29.36", "policyConstraints");
  _IN("2.5.29.37", "extKeyUsage");
  _I_("2.5.29.46", "freshestCRL");
  _I_("2.5.29.54", "inhibitAnyPolicy");
  _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
  _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
  _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
  _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
  _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
  _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
  _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  var forge$j = forge$m;
  var asn1$2 = forge$j.asn1 = forge$j.asn1 || {};
  asn1$2.Class = {
    UNIVERSAL: 0,
    APPLICATION: 64,
    CONTEXT_SPECIFIC: 128,
    PRIVATE: 192
  };
  asn1$2.Type = {
    NONE: 0,
    BOOLEAN: 1,
    INTEGER: 2,
    BITSTRING: 3,
    OCTETSTRING: 4,
    NULL: 5,
    OID: 6,
    ODESC: 7,
    EXTERNAL: 8,
    REAL: 9,
    ENUMERATED: 10,
    EMBEDDED: 11,
    UTF8: 12,
    ROID: 13,
    SEQUENCE: 16,
    SET: 17,
    PRINTABLESTRING: 19,
    IA5STRING: 22,
    UTCTIME: 23,
    GENERALIZEDTIME: 24,
    BMPSTRING: 30
  };
  asn1$2.create = function(tagClass, type, constructed, value, options) {
    if (forge$j.util.isArray(value)) {
      var tmp = [];
      for (var i = 0;i < value.length; ++i) {
        if (value[i] !== undefined) {
          tmp.push(value[i]);
        }
      }
      value = tmp;
    }
    var obj = {
      tagClass,
      type,
      constructed,
      composed: constructed || forge$j.util.isArray(value),
      value
    };
    if (options && ("bitStringContents" in options)) {
      obj.bitStringContents = options.bitStringContents;
      obj.original = asn1$2.copy(obj);
    }
    return obj;
  };
  asn1$2.copy = function(obj, options) {
    var copy2;
    if (forge$j.util.isArray(obj)) {
      copy2 = [];
      for (var i = 0;i < obj.length; ++i) {
        copy2.push(asn1$2.copy(obj[i], options));
      }
      return copy2;
    }
    if (typeof obj === "string") {
      return obj;
    }
    copy2 = {
      tagClass: obj.tagClass,
      type: obj.type,
      constructed: obj.constructed,
      composed: obj.composed,
      value: asn1$2.copy(obj.value, options)
    };
    if (options && !options.excludeBitStringContents) {
      copy2.bitStringContents = obj.bitStringContents;
    }
    return copy2;
  };
  asn1$2.equals = function(obj1, obj2, options) {
    if (forge$j.util.isArray(obj1)) {
      if (!forge$j.util.isArray(obj2)) {
        return false;
      }
      if (obj1.length !== obj2.length) {
        return false;
      }
      for (var i = 0;i < obj1.length; ++i) {
        if (!asn1$2.equals(obj1[i], obj2[i])) {
          return false;
        }
      }
      return true;
    }
    if (typeof obj1 !== typeof obj2) {
      return false;
    }
    if (typeof obj1 === "string") {
      return obj1 === obj2;
    }
    var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$2.equals(obj1.value, obj2.value);
    if (options && options.includeBitStringContents) {
      equal = equal && obj1.bitStringContents === obj2.bitStringContents;
    }
    return equal;
  };
  asn1$2.getBerValueLength = function(b) {
    var b2 = b.getByte();
    if (b2 === 128) {
      return;
    }
    var length2;
    var longForm = b2 & 128;
    if (!longForm) {
      length2 = b2;
    } else {
      length2 = b.getInt((b2 & 127) << 3);
    }
    return length2;
  };
  var _getValueLength = function(bytes2, remaining) {
    var b2 = bytes2.getByte();
    remaining--;
    if (b2 === 128) {
      return;
    }
    var length2;
    var longForm = b2 & 128;
    if (!longForm) {
      length2 = b2;
    } else {
      var longFormBytes = b2 & 127;
      _checkBufferLength(bytes2, remaining, longFormBytes);
      length2 = bytes2.getInt(longFormBytes << 3);
    }
    if (length2 < 0) {
      throw new Error("Negative length: " + length2);
    }
    return length2;
  };
  asn1$2.fromDer = function(bytes2, options) {
    if (options === undefined) {
      options = {
        strict: true,
        parseAllBytes: true,
        decodeBitStrings: true
      };
    }
    if (typeof options === "boolean") {
      options = {
        strict: options,
        parseAllBytes: true,
        decodeBitStrings: true
      };
    }
    if (!("strict" in options)) {
      options.strict = true;
    }
    if (!("parseAllBytes" in options)) {
      options.parseAllBytes = true;
    }
    if (!("decodeBitStrings" in options)) {
      options.decodeBitStrings = true;
    }
    if (typeof bytes2 === "string") {
      bytes2 = forge$j.util.createBuffer(bytes2);
    }
    var byteCount = bytes2.length();
    var value = _fromDer(bytes2, bytes2.length(), 0, options);
    if (options.parseAllBytes && bytes2.length() !== 0) {
      var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
      error.byteCount = byteCount;
      error.remaining = bytes2.length();
      throw error;
    }
    return value;
  };
  asn1$2.toDer = function(obj) {
    var bytes2 = forge$j.util.createBuffer();
    var b1 = obj.tagClass | obj.type;
    var value = forge$j.util.createBuffer();
    var useBitStringContents = false;
    if ("bitStringContents" in obj) {
      useBitStringContents = true;
      if (obj.original) {
        useBitStringContents = asn1$2.equals(obj, obj.original);
      }
    }
    if (useBitStringContents) {
      value.putBytes(obj.bitStringContents);
    } else if (obj.composed) {
      if (obj.constructed) {
        b1 |= 32;
      } else {
        value.putByte(0);
      }
      for (var i = 0;i < obj.value.length; ++i) {
        if (obj.value[i] !== undefined) {
          value.putBuffer(asn1$2.toDer(obj.value[i]));
        }
      }
    } else {
      if (obj.type === asn1$2.Type.BMPSTRING) {
        for (var i = 0;i < obj.value.length; ++i) {
          value.putInt16(obj.value.charCodeAt(i));
        }
      } else {
        if (obj.type === asn1$2.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
          value.putBytes(obj.value.substr(1));
        } else {
          value.putBytes(obj.value);
        }
      }
    }
    bytes2.putByte(b1);
    if (value.length() <= 127) {
      bytes2.putByte(value.length() & 127);
    } else {
      var len = value.length();
      var lenBytes = "";
      do {
        lenBytes += String.fromCharCode(len & 255);
        len = len >>> 8;
      } while (len > 0);
      bytes2.putByte(lenBytes.length | 128);
      for (var i = lenBytes.length - 1;i >= 0; --i) {
        bytes2.putByte(lenBytes.charCodeAt(i));
      }
    }
    bytes2.putBuffer(value);
    return bytes2;
  };
  asn1$2.oidToDer = function(oid) {
    var values = oid.split(".");
    var bytes2 = forge$j.util.createBuffer();
    bytes2.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
    var last, valueBytes, value, b;
    for (var i = 2;i < values.length; ++i) {
      last = true;
      valueBytes = [];
      value = parseInt(values[i], 10);
      do {
        b = value & 127;
        value = value >>> 7;
        if (!last) {
          b |= 128;
        }
        valueBytes.push(b);
        last = false;
      } while (value > 0);
      for (var n = valueBytes.length - 1;n >= 0; --n) {
        bytes2.putByte(valueBytes[n]);
      }
    }
    return bytes2;
  };
  asn1$2.derToOid = function(bytes2) {
    var oid;
    if (typeof bytes2 === "string") {
      bytes2 = forge$j.util.createBuffer(bytes2);
    }
    var b = bytes2.getByte();
    oid = Math.floor(b / 40) + "." + b % 40;
    var value = 0;
    while (bytes2.length() > 0) {
      b = bytes2.getByte();
      value = value << 7;
      if (b & 128) {
        value += b & 127;
      } else {
        oid += "." + (value + b);
        value = 0;
      }
    }
    return oid;
  };
  asn1$2.utcTimeToDate = function(utc) {
    var date = new Date;
    var year = parseInt(utc.substr(0, 2), 10);
    year = year >= 50 ? 1900 + year : 2000 + year;
    var MM = parseInt(utc.substr(2, 2), 10) - 1;
    var DD = parseInt(utc.substr(4, 2), 10);
    var hh = parseInt(utc.substr(6, 2), 10);
    var mm = parseInt(utc.substr(8, 2), 10);
    var ss = 0;
    if (utc.length > 11) {
      var c = utc.charAt(10);
      var end = 10;
      if (c !== "+" && c !== "-") {
        ss = parseInt(utc.substr(10, 2), 10);
        end += 2;
      }
    }
    date.setUTCFullYear(year, MM, DD);
    date.setUTCHours(hh, mm, ss, 0);
    if (end) {
      c = utc.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
        var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
        var offset = hhoffset * 60 + mmoffset;
        offset *= 60000;
        if (c === "+") {
          date.setTime(+date - offset);
        } else {
          date.setTime(+date + offset);
        }
      }
    }
    return date;
  };
  asn1$2.generalizedTimeToDate = function(gentime) {
    var date = new Date;
    var YYYY = parseInt(gentime.substr(0, 4), 10);
    var MM = parseInt(gentime.substr(4, 2), 10) - 1;
    var DD = parseInt(gentime.substr(6, 2), 10);
    var hh = parseInt(gentime.substr(8, 2), 10);
    var mm = parseInt(gentime.substr(10, 2), 10);
    var ss = parseInt(gentime.substr(12, 2), 10);
    var fff = 0;
    var offset = 0;
    var isUTC = false;
    if (gentime.charAt(gentime.length - 1) === "Z") {
      isUTC = true;
    }
    var end = gentime.length - 5, c = gentime.charAt(end);
    if (c === "+" || c === "-") {
      var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
      var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
      offset = hhoffset * 60 + mmoffset;
      offset *= 60000;
      if (c === "+") {
        offset *= -1;
      }
      isUTC = true;
    }
    if (gentime.charAt(14) === ".") {
      fff = parseFloat(gentime.substr(14), 10) * 1000;
    }
    if (isUTC) {
      date.setUTCFullYear(YYYY, MM, DD);
      date.setUTCHours(hh, mm, ss, fff);
      date.setTime(+date + offset);
    } else {
      date.setFullYear(YYYY, MM, DD);
      date.setHours(hh, mm, ss, fff);
    }
    return date;
  };
  asn1$2.dateToUtcTime = function(date) {
    if (typeof date === "string") {
      return date;
    }
    var rval = "";
    var format4 = [];
    format4.push(("" + date.getUTCFullYear()).substr(2));
    format4.push("" + (date.getUTCMonth() + 1));
    format4.push("" + date.getUTCDate());
    format4.push("" + date.getUTCHours());
    format4.push("" + date.getUTCMinutes());
    format4.push("" + date.getUTCSeconds());
    for (var i = 0;i < format4.length; ++i) {
      if (format4[i].length < 2) {
        rval += "0";
      }
      rval += format4[i];
    }
    rval += "Z";
    return rval;
  };
  asn1$2.dateToGeneralizedTime = function(date) {
    if (typeof date === "string") {
      return date;
    }
    var rval = "";
    var format4 = [];
    format4.push("" + date.getUTCFullYear());
    format4.push("" + (date.getUTCMonth() + 1));
    format4.push("" + date.getUTCDate());
    format4.push("" + date.getUTCHours());
    format4.push("" + date.getUTCMinutes());
    format4.push("" + date.getUTCSeconds());
    for (var i = 0;i < format4.length; ++i) {
      if (format4[i].length < 2) {
        rval += "0";
      }
      rval += format4[i];
    }
    rval += "Z";
    return rval;
  };
  asn1$2.integerToDer = function(x) {
    var rval = forge$j.util.createBuffer();
    if (x >= -128 && x < 128) {
      return rval.putSignedInt(x, 8);
    }
    if (x >= -32768 && x < 32768) {
      return rval.putSignedInt(x, 16);
    }
    if (x >= -8388608 && x < 8388608) {
      return rval.putSignedInt(x, 24);
    }
    if (x >= -2147483648 && x < 2147483648) {
      return rval.putSignedInt(x, 32);
    }
    var error = new Error("Integer too large; max is 32-bits.");
    error.integer = x;
    throw error;
  };
  asn1$2.derToInteger = function(bytes2) {
    if (typeof bytes2 === "string") {
      bytes2 = forge$j.util.createBuffer(bytes2);
    }
    var n = bytes2.length() * 8;
    if (n > 32) {
      throw new Error("Integer too large; max is 32-bits.");
    }
    return bytes2.getSignedInt(n);
  };
  asn1$2.validate = function(obj, v, capture, errors) {
    var rval = false;
    if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
      if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
        rval = true;
        if (v.value && forge$j.util.isArray(v.value)) {
          var j = 0;
          for (var i = 0;rval && i < v.value.length; ++i) {
            rval = v.value[i].optional || false;
            if (obj.value[j]) {
              rval = asn1$2.validate(obj.value[j], v.value[i], capture, errors);
              if (rval) {
                ++j;
              } else if (v.value[i].optional) {
                rval = true;
              }
            }
            if (!rval && errors) {
              errors.push("[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
            }
          }
        }
        if (rval && capture) {
          if (v.capture) {
            capture[v.capture] = obj.value;
          }
          if (v.captureAsn1) {
            capture[v.captureAsn1] = obj;
          }
          if (v.captureBitStringContents && ("bitStringContents" in obj)) {
            capture[v.captureBitStringContents] = obj.bitStringContents;
          }
          if (v.captureBitStringValue && ("bitStringContents" in obj)) {
            if (obj.bitStringContents.length < 2) {
              capture[v.captureBitStringValue] = "";
            } else {
              var unused = obj.bitStringContents.charCodeAt(0);
              if (unused !== 0) {
                throw new Error("captureBitStringValue only supported for zero unused bits");
              }
              capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
            }
          }
        }
      } else if (errors) {
        errors.push("[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
      }
    } else if (errors) {
      if (obj.tagClass !== v.tagClass) {
        errors.push("[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
      }
      if (obj.type !== v.type) {
        errors.push("[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"');
      }
    }
    return rval;
  };
  var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
  asn1$2.prettyPrint = function(obj, level, indentation) {
    var rval = "";
    level = level || 0;
    indentation = indentation || 2;
    if (level > 0) {
      rval += "\n";
    }
    var indent = "";
    for (var i = 0;i < level * indentation; ++i) {
      indent += " ";
    }
    rval += indent + "Tag: ";
    switch (obj.tagClass) {
      case asn1$2.Class.UNIVERSAL:
        rval += "Universal:";
        break;
      case asn1$2.Class.APPLICATION:
        rval += "Application:";
        break;
      case asn1$2.Class.CONTEXT_SPECIFIC:
        rval += "Context-Specific:";
        break;
      case asn1$2.Class.PRIVATE:
        rval += "Private:";
        break;
    }
    if (obj.tagClass === asn1$2.Class.UNIVERSAL) {
      rval += obj.type;
      switch (obj.type) {
        case asn1$2.Type.NONE:
          rval += " (None)";
          break;
        case asn1$2.Type.BOOLEAN:
          rval += " (Boolean)";
          break;
        case asn1$2.Type.INTEGER:
          rval += " (Integer)";
          break;
        case asn1$2.Type.BITSTRING:
          rval += " (Bit string)";
          break;
        case asn1$2.Type.OCTETSTRING:
          rval += " (Octet string)";
          break;
        case asn1$2.Type.NULL:
          rval += " (Null)";
          break;
        case asn1$2.Type.OID:
          rval += " (Object Identifier)";
          break;
        case asn1$2.Type.ODESC:
          rval += " (Object Descriptor)";
          break;
        case asn1$2.Type.EXTERNAL:
          rval += " (External or Instance of)";
          break;
        case asn1$2.Type.REAL:
          rval += " (Real)";
          break;
        case asn1$2.Type.ENUMERATED:
          rval += " (Enumerated)";
          break;
        case asn1$2.Type.EMBEDDED:
          rval += " (Embedded PDV)";
          break;
        case asn1$2.Type.UTF8:
          rval += " (UTF8)";
          break;
        case asn1$2.Type.ROID:
          rval += " (Relative Object Identifier)";
          break;
        case asn1$2.Type.SEQUENCE:
          rval += " (Sequence)";
          break;
        case asn1$2.Type.SET:
          rval += " (Set)";
          break;
        case asn1$2.Type.PRINTABLESTRING:
          rval += " (Printable String)";
          break;
        case asn1$2.Type.IA5String:
          rval += " (IA5String (ASCII))";
          break;
        case asn1$2.Type.UTCTIME:
          rval += " (UTC time)";
          break;
        case asn1$2.Type.GENERALIZEDTIME:
          rval += " (Generalized time)";
          break;
        case asn1$2.Type.BMPSTRING:
          rval += " (BMP String)";
          break;
      }
    } else {
      rval += obj.type;
    }
    rval += "\n";
    rval += indent + "Constructed: " + obj.constructed + "\n";
    if (obj.composed) {
      var subvalues = 0;
      var sub = "";
      for (var i = 0;i < obj.value.length; ++i) {
        if (obj.value[i] !== undefined) {
          subvalues += 1;
          sub += asn1$2.prettyPrint(obj.value[i], level + 1, indentation);
          if (i + 1 < obj.value.length) {
            sub += ",";
          }
        }
      }
      rval += indent + "Sub values: " + subvalues + sub;
    } else {
      rval += indent + "Value: ";
      if (obj.type === asn1$2.Type.OID) {
        var oid = asn1$2.derToOid(obj.value);
        rval += oid;
        if (forge$j.pki && forge$j.pki.oids) {
          if (oid in forge$j.pki.oids) {
            rval += " (" + forge$j.pki.oids[oid] + ") ";
          }
        }
      }
      if (obj.type === asn1$2.Type.INTEGER) {
        try {
          rval += asn1$2.derToInteger(obj.value);
        } catch (ex) {
          rval += "0x" + forge$j.util.bytesToHex(obj.value);
        }
      } else if (obj.type === asn1$2.Type.BITSTRING) {
        if (obj.value.length > 1) {
          rval += "0x" + forge$j.util.bytesToHex(obj.value.slice(1));
        } else {
          rval += "(none)";
        }
        if (obj.value.length > 0) {
          var unused = obj.value.charCodeAt(0);
          if (unused == 1) {
            rval += " (1 unused bit shown)";
          } else if (unused > 1) {
            rval += " (" + unused + " unused bits shown)";
          }
        }
      } else if (obj.type === asn1$2.Type.OCTETSTRING) {
        if (!_nonLatinRegex.test(obj.value)) {
          rval += "(" + obj.value + ") ";
        }
        rval += "0x" + forge$j.util.bytesToHex(obj.value);
      } else if (obj.type === asn1$2.Type.UTF8) {
        try {
          rval += forge$j.util.decodeUtf8(obj.value);
        } catch (e) {
          if (e.message === "URI malformed") {
            rval += "0x" + forge$j.util.bytesToHex(obj.value) + " (malformed UTF8)";
          } else {
            throw e;
          }
        }
      } else if (obj.type === asn1$2.Type.PRINTABLESTRING || obj.type === asn1$2.Type.IA5String) {
        rval += obj.value;
      } else if (_nonLatinRegex.test(obj.value)) {
        rval += "0x" + forge$j.util.bytesToHex(obj.value);
      } else if (obj.value.length === 0) {
        rval += "[null]";
      } else {
        rval += obj.value;
      }
    }
    return rval;
  };
  var forge$i = forge$m;
  forge$i.cipher = forge$i.cipher || {};
  forge$i.cipher.algorithms = forge$i.cipher.algorithms || {};
  forge$i.cipher.createCipher = function(algorithm, key) {
    var api2 = algorithm;
    if (typeof api2 === "string") {
      api2 = forge$i.cipher.getAlgorithm(api2);
      if (api2) {
        api2 = api2();
      }
    }
    if (!api2) {
      throw new Error("Unsupported algorithm: " + algorithm);
    }
    return new forge$i.cipher.BlockCipher({
      algorithm: api2,
      key,
      decrypt: false
    });
  };
  forge$i.cipher.createDecipher = function(algorithm, key) {
    var api2 = algorithm;
    if (typeof api2 === "string") {
      api2 = forge$i.cipher.getAlgorithm(api2);
      if (api2) {
        api2 = api2();
      }
    }
    if (!api2) {
      throw new Error("Unsupported algorithm: " + algorithm);
    }
    return new forge$i.cipher.BlockCipher({
      algorithm: api2,
      key,
      decrypt: true
    });
  };
  forge$i.cipher.registerAlgorithm = function(name2, algorithm) {
    name2 = name2.toUpperCase();
    forge$i.cipher.algorithms[name2] = algorithm;
  };
  forge$i.cipher.getAlgorithm = function(name2) {
    name2 = name2.toUpperCase();
    if (name2 in forge$i.cipher.algorithms) {
      return forge$i.cipher.algorithms[name2];
    }
    return null;
  };
  var BlockCipher = forge$i.cipher.BlockCipher = function(options) {
    this.algorithm = options.algorithm;
    this.mode = this.algorithm.mode;
    this.blockSize = this.mode.blockSize;
    this._finish = false;
    this._input = null;
    this.output = null;
    this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
    this._decrypt = options.decrypt;
    this.algorithm.initialize(options);
  };
  BlockCipher.prototype.start = function(options) {
    options = options || {};
    var opts = {};
    for (var key in options) {
      opts[key] = options[key];
    }
    opts.decrypt = this._decrypt;
    this._finish = false;
    this._input = forge$i.util.createBuffer();
    this.output = options.output || forge$i.util.createBuffer();
    this.mode.start(opts);
  };
  BlockCipher.prototype.update = function(input) {
    if (input) {
      this._input.putBuffer(input);
    }
    while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
    }
    this._input.compact();
  };
  BlockCipher.prototype.finish = function(pad) {
    if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
      this.mode.pad = function(input) {
        return pad(this.blockSize, input, false);
      };
      this.mode.unpad = function(output2) {
        return pad(this.blockSize, output2, true);
      };
    }
    var options = {};
    options.decrypt = this._decrypt;
    options.overflow = this._input.length() % this.blockSize;
    if (!this._decrypt && this.mode.pad) {
      if (!this.mode.pad(this._input, options)) {
        return false;
      }
    }
    this._finish = true;
    this.update();
    if (this._decrypt && this.mode.unpad) {
      if (!this.mode.unpad(this.output, options)) {
        return false;
      }
    }
    if (this.mode.afterFinish) {
      if (!this.mode.afterFinish(this.output, options)) {
        return false;
      }
    }
    return true;
  };
  var forge$h = forge$m;
  forge$h.cipher = forge$h.cipher || {};
  var modes = forge$h.cipher.modes = forge$h.cipher.modes || {};
  modes.ecb = function(options) {
    options = options || {};
    this.name = "ECB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
  };
  modes.ecb.prototype.start = function(options) {
  };
  modes.ecb.prototype.encrypt = function(input, output2, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0;i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var i = 0;i < this._ints; ++i) {
      output2.putInt32(this._outBlock[i]);
    }
  };
  modes.ecb.prototype.decrypt = function(input, output2, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0;i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var i = 0;i < this._ints; ++i) {
      output2.putInt32(this._outBlock[i]);
    }
  };
  modes.ecb.prototype.pad = function(input, options) {
    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
    input.fillWithByte(padding, padding);
    return true;
  };
  modes.ecb.prototype.unpad = function(output2, options) {
    if (options.overflow > 0) {
      return false;
    }
    var len = output2.length();
    var count = output2.at(len - 1);
    if (count > this.blockSize << 2) {
      return false;
    }
    output2.truncate(count);
    return true;
  };
  modes.cbc = function(options) {
    options = options || {};
    this.name = "CBC";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
  };
  modes.cbc.prototype.start = function(options) {
    if (options.iv === null) {
      if (!this._prev) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = this._prev.slice(0);
    } else if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    } else {
      this._iv = transformIV(options.iv, this.blockSize);
      this._prev = this._iv.slice(0);
    }
  };
  modes.cbc.prototype.encrypt = function(input, output2, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0;i < this._ints; ++i) {
      this._inBlock[i] = this._prev[i] ^ input.getInt32();
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var i = 0;i < this._ints; ++i) {
      output2.putInt32(this._outBlock[i]);
    }
    this._prev = this._outBlock;
  };
  modes.cbc.prototype.decrypt = function(input, output2, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0;i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var i = 0;i < this._ints; ++i) {
      output2.putInt32(this._prev[i] ^ this._outBlock[i]);
    }
    this._prev = this._inBlock.slice(0);
  };
  modes.cbc.prototype.pad = function(input, options) {
    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
    input.fillWithByte(padding, padding);
    return true;
  };
  modes.cbc.prototype.unpad = function(output2, options) {
    if (options.overflow > 0) {
      return false;
    }
    var len = output2.length();
    var count = output2.at(len - 1);
    if (count > this.blockSize << 2) {
      return false;
    }
    output2.truncate(count);
    return true;
  };
  modes.cfb = function(options) {
    options = options || {};
    this.name = "CFB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialBlock = new Array(this._ints);
    this._partialOutput = forge$h.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.cfb.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.cfb.prototype.encrypt = function(input, output2, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0;i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
        output2.putInt32(this._inBlock[i]);
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0;i < this._ints; ++i) {
      this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
      this._partialOutput.putInt32(this._partialBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0;i < this._ints; ++i) {
        this._inBlock[i] = this._partialBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output2.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output2.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.cfb.prototype.decrypt = function(input, output2, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0;i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
        output2.putInt32(this._inBlock[i] ^ this._outBlock[i]);
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0;i < this._ints; ++i) {
      this._partialBlock[i] = input.getInt32();
      this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0;i < this._ints; ++i) {
        this._inBlock[i] = this._partialBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output2.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output2.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.ofb = function(options) {
    options = options || {};
    this.name = "OFB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge$h.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.ofb.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.ofb.prototype.encrypt = function(input, output2, finish) {
    var inputLength = input.length();
    if (input.length() === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0;i < this._ints; ++i) {
        output2.putInt32(input.getInt32() ^ this._outBlock[i]);
        this._inBlock[i] = this._outBlock[i];
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0;i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0;i < this._ints; ++i) {
        this._inBlock[i] = this._outBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output2.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output2.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
  modes.ctr = function(options) {
    options = options || {};
    this.name = "CTR";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge$h.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.ctr.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.ctr.prototype.encrypt = function(input, output2, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0;i < this._ints; ++i) {
        output2.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
    } else {
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0;i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output2.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output2.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    }
    inc32(this._inBlock);
  };
  modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
  modes.gcm = function(options) {
    options = options || {};
    this.name = "GCM";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge$h.util.createBuffer();
    this._partialBytes = 0;
    this._R = 3774873600;
  };
  modes.gcm.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    var iv = forge$h.util.createBuffer(options.iv);
    this._cipherLength = 0;
    var additionalData;
    if ("additionalData" in options) {
      additionalData = forge$h.util.createBuffer(options.additionalData);
    } else {
      additionalData = forge$h.util.createBuffer();
    }
    if ("tagLength" in options) {
      this._tagLength = options.tagLength;
    } else {
      this._tagLength = 128;
    }
    this._tag = null;
    if (options.decrypt) {
      this._tag = forge$h.util.createBuffer(options.tag).getBytes();
      if (this._tag.length !== this._tagLength / 8) {
        throw new Error("Authentication tag does not match tag length.");
      }
    }
    this._hashBlock = new Array(this._ints);
    this.tag = null;
    this._hashSubkey = new Array(this._ints);
    this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
    this.componentBits = 4;
    this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
    var ivLength = iv.length();
    if (ivLength === 12) {
      this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
    } else {
      this._j0 = [0, 0, 0, 0];
      while (iv.length() > 0) {
        this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
      }
      this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
    }
    this._inBlock = this._j0.slice(0);
    inc32(this._inBlock);
    this._partialBytes = 0;
    additionalData = forge$h.util.createBuffer(additionalData);
    this._aDataLength = from64To32(additionalData.length() * 8);
    var overflow = additionalData.length() % this.blockSize;
    if (overflow) {
      additionalData.fillWithByte(0, this.blockSize - overflow);
    }
    this._s = [0, 0, 0, 0];
    while (additionalData.length() > 0) {
      this._s = this.ghash(this._hashSubkey, this._s, [
        additionalData.getInt32(),
        additionalData.getInt32(),
        additionalData.getInt32(),
        additionalData.getInt32()
      ]);
    }
  };
  modes.gcm.prototype.encrypt = function(input, output2, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0;i < this._ints; ++i) {
        output2.putInt32(this._outBlock[i] ^= input.getInt32());
      }
      this._cipherLength += this.blockSize;
    } else {
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0;i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes <= 0 || finish) {
        if (finish) {
          var overflow = inputLength % this.blockSize;
          this._cipherLength += overflow;
          this._partialOutput.truncate(this.blockSize - overflow);
        } else {
          this._cipherLength += this.blockSize;
        }
        for (var i = 0;i < this._ints; ++i) {
          this._outBlock[i] = this._partialOutput.getInt32();
        }
        this._partialOutput.read -= this.blockSize;
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        input.read -= this.blockSize;
        output2.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output2.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    }
    this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
    inc32(this._inBlock);
  };
  modes.gcm.prototype.decrypt = function(input, output2, finish) {
    var inputLength = input.length();
    if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    inc32(this._inBlock);
    this._hashBlock[0] = input.getInt32();
    this._hashBlock[1] = input.getInt32();
    this._hashBlock[2] = input.getInt32();
    this._hashBlock[3] = input.getInt32();
    this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
    for (var i = 0;i < this._ints; ++i) {
      output2.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
    }
    if (inputLength < this.blockSize) {
      this._cipherLength += inputLength % this.blockSize;
    } else {
      this._cipherLength += this.blockSize;
    }
  };
  modes.gcm.prototype.afterFinish = function(output2, options) {
    var rval = true;
    if (options.decrypt && options.overflow) {
      output2.truncate(this.blockSize - options.overflow);
    }
    this.tag = forge$h.util.createBuffer();
    var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
    this._s = this.ghash(this._hashSubkey, this._s, lengths);
    var tag = [];
    this.cipher.encrypt(this._j0, tag);
    for (var i = 0;i < this._ints; ++i) {
      this.tag.putInt32(this._s[i] ^ tag[i]);
    }
    this.tag.truncate(this.tag.length() % (this._tagLength / 8));
    if (options.decrypt && this.tag.bytes() !== this._tag) {
      rval = false;
    }
    return rval;
  };
  modes.gcm.prototype.multiply = function(x, y) {
    var z_i = [0, 0, 0, 0];
    var v_i = y.slice(0);
    for (var i = 0;i < 128; ++i) {
      var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
      if (x_i) {
        z_i[0] ^= v_i[0];
        z_i[1] ^= v_i[1];
        z_i[2] ^= v_i[2];
        z_i[3] ^= v_i[3];
      }
      this.pow(v_i, v_i);
    }
    return z_i;
  };
  modes.gcm.prototype.pow = function(x, out) {
    var lsb = x[3] & 1;
    for (var i = 3;i > 0; --i) {
      out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
    }
    out[0] = x[0] >>> 1;
    if (lsb) {
      out[0] ^= this._R;
    }
  };
  modes.gcm.prototype.tableMultiply = function(x) {
    var z = [0, 0, 0, 0];
    for (var i = 0;i < 32; ++i) {
      var idx = i / 8 | 0;
      var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
      var ah = this._m[i][x_i];
      z[0] ^= ah[0];
      z[1] ^= ah[1];
      z[2] ^= ah[2];
      z[3] ^= ah[3];
    }
    return z;
  };
  modes.gcm.prototype.ghash = function(h, y, x) {
    y[0] ^= x[0];
    y[1] ^= x[1];
    y[2] ^= x[2];
    y[3] ^= x[3];
    return this.tableMultiply(y);
  };
  modes.gcm.prototype.generateHashTable = function(h, bits2) {
    var multiplier = 8 / bits2;
    var perInt = 4 * multiplier;
    var size = 16 * multiplier;
    var m = new Array(size);
    for (var i = 0;i < size; ++i) {
      var tmp = [0, 0, 0, 0];
      var idx = i / perInt | 0;
      var shft = (perInt - 1 - i % perInt) * bits2;
      tmp[idx] = 1 << bits2 - 1 << shft;
      m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits2);
    }
    return m;
  };
  modes.gcm.prototype.generateSubHashTable = function(mid, bits2) {
    var size = 1 << bits2;
    var half = size >>> 1;
    var m = new Array(size);
    m[half] = mid.slice(0);
    var i = half >>> 1;
    while (i > 0) {
      this.pow(m[2 * i], m[i] = []);
      i >>= 1;
    }
    i = 2;
    while (i < half) {
      for (var j = 1;j < i; ++j) {
        var m_i = m[i];
        var m_j = m[j];
        m[i + j] = [
          m_i[0] ^ m_j[0],
          m_i[1] ^ m_j[1],
          m_i[2] ^ m_j[2],
          m_i[3] ^ m_j[3]
        ];
      }
      i *= 2;
    }
    m[0] = [0, 0, 0, 0];
    for (i = half + 1;i < size; ++i) {
      var c = m[i ^ half];
      m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
    }
    return m;
  };
  var forge$g = forge$m;
  forge$g.aes = forge$g.aes || {};
  forge$g.aes.startEncrypting = function(key, iv, output2, mode) {
    var cipher = _createCipher$1({
      key,
      output: output2,
      decrypt: false,
      mode
    });
    cipher.start(iv);
    return cipher;
  };
  forge$g.aes.createEncryptionCipher = function(key, mode) {
    return _createCipher$1({
      key,
      output: null,
      decrypt: false,
      mode
    });
  };
  forge$g.aes.startDecrypting = function(key, iv, output2, mode) {
    var cipher = _createCipher$1({
      key,
      output: output2,
      decrypt: true,
      mode
    });
    cipher.start(iv);
    return cipher;
  };
  forge$g.aes.createDecryptionCipher = function(key, mode) {
    return _createCipher$1({
      key,
      output: null,
      decrypt: true,
      mode
    });
  };
  forge$g.aes.Algorithm = function(name2, mode) {
    if (!init) {
      initialize();
    }
    var self2 = this;
    self2.name = name2;
    self2.mode = new mode({
      blockSize: 16,
      cipher: {
        encrypt: function(inBlock, outBlock) {
          return _updateBlock$1(self2._w, inBlock, outBlock, false);
        },
        decrypt: function(inBlock, outBlock) {
          return _updateBlock$1(self2._w, inBlock, outBlock, true);
        }
      }
    });
    self2._init = false;
  };
  forge$g.aes.Algorithm.prototype.initialize = function(options) {
    if (this._init) {
      return;
    }
    var key = options.key;
    var tmp;
    if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
      key = forge$g.util.createBuffer(key);
    } else if (forge$g.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
      tmp = key;
      key = forge$g.util.createBuffer();
      for (var i = 0;i < tmp.length; ++i) {
        key.putByte(tmp[i]);
      }
    }
    if (!forge$g.util.isArray(key)) {
      tmp = key;
      key = [];
      var len = tmp.length();
      if (len === 16 || len === 24 || len === 32) {
        len = len >>> 2;
        for (var i = 0;i < len; ++i) {
          key.push(tmp.getInt32());
        }
      }
    }
    if (!forge$g.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
      throw new Error("Invalid key parameter.");
    }
    var mode = this.mode.name;
    var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
    this._w = _expandKey(key, options.decrypt && !encryptOp);
    this._init = true;
  };
  forge$g.aes._expandKey = function(key, decrypt2) {
    if (!init) {
      initialize();
    }
    return _expandKey(key, decrypt2);
  };
  forge$g.aes._updateBlock = _updateBlock$1;
  registerAlgorithm$1("AES-ECB", forge$g.cipher.modes.ecb);
  registerAlgorithm$1("AES-CBC", forge$g.cipher.modes.cbc);
  registerAlgorithm$1("AES-CFB", forge$g.cipher.modes.cfb);
  registerAlgorithm$1("AES-OFB", forge$g.cipher.modes.ofb);
  registerAlgorithm$1("AES-CTR", forge$g.cipher.modes.ctr);
  registerAlgorithm$1("AES-GCM", forge$g.cipher.modes.gcm);
  var init = false;
  var Nb = 4;
  var sbox;
  var isbox;
  var rcon;
  var mix;
  var imix;
  var forge$f = forge$m;
  forge$f.des = forge$f.des || {};
  forge$f.des.startEncrypting = function(key, iv, output2, mode) {
    var cipher = _createCipher({
      key,
      output: output2,
      decrypt: false,
      mode: mode || (iv === null ? "ECB" : "CBC")
    });
    cipher.start(iv);
    return cipher;
  };
  forge$f.des.createEncryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: false,
      mode
    });
  };
  forge$f.des.startDecrypting = function(key, iv, output2, mode) {
    var cipher = _createCipher({
      key,
      output: output2,
      decrypt: true,
      mode: mode || (iv === null ? "ECB" : "CBC")
    });
    cipher.start(iv);
    return cipher;
  };
  forge$f.des.createDecryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: true,
      mode
    });
  };
  forge$f.des.Algorithm = function(name2, mode) {
    var self2 = this;
    self2.name = name2;
    self2.mode = new mode({
      blockSize: 8,
      cipher: {
        encrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._keys, inBlock, outBlock, false);
        },
        decrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._keys, inBlock, outBlock, true);
        }
      }
    });
    self2._init = false;
  };
  forge$f.des.Algorithm.prototype.initialize = function(options) {
    if (this._init) {
      return;
    }
    var key = forge$f.util.createBuffer(options.key);
    if (this.name.indexOf("3DES") === 0) {
      if (key.length() !== 24) {
        throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
      }
    }
    this._keys = _createKeys(key);
    this._init = true;
  };
  registerAlgorithm("DES-ECB", forge$f.cipher.modes.ecb);
  registerAlgorithm("DES-CBC", forge$f.cipher.modes.cbc);
  registerAlgorithm("DES-CFB", forge$f.cipher.modes.cfb);
  registerAlgorithm("DES-OFB", forge$f.cipher.modes.ofb);
  registerAlgorithm("DES-CTR", forge$f.cipher.modes.ctr);
  registerAlgorithm("3DES-ECB", forge$f.cipher.modes.ecb);
  registerAlgorithm("3DES-CBC", forge$f.cipher.modes.cbc);
  registerAlgorithm("3DES-CFB", forge$f.cipher.modes.cfb);
  registerAlgorithm("3DES-OFB", forge$f.cipher.modes.ofb);
  registerAlgorithm("3DES-CTR", forge$f.cipher.modes.ctr);
  var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
  var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
  var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
  var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
  var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
  var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
  var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
  var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
  var forge$e = forge$m;
  forge$e.md = forge$e.md || {};
  forge$e.md.algorithms = forge$e.md.algorithms || {};
  var forge$d = forge$m;
  var hmac$1 = forge$d.hmac = forge$d.hmac || {};
  hmac$1.create = function() {
    var _key = null;
    var _md = null;
    var _ipadding = null;
    var _opadding = null;
    var ctx = {};
    ctx.start = function(md, key) {
      if (md !== null) {
        if (typeof md === "string") {
          md = md.toLowerCase();
          if (md in forge$d.md.algorithms) {
            _md = forge$d.md.algorithms[md].create();
          } else {
            throw new Error('Unknown hash algorithm "' + md + '"');
          }
        } else {
          _md = md;
        }
      }
      if (key === null) {
        key = _key;
      } else {
        if (typeof key === "string") {
          key = forge$d.util.createBuffer(key);
        } else if (forge$d.util.isArray(key)) {
          var tmp = key;
          key = forge$d.util.createBuffer();
          for (var i = 0;i < tmp.length; ++i) {
            key.putByte(tmp[i]);
          }
        }
        var keylen = key.length();
        if (keylen > _md.blockLength) {
          _md.start();
          _md.update(key.bytes());
          key = _md.digest();
        }
        _ipadding = forge$d.util.createBuffer();
        _opadding = forge$d.util.createBuffer();
        keylen = key.length();
        for (var i = 0;i < keylen; ++i) {
          var tmp = key.at(i);
          _ipadding.putByte(54 ^ tmp);
          _opadding.putByte(92 ^ tmp);
        }
        if (keylen < _md.blockLength) {
          var tmp = _md.blockLength - keylen;
          for (var i = 0;i < tmp; ++i) {
            _ipadding.putByte(54);
            _opadding.putByte(92);
          }
        }
        _key = key;
        _ipadding = _ipadding.bytes();
        _opadding = _opadding.bytes();
      }
      _md.start();
      _md.update(_ipadding);
    };
    ctx.update = function(bytes2) {
      _md.update(bytes2);
    };
    ctx.getMac = function() {
      var inner = _md.digest().bytes();
      _md.start();
      _md.update(_opadding);
      _md.update(inner);
      return _md.digest();
    };
    ctx.digest = ctx.getMac;
    return ctx;
  };
  var _nodeResolve_empty = {};
  var nodeCrypto = Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
  });
  var require$$1 = getAugmentedNamespace(nodeCrypto);
  var forge$c = forge$m;
  var pkcs5 = forge$c.pkcs5 = forge$c.pkcs5 || {};
  var crypto$5;
  if (forge$c.util.isNodejs && !forge$c.options.usePureJavaScript) {
    crypto$5 = require$$1;
  }
  var pbkdf2$1 = forge$c.pbkdf2 = pkcs5.pbkdf2 = function(p, s2, c, dkLen, md, callback) {
    if (typeof md === "function") {
      callback = md;
      md = null;
    }
    if (forge$c.util.isNodejs && !forge$c.options.usePureJavaScript && crypto$5.pbkdf2 && (md === null || typeof md !== "object") && (crypto$5.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
      if (typeof md !== "string") {
        md = "sha1";
      }
      p = Buffer.from(p, "binary");
      s2 = Buffer.from(s2, "binary");
      if (!callback) {
        if (crypto$5.pbkdf2Sync.length === 4) {
          return crypto$5.pbkdf2Sync(p, s2, c, dkLen).toString("binary");
        }
        return crypto$5.pbkdf2Sync(p, s2, c, dkLen, md).toString("binary");
      }
      if (crypto$5.pbkdf2Sync.length === 4) {
        return crypto$5.pbkdf2(p, s2, c, dkLen, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      return crypto$5.pbkdf2(p, s2, c, dkLen, md, function(err2, key) {
        if (err2) {
          return callback(err2);
        }
        callback(null, key.toString("binary"));
      });
    }
    if (typeof md === "undefined" || md === null) {
      md = "sha1";
    }
    if (typeof md === "string") {
      if (!(md in forge$c.md.algorithms)) {
        throw new Error("Unknown hash algorithm: " + md);
      }
      md = forge$c.md[md].create();
    }
    var hLen = md.digestLength;
    if (dkLen > 4294967295 * hLen) {
      var err = new Error("Derived key is too long.");
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    var len = Math.ceil(dkLen / hLen);
    var r = dkLen - (len - 1) * hLen;
    var prf = forge$c.hmac.create();
    prf.start(md, p);
    var dk = "";
    var xor, u_c, u_c1;
    if (!callback) {
      for (var i = 1;i <= len; ++i) {
        prf.start(null, null);
        prf.update(s2);
        prf.update(forge$c.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        for (var j = 2;j <= c; ++j) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge$c.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
        }
        dk += i < len ? xor : xor.substr(0, r);
      }
      return dk;
    }
    var i = 1, j;
    function outer() {
      if (i > len) {
        return callback(null, dk);
      }
      prf.start(null, null);
      prf.update(s2);
      prf.update(forge$c.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();
      j = 2;
      inner();
    }
    function inner() {
      if (j <= c) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        xor = forge$c.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
        ++j;
        return forge$c.util.setImmediate(inner);
      }
      dk += i < len ? xor : xor.substr(0, r);
      ++i;
      outer();
    }
    outer();
  };
  var forgePbkdf2 = getDefaultExportFromCjs(pbkdf2$1);
  var forge$b = forge$m;
  var pem = forge$b.pem = forge$b.pem || {};
  pem.encode = function(msg, options) {
    options = options || {};
    var rval = "-----BEGIN " + msg.type + "-----\r\n";
    var header2;
    if (msg.procType) {
      header2 = {
        name: "Proc-Type",
        values: [String(msg.procType.version), msg.procType.type]
      };
      rval += foldHeader(header2);
    }
    if (msg.contentDomain) {
      header2 = { name: "Content-Domain", values: [msg.contentDomain] };
      rval += foldHeader(header2);
    }
    if (msg.dekInfo) {
      header2 = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
      if (msg.dekInfo.parameters) {
        header2.values.push(msg.dekInfo.parameters);
      }
      rval += foldHeader(header2);
    }
    if (msg.headers) {
      for (var i = 0;i < msg.headers.length; ++i) {
        rval += foldHeader(msg.headers[i]);
      }
    }
    if (msg.procType) {
      rval += "\r\n";
    }
    rval += forge$b.util.encode64(msg.body, options.maxline || 64) + "\r\n";
    rval += "-----END " + msg.type + "-----\r\n";
    return rval;
  };
  pem.decode = function(str) {
    var rval = [];
    var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
    var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
    var rCRLF = /\r?\n/;
    var match;
    while (true) {
      match = rMessage.exec(str);
      if (!match) {
        break;
      }
      var type = match[1];
      if (type === "NEW CERTIFICATE REQUEST") {
        type = "CERTIFICATE REQUEST";
      }
      var msg = {
        type,
        procType: null,
        contentDomain: null,
        dekInfo: null,
        headers: [],
        body: forge$b.util.decode64(match[3])
      };
      rval.push(msg);
      if (!match[2]) {
        continue;
      }
      var lines = match[2].split(rCRLF);
      var li = 0;
      while (match && li < lines.length) {
        var line = lines[li].replace(/\s+$/, "");
        for (var nl = li + 1;nl < lines.length; ++nl) {
          var next = lines[nl];
          if (!/\s/.test(next[0])) {
            break;
          }
          line += next;
          li = nl;
        }
        match = line.match(rHeader);
        if (match) {
          var header2 = { name: match[1], values: [] };
          var values = match[2].split(",");
          for (var vi = 0;vi < values.length; ++vi) {
            header2.values.push(ltrim(values[vi]));
          }
          if (!msg.procType) {
            if (header2.name !== "Proc-Type") {
              throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
            } else if (header2.values.length !== 2) {
              throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
            }
            msg.procType = { version: values[0], type: values[1] };
          } else if (!msg.contentDomain && header2.name === "Content-Domain") {
            msg.contentDomain = values[0] || "";
          } else if (!msg.dekInfo && header2.name === "DEK-Info") {
            if (header2.values.length === 0) {
              throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
            }
            msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
          } else {
            msg.headers.push(header2);
          }
        }
        ++li;
      }
      if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
        throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
      }
    }
    if (rval.length === 0) {
      throw new Error("Invalid PEM formatted message.");
    }
    return rval;
  };
  var forge$a = forge$m;
  var sha256$9 = forge$a.sha256 = forge$a.sha256 || {};
  forge$a.md.sha256 = forge$a.md.algorithms.sha256 = sha256$9;
  sha256$9.create = function() {
    if (!_initialized$2) {
      _init$2();
    }
    var _state = null;
    var _input = forge$a.util.createBuffer();
    var _w = new Array(64);
    var md = {
      algorithm: "sha256",
      blockLength: 64,
      digestLength: 32,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 8
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength64 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0;i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge$a.util.createBuffer();
      _state = {
        h0: 1779033703,
        h1: 3144134277,
        h2: 1013904242,
        h3: 2773480762,
        h4: 1359893119,
        h5: 2600822924,
        h6: 528734635,
        h7: 1541459225
      };
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge$a.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1;i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update$2(_state, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge$a.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding$2.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits2 = md.fullMessageLength[0] * 8;
      for (var i = 0;i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits2 += carry;
        finalBlock.putInt32(bits2 >>> 0);
        bits2 = next >>> 0;
      }
      finalBlock.putInt32(bits2);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3,
        h4: _state.h4,
        h5: _state.h5,
        h6: _state.h6,
        h7: _state.h7
      };
      _update$2(s2, _w, finalBlock);
      var rval = forge$a.util.createBuffer();
      rval.putInt32(s2.h0);
      rval.putInt32(s2.h1);
      rval.putInt32(s2.h2);
      rval.putInt32(s2.h3);
      rval.putInt32(s2.h4);
      rval.putInt32(s2.h5);
      rval.putInt32(s2.h6);
      rval.putInt32(s2.h7);
      return rval;
    };
    return md;
  };
  var _padding$2 = null;
  var _initialized$2 = false;
  var _k$1 = null;
  var forge$9 = forge$m;
  var _crypto$1 = null;
  if (forge$9.util.isNodejs && !forge$9.options.usePureJavaScript && !process.versions["node-webkit"]) {
    _crypto$1 = require$$1;
  }
  var prng = forge$9.prng = forge$9.prng || {};
  prng.create = function(plugin) {
    var ctx = {
      plugin,
      key: null,
      seed: null,
      time: null,
      reseeds: 0,
      generated: 0,
      keyBytes: ""
    };
    var md = plugin.md;
    var pools = new Array(32);
    for (var i = 0;i < 32; ++i) {
      pools[i] = md.create();
    }
    ctx.pools = pools;
    ctx.pool = 0;
    ctx.generate = function(count, callback) {
      if (!callback) {
        return ctx.generateSync(count);
      }
      var cipher = ctx.plugin.cipher;
      var increment2 = ctx.plugin.increment;
      var formatKey = ctx.plugin.formatKey;
      var formatSeed = ctx.plugin.formatSeed;
      var b = forge$9.util.createBuffer();
      ctx.key = null;
      generate();
      function generate(err) {
        if (err) {
          return callback(err);
        }
        if (b.length() >= count) {
          return callback(null, b.getBytes(count));
        }
        if (ctx.generated > 1048575) {
          ctx.key = null;
        }
        if (ctx.key === null) {
          return forge$9.util.nextTick(function() {
            _reseed(generate);
          });
        }
        var bytes2 = cipher(ctx.key, ctx.seed);
        ctx.generated += bytes2.length;
        b.putBytes(bytes2);
        ctx.key = formatKey(cipher(ctx.key, increment2(ctx.seed)));
        ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        forge$9.util.setImmediate(generate);
      }
    };
    ctx.generateSync = function(count) {
      var cipher = ctx.plugin.cipher;
      var increment2 = ctx.plugin.increment;
      var formatKey = ctx.plugin.formatKey;
      var formatSeed = ctx.plugin.formatSeed;
      ctx.key = null;
      var b = forge$9.util.createBuffer();
      while (b.length() < count) {
        if (ctx.generated > 1048575) {
          ctx.key = null;
        }
        if (ctx.key === null) {
          _reseedSync();
        }
        var bytes2 = cipher(ctx.key, ctx.seed);
        ctx.generated += bytes2.length;
        b.putBytes(bytes2);
        ctx.key = formatKey(cipher(ctx.key, increment2(ctx.seed)));
        ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      }
      return b.getBytes(count);
    };
    function _reseed(callback) {
      if (ctx.pools[0].messageLength >= 32) {
        _seed();
        return callback();
      }
      var needed = 32 - ctx.pools[0].messageLength << 5;
      ctx.seedFile(needed, function(err, bytes2) {
        if (err) {
          return callback(err);
        }
        ctx.collect(bytes2);
        _seed();
        callback();
      });
    }
    function _reseedSync() {
      if (ctx.pools[0].messageLength >= 32) {
        return _seed();
      }
      var needed = 32 - ctx.pools[0].messageLength << 5;
      ctx.collect(ctx.seedFileSync(needed));
      _seed();
    }
    function _seed() {
      ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
      var md2 = ctx.plugin.md.create();
      md2.update(ctx.keyBytes);
      var _2powK = 1;
      for (var k = 0;k < 32; ++k) {
        if (ctx.reseeds % _2powK === 0) {
          md2.update(ctx.pools[k].digest().getBytes());
          ctx.pools[k].start();
        }
        _2powK = _2powK << 1;
      }
      ctx.keyBytes = md2.digest().getBytes();
      md2.start();
      md2.update(ctx.keyBytes);
      var seedBytes = md2.digest().getBytes();
      ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
      ctx.seed = ctx.plugin.formatSeed(seedBytes);
      ctx.generated = 0;
    }
    function defaultSeedFile(needed) {
      var getRandomValues2 = null;
      var globalScope = forge$9.util.globalScope;
      var _crypto2 = globalScope.crypto || globalScope.msCrypto;
      if (_crypto2 && _crypto2.getRandomValues) {
        getRandomValues2 = function(arr) {
          return _crypto2.getRandomValues(arr);
        };
      }
      var b = forge$9.util.createBuffer();
      if (getRandomValues2) {
        while (b.length() < needed) {
          var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
          var entropy = new Uint32Array(Math.floor(count));
          try {
            getRandomValues2(entropy);
            for (var i2 = 0;i2 < entropy.length; ++i2) {
              b.putInt32(entropy[i2]);
            }
          } catch (e) {
            if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
              throw e;
            }
          }
        }
      }
      if (b.length() < needed) {
        var hi, lo, next;
        var seed = Math.floor(Math.random() * 65536);
        while (b.length() < needed) {
          lo = 16807 * (seed & 65535);
          hi = 16807 * (seed >> 16);
          lo += (hi & 32767) << 16;
          lo += hi >> 15;
          lo = (lo & 2147483647) + (lo >> 31);
          seed = lo & 4294967295;
          for (var i2 = 0;i2 < 3; ++i2) {
            next = seed >>> (i2 << 3);
            next ^= Math.floor(Math.random() * 256);
            b.putByte(next & 255);
          }
        }
      }
      return b.getBytes(needed);
    }
    if (_crypto$1) {
      ctx.seedFile = function(needed, callback) {
        _crypto$1.randomBytes(needed, function(err, bytes2) {
          if (err) {
            return callback(err);
          }
          callback(null, bytes2.toString());
        });
      };
      ctx.seedFileSync = function(needed) {
        return _crypto$1.randomBytes(needed).toString();
      };
    } else {
      ctx.seedFile = function(needed, callback) {
        try {
          callback(null, defaultSeedFile(needed));
        } catch (e) {
          callback(e);
        }
      };
      ctx.seedFileSync = defaultSeedFile;
    }
    ctx.collect = function(bytes2) {
      var count = bytes2.length;
      for (var i2 = 0;i2 < count; ++i2) {
        ctx.pools[ctx.pool].update(bytes2.substr(i2, 1));
        ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
      }
    };
    ctx.collectInt = function(i2, n) {
      var bytes2 = "";
      for (var x = 0;x < n; x += 8) {
        bytes2 += String.fromCharCode(i2 >> x & 255);
      }
      ctx.collect(bytes2);
    };
    ctx.registerWorker = function(worker) {
      if (worker === self) {
        ctx.seedFile = function(needed, callback) {
          function listener2(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              self.removeEventListener("message", listener2);
              callback(data.forge.prng.err, data.forge.prng.bytes);
            }
          }
          self.addEventListener("message", listener2);
          self.postMessage({ forge: { prng: { needed } } });
        };
      } else {
        var listener = function(e) {
          var data = e.data;
          if (data.forge && data.forge.prng) {
            ctx.seedFile(data.forge.prng.needed, function(err, bytes2) {
              worker.postMessage({ forge: { prng: { err, bytes: bytes2 } } });
            });
          }
        };
        worker.addEventListener("message", listener);
      }
    };
    return ctx;
  };
  var forge$8 = forge$m;
  (function() {
    if (forge$8.random && forge$8.random.getBytes) {
      forge$8.random;
      return;
    }
    (function(jQuery2) {
      var prng_aes = {};
      var _prng_aes_output = new Array(4);
      var _prng_aes_buffer = forge$8.util.createBuffer();
      prng_aes.formatKey = function(key2) {
        var tmp = forge$8.util.createBuffer(key2);
        key2 = new Array(4);
        key2[0] = tmp.getInt32();
        key2[1] = tmp.getInt32();
        key2[2] = tmp.getInt32();
        key2[3] = tmp.getInt32();
        return forge$8.aes._expandKey(key2, false);
      };
      prng_aes.formatSeed = function(seed) {
        var tmp = forge$8.util.createBuffer(seed);
        seed = new Array(4);
        seed[0] = tmp.getInt32();
        seed[1] = tmp.getInt32();
        seed[2] = tmp.getInt32();
        seed[3] = tmp.getInt32();
        return seed;
      };
      prng_aes.cipher = function(key2, seed) {
        forge$8.aes._updateBlock(key2, seed, _prng_aes_output, false);
        _prng_aes_buffer.putInt32(_prng_aes_output[0]);
        _prng_aes_buffer.putInt32(_prng_aes_output[1]);
        _prng_aes_buffer.putInt32(_prng_aes_output[2]);
        _prng_aes_buffer.putInt32(_prng_aes_output[3]);
        return _prng_aes_buffer.getBytes();
      };
      prng_aes.increment = function(seed) {
        ++seed[3];
        return seed;
      };
      prng_aes.md = forge$8.md.sha256;
      function spawnPrng() {
        var ctx = forge$8.prng.create(prng_aes);
        ctx.getBytes = function(count, callback) {
          return ctx.generate(count, callback);
        };
        ctx.getBytesSync = function(count) {
          return ctx.generate(count);
        };
        return ctx;
      }
      var _ctx = spawnPrng();
      var getRandomValues2 = null;
      var globalScope = forge$8.util.globalScope;
      var _crypto2 = globalScope.crypto || globalScope.msCrypto;
      if (_crypto2 && _crypto2.getRandomValues) {
        getRandomValues2 = function(arr) {
          return _crypto2.getRandomValues(arr);
        };
      }
      if (forge$8.options.usePureJavaScript || !forge$8.util.isNodejs && !getRandomValues2) {
        _ctx.collectInt(+new Date, 32);
        if (typeof navigator !== "undefined") {
          var _navBytes = "";
          for (var key in navigator) {
            try {
              if (typeof navigator[key] == "string") {
                _navBytes += navigator[key];
              }
            } catch (e) {
            }
          }
          _ctx.collect(_navBytes);
          _navBytes = null;
        }
        if (jQuery2) {
          jQuery2().mousemove(function(e) {
            _ctx.collectInt(e.clientX, 16);
            _ctx.collectInt(e.clientY, 16);
          });
          jQuery2().keypress(function(e) {
            _ctx.collectInt(e.charCode, 8);
          });
        }
      }
      if (!forge$8.random) {
        forge$8.random = _ctx;
      } else {
        for (var key in _ctx) {
          forge$8.random[key] = _ctx[key];
        }
      }
      forge$8.random.createInstance = spawnPrng;
      forge$8.random;
    })(typeof jQuery !== "undefined" ? jQuery : null);
  })();
  var forge$7 = forge$m;
  var piTable = [
    217,
    120,
    249,
    196,
    25,
    221,
    181,
    237,
    40,
    233,
    253,
    121,
    74,
    160,
    216,
    157,
    198,
    126,
    55,
    131,
    43,
    118,
    83,
    142,
    98,
    76,
    100,
    136,
    68,
    139,
    251,
    162,
    23,
    154,
    89,
    245,
    135,
    179,
    79,
    19,
    97,
    69,
    109,
    141,
    9,
    129,
    125,
    50,
    189,
    143,
    64,
    235,
    134,
    183,
    123,
    11,
    240,
    149,
    33,
    34,
    92,
    107,
    78,
    130,
    84,
    214,
    101,
    147,
    206,
    96,
    178,
    28,
    115,
    86,
    192,
    20,
    167,
    140,
    241,
    220,
    18,
    117,
    202,
    31,
    59,
    190,
    228,
    209,
    66,
    61,
    212,
    48,
    163,
    60,
    182,
    38,
    111,
    191,
    14,
    218,
    70,
    105,
    7,
    87,
    39,
    242,
    29,
    155,
    188,
    148,
    67,
    3,
    248,
    17,
    199,
    246,
    144,
    239,
    62,
    231,
    6,
    195,
    213,
    47,
    200,
    102,
    30,
    215,
    8,
    232,
    234,
    222,
    128,
    82,
    238,
    247,
    132,
    170,
    114,
    172,
    53,
    77,
    106,
    42,
    150,
    26,
    210,
    113,
    90,
    21,
    73,
    116,
    75,
    159,
    208,
    94,
    4,
    24,
    164,
    236,
    194,
    224,
    65,
    110,
    15,
    81,
    203,
    204,
    36,
    145,
    175,
    80,
    161,
    244,
    112,
    57,
    153,
    124,
    58,
    133,
    35,
    184,
    180,
    122,
    252,
    2,
    54,
    91,
    37,
    85,
    151,
    49,
    45,
    93,
    250,
    152,
    227,
    138,
    146,
    174,
    5,
    223,
    41,
    16,
    103,
    108,
    186,
    201,
    211,
    0,
    230,
    207,
    225,
    158,
    168,
    44,
    99,
    22,
    1,
    63,
    88,
    226,
    137,
    169,
    13,
    56,
    52,
    27,
    171,
    51,
    255,
    176,
    187,
    72,
    12,
    95,
    185,
    177,
    205,
    46,
    197,
    243,
    219,
    71,
    229,
    165,
    156,
    119,
    10,
    166,
    32,
    104,
    254,
    127,
    193,
    173
  ];
  var s = [1, 2, 3, 5];
  var rol = function(word2, bits2) {
    return word2 << bits2 & 65535 | (word2 & 65535) >> 16 - bits2;
  };
  var ror = function(word2, bits2) {
    return (word2 & 65535) >> bits2 | word2 << 16 - bits2 & 65535;
  };
  forge$7.rc2 = forge$7.rc2 || {};
  forge$7.rc2.expandKey = function(key, effKeyBits) {
    if (typeof key === "string") {
      key = forge$7.util.createBuffer(key);
    }
    effKeyBits = effKeyBits || 128;
    var L = key;
    var T = key.length();
    var T1 = effKeyBits;
    var T8 = Math.ceil(T1 / 8);
    var TM = 255 >> (T1 & 7);
    var i;
    for (i = T;i < 128; i++) {
      L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
    }
    L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
    for (i = 127 - T8;i >= 0; i--) {
      L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
    }
    return L;
  };
  var createCipher = function(key, bits2, encrypt2) {
    var _finish = false, _input = null, _output = null, _iv = null;
    var mixRound, mashRound;
    var i, j, K = [];
    key = forge$7.rc2.expandKey(key, bits2);
    for (i = 0;i < 64; i++) {
      K.push(key.getInt16Le());
    }
    if (encrypt2) {
      mixRound = function(R2) {
        for (i = 0;i < 4; i++) {
          R2[i] += K[j] + (R2[(i + 3) % 4] & R2[(i + 2) % 4]) + (~R2[(i + 3) % 4] & R2[(i + 1) % 4]);
          R2[i] = rol(R2[i], s[i]);
          j++;
        }
      };
      mashRound = function(R2) {
        for (i = 0;i < 4; i++) {
          R2[i] += K[R2[(i + 3) % 4] & 63];
        }
      };
    } else {
      mixRound = function(R2) {
        for (i = 3;i >= 0; i--) {
          R2[i] = ror(R2[i], s[i]);
          R2[i] -= K[j] + (R2[(i + 3) % 4] & R2[(i + 2) % 4]) + (~R2[(i + 3) % 4] & R2[(i + 1) % 4]);
          j--;
        }
      };
      mashRound = function(R2) {
        for (i = 3;i >= 0; i--) {
          R2[i] -= K[R2[(i + 3) % 4] & 63];
        }
      };
    }
    var runPlan = function(plan) {
      var R2 = [];
      for (i = 0;i < 4; i++) {
        var val = _input.getInt16Le();
        if (_iv !== null) {
          if (encrypt2) {
            val ^= _iv.getInt16Le();
          } else {
            _iv.putInt16Le(val);
          }
        }
        R2.push(val & 65535);
      }
      j = encrypt2 ? 0 : 63;
      for (var ptr = 0;ptr < plan.length; ptr++) {
        for (var ctr = 0;ctr < plan[ptr][0]; ctr++) {
          plan[ptr][1](R2);
        }
      }
      for (i = 0;i < 4; i++) {
        if (_iv !== null) {
          if (encrypt2) {
            _iv.putInt16Le(R2[i]);
          } else {
            R2[i] ^= _iv.getInt16Le();
          }
        }
        _output.putInt16Le(R2[i]);
      }
    };
    var cipher = null;
    cipher = {
      start: function(iv, output2) {
        if (iv) {
          if (typeof iv === "string") {
            iv = forge$7.util.createBuffer(iv);
          }
        }
        _finish = false;
        _input = forge$7.util.createBuffer();
        _output = output2 || new forge$7.util.createBuffer;
        _iv = iv;
        cipher.output = _output;
      },
      update: function(input) {
        if (!_finish) {
          _input.putBuffer(input);
        }
        while (_input.length() >= 8) {
          runPlan([
            [5, mixRound],
            [1, mashRound],
            [6, mixRound],
            [1, mashRound],
            [5, mixRound]
          ]);
        }
      },
      finish: function(pad) {
        var rval = true;
        if (encrypt2) {
          if (pad) {
            rval = pad(8, _input, !encrypt2);
          } else {
            var padding = _input.length() === 8 ? 8 : 8 - _input.length();
            _input.fillWithByte(padding, padding);
          }
        }
        if (rval) {
          _finish = true;
          cipher.update();
        }
        if (!encrypt2) {
          rval = _input.length() === 0;
          if (rval) {
            if (pad) {
              rval = pad(8, _output, !encrypt2);
            } else {
              var len = _output.length();
              var count = _output.at(len - 1);
              if (count > len) {
                rval = false;
              } else {
                _output.truncate(count);
              }
            }
          }
        }
        return rval;
      }
    };
    return cipher;
  };
  forge$7.rc2.startEncrypting = function(key, iv, output2) {
    var cipher = forge$7.rc2.createEncryptionCipher(key, 128);
    cipher.start(iv, output2);
    return cipher;
  };
  forge$7.rc2.createEncryptionCipher = function(key, bits2) {
    return createCipher(key, bits2, true);
  };
  forge$7.rc2.startDecrypting = function(key, iv, output2) {
    var cipher = forge$7.rc2.createDecryptionCipher(key, 128);
    cipher.start(iv, output2);
    return cipher;
  };
  forge$7.rc2.createDecryptionCipher = function(key, bits2) {
    return createCipher(key, bits2, false);
  };
  var forge$6 = forge$m;
  forge$6.jsbn = forge$6.jsbn || {};
  var dbits;
  forge$6.jsbn.BigInteger = BigInteger$2;
  if (typeof navigator === "undefined") {
    BigInteger$2.prototype.am = am3;
    dbits = 28;
  } else if (navigator.appName == "Microsoft Internet Explorer") {
    BigInteger$2.prototype.am = am2;
    dbits = 30;
  } else if (navigator.appName != "Netscape") {
    BigInteger$2.prototype.am = am1;
    dbits = 26;
  } else {
    BigInteger$2.prototype.am = am3;
    dbits = 28;
  }
  BigInteger$2.prototype.DB = dbits;
  BigInteger$2.prototype.DM = (1 << dbits) - 1;
  BigInteger$2.prototype.DV = 1 << dbits;
  var BI_FP = 52;
  BigInteger$2.prototype.FV = Math.pow(2, BI_FP);
  BigInteger$2.prototype.F1 = BI_FP - dbits;
  BigInteger$2.prototype.F2 = 2 * dbits - BI_FP;
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array;
  var rr;
  var vv;
  rr = "0".charCodeAt(0);
  for (vv = 0;vv <= 9; ++vv)
    BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10;vv < 36; ++vv)
    BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10;vv < 36; ++vv)
    BI_RC[rr++] = vv;
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  BigInteger$2.prototype.copyTo = bnpCopyTo;
  BigInteger$2.prototype.fromInt = bnpFromInt;
  BigInteger$2.prototype.fromString = bnpFromString;
  BigInteger$2.prototype.clamp = bnpClamp;
  BigInteger$2.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger$2.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger$2.prototype.lShiftTo = bnpLShiftTo;
  BigInteger$2.prototype.rShiftTo = bnpRShiftTo;
  BigInteger$2.prototype.subTo = bnpSubTo;
  BigInteger$2.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger$2.prototype.squareTo = bnpSquareTo;
  BigInteger$2.prototype.divRemTo = bnpDivRemTo;
  BigInteger$2.prototype.invDigit = bnpInvDigit;
  BigInteger$2.prototype.isEven = bnpIsEven;
  BigInteger$2.prototype.exp = bnpExp;
  BigInteger$2.prototype.toString = bnToString;
  BigInteger$2.prototype.negate = bnNegate;
  BigInteger$2.prototype.abs = bnAbs;
  BigInteger$2.prototype.compareTo = bnCompareTo;
  BigInteger$2.prototype.bitLength = bnBitLength;
  BigInteger$2.prototype.mod = bnMod;
  BigInteger$2.prototype.modPowInt = bnModPowInt;
  BigInteger$2.ZERO = nbv(0);
  BigInteger$2.ONE = nbv(1);
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  BigInteger$2.prototype.chunkSize = bnpChunkSize;
  BigInteger$2.prototype.toRadix = bnpToRadix;
  BigInteger$2.prototype.fromRadix = bnpFromRadix;
  BigInteger$2.prototype.fromNumber = bnpFromNumber;
  BigInteger$2.prototype.bitwiseTo = bnpBitwiseTo;
  BigInteger$2.prototype.changeBit = bnpChangeBit;
  BigInteger$2.prototype.addTo = bnpAddTo;
  BigInteger$2.prototype.dMultiply = bnpDMultiply;
  BigInteger$2.prototype.dAddOffset = bnpDAddOffset;
  BigInteger$2.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
  BigInteger$2.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
  BigInteger$2.prototype.modInt = bnpModInt;
  BigInteger$2.prototype.millerRabin = bnpMillerRabin;
  BigInteger$2.prototype.clone = bnClone;
  BigInteger$2.prototype.intValue = bnIntValue;
  BigInteger$2.prototype.byteValue = bnByteValue;
  BigInteger$2.prototype.shortValue = bnShortValue;
  BigInteger$2.prototype.signum = bnSigNum;
  BigInteger$2.prototype.toByteArray = bnToByteArray;
  BigInteger$2.prototype.equals = bnEquals;
  BigInteger$2.prototype.min = bnMin;
  BigInteger$2.prototype.max = bnMax;
  BigInteger$2.prototype.and = bnAnd;
  BigInteger$2.prototype.or = bnOr;
  BigInteger$2.prototype.xor = bnXor;
  BigInteger$2.prototype.andNot = bnAndNot;
  BigInteger$2.prototype.not = bnNot;
  BigInteger$2.prototype.shiftLeft = bnShiftLeft;
  BigInteger$2.prototype.shiftRight = bnShiftRight;
  BigInteger$2.prototype.getLowestSetBit = bnGetLowestSetBit;
  BigInteger$2.prototype.bitCount = bnBitCount;
  BigInteger$2.prototype.testBit = bnTestBit;
  BigInteger$2.prototype.setBit = bnSetBit;
  BigInteger$2.prototype.clearBit = bnClearBit;
  BigInteger$2.prototype.flipBit = bnFlipBit;
  BigInteger$2.prototype.add = bnAdd;
  BigInteger$2.prototype.subtract = bnSubtract;
  BigInteger$2.prototype.multiply = bnMultiply;
  BigInteger$2.prototype.divide = bnDivide;
  BigInteger$2.prototype.remainder = bnRemainder;
  BigInteger$2.prototype.divideAndRemainder = bnDivideAndRemainder;
  BigInteger$2.prototype.modPow = bnModPow;
  BigInteger$2.prototype.modInverse = bnModInverse;
  BigInteger$2.prototype.pow = bnPow;
  BigInteger$2.prototype.gcd = bnGCD;
  BigInteger$2.prototype.isProbablePrime = bnIsProbablePrime;
  var forge$5 = forge$m;
  var sha1 = forge$5.sha1 = forge$5.sha1 || {};
  forge$5.md.sha1 = forge$5.md.algorithms.sha1 = sha1;
  sha1.create = function() {
    if (!_initialized$1) {
      _init$1();
    }
    var _state = null;
    var _input = forge$5.util.createBuffer();
    var _w = new Array(80);
    var md = {
      algorithm: "sha1",
      blockLength: 64,
      digestLength: 20,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 8
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength64 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0;i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge$5.util.createBuffer();
      _state = {
        h0: 1732584193,
        h1: 4023233417,
        h2: 2562383102,
        h3: 271733878,
        h4: 3285377520
      };
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge$5.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1;i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update$1(_state, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge$5.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding$1.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits2 = md.fullMessageLength[0] * 8;
      for (var i = 0;i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits2 += carry;
        finalBlock.putInt32(bits2 >>> 0);
        bits2 = next >>> 0;
      }
      finalBlock.putInt32(bits2);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3,
        h4: _state.h4
      };
      _update$1(s2, _w, finalBlock);
      var rval = forge$5.util.createBuffer();
      rval.putInt32(s2.h0);
      rval.putInt32(s2.h1);
      rval.putInt32(s2.h2);
      rval.putInt32(s2.h3);
      rval.putInt32(s2.h4);
      return rval;
    };
    return md;
  };
  var _padding$1 = null;
  var _initialized$1 = false;
  var forge$4 = forge$m;
  var pkcs1 = forge$4.pkcs1 = forge$4.pkcs1 || {};
  pkcs1.encode_rsa_oaep = function(key, message2, options) {
    var label;
    var seed;
    var md;
    var mgf1Md;
    if (typeof options === "string") {
      label = options;
      seed = arguments[3] || undefined;
      md = arguments[4] || undefined;
    } else if (options) {
      label = options.label || undefined;
      seed = options.seed || undefined;
      md = options.md || undefined;
      if (options.mgf1 && options.mgf1.md) {
        mgf1Md = options.mgf1.md;
      }
    }
    if (!md) {
      md = forge$4.md.sha1.create();
    } else {
      md.start();
    }
    if (!mgf1Md) {
      mgf1Md = md;
    }
    var keyLength = Math.ceil(key.n.bitLength() / 8);
    var maxLength = keyLength - 2 * md.digestLength - 2;
    if (message2.length > maxLength) {
      var error = new Error("RSAES-OAEP input message length is too long.");
      error.length = message2.length;
      error.maxLength = maxLength;
      throw error;
    }
    if (!label) {
      label = "";
    }
    md.update(label, "raw");
    var lHash = md.digest();
    var PS = "";
    var PS_length = maxLength - message2.length;
    for (var i = 0;i < PS_length; i++) {
      PS += "\0";
    }
    var DB = lHash.getBytes() + PS + "\x01" + message2;
    if (!seed) {
      seed = forge$4.random.getBytes(md.digestLength);
    } else if (seed.length !== md.digestLength) {
      var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
      error.seedLength = seed.length;
      error.digestLength = md.digestLength;
      throw error;
    }
    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
    var maskedDB = forge$4.util.xorBytes(DB, dbMask, DB.length);
    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
    var maskedSeed = forge$4.util.xorBytes(seed, seedMask, seed.length);
    return "\0" + maskedSeed + maskedDB;
  };
  pkcs1.decode_rsa_oaep = function(key, em, options) {
    var label;
    var md;
    var mgf1Md;
    if (typeof options === "string") {
      label = options;
      md = arguments[3] || undefined;
    } else if (options) {
      label = options.label || undefined;
      md = options.md || undefined;
      if (options.mgf1 && options.mgf1.md) {
        mgf1Md = options.mgf1.md;
      }
    }
    var keyLength = Math.ceil(key.n.bitLength() / 8);
    if (em.length !== keyLength) {
      var error = new Error("RSAES-OAEP encoded message length is invalid.");
      error.length = em.length;
      error.expectedLength = keyLength;
      throw error;
    }
    if (md === undefined) {
      md = forge$4.md.sha1.create();
    } else {
      md.start();
    }
    if (!mgf1Md) {
      mgf1Md = md;
    }
    if (keyLength < 2 * md.digestLength + 2) {
      throw new Error("RSAES-OAEP key is too short for the hash function.");
    }
    if (!label) {
      label = "";
    }
    md.update(label, "raw");
    var lHash = md.digest().getBytes();
    var y = em.charAt(0);
    var maskedSeed = em.substring(1, md.digestLength + 1);
    var maskedDB = em.substring(1 + md.digestLength);
    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
    var seed = forge$4.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
    var db = forge$4.util.xorBytes(maskedDB, dbMask, maskedDB.length);
    var lHashPrime = db.substring(0, md.digestLength);
    var error = y !== "\0";
    for (var i = 0;i < md.digestLength; ++i) {
      error |= lHash.charAt(i) !== lHashPrime.charAt(i);
    }
    var in_ps = 1;
    var index2 = md.digestLength;
    for (var j = md.digestLength;j < db.length; j++) {
      var code2 = db.charCodeAt(j);
      var is_0 = code2 & 1 ^ 1;
      var error_mask = in_ps ? 65534 : 0;
      error |= code2 & error_mask;
      in_ps = in_ps & is_0;
      index2 += in_ps;
    }
    if (error || db.charCodeAt(index2) !== 1) {
      throw new Error("Invalid RSAES-OAEP padding.");
    }
    return db.substring(index2 + 1);
  };
  var forge$3 = forge$m;
  (function() {
    if (forge$3.prime) {
      forge$3.prime;
      return;
    }
    var prime = forge$3.prime = forge$3.prime || {};
    var BigInteger2 = forge$3.jsbn.BigInteger;
    var GCD_30_DELTA2 = [6, 4, 2, 4, 2, 4, 6, 2];
    var THIRTY = new BigInteger2(null);
    THIRTY.fromInt(30);
    var op_or2 = function(x, y) {
      return x | y;
    };
    prime.generateProbablePrime = function(bits2, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var algorithm = options.algorithm || "PRIMEINC";
      if (typeof algorithm === "string") {
        algorithm = { name: algorithm };
      }
      algorithm.options = algorithm.options || {};
      var prng2 = options.prng || forge$3.random;
      var rng2 = {
        nextBytes: function(x) {
          var b = prng2.getBytesSync(x.length);
          for (var i = 0;i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      if (algorithm.name === "PRIMEINC") {
        return primeincFindPrime(bits2, rng2, algorithm.options, callback);
      }
      throw new Error("Invalid prime generation algorithm: " + algorithm.name);
    };
    function primeincFindPrime(bits2, rng2, options, callback) {
      if ("workers" in options) {
        return primeincFindPrimeWithWorkers(bits2, rng2, options, callback);
      }
      return primeincFindPrimeWithoutWorkers(bits2, rng2, options, callback);
    }
    function primeincFindPrimeWithoutWorkers(bits2, rng2, options, callback) {
      var num = generateRandom(bits2, rng2);
      var deltaIdx = 0;
      var mrTests = getMillerRabinTests(num.bitLength());
      if ("millerRabinTests" in options) {
        mrTests = options.millerRabinTests;
      }
      var maxBlockTime = 10;
      if ("maxBlockTime" in options) {
        maxBlockTime = options.maxBlockTime;
      }
      _primeinc(num, bits2, rng2, deltaIdx, mrTests, maxBlockTime, callback);
    }
    function _primeinc(num, bits2, rng2, deltaIdx, mrTests, maxBlockTime, callback) {
      var start = +new Date;
      do {
        if (num.bitLength() > bits2) {
          num = generateRandom(bits2, rng2);
        }
        if (num.isProbablePrime(mrTests)) {
          return callback(null, num);
        }
        num.dAddOffset(GCD_30_DELTA2[deltaIdx++ % 8], 0);
      } while (maxBlockTime < 0 || +new Date - start < maxBlockTime);
      forge$3.util.setImmediate(function() {
        _primeinc(num, bits2, rng2, deltaIdx, mrTests, maxBlockTime, callback);
      });
    }
    function primeincFindPrimeWithWorkers(bits2, rng2, options, callback) {
      if (typeof Worker === "undefined") {
        return primeincFindPrimeWithoutWorkers(bits2, rng2, options, callback);
      }
      var num = generateRandom(bits2, rng2);
      var numWorkers = options.workers;
      var workLoad = options.workLoad || 100;
      var range = workLoad * 30 / 8;
      var workerScript = options.workerScript || "forge/prime.worker.js";
      if (numWorkers === -1) {
        return forge$3.util.estimateCores(function(err, cores) {
          if (err) {
            cores = 2;
          }
          numWorkers = cores - 1;
          generate();
        });
      }
      generate();
      function generate() {
        numWorkers = Math.max(1, numWorkers);
        var workers = [];
        for (var i = 0;i < numWorkers; ++i) {
          workers[i] = new Worker(workerScript);
        }
        for (var i = 0;i < numWorkers; ++i) {
          workers[i].addEventListener("message", workerMessage);
        }
        var found = false;
        function workerMessage(e) {
          if (found) {
            return;
          }
          var data = e.data;
          if (data.found) {
            for (var i2 = 0;i2 < workers.length; ++i2) {
              workers[i2].terminate();
            }
            found = true;
            return callback(null, new BigInteger2(data.prime, 16));
          }
          if (num.bitLength() > bits2) {
            num = generateRandom(bits2, rng2);
          }
          var hex = num.toString(16);
          e.target.postMessage({
            hex,
            workLoad
          });
          num.dAddOffset(range, 0);
        }
      }
    }
    function generateRandom(bits2, rng2) {
      var num = new BigInteger2(bits2, rng2);
      var bits1 = bits2 - 1;
      if (!num.testBit(bits1)) {
        num.bitwiseTo(BigInteger2.ONE.shiftLeft(bits1), op_or2, num);
      }
      num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
      return num;
    }
    function getMillerRabinTests(bits2) {
      if (bits2 <= 100)
        return 27;
      if (bits2 <= 150)
        return 18;
      if (bits2 <= 200)
        return 15;
      if (bits2 <= 250)
        return 12;
      if (bits2 <= 300)
        return 9;
      if (bits2 <= 350)
        return 8;
      if (bits2 <= 400)
        return 7;
      if (bits2 <= 500)
        return 6;
      if (bits2 <= 600)
        return 5;
      if (bits2 <= 800)
        return 4;
      if (bits2 <= 1250)
        return 3;
      return 2;
    }
  })();
  var forge$2 = forge$m;
  if (typeof BigInteger$1 === "undefined") {
    BigInteger$1 = forge$2.jsbn.BigInteger;
  }
  var BigInteger$1;
  var _crypto = forge$2.util.isNodejs ? require$$1 : null;
  var asn1$1 = forge$2.asn1;
  var util$1 = forge$2.util;
  forge$2.pki = forge$2.pki || {};
  forge$2.pki.rsa = forge$2.rsa = forge$2.rsa || {};
  var pki$1 = forge$2.pki;
  var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
  var privateKeyValidator = {
    name: "PrivateKeyInfo",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PrivateKeyInfo.version",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyVersion"
    }, {
      name: "PrivateKeyInfo.privateKeyAlgorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "privateKeyOid"
      }]
    }, {
      name: "PrivateKeyInfo",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OCTETSTRING,
      constructed: false,
      capture: "privateKey"
    }]
  };
  var rsaPrivateKeyValidator = {
    name: "RSAPrivateKey",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RSAPrivateKey.version",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyVersion"
    }, {
      name: "RSAPrivateKey.modulus",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyModulus"
    }, {
      name: "RSAPrivateKey.publicExponent",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPublicExponent"
    }, {
      name: "RSAPrivateKey.privateExponent",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrivateExponent"
    }, {
      name: "RSAPrivateKey.prime1",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrime1"
    }, {
      name: "RSAPrivateKey.prime2",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrime2"
    }, {
      name: "RSAPrivateKey.exponent1",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyExponent1"
    }, {
      name: "RSAPrivateKey.exponent2",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyExponent2"
    }, {
      name: "RSAPrivateKey.coefficient",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyCoefficient"
    }]
  };
  var rsaPublicKeyValidator = {
    name: "RSAPublicKey",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RSAPublicKey.modulus",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "publicKeyModulus"
    }, {
      name: "RSAPublicKey.exponent",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.INTEGER,
      constructed: false,
      capture: "publicKeyExponent"
    }]
  };
  var publicKeyValidator = forge$2.pki.rsa.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "subjectPublicKeyInfo",
    value: [{
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "publicKeyOid"
      }]
    }, {
      name: "SubjectPublicKeyInfo.subjectPublicKey",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.BITSTRING,
      constructed: false,
      value: [{
        name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: "rsaPublicKey"
      }]
    }]
  };
  var digestInfoValidator = {
    name: "DigestInfo",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "DigestInfo.DigestAlgorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "algorithmIdentifier"
      }, {
        name: "DigestInfo.DigestAlgorithm.parameters",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.NULL,
        capture: "parameters",
        optional: true,
        constructed: false
      }]
    }, {
      name: "DigestInfo.digest",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OCTETSTRING,
      constructed: false,
      capture: "digest"
    }]
  };
  var emsaPkcs1v15encode = function(md) {
    var oid;
    if (md.algorithm in pki$1.oids) {
      oid = pki$1.oids[md.algorithm];
    } else {
      var error = new Error("Unknown message digest algorithm.");
      error.algorithm = md.algorithm;
      throw error;
    }
    var oidBytes = asn1$1.oidToDer(oid).getBytes();
    var digestInfo = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, []);
    var digestAlgorithm = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, []);
    digestAlgorithm.value.push(asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, oidBytes));
    digestAlgorithm.value.push(asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, false, ""));
    var digest2 = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, md.digest().getBytes());
    digestInfo.value.push(digestAlgorithm);
    digestInfo.value.push(digest2);
    return asn1$1.toDer(digestInfo).getBytes();
  };
  var _modPow = function(x, key, pub) {
    if (pub) {
      return x.modPow(key.e, key.n);
    }
    if (!key.p || !key.q) {
      return x.modPow(key.d, key.n);
    }
    if (!key.dP) {
      key.dP = key.d.mod(key.p.subtract(BigInteger$1.ONE));
    }
    if (!key.dQ) {
      key.dQ = key.d.mod(key.q.subtract(BigInteger$1.ONE));
    }
    if (!key.qInv) {
      key.qInv = key.q.modInverse(key.p);
    }
    var r;
    do {
      r = new BigInteger$1(forge$2.util.bytesToHex(forge$2.random.getBytes(key.n.bitLength() / 8)), 16);
    } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger$1.ONE));
    x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
    var xp = x.mod(key.p).modPow(key.dP, key.p);
    var xq = x.mod(key.q).modPow(key.dQ, key.q);
    while (xp.compareTo(xq) < 0) {
      xp = xp.add(key.p);
    }
    var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
    y = y.multiply(r.modInverse(key.n)).mod(key.n);
    return y;
  };
  pki$1.rsa.encrypt = function(m, key, bt) {
    var pub = bt;
    var eb;
    var k = Math.ceil(key.n.bitLength() / 8);
    if (bt !== false && bt !== true) {
      pub = bt === 2;
      eb = _encodePkcs1_v1_5(m, key, bt);
    } else {
      eb = forge$2.util.createBuffer();
      eb.putBytes(m);
    }
    var x = new BigInteger$1(eb.toHex(), 16);
    var y = _modPow(x, key, pub);
    var yhex = y.toString(16);
    var ed = forge$2.util.createBuffer();
    var zeros = k - Math.ceil(yhex.length / 2);
    while (zeros > 0) {
      ed.putByte(0);
      --zeros;
    }
    ed.putBytes(forge$2.util.hexToBytes(yhex));
    return ed.getBytes();
  };
  pki$1.rsa.decrypt = function(ed, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8);
    if (ed.length !== k) {
      var error = new Error("Encrypted message length is invalid.");
      error.length = ed.length;
      error.expected = k;
      throw error;
    }
    var y = new BigInteger$1(forge$2.util.createBuffer(ed).toHex(), 16);
    if (y.compareTo(key.n) >= 0) {
      throw new Error("Encrypted message is invalid.");
    }
    var x = _modPow(y, key, pub);
    var xhex = x.toString(16);
    var eb = forge$2.util.createBuffer();
    var zeros = k - Math.ceil(xhex.length / 2);
    while (zeros > 0) {
      eb.putByte(0);
      --zeros;
    }
    eb.putBytes(forge$2.util.hexToBytes(xhex));
    if (ml !== false) {
      return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
    }
    return eb.getBytes();
  };
  pki$1.rsa.createKeyPairGenerationState = function(bits2, e, options) {
    if (typeof bits2 === "string") {
      bits2 = parseInt(bits2, 10);
    }
    bits2 = bits2 || 2048;
    options = options || {};
    var prng2 = options.prng || forge$2.random;
    var rng2 = {
      nextBytes: function(x) {
        var b = prng2.getBytesSync(x.length);
        for (var i = 0;i < x.length; ++i) {
          x[i] = b.charCodeAt(i);
        }
      }
    };
    var algorithm = options.algorithm || "PRIMEINC";
    var rval;
    if (algorithm === "PRIMEINC") {
      rval = {
        algorithm,
        state: 0,
        bits: bits2,
        rng: rng2,
        eInt: e || 65537,
        e: new BigInteger$1(null),
        p: null,
        q: null,
        qBits: bits2 >> 1,
        pBits: bits2 - (bits2 >> 1),
        pqState: 0,
        num: null,
        keys: null
      };
      rval.e.fromInt(rval.eInt);
    } else {
      throw new Error("Invalid key generation algorithm: " + algorithm);
    }
    return rval;
  };
  pki$1.rsa.stepKeyPairGenerationState = function(state, n) {
    if (!("algorithm" in state)) {
      state.algorithm = "PRIMEINC";
    }
    var THIRTY = new BigInteger$1(null);
    THIRTY.fromInt(30);
    var deltaIdx = 0;
    var op_or2 = function(x, y) {
      return x | y;
    };
    var t1 = +new Date;
    var t2;
    var total = 0;
    while (state.keys === null && (n <= 0 || total < n)) {
      if (state.state === 0) {
        var bits2 = state.p === null ? state.pBits : state.qBits;
        var bits1 = bits2 - 1;
        if (state.pqState === 0) {
          state.num = new BigInteger$1(bits2, state.rng);
          if (!state.num.testBit(bits1)) {
            state.num.bitwiseTo(BigInteger$1.ONE.shiftLeft(bits1), op_or2, state.num);
          }
          state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
          deltaIdx = 0;
          ++state.pqState;
        } else if (state.pqState === 1) {
          if (state.num.bitLength() > bits2) {
            state.pqState = 0;
          } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
            ++state.pqState;
          } else {
            state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
          }
        } else if (state.pqState === 2) {
          state.pqState = state.num.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) === 0 ? 3 : 0;
        } else if (state.pqState === 3) {
          state.pqState = 0;
          if (state.p === null) {
            state.p = state.num;
          } else {
            state.q = state.num;
          }
          if (state.p !== null && state.q !== null) {
            ++state.state;
          }
          state.num = null;
        }
      } else if (state.state === 1) {
        if (state.p.compareTo(state.q) < 0) {
          state.num = state.p;
          state.p = state.q;
          state.q = state.num;
        }
        ++state.state;
      } else if (state.state === 2) {
        state.p1 = state.p.subtract(BigInteger$1.ONE);
        state.q1 = state.q.subtract(BigInteger$1.ONE);
        state.phi = state.p1.multiply(state.q1);
        ++state.state;
      } else if (state.state === 3) {
        if (state.phi.gcd(state.e).compareTo(BigInteger$1.ONE) === 0) {
          ++state.state;
        } else {
          state.p = null;
          state.q = null;
          state.state = 0;
        }
      } else if (state.state === 4) {
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() === state.bits) {
          ++state.state;
        } else {
          state.q = null;
          state.state = 0;
        }
      } else if (state.state === 5) {
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki$1.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki$1.rsa.setPublicKey(state.n, state.e)
        };
      }
      t2 = +new Date;
      total += t2 - t1;
      t1 = t2;
    }
    return state.keys !== null;
  };
  pki$1.rsa.generateKeyPair = function(bits2, e, options, callback) {
    if (arguments.length === 1) {
      if (typeof bits2 === "object") {
        options = bits2;
        bits2 = undefined;
      } else if (typeof bits2 === "function") {
        callback = bits2;
        bits2 = undefined;
      }
    } else if (arguments.length === 2) {
      if (typeof bits2 === "number") {
        if (typeof e === "function") {
          callback = e;
          e = undefined;
        } else if (typeof e !== "number") {
          options = e;
          e = undefined;
        }
      } else {
        options = bits2;
        callback = e;
        bits2 = undefined;
        e = undefined;
      }
    } else if (arguments.length === 3) {
      if (typeof e === "number") {
        if (typeof options === "function") {
          callback = options;
          options = undefined;
        }
      } else {
        callback = options;
        options = e;
        e = undefined;
      }
    }
    options = options || {};
    if (bits2 === undefined) {
      bits2 = options.bits || 2048;
    }
    if (e === undefined) {
      e = options.e || 65537;
    }
    if (!forge$2.options.usePureJavaScript && !options.prng && bits2 >= 256 && bits2 <= 16384 && (e === 65537 || e === 3)) {
      if (callback) {
        if (_detectNodeCrypto("generateKeyPair")) {
          return _crypto.generateKeyPair("rsa", {
            modulusLength: bits2,
            publicExponent: e,
            publicKeyEncoding: {
              type: "spki",
              format: "pem"
            },
            privateKeyEncoding: {
              type: "pkcs8",
              format: "pem"
            }
          }, function(err, pub, priv) {
            if (err) {
              return callback(err);
            }
            callback(null, {
              privateKey: pki$1.privateKeyFromPem(priv),
              publicKey: pki$1.publicKeyFromPem(pub)
            });
          });
        }
        if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
          return util$1.globalScope.crypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: bits2,
            publicExponent: _intToUint8Array(e),
            hash: { name: "SHA-256" }
          }, true, ["sign", "verify"]).then(function(pair2) {
            return util$1.globalScope.crypto.subtle.exportKey("pkcs8", pair2.privateKey);
          }).then(undefined, function(err) {
            callback(err);
          }).then(function(pkcs8) {
            if (pkcs8) {
              var privateKey = pki$1.privateKeyFromAsn1(asn1$1.fromDer(forge$2.util.createBuffer(pkcs8)));
              callback(null, {
                privateKey,
                publicKey: pki$1.setRsaPublicKey(privateKey.n, privateKey.e)
              });
            }
          });
        }
        if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
          var genOp = util$1.globalScope.msCrypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: bits2,
            publicExponent: _intToUint8Array(e),
            hash: { name: "SHA-256" }
          }, true, ["sign", "verify"]);
          genOp.oncomplete = function(e2) {
            var pair2 = e2.target.result;
            var exportOp = util$1.globalScope.msCrypto.subtle.exportKey("pkcs8", pair2.privateKey);
            exportOp.oncomplete = function(e3) {
              var pkcs8 = e3.target.result;
              var privateKey = pki$1.privateKeyFromAsn1(asn1$1.fromDer(forge$2.util.createBuffer(pkcs8)));
              callback(null, {
                privateKey,
                publicKey: pki$1.setRsaPublicKey(privateKey.n, privateKey.e)
              });
            };
            exportOp.onerror = function(err) {
              callback(err);
            };
          };
          genOp.onerror = function(err) {
            callback(err);
          };
          return;
        }
      } else {
        if (_detectNodeCrypto("generateKeyPairSync")) {
          var keypair = _crypto.generateKeyPairSync("rsa", {
            modulusLength: bits2,
            publicExponent: e,
            publicKeyEncoding: {
              type: "spki",
              format: "pem"
            },
            privateKeyEncoding: {
              type: "pkcs8",
              format: "pem"
            }
          });
          return {
            privateKey: pki$1.privateKeyFromPem(keypair.privateKey),
            publicKey: pki$1.publicKeyFromPem(keypair.publicKey)
          };
        }
      }
    }
    var state = pki$1.rsa.createKeyPairGenerationState(bits2, e, options);
    if (!callback) {
      pki$1.rsa.stepKeyPairGenerationState(state, 0);
      return state.keys;
    }
    _generateKeyPair(state, options, callback);
  };
  pki$1.setRsaPublicKey = pki$1.rsa.setPublicKey = function(n, e) {
    var key = {
      n,
      e
    };
    key.encrypt = function(data, scheme, schemeOptions) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === undefined) {
        scheme = "RSAES-PKCS1-V1_5";
      }
      if (scheme === "RSAES-PKCS1-V1_5") {
        scheme = {
          encode: function(m, key2, pub) {
            return _encodePkcs1_v1_5(m, key2, 2).getBytes();
          }
        };
      } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
        scheme = {
          encode: function(m, key2) {
            return forge$2.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
          }
        };
      } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
        scheme = { encode: function(e3) {
          return e3;
        } };
      } else if (typeof scheme === "string") {
        throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      }
      var e2 = scheme.encode(data, key, true);
      return pki$1.rsa.encrypt(e2, key, true);
    };
    key.verify = function(digest2, signature, scheme, options) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === undefined) {
        scheme = "RSASSA-PKCS1-V1_5";
      }
      if (options === undefined) {
        options = {
          _parseAllDigestBytes: true
        };
      }
      if (!("_parseAllDigestBytes" in options)) {
        options._parseAllDigestBytes = true;
      }
      if (scheme === "RSASSA-PKCS1-V1_5") {
        scheme = {
          verify: function(digest3, d2) {
            d2 = _decodePkcs1_v1_5(d2, key, true);
            var obj = asn1$1.fromDer(d2, {
              parseAllBytes: options._parseAllDigestBytes
            });
            var capture = {};
            var errors = [];
            if (!asn1$1.validate(obj, digestInfoValidator, capture, errors)) {
              var error = new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
              error.errors = errors;
              throw error;
            }
            var oid = asn1$1.derToOid(capture.algorithmIdentifier);
            if (!(oid === forge$2.oids.md2 || oid === forge$2.oids.md5 || oid === forge$2.oids.sha1 || oid === forge$2.oids.sha224 || oid === forge$2.oids.sha256 || oid === forge$2.oids.sha384 || oid === forge$2.oids.sha512 || oid === forge$2.oids["sha512-224"] || oid === forge$2.oids["sha512-256"])) {
              var error = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
              error.oid = oid;
              throw error;
            }
            if (oid === forge$2.oids.md2 || oid === forge$2.oids.md5) {
              if (!("parameters" in capture)) {
                throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.");
              }
            }
            return digest3 === capture.digest;
          }
        };
      } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
        scheme = {
          verify: function(digest3, d2) {
            d2 = _decodePkcs1_v1_5(d2, key, true);
            return digest3 === d2;
          }
        };
      }
      var d = pki$1.rsa.decrypt(signature, key, true, false);
      return scheme.verify(digest2, d, key.n.bitLength());
    };
    return key;
  };
  pki$1.setRsaPrivateKey = pki$1.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
    var key = {
      n,
      e,
      d,
      p,
      q,
      dP,
      dQ,
      qInv
    };
    key.decrypt = function(data, scheme, schemeOptions) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === undefined) {
        scheme = "RSAES-PKCS1-V1_5";
      }
      var d2 = pki$1.rsa.decrypt(data, key, false, false);
      if (scheme === "RSAES-PKCS1-V1_5") {
        scheme = { decode: _decodePkcs1_v1_5 };
      } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
        scheme = {
          decode: function(d3, key2) {
            return forge$2.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
          }
        };
      } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
        scheme = { decode: function(d3) {
          return d3;
        } };
      } else {
        throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      }
      return scheme.decode(d2, key, false);
    };
    key.sign = function(md, scheme) {
      var bt = false;
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      }
      if (scheme === undefined || scheme === "RSASSA-PKCS1-V1_5") {
        scheme = { encode: emsaPkcs1v15encode };
        bt = 1;
      } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
        scheme = { encode: function() {
          return md;
        } };
        bt = 1;
      }
      var d2 = scheme.encode(md, key.n.bitLength());
      return pki$1.rsa.encrypt(d2, key, bt);
    };
    return key;
  };
  pki$1.wrapRsaPrivateKey = function(rsaKey) {
    return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, asn1$1.integerToDer(0).getBytes()),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.rsaEncryption).getBytes()),
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, false, "")
      ]),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, asn1$1.toDer(rsaKey).getBytes())
    ]);
  };
  pki$1.privateKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    if (asn1$1.validate(obj, privateKeyValidator, capture, errors)) {
      obj = asn1$1.fromDer(forge$2.util.createBuffer(capture.privateKey));
    }
    capture = {};
    errors = [];
    if (!asn1$1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
      error.errors = errors;
      throw error;
    }
    var n, e, d, p, q, dP, dQ, qInv;
    n = forge$2.util.createBuffer(capture.privateKeyModulus).toHex();
    e = forge$2.util.createBuffer(capture.privateKeyPublicExponent).toHex();
    d = forge$2.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
    p = forge$2.util.createBuffer(capture.privateKeyPrime1).toHex();
    q = forge$2.util.createBuffer(capture.privateKeyPrime2).toHex();
    dP = forge$2.util.createBuffer(capture.privateKeyExponent1).toHex();
    dQ = forge$2.util.createBuffer(capture.privateKeyExponent2).toHex();
    qInv = forge$2.util.createBuffer(capture.privateKeyCoefficient).toHex();
    return pki$1.setRsaPrivateKey(new BigInteger$1(n, 16), new BigInteger$1(e, 16), new BigInteger$1(d, 16), new BigInteger$1(p, 16), new BigInteger$1(q, 16), new BigInteger$1(dP, 16), new BigInteger$1(dQ, 16), new BigInteger$1(qInv, 16));
  };
  pki$1.privateKeyToAsn1 = pki$1.privateKeyToRSAPrivateKey = function(key) {
    return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, asn1$1.integerToDer(0).getBytes()),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.n)),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.e)),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.d)),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.p)),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.q)),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.dP)),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.dQ)),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.qInv))
    ]);
  };
  pki$1.publicKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    if (asn1$1.validate(obj, publicKeyValidator, capture, errors)) {
      var oid = asn1$1.derToOid(capture.publicKeyOid);
      if (oid !== pki$1.oids.rsaEncryption) {
        var error = new Error("Cannot read public key. Unknown OID.");
        error.oid = oid;
        throw error;
      }
      obj = capture.rsaPublicKey;
    }
    errors = [];
    if (!asn1$1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
      var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
      error.errors = errors;
      throw error;
    }
    var n = forge$2.util.createBuffer(capture.publicKeyModulus).toHex();
    var e = forge$2.util.createBuffer(capture.publicKeyExponent).toHex();
    return pki$1.setRsaPublicKey(new BigInteger$1(n, 16), new BigInteger$1(e, 16));
  };
  pki$1.publicKeyToAsn1 = pki$1.publicKeyToSubjectPublicKeyInfo = function(key) {
    return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.rsaEncryption).getBytes()),
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, false, "")
      ]),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.BITSTRING, false, [
        pki$1.publicKeyToRSAPublicKey(key)
      ])
    ]);
  };
  pki$1.publicKeyToRSAPublicKey = function(key) {
    return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.n)),
      asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, _bnToBytes(key.e))
    ]);
  };
  var forge$1 = forge$m;
  if (typeof BigInteger === "undefined") {
    BigInteger = forge$1.jsbn.BigInteger;
  }
  var BigInteger;
  var asn1 = forge$1.asn1;
  var pki = forge$1.pki = forge$1.pki || {};
  pki.pbe = forge$1.pbe = forge$1.pbe || {};
  var oids = pki.oids;
  var encryptedPrivateKeyValidator = {
    name: "EncryptedPrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encryptionOid"
      }, {
        name: "AlgorithmIdentifier.parameters",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "encryptionParams"
      }]
    }, {
      name: "EncryptedPrivateKeyInfo.encryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "encryptedData"
    }]
  };
  var PBES2AlgorithmsValidator = {
    name: "PBES2Algorithms",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc.oid",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "kdfOid"
      }, {
        name: "PBES2Algorithms.params",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.params.salt",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "kdfSalt"
        }, {
          name: "PBES2Algorithms.params.iterationCount",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "kdfIterationCount"
        }, {
          name: "PBES2Algorithms.params.keyLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          optional: true,
          capture: "keyLength"
        }, {
          name: "PBES2Algorithms.params.prf",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "PBES2Algorithms.params.prf.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "prfOid"
          }]
        }]
      }]
    }, {
      name: "PBES2Algorithms.encryptionScheme",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.encryptionScheme.oid",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encOid"
      }, {
        name: "PBES2Algorithms.encryptionScheme.iv",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encIv"
      }]
    }]
  };
  var pkcs12PbeParamsValidator = {
    name: "pkcs-12PbeParams",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "pkcs-12PbeParams.salt",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "salt"
    }, {
      name: "pkcs-12PbeParams.iterations",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "iterations"
    }]
  };
  pki.encryptPrivateKeyInfo = function(obj, password, options) {
    options = options || {};
    options.saltSize = options.saltSize || 8;
    options.count = options.count || 2048;
    options.algorithm = options.algorithm || "aes128";
    options.prfAlgorithm = options.prfAlgorithm || "sha1";
    var salt = forge$1.random.getBytesSync(options.saltSize);
    var count = options.count;
    var countBytes = asn1.integerToDer(count);
    var dkLen;
    var encryptionAlgorithm;
    var encryptedData;
    if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
      var ivLen, encOid, cipherFn;
      switch (options.algorithm) {
        case "aes128":
          dkLen = 16;
          ivLen = 16;
          encOid = oids["aes128-CBC"];
          cipherFn = forge$1.aes.createEncryptionCipher;
          break;
        case "aes192":
          dkLen = 24;
          ivLen = 16;
          encOid = oids["aes192-CBC"];
          cipherFn = forge$1.aes.createEncryptionCipher;
          break;
        case "aes256":
          dkLen = 32;
          ivLen = 16;
          encOid = oids["aes256-CBC"];
          cipherFn = forge$1.aes.createEncryptionCipher;
          break;
        case "des":
          dkLen = 8;
          ivLen = 8;
          encOid = oids["desCBC"];
          cipherFn = forge$1.des.createEncryptionCipher;
          break;
        default:
          var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          error.algorithm = options.algorithm;
          throw error;
      }
      var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
      var md = prfAlgorithmToMessageDigest(prfAlgorithm);
      var dk = forge$1.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = forge$1.random.getBytesSync(ivLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(obj));
      cipher.finish();
      encryptedData = cipher.output.getBytes();
      var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
      encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()),
            params
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
          ])
        ])
      ]);
    } else if (options.algorithm === "3des") {
      dkLen = 24;
      var saltBytes = new forge$1.util.ByteBuffer(salt);
      var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
      var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
      var cipher = forge$1.des.createEncryptionCipher(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(obj));
      cipher.finish();
      encryptedData = cipher.output.getBytes();
      encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
        ])
      ]);
    } else {
      var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
      error.algorithm = options.algorithm;
      throw error;
    }
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      encryptionAlgorithm,
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
    ]);
    return rval;
  };
  pki.decryptPrivateKeyInfo = function(obj, password) {
    var rval = null;
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    var oid = asn1.derToOid(capture.encryptionOid);
    var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
    var encrypted = forge$1.util.createBuffer(capture.encryptedData);
    cipher.update(encrypted);
    if (cipher.finish()) {
      rval = asn1.fromDer(cipher.output);
    }
    return rval;
  };
  pki.encryptedPrivateKeyToPem = function(epki, maxline) {
    var msg = {
      type: "ENCRYPTED PRIVATE KEY",
      body: asn1.toDer(epki).getBytes()
    };
    return forge$1.pem.encode(msg, { maxline });
  };
  pki.encryptedPrivateKeyFromPem = function(pem2) {
    var msg = forge$1.pem.decode(pem2)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY") {
      var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
    }
    return asn1.fromDer(msg.body);
  };
  pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
    options = options || {};
    if (!options.legacy) {
      var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
      rval = pki.encryptPrivateKeyInfo(rval, password, options);
      return pki.encryptedPrivateKeyToPem(rval);
    }
    var algorithm;
    var iv;
    var dkLen;
    var cipherFn;
    switch (options.algorithm) {
      case "aes128":
        algorithm = "AES-128-CBC";
        dkLen = 16;
        iv = forge$1.random.getBytesSync(16);
        cipherFn = forge$1.aes.createEncryptionCipher;
        break;
      case "aes192":
        algorithm = "AES-192-CBC";
        dkLen = 24;
        iv = forge$1.random.getBytesSync(16);
        cipherFn = forge$1.aes.createEncryptionCipher;
        break;
      case "aes256":
        algorithm = "AES-256-CBC";
        dkLen = 32;
        iv = forge$1.random.getBytesSync(16);
        cipherFn = forge$1.aes.createEncryptionCipher;
        break;
      case "3des":
        algorithm = "DES-EDE3-CBC";
        dkLen = 24;
        iv = forge$1.random.getBytesSync(8);
        cipherFn = forge$1.des.createEncryptionCipher;
        break;
      case "des":
        algorithm = "DES-CBC";
        dkLen = 8;
        iv = forge$1.random.getBytesSync(8);
        cipherFn = forge$1.des.createEncryptionCipher;
        break;
      default:
        var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
        error.algorithm = options.algorithm;
        throw error;
    }
    var dk = forge$1.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
    cipher.finish();
    var msg = {
      type: "RSA PRIVATE KEY",
      procType: {
        version: "4",
        type: "ENCRYPTED"
      },
      dekInfo: {
        algorithm,
        parameters: forge$1.util.bytesToHex(iv).toUpperCase()
      },
      body: cipher.output.getBytes()
    };
    return forge$1.pem.encode(msg);
  };
  pki.decryptRsaPrivateKey = function(pem2, password) {
    var rval = null;
    var msg = forge$1.pem.decode(pem2)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
      var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
      error.headerType = error;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      var dkLen;
      var cipherFn;
      switch (msg.dekInfo.algorithm) {
        case "DES-CBC":
          dkLen = 8;
          cipherFn = forge$1.des.createDecryptionCipher;
          break;
        case "DES-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge$1.des.createDecryptionCipher;
          break;
        case "AES-128-CBC":
          dkLen = 16;
          cipherFn = forge$1.aes.createDecryptionCipher;
          break;
        case "AES-192-CBC":
          dkLen = 24;
          cipherFn = forge$1.aes.createDecryptionCipher;
          break;
        case "AES-256-CBC":
          dkLen = 32;
          cipherFn = forge$1.aes.createDecryptionCipher;
          break;
        case "RC2-40-CBC":
          dkLen = 5;
          cipherFn = function(key) {
            return forge$1.rc2.createDecryptionCipher(key, 40);
          };
          break;
        case "RC2-64-CBC":
          dkLen = 8;
          cipherFn = function(key) {
            return forge$1.rc2.createDecryptionCipher(key, 64);
          };
          break;
        case "RC2-128-CBC":
          dkLen = 16;
          cipherFn = function(key) {
            return forge$1.rc2.createDecryptionCipher(key, 128);
          };
          break;
        default:
          var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
          error.algorithm = msg.dekInfo.algorithm;
          throw error;
      }
      var iv = forge$1.util.hexToBytes(msg.dekInfo.parameters);
      var dk = forge$1.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(forge$1.util.createBuffer(msg.body));
      if (cipher.finish()) {
        rval = cipher.output.getBytes();
      } else {
        return rval;
      }
    } else {
      rval = msg.body;
    }
    if (msg.type === "ENCRYPTED PRIVATE KEY") {
      rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
    } else {
      rval = asn1.fromDer(rval);
    }
    if (rval !== null) {
      rval = pki.privateKeyFromAsn1(rval);
    }
    return rval;
  };
  pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
    var j, l;
    if (typeof md === "undefined" || md === null) {
      if (!("sha1" in forge$1.md)) {
        throw new Error('"sha1" hash algorithm unavailable.');
      }
      md = forge$1.md.sha1.create();
    }
    var u = md.digestLength;
    var v = md.blockLength;
    var result = new forge$1.util.ByteBuffer;
    var passBuf = new forge$1.util.ByteBuffer;
    if (password !== null && password !== undefined) {
      for (l = 0;l < password.length; l++) {
        passBuf.putInt16(password.charCodeAt(l));
      }
      passBuf.putInt16(0);
    }
    var p = passBuf.length();
    var s2 = salt.length();
    var D = new forge$1.util.ByteBuffer;
    D.fillWithByte(id, v);
    var Slen = v * Math.ceil(s2 / v);
    var S = new forge$1.util.ByteBuffer;
    for (l = 0;l < Slen; l++) {
      S.putByte(salt.at(l % s2));
    }
    var Plen = v * Math.ceil(p / v);
    var P = new forge$1.util.ByteBuffer;
    for (l = 0;l < Plen; l++) {
      P.putByte(passBuf.at(l % p));
    }
    var I = S;
    I.putBuffer(P);
    var c = Math.ceil(n / u);
    for (var i = 1;i <= c; i++) {
      var buf = new forge$1.util.ByteBuffer;
      buf.putBytes(D.bytes());
      buf.putBytes(I.bytes());
      for (var round = 0;round < iter; round++) {
        md.start();
        md.update(buf.getBytes());
        buf = md.digest();
      }
      var B = new forge$1.util.ByteBuffer;
      for (l = 0;l < v; l++) {
        B.putByte(buf.at(l % u));
      }
      var k = Math.ceil(s2 / v) + Math.ceil(p / v);
      var Inew = new forge$1.util.ByteBuffer;
      for (j = 0;j < k; j++) {
        var chunk = new forge$1.util.ByteBuffer(I.getBytes(v));
        var x = 511;
        for (l = B.length() - 1;l >= 0; l--) {
          x = x >> 8;
          x += B.at(l) + chunk.at(l);
          chunk.setAt(l, x & 255);
        }
        Inew.putBuffer(chunk);
      }
      I = Inew;
      result.putBuffer(buf);
    }
    result.truncate(result.length() - n);
    return result;
  };
  pki.pbe.getCipher = function(oid, params, password) {
    switch (oid) {
      case pki.oids["pkcs5PBES2"]:
        return pki.pbe.getCipherForPBES2(oid, params, password);
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
      default:
        var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
        error.oid = oid;
        error.supportedOids = [
          "pkcs5PBES2",
          "pbeWithSHAAnd3-KeyTripleDES-CBC",
          "pbewithSHAAnd40BitRC2-CBC"
        ];
        throw error;
    }
  };
  pki.pbe.getCipherForPBES2 = function(oid, params, password) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    oid = asn1.derToOid(capture.kdfOid);
    if (oid !== pki.oids["pkcs5PBKDF2"]) {
      var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
      error.oid = oid;
      error.supportedOids = ["pkcs5PBKDF2"];
      throw error;
    }
    oid = asn1.derToOid(capture.encOid);
    if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
      var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
      error.oid = oid;
      error.supportedOids = [
        "aes128-CBC",
        "aes192-CBC",
        "aes256-CBC",
        "des-EDE3-CBC",
        "desCBC"
      ];
      throw error;
    }
    var salt = capture.kdfSalt;
    var count = forge$1.util.createBuffer(capture.kdfIterationCount);
    count = count.getInt(count.length() << 3);
    var dkLen;
    var cipherFn;
    switch (pki.oids[oid]) {
      case "aes128-CBC":
        dkLen = 16;
        cipherFn = forge$1.aes.createDecryptionCipher;
        break;
      case "aes192-CBC":
        dkLen = 24;
        cipherFn = forge$1.aes.createDecryptionCipher;
        break;
      case "aes256-CBC":
        dkLen = 32;
        cipherFn = forge$1.aes.createDecryptionCipher;
        break;
      case "des-EDE3-CBC":
        dkLen = 24;
        cipherFn = forge$1.des.createDecryptionCipher;
        break;
      case "desCBC":
        dkLen = 8;
        cipherFn = forge$1.des.createDecryptionCipher;
        break;
    }
    var md = prfOidToMessageDigest(capture.prfOid);
    var dk = forge$1.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = capture.encIv;
    var cipher = cipherFn(dk);
    cipher.start(iv);
    return cipher;
  };
  pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    var salt = forge$1.util.createBuffer(capture.salt);
    var count = forge$1.util.createBuffer(capture.iterations);
    count = count.getInt(count.length() << 3);
    var dkLen, dIvLen, cipherFn;
    switch (oid) {
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        dkLen = 24;
        dIvLen = 8;
        cipherFn = forge$1.des.startDecrypting;
        break;
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        dkLen = 5;
        dIvLen = 8;
        cipherFn = function(key2, iv2) {
          var cipher = forge$1.rc2.createDecryptionCipher(key2, 40);
          cipher.start(iv2, null);
          return cipher;
        };
        break;
      default:
        var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
        error.oid = oid;
        throw error;
    }
    var md = prfOidToMessageDigest(capture.prfOid);
    var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
    md.start();
    var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
    return cipherFn(key, iv);
  };
  pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
    if (typeof md === "undefined" || md === null) {
      if (!("md5" in forge$1.md)) {
        throw new Error('"md5" hash algorithm unavailable.');
      }
      md = forge$1.md.md5.create();
    }
    if (salt === null) {
      salt = "";
    }
    var digests = [hash(md, password + salt)];
    for (var length2 = 16, i = 1;length2 < dkLen; ++i, length2 += 16) {
      digests.push(hash(md, digests[i - 1] + password + salt));
    }
    return digests.join("").substr(0, dkLen);
  };
  var src$c = base$d;
  var _brrp__multiformats_scope_baseX$c = src$c;
  var coerce$c = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$d = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$d = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$d(this, decoder);
    }
  };
  var ComposedDecoder$c = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$d(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$d = (left2, right2) => new ComposedDecoder$c({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$c = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$d(name2, prefix, baseEncode);
      this.decoder = new Decoder$d(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$l = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$c(name2, prefix, encode3, decode3);
  var baseX$c = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$c(alphabet2, name2);
    return from$l({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$c(decode3(text))
    });
  };
  var decode$u = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$A = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$c = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$l({
      prefix,
      name: name2,
      encode(input) {
        return encode$A(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$u(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base58btc$b = baseX$c({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$c({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var encode_1$7 = encode$z;
  var MSB$9 = 128;
  var REST$9 = 127;
  var MSBALL$7 = ~REST$9;
  var INT$7 = Math.pow(2, 31);
  var decode$t = read$8;
  var MSB$1$7 = 128;
  var REST$1$7 = 127;
  var N1$7 = Math.pow(2, 7);
  var N2$7 = Math.pow(2, 14);
  var N3$7 = Math.pow(2, 21);
  var N4$7 = Math.pow(2, 28);
  var N5$7 = Math.pow(2, 35);
  var N6$7 = Math.pow(2, 42);
  var N7$7 = Math.pow(2, 49);
  var N8$7 = Math.pow(2, 56);
  var N9$7 = Math.pow(2, 63);
  var length$7 = function(value) {
    return value < N1$7 ? 1 : value < N2$7 ? 2 : value < N3$7 ? 3 : value < N4$7 ? 4 : value < N5$7 ? 5 : value < N6$7 ? 6 : value < N7$7 ? 7 : value < N8$7 ? 8 : value < N9$7 ? 9 : 10;
  };
  var varint$7 = {
    encode: encode_1$7,
    decode: decode$t,
    encodingLength: length$7
  };
  var _brrp_varint$7 = varint$7;
  var encodeTo$7 = (int, target, offset = 0) => {
    _brrp_varint$7.encode(int, target, offset);
    return target;
  };
  var encodingLength$9 = (int) => {
    return _brrp_varint$7.encodingLength(int);
  };
  var create$e = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength$9(code2);
    const digestOffset = sizeOffset + encodingLength$9(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo$7(code2, bytes2, 0);
    encodeTo$7(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest$7(code2, size, digest2, bytes2);
  };
  var Digest$7 = class Digest2 {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  };
  var code$7 = 0;
  var name$8 = "identity";
  var encode$y = coerce$c;
  var digest$7 = (input) => create$e(code$7, encode$y(input));
  var identity$9 = { code: code$7, name: name$8, encode: encode$y, digest: digest$7 };
  var from$k = ({ name: name2, code: code2, encode: encode3 }) => new Hasher$7(name2, code2, encode3);
  var Hasher$7 = class Hasher2 {
    constructor(name2, code2, encode3) {
      this.name = name2;
      this.code = code2;
      this.encode = encode3;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create$e(this.code, result) : result.then((digest2) => create$e(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var sha$7 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
  var sha256$8 = from$k({
    name: "sha2-256",
    code: 18,
    encode: sha$7("SHA-256")
  });
  /*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  var _0n$2 = BigInt(0);
  var _1n$3 = BigInt(1);
  var _2n$2 = BigInt(2);
  var _8n$1 = BigInt(8);
  var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
  var CURVE$1 = Object.freeze({
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
    l: CU_O,
    n: CU_O,
    h: BigInt(8),
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
  });
  var POW_2_256$1 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
  var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");

  class ExtendedPoint {
    constructor(x, y, z, t) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.t = t;
    }
    static fromAffine(p) {
      if (!(p instanceof Point$1)) {
        throw new TypeError("ExtendedPoint#fromAffine: expected Point");
      }
      if (p.equals(Point$1.ZERO))
        return ExtendedPoint.ZERO;
      return new ExtendedPoint(p.x, p.y, _1n$3, mod$1(p.x * p.y));
    }
    static toAffineBatch(points) {
      const toInv = invertBatch$1(points.map((p) => p.z));
      return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
      return this.toAffineBatch(points).map(this.fromAffine);
    }
    equals(other) {
      assertExtPoint(other);
      const { x: X1, y: Y1, z: Z1 } = this;
      const { x: X2, y: Y2, z: Z2 } = other;
      const X1Z2 = mod$1(X1 * Z2);
      const X2Z1 = mod$1(X2 * Z1);
      const Y1Z2 = mod$1(Y1 * Z2);
      const Y2Z1 = mod$1(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    negate() {
      return new ExtendedPoint(mod$1(-this.x), this.y, this.z, mod$1(-this.t));
    }
    double() {
      const { x: X1, y: Y1, z: Z1 } = this;
      const { a } = CURVE$1;
      const A = mod$1(X1 * X1);
      const B = mod$1(Y1 * Y1);
      const C = mod$1(_2n$2 * mod$1(Z1 * Z1));
      const D = mod$1(a * A);
      const x1y1 = X1 + Y1;
      const E = mod$1(mod$1(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = mod$1(E * F);
      const Y3 = mod$1(G * H);
      const T3 = mod$1(E * H);
      const Z3 = mod$1(F * G);
      return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    add(other) {
      assertExtPoint(other);
      const { x: X1, y: Y1, z: Z1, t: T1 } = this;
      const { x: X2, y: Y2, z: Z2, t: T2 } = other;
      const A = mod$1((Y1 - X1) * (Y2 + X2));
      const B = mod$1((Y1 + X1) * (Y2 - X2));
      const F = mod$1(B - A);
      if (F === _0n$2)
        return this.double();
      const C = mod$1(Z1 * _2n$2 * T2);
      const D = mod$1(T1 * _2n$2 * Z2);
      const E = D + C;
      const G = B + A;
      const H = D - C;
      const X3 = mod$1(E * F);
      const Y3 = mod$1(G * H);
      const T3 = mod$1(E * H);
      const Z3 = mod$1(F * G);
      return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    precomputeWindow(W) {
      const windows = 1 + 256 / W;
      const points = [];
      let p = this;
      let base3 = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base3 = p;
        points.push(base3);
        for (let i = 1;i < 2 ** (W - 1); i++) {
          base3 = base3.add(p);
          points.push(base3);
        }
        p = base3.double();
      }
      return points;
    }
    wNAF(n, affinePoint) {
      if (!affinePoint && this.equals(ExtendedPoint.BASE))
        affinePoint = Point$1.BASE;
      const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
      if (256 % W) {
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      }
      let precomputes = affinePoint && pointPrecomputes$1.get(affinePoint);
      if (!precomputes) {
        precomputes = this.precomputeWindow(W);
        if (affinePoint && W !== 1) {
          precomputes = ExtendedPoint.normalizeZ(precomputes);
          pointPrecomputes$1.set(affinePoint, precomputes);
        }
      }
      let p = ExtendedPoint.ZERO;
      let f = ExtendedPoint.BASE;
      const windows = 1 + 256 / W;
      const windowSize = 2 ** (W - 1);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n$3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate$1(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate$1(cond2, precomputes[offset2]));
        }
      }
      return ExtendedPoint.normalizeZ([p, f])[0];
    }
    multiply(scalar, affinePoint) {
      return this.wNAF(normalizeScalar$1(scalar, CURVE$1.l), affinePoint);
    }
    multiplyUnsafe(scalar) {
      let n = normalizeScalar$1(scalar, CURVE$1.l, false);
      const G = ExtendedPoint.BASE;
      const P0 = ExtendedPoint.ZERO;
      if (n === _0n$2)
        return P0;
      if (this.equals(P0) || n === _1n$3)
        return this;
      if (this.equals(G))
        return this.wNAF(n);
      let p = P0;
      let d = this;
      while (n > _0n$2) {
        if (n & _1n$3)
          p = p.add(d);
        d = d.double();
        n >>= _1n$3;
      }
      return p;
    }
    isSmallOrder() {
      return this.multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO);
    }
    isTorsionFree() {
      let p = this.multiplyUnsafe(CURVE$1.l / _2n$2).double();
      if (CURVE$1.l % _2n$2)
        p = p.add(this);
      return p.equals(ExtendedPoint.ZERO);
    }
    toAffine(invZ) {
      const { x, y, z } = this;
      const is0 = this.equals(ExtendedPoint.ZERO);
      if (invZ == null)
        invZ = is0 ? _8n$1 : invert$1(z);
      const ax = mod$1(x * invZ);
      const ay = mod$1(y * invZ);
      const zz = mod$1(z * invZ);
      if (is0)
        return Point$1.ZERO;
      if (zz !== _1n$3)
        throw new Error("invZ was invalid");
      return new Point$1(ax, ay);
    }
    fromRistrettoBytes() {
      legacyRist();
    }
    toRistrettoBytes() {
      legacyRist();
    }
    fromRistrettoHash() {
      legacyRist();
    }
  }
  ExtendedPoint.BASE = new ExtendedPoint(CURVE$1.Gx, CURVE$1.Gy, _1n$3, mod$1(CURVE$1.Gx * CURVE$1.Gy));
  ExtendedPoint.ZERO = new ExtendedPoint(_0n$2, _1n$3, _1n$3, _0n$2);

  class RistrettoPoint {
    constructor(ep) {
      this.ep = ep;
    }
    static calcElligatorRistrettoMap(r0) {
      const { d } = CURVE$1;
      const r = mod$1(SQRT_M1 * r0 * r0);
      const Ns = mod$1((r + _1n$3) * ONE_MINUS_D_SQ);
      let c = BigInt(-1);
      const D = mod$1((c - d * r) * mod$1(r + d));
      let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
      let s_ = mod$1(s2 * r0);
      if (!edIsNegative(s_))
        s_ = mod$1(-s_);
      if (!Ns_D_is_sq)
        s2 = s_;
      if (!Ns_D_is_sq)
        c = r;
      const Nt = mod$1(c * (r - _1n$3) * D_MINUS_ONE_SQ - D);
      const s22 = s2 * s2;
      const W0 = mod$1((s2 + s2) * D);
      const W1 = mod$1(Nt * SQRT_AD_MINUS_ONE);
      const W2 = mod$1(_1n$3 - s22);
      const W3 = mod$1(_1n$3 + s22);
      return new ExtendedPoint(mod$1(W0 * W3), mod$1(W2 * W1), mod$1(W1 * W3), mod$1(W0 * W2));
    }
    static hashToCurve(hex) {
      hex = ensureBytes$1(hex, 64);
      const r1 = bytes255ToNumberLE(hex.slice(0, 32));
      const R1 = this.calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(hex.slice(32, 64));
      const R2 = this.calcElligatorRistrettoMap(r2);
      return new RistrettoPoint(R1.add(R2));
    }
    static fromHex(hex) {
      hex = ensureBytes$1(hex, 32);
      const { a, d } = CURVE$1;
      const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
      const s2 = bytes255ToNumberLE(hex);
      if (!equalBytes(numberTo32BytesLE(s2), hex) || edIsNegative(s2))
        throw new Error(emsg);
      const s22 = mod$1(s2 * s2);
      const u1 = mod$1(_1n$3 + a * s22);
      const u2 = mod$1(_1n$3 - a * s22);
      const u1_2 = mod$1(u1 * u1);
      const u2_2 = mod$1(u2 * u2);
      const v = mod$1(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod$1(v * u2_2));
      const Dx = mod$1(I * u2);
      const Dy = mod$1(I * Dx * v);
      let x = mod$1((s2 + s2) * Dx);
      if (edIsNegative(x))
        x = mod$1(-x);
      const y = mod$1(u1 * Dy);
      const t = mod$1(x * y);
      if (!isValid || edIsNegative(t) || y === _0n$2)
        throw new Error(emsg);
      return new RistrettoPoint(new ExtendedPoint(x, y, _1n$3, t));
    }
    toRawBytes() {
      let { x, y, z, t } = this.ep;
      const u1 = mod$1(mod$1(z + y) * mod$1(z - y));
      const u2 = mod$1(x * y);
      const u2sq = mod$1(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod$1(u1 * u2sq));
      const D1 = mod$1(invsqrt * u1);
      const D2 = mod$1(invsqrt * u2);
      const zInv = mod$1(D1 * D2 * t);
      let D;
      if (edIsNegative(t * zInv)) {
        let _x = mod$1(y * SQRT_M1);
        let _y = mod$1(x * SQRT_M1);
        x = _x;
        y = _y;
        D = mod$1(D1 * INVSQRT_A_MINUS_D);
      } else {
        D = D2;
      }
      if (edIsNegative(x * zInv))
        y = mod$1(-y);
      let s2 = mod$1((z - y) * D);
      if (edIsNegative(s2))
        s2 = mod$1(-s2);
      return numberTo32BytesLE(s2);
    }
    toHex() {
      return bytesToHex$1(this.toRawBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(other) {
      assertRstPoint(other);
      const a = this.ep;
      const b = other.ep;
      const one = mod$1(a.x * b.y) === mod$1(a.y * b.x);
      const two = mod$1(a.y * b.y) === mod$1(a.x * b.x);
      return one || two;
    }
    add(other) {
      assertRstPoint(other);
      return new RistrettoPoint(this.ep.add(other.ep));
    }
    subtract(other) {
      assertRstPoint(other);
      return new RistrettoPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return new RistrettoPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
    }
  }
  RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
  RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
  var pointPrecomputes$1 = new WeakMap;
  var Point$1 = class Point2 {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes$1.delete(this);
    }
    static fromHex(hex, strict = true) {
      const { d, P } = CURVE$1;
      hex = ensureBytes$1(hex, 32);
      const normed = hex.slice();
      normed[31] = hex[31] & ~128;
      const y = bytesToNumberLE(normed);
      if (strict && y >= P)
        throw new Error("Expected 0 < hex < P");
      if (!strict && y >= POW_2_256$1)
        throw new Error("Expected 0 < hex < 2**256");
      const y2 = mod$1(y * y);
      const u = mod$1(y2 - _1n$3);
      const v = mod$1(d * y2 + _1n$3);
      let { isValid, value: x } = uvRatio(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n$3) === _1n$3;
      const isLastByteOdd = (hex[31] & 128) !== 0;
      if (isLastByteOdd !== isXOdd) {
        x = mod$1(-x);
      }
      return new Point2(x, y);
    }
    static async fromPrivateKey(privateKey) {
      return (await getExtendedPublicKey(privateKey)).point;
    }
    toRawBytes() {
      const bytes2 = numberTo32BytesLE(this.y);
      bytes2[31] |= this.x & _1n$3 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex$1(this.toRawBytes());
    }
    toX25519() {
      const { y } = this;
      const u = mod$1((_1n$3 + y) * invert$1(_1n$3 - y));
      return numberTo32BytesLE(u);
    }
    isTorsionFree() {
      return ExtendedPoint.fromAffine(this).isTorsionFree();
    }
    equals(other) {
      return this.x === other.x && this.y === other.y;
    }
    negate() {
      return new Point2(mod$1(-this.x), this.y);
    }
    add(other) {
      return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
  };
  Point$1.BASE = new Point$1(CURVE$1.Gx, CURVE$1.Gy);
  Point$1.ZERO = new Point$1(_0n$2, _1n$3);
  var Signature$1 = class Signature2 {
    constructor(r, s2) {
      this.r = r;
      this.s = s2;
      this.assertValidity();
    }
    static fromHex(hex) {
      const bytes2 = ensureBytes$1(hex, 64);
      const r = Point$1.fromHex(bytes2.slice(0, 32), false);
      const s2 = bytesToNumberLE(bytes2.slice(32, 64));
      return new Signature2(r, s2);
    }
    assertValidity() {
      const { r, s: s2 } = this;
      if (!(r instanceof Point$1))
        throw new Error("Expected Point instance");
      normalizeScalar$1(s2, CURVE$1.l, false);
      return this;
    }
    toRawBytes() {
      const u8 = new Uint8Array(64);
      u8.set(this.r.toRawBytes());
      u8.set(numberTo32BytesLE(this.s), 32);
      return u8;
    }
    toHex() {
      return bytesToHex$1(this.toRawBytes());
    }
  };
  var hexes$1 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var _sha512Sync;
  Point$1.BASE._setWindowSize(8);
  var crypto$4 = {
    node: nodeCrypto,
    web: typeof self === "object" && ("crypto" in self) ? self.crypto : undefined
  };
  var utils$1 = {
    bytesToHex: bytesToHex$1,
    hexToBytes: hexToBytes$1,
    concatBytes: concatBytes$1,
    getExtendedPublicKey,
    mod: mod$1,
    invert: invert$1,
    TORSION_SUBGROUP: [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ],
    hashToPrivateScalar: (hash2) => {
      hash2 = ensureBytes$1(hash2);
      if (hash2.length < 40 || hash2.length > 1024)
        throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
      return mod$1(bytesToNumberLE(hash2), CURVE$1.l - _1n$3) + _1n$3;
    },
    randomBytes: (bytesLength = 32) => {
      if (crypto$4.web) {
        return crypto$4.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto$4.node) {
        const { randomBytes: randomBytes2 } = crypto$4.node;
        return new Uint8Array(randomBytes2(bytesLength).buffer);
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    },
    randomPrivateKey: () => {
      return utils$1.randomBytes(32);
    },
    sha512: async (...messages2) => {
      const message2 = concatBytes$1(...messages2);
      if (crypto$4.web) {
        const buffer = await crypto$4.web.subtle.digest("SHA-512", message2.buffer);
        return new Uint8Array(buffer);
      } else if (crypto$4.node) {
        return Uint8Array.from(crypto$4.node.createHash("sha512").update(message2).digest());
      } else {
        throw new Error("The environment doesn't have sha512 function");
      }
    },
    precompute(windowSize = 8, point = Point$1.BASE) {
      const cached = point.equals(Point$1.BASE) ? point : new Point$1(point.x, point.y);
      cached._setWindowSize(windowSize);
      cached.multiply(_2n$2);
      return cached;
    },
    sha512Sync: undefined
  };
  Object.defineProperties(utils$1, {
    sha512Sync: {
      configurable: false,
      get() {
        return _sha512Sync;
      },
      set(val) {
        if (!_sha512Sync)
          _sha512Sync = val;
      }
    }
  });
  var PUBLIC_KEY_BYTE_LENGTH$6 = 32;
  var PRIVATE_KEY_BYTE_LENGTH$6 = 64;
  var KEYS_BYTE_LENGTH$6 = 32;
  var base64$d = rfc4648$c({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$c({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$c({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$c({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var webcrypto$6 = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto == null || nativeCrypto.subtle == null) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    }
  };
  var derivedEmptyPasswordKey$6 = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
  var KeyType$7;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["Secp256k1"] = "Secp256k1";
  })(KeyType$7 || (KeyType$7 = {}));
  var __KeyTypeValues$7;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
  })(__KeyTypeValues$7 || (__KeyTypeValues$7 = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues$7);
    };
  })(KeyType$7 || (KeyType$7 = {}));
  var PublicKey$7;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$7.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$7.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf) => {
      return decodeMessage$1(buf, PublicKey2.codec());
    };
  })(PublicKey$7 || (PublicKey$7 = {}));
  var PrivateKey$7;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$7.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$7.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf) => {
      return decodeMessage$1(buf, PrivateKey2.codec());
    };
  })(PrivateKey$7 || (PrivateKey$7 = {}));
  var Ed25519PublicKey$6 = class Ed25519PublicKey2 {
    constructor(key) {
      this._key = ensureKey$6(key, PUBLIC_KEY_BYTE_LENGTH$6);
    }
    async verify(data, sig) {
      return hashAndVerify$k(this._key, sig, data);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PublicKey$7.encode({
        Type: KeyType$7.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$8.digest(this.bytes);
      return bytes2;
    }
  };
  var Ed25519PrivateKey$6 = class Ed25519PrivateKey2 {
    constructor(key, publicKey) {
      this._key = ensureKey$6(key, PRIVATE_KEY_BYTE_LENGTH$6);
      this._publicKey = ensureKey$6(publicKey, PUBLIC_KEY_BYTE_LENGTH$6);
    }
    async sign(message2) {
      return hashAndSign$k(this._key, message2);
    }
    get public() {
      return new Ed25519PublicKey$6(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$7.encode({
        Type: KeyType$7.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$8.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const encoding = identity$9.digest(this.public.bytes);
      return base58btc$b.encode(encoding.bytes).substring(1);
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$6(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Ed25519$6 = Object.freeze({
    __proto__: null,
    Ed25519PrivateKey: Ed25519PrivateKey$6,
    Ed25519PublicKey: Ed25519PublicKey$6,
    generateKeyPair: generateKeyPair$m,
    generateKeyPairFromSeed: generateKeyPairFromSeed$6,
    unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey$6,
    unmarshalEd25519PublicKey: unmarshalEd25519PublicKey$6
  });
  var bits$7 = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  var curveTypes$7 = Object.keys(bits$7);
  curveTypes$7.join(" / ");
  var forge = forge$m;
  var sha512 = forge.sha512 = forge.sha512 || {};
  forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
  var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
  sha384.create = function() {
    return sha512.create("SHA-384");
  };
  forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
  forge.sha512.sha256 = forge.sha512.sha256 || {
    create: function() {
      return sha512.create("SHA-512/256");
    }
  };
  forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
  forge.sha512.sha224 = forge.sha512.sha224 || {
    create: function() {
      return sha512.create("SHA-512/224");
    }
  };
  forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
  sha512.create = function(algorithm) {
    if (!_initialized) {
      _init();
    }
    if (typeof algorithm === "undefined") {
      algorithm = "SHA-512";
    }
    if (!(algorithm in _states)) {
      throw new Error("Invalid SHA-512 algorithm: " + algorithm);
    }
    var _state = _states[algorithm];
    var _h = null;
    var _input = forge.util.createBuffer();
    var _w = new Array(80);
    for (var wi = 0;wi < 80; ++wi) {
      _w[wi] = new Array(2);
    }
    var digestLength = 64;
    switch (algorithm) {
      case "SHA-384":
        digestLength = 48;
        break;
      case "SHA-512/256":
        digestLength = 32;
        break;
      case "SHA-512/224":
        digestLength = 28;
        break;
    }
    var md = {
      algorithm: algorithm.replace("-", "").toLowerCase(),
      blockLength: 128,
      digestLength,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 16
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength128 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0;i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge.util.createBuffer();
      _h = new Array(_state.length);
      for (var i = 0;i < _state.length; ++i) {
        _h[i] = _state[i].slice(0);
      }
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1;i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update(_h, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits2 = md.fullMessageLength[0] * 8;
      for (var i = 0;i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits2 += carry;
        finalBlock.putInt32(bits2 >>> 0);
        bits2 = next >>> 0;
      }
      finalBlock.putInt32(bits2);
      var h = new Array(_h.length);
      for (var i = 0;i < _h.length; ++i) {
        h[i] = _h[i].slice(0);
      }
      _update(h, _w, finalBlock);
      var rval = forge.util.createBuffer();
      var hlen;
      if (algorithm === "SHA-512") {
        hlen = h.length;
      } else if (algorithm === "SHA-384") {
        hlen = h.length - 2;
      } else {
        hlen = h.length - 4;
      }
      for (var i = 0;i < hlen; ++i) {
        rval.putInt32(h[i][0]);
        if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
          rval.putInt32(h[i][1]);
        }
      }
      return rval;
    };
    return md;
  };
  var _padding = null;
  var _initialized = false;
  var _k = null;
  var _states = null;
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  var _0n$1 = BigInt(0);
  var _1n$2 = BigInt(1);
  var _2n$1 = BigInt(2);
  var _3n$1 = BigInt(3);
  var _8n = BigInt(8);
  var CURVE = Object.freeze({
    a: _0n$1,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: _1n$2,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  var divNearest$1 = (a, b) => (a + b / _2n$1) / b;
  var endo = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(k) {
      const { n } = CURVE;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n$2 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest$1(b2 * k, n);
      const c2 = divNearest$1(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  };
  var fieldLen = 32;
  var groupLen = 32;
  var hashLen = 32;
  var compressedLen = fieldLen + 1;
  var uncompressedLen = 2 * fieldLen + 1;
  var USE_ENDOMORPHISM = CURVE.a === _0n$1;

  class ShaError extends Error {
    constructor(message2) {
      super(message2);
    }
  }

  class JacobianPoint {
    constructor(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    static fromAffine(p) {
      if (!(p instanceof Point)) {
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      }
      if (p.equals(Point.ZERO))
        return JacobianPoint.ZERO;
      return new JacobianPoint(p.x, p.y, _1n$2);
    }
    static toAffineBatch(points) {
      const toInv = invertBatch(points.map((p) => p.z));
      return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
      assertJacPoint(other);
      const { x: X1, y: Y1, z: Z1 } = this;
      const { x: X2, y: Y2, z: Z2 } = other;
      const Z1Z1 = mod(Z1 * Z1);
      const Z2Z2 = mod(Z2 * Z2);
      const U1 = mod(X1 * Z2Z2);
      const U2 = mod(X2 * Z1Z1);
      const S1 = mod(mod(Y1 * Z2) * Z2Z2);
      const S2 = mod(mod(Y2 * Z1) * Z1Z1);
      return U1 === U2 && S1 === S2;
    }
    negate() {
      return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
      const { x: X1, y: Y1, z: Z1 } = this;
      const A = mod(X1 * X1);
      const B = mod(Y1 * Y1);
      const C = mod(B * B);
      const x1b = X1 + B;
      const D = mod(_2n$1 * (mod(x1b * x1b) - A - C));
      const E = mod(_3n$1 * A);
      const F = mod(E * E);
      const X3 = mod(F - _2n$1 * D);
      const Y3 = mod(E * (D - X3) - _8n * C);
      const Z3 = mod(_2n$1 * Y1 * Z1);
      return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
      assertJacPoint(other);
      const { x: X1, y: Y1, z: Z1 } = this;
      const { x: X2, y: Y2, z: Z2 } = other;
      if (X2 === _0n$1 || Y2 === _0n$1)
        return this;
      if (X1 === _0n$1 || Y1 === _0n$1)
        return other;
      const Z1Z1 = mod(Z1 * Z1);
      const Z2Z2 = mod(Z2 * Z2);
      const U1 = mod(X1 * Z2Z2);
      const U2 = mod(X2 * Z1Z1);
      const S1 = mod(mod(Y1 * Z2) * Z2Z2);
      const S2 = mod(mod(Y2 * Z1) * Z1Z1);
      const H = mod(U2 - U1);
      const r = mod(S2 - S1);
      if (H === _0n$1) {
        if (r === _0n$1) {
          return this.double();
        } else {
          return JacobianPoint.ZERO;
        }
      }
      const HH = mod(H * H);
      const HHH = mod(H * HH);
      const V2 = mod(U1 * HH);
      const X3 = mod(r * r - HHH - _2n$1 * V2);
      const Y3 = mod(r * (V2 - X3) - S1 * HHH);
      const Z3 = mod(Z1 * Z2 * H);
      return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
      const P0 = JacobianPoint.ZERO;
      if (typeof scalar === "bigint" && scalar === _0n$1)
        return P0;
      let n = normalizeScalar(scalar);
      if (n === _1n$2)
        return this;
      if (!USE_ENDOMORPHISM) {
        let p = P0;
        let d2 = this;
        while (n > _0n$1) {
          if (n & _1n$2)
            p = p.add(d2);
          d2 = d2.double();
          n >>= _1n$2;
        }
        return p;
      }
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = P0;
      let k2p = P0;
      let d = this;
      while (k1 > _0n$1 || k2 > _0n$1) {
        if (k1 & _1n$2)
          k1p = k1p.add(d);
        if (k2 & _1n$2)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$2;
        k2 >>= _1n$2;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
      return k1p.add(k2p);
    }
    precomputeWindow(W) {
      const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
      const points = [];
      let p = this;
      let base3 = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base3 = p;
        points.push(base3);
        for (let i = 1;i < 2 ** (W - 1); i++) {
          base3 = base3.add(p);
          points.push(base3);
        }
        p = base3.double();
      }
      return points;
    }
    wNAF(n, affinePoint) {
      if (!affinePoint && this.equals(JacobianPoint.BASE))
        affinePoint = Point.BASE;
      const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
      if (256 % W) {
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      }
      let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
      if (!precomputes) {
        precomputes = this.precomputeWindow(W);
        if (affinePoint && W !== 1) {
          precomputes = JacobianPoint.normalizeZ(precomputes);
          pointPrecomputes.set(affinePoint, precomputes);
        }
      }
      let p = JacobianPoint.ZERO;
      let f = JacobianPoint.BASE;
      const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
      const windowSize = 2 ** (W - 1);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n$2;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    }
    multiply(scalar, affinePoint) {
      let n = normalizeScalar(scalar);
      let point;
      let fake;
      if (USE_ENDOMORPHISM) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
        let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
        k1p = constTimeNegate(k1neg, k1p);
        k2p = constTimeNegate(k2neg, k2p);
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n, affinePoint);
        point = p;
        fake = f;
      }
      return JacobianPoint.normalizeZ([point, fake])[0];
    }
    toAffine(invZ) {
      const { x, y, z } = this;
      const is0 = this.equals(JacobianPoint.ZERO);
      if (invZ == null)
        invZ = is0 ? _8n : invert(z);
      const iz1 = invZ;
      const iz2 = mod(iz1 * iz1);
      const iz3 = mod(iz2 * iz1);
      const ax = mod(x * iz2);
      const ay = mod(y * iz3);
      const zz = mod(z * iz1);
      if (is0)
        return Point.ZERO;
      if (zz !== _1n$2)
        throw new Error("invZ was invalid");
      return new Point(ax, ay);
    }
  }
  JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n$2);
  JacobianPoint.ZERO = new JacobianPoint(_0n$1, _1n$2, _0n$1);
  var pointPrecomputes = new WeakMap;

  class Point {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    hasEvenY() {
      return this.y % _2n$1 === _0n$1;
    }
    static fromCompressedHex(bytes2) {
      const isShort = bytes2.length === 32;
      const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
      if (!isValidFieldElement(x))
        throw new Error("Point is not on curve");
      const y2 = weierstrass$1(x);
      let y = sqrtMod$1(y2);
      const isYOdd = (y & _1n$2) === _1n$2;
      if (isShort) {
        if (isYOdd)
          y = mod(-y);
      } else {
        const isFirstByteOdd = (bytes2[0] & 1) === 1;
        if (isFirstByteOdd !== isYOdd)
          y = mod(-y);
      }
      const point = new Point(x, y);
      point.assertValidity();
      return point;
    }
    static fromUncompressedHex(bytes2) {
      const x = bytesToNumber(bytes2.subarray(1, fieldLen + 1));
      const y = bytesToNumber(bytes2.subarray(fieldLen + 1, fieldLen * 2 + 1));
      const point = new Point(x, y);
      point.assertValidity();
      return point;
    }
    static fromHex(hex) {
      const bytes2 = ensureBytes(hex);
      const len = bytes2.length;
      const header2 = bytes2[0];
      if (len === fieldLen)
        return this.fromCompressedHex(bytes2);
      if (len === compressedLen && (header2 === 2 || header2 === 3)) {
        return this.fromCompressedHex(bytes2);
      }
      if (len === uncompressedLen && header2 === 4)
        return this.fromUncompressedHex(bytes2);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
      const { r, s: s2 } = normalizeSignature(signature);
      if (![0, 1, 2, 3].includes(recovery))
        throw new Error("Cannot recover: invalid recovery bit");
      const h = truncateHash(ensureBytes(msgHash));
      const { n } = CURVE;
      const radj = recovery === 2 || recovery === 3 ? r + n : r;
      const rinv = invert(radj, n);
      const u1 = mod(-h * rinv, n);
      const u2 = mod(s2 * rinv, n);
      const prefix = recovery & 1 ? "03" : "02";
      const R2 = Point.fromHex(prefix + numTo32bStr(radj));
      const Q = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q)
        throw new Error("Cannot recover signature: point at infinify");
      Q.assertValidity();
      return Q;
    }
    toRawBytes(isCompressed = false) {
      return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
      const x = numTo32bStr(this.x);
      if (isCompressed) {
        const prefix = this.hasEvenY() ? "02" : "03";
        return `${prefix}${x}`;
      } else {
        return `04${x}${numTo32bStr(this.y)}`;
      }
    }
    toHexX() {
      return this.toHex(true).slice(2);
    }
    toRawX() {
      return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
      const msg = "Point is not on elliptic curve";
      const { x, y } = this;
      if (!isValidFieldElement(x) || !isValidFieldElement(y))
        throw new Error(msg);
      const left2 = mod(y * y);
      const right2 = weierstrass$1(x);
      if (mod(left2 - right2) !== _0n$1)
        throw new Error(msg);
    }
    equals(other) {
      return this.x === other.x && this.y === other.y;
    }
    negate() {
      return new Point(this.x, mod(-this.y));
    }
    double() {
      return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const P = JacobianPoint.fromAffine(this);
      const aP = a === _0n$1 || a === _1n$2 || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
      const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
      const sum = aP.add(bQ);
      return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
  Point.ZERO = new Point(_0n$1, _0n$1);

  class Signature {
    constructor(r, s2) {
      this.r = r;
      this.s = s2;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const arr = hex instanceof Uint8Array;
      const name2 = "Signature.fromCompact";
      if (typeof hex !== "string" && !arr)
        throw new TypeError(`${name2}: Expected string or Uint8Array`);
      const str = arr ? bytesToHex(hex) : hex;
      if (str.length !== 128)
        throw new Error(`${name2}: Expected 64-byte hex`);
      return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
    static fromDER(hex) {
      const arr = hex instanceof Uint8Array;
      if (typeof hex !== "string" && !arr)
        throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
      const { r, s: s2 } = parseDERSignature(arr ? hex : hexToBytes(hex));
      return new Signature(r, s2);
    }
    static fromHex(hex) {
      return this.fromDER(hex);
    }
    assertValidity() {
      const { r, s: s2 } = this;
      if (!isWithinCurveOrder(r))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!isWithinCurveOrder(s2))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const HALF = CURVE.n >> _1n$2;
      return this.s > HALF;
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
    }
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      const sHex = sliceDER(numberToHexUnpadded(this.s));
      const rHex = sliceDER(numberToHexUnpadded(this.r));
      const sHexL = sHex.length / 2;
      const rHexL = rHex.length / 2;
      const sLen = numberToHexUnpadded(sHexL);
      const rLen = numberToHexUnpadded(rHexL);
      const length2 = numberToHexUnpadded(rHexL + sHexL + 4);
      return `30${length2}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
  }
  var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  var _sha256Sync;
  var _hmacSha256Sync;

  class HmacDrbg {
    constructor(hashLen2, qByteLen) {
      this.hashLen = hashLen2;
      this.qByteLen = qByteLen;
      if (typeof hashLen2 !== "number" || hashLen2 < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(hashLen2).fill(1);
      this.k = new Uint8Array(hashLen2).fill(0);
      this.counter = 0;
    }
    hmac(...values) {
      return utils.hmacSha256(this.k, ...values);
    }
    hmacSync(...values) {
      return _hmacSha256Sync(this.k, ...values);
    }
    checkSync() {
      if (typeof _hmacSha256Sync !== "function")
        throw new ShaError("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1000)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(seed = new Uint8Array) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
      this.v = await this.hmac(this.v);
      if (seed.length === 0)
        return;
      this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
      this.v = await this.hmac(this.v);
    }
    reseedSync(seed = new Uint8Array) {
      this.checkSync();
      this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
      this.v = this.hmacSync(this.v);
      if (seed.length === 0)
        return;
      this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
      this.v = this.hmacSync(this.v);
    }
    async generate() {
      this.incr();
      let len = 0;
      const out = [];
      while (len < this.qByteLen) {
        this.v = await this.hmac(this.v);
        const sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes(...out);
    }
    generateSync() {
      this.checkSync();
      this.incr();
      let len = 0;
      const out = [];
      while (len < this.qByteLen) {
        this.v = this.hmacSync(this.v);
        const sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes(...out);
    }
  }
  var vopts = { strict: true };
  Point.BASE._setWindowSize(8);
  var crypto$3 = {
    node: nodeCrypto,
    web: typeof self === "object" && ("crypto" in self) ? self.crypto : undefined
  };
  var TAGGED_HASH_PREFIXES = {};
  var utils = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    mod,
    invert,
    isValidPrivateKey(privateKey) {
      try {
        normalizePrivateKey(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    _bigintTo32Bytes: numTo32b,
    _normalizePrivateKey: normalizePrivateKey,
    hashToPrivateKey: (hash2) => {
      hash2 = ensureBytes(hash2);
      const minLen = groupLen + 8;
      if (hash2.length < minLen || hash2.length > 1024) {
        throw new Error(`Expected valid bytes of private key as per FIPS 186`);
      }
      const num = mod(bytesToNumber(hash2), CURVE.n - _1n$2) + _1n$2;
      return numTo32b(num);
    },
    randomBytes: (bytesLength = 32) => {
      if (crypto$3.web) {
        return crypto$3.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto$3.node) {
        const { randomBytes: randomBytes2 } = crypto$3.node;
        return Uint8Array.from(randomBytes2(bytesLength));
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    },
    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
    precompute(windowSize = 8, point = Point.BASE) {
      const cached = point === Point.BASE ? point : new Point(point.x, point.y);
      cached._setWindowSize(windowSize);
      cached.multiply(_3n$1);
      return cached;
    },
    sha256: async (...messages2) => {
      if (crypto$3.web) {
        const buffer = await crypto$3.web.subtle.digest("SHA-256", concatBytes(...messages2));
        return new Uint8Array(buffer);
      } else if (crypto$3.node) {
        const { createHash } = crypto$3.node;
        const hash2 = createHash("sha256");
        messages2.forEach((m) => hash2.update(m));
        return Uint8Array.from(hash2.digest());
      } else {
        throw new Error("The environment doesn't have sha256 function");
      }
    },
    hmacSha256: async (key, ...messages2) => {
      if (crypto$3.web) {
        const ckey = await crypto$3.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
        const message2 = concatBytes(...messages2);
        const buffer = await crypto$3.web.subtle.sign("HMAC", ckey, message2);
        return new Uint8Array(buffer);
      } else if (crypto$3.node) {
        const { createHmac } = crypto$3.node;
        const hash2 = createHmac("sha256", key);
        messages2.forEach((m) => hash2.update(m));
        return Uint8Array.from(hash2.digest());
      } else {
        throw new Error("The environment doesn't have hmac-sha256 function");
      }
    },
    sha256Sync: undefined,
    hmacSha256Sync: undefined,
    taggedHash: async (tag, ...messages2) => {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === undefined) {
        const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = concatBytes(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return utils.sha256(tagP, ...messages2);
    },
    taggedHashSync: (tag, ...messages2) => {
      if (typeof _sha256Sync !== "function")
        throw new ShaError("sha256Sync is undefined, you need to set it");
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === undefined) {
        const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = concatBytes(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return _sha256Sync(tagP, ...messages2);
    },
    _JacobianPoint: JacobianPoint
  };
  Object.defineProperties(utils, {
    sha256Sync: {
      configurable: false,
      get() {
        return _sha256Sync;
      },
      set(val) {
        if (!_sha256Sync)
          _sha256Sync = val;
      }
    },
    hmacSha256Sync: {
      configurable: false,
      get() {
        return _hmacSha256Sync;
      },
      set(val) {
        if (!_hmacSha256Sync)
          _hmacSha256Sync = val;
      }
    }
  });
  var MAX_KEY_SIZE$5 = 8192;
  var RsaPublicKey$6 = class RsaPublicKey2 {
    constructor(key) {
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$j(this._key, sig, data);
    }
    marshal() {
      return jwkToPkix$6(this._key);
    }
    get bytes() {
      return PublicKey$7.encode({
        Type: KeyType$7.RSA,
        Data: this.marshal()
      }).subarray();
    }
    encrypt(bytes2) {
      return encrypt$6(this._key, bytes2);
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$8.digest(this.bytes);
      return bytes2;
    }
  };
  var RsaPrivateKey$6 = class RsaPrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey;
    }
    genSecret() {
      return randomBytes$6(16);
    }
    async sign(message2) {
      return hashAndSign$j(this._key, message2);
    }
    get public() {
      if (this._publicKey == null) {
        throw new CodeError$3("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
      }
      return new RsaPublicKey$6(this._publicKey);
    }
    decrypt(bytes2) {
      return decrypt$6(this._key, bytes2);
    }
    marshal() {
      return jwkToPkcs1$6(this._key);
    }
    get bytes() {
      return PrivateKey$7.encode({
        Type: KeyType$7.RSA,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$8.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "pkcs-8") {
      if (format4 === "pkcs-8") {
        const buffer = new forge$n.util.ByteBuffer(this.marshal());
        const asn12 = forge$n.asn1.fromDer(buffer);
        const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
        const options = {
          algorithm: "aes256",
          count: 1e4,
          saltSize: 128 / 8,
          prfAlgorithm: "sha512"
        };
        return forge$n.pki.encryptRsaPrivateKey(privateKey, password, options);
      } else if (format4 === "libp2p-key") {
        return exporter$6(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var RSA$6 = Object.freeze({
    __proto__: null,
    MAX_KEY_SIZE: MAX_KEY_SIZE$5,
    RsaPrivateKey: RsaPrivateKey$6,
    RsaPublicKey: RsaPublicKey$6,
    fromJwk: fromJwk$6,
    generateKeyPair: generateKeyPair$l,
    unmarshalRsaPrivateKey: unmarshalRsaPrivateKey$6,
    unmarshalRsaPublicKey: unmarshalRsaPublicKey$6
  });
  var Secp256k1PublicKey$6 = class Secp256k1PublicKey2 {
    constructor(key) {
      validatePublicKey$6(key);
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$i(this._key, sig, data);
    }
    marshal() {
      return compressPublicKey$6(this._key);
    }
    get bytes() {
      return PublicKey$7.encode({
        Type: KeyType$7.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$8.digest(this.bytes);
      return bytes2;
    }
  };
  var Secp256k1PrivateKey$6 = class Secp256k1PrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey ?? computePublicKey$6(key);
      validatePrivateKey$6(this._key);
      validatePublicKey$6(this._publicKey);
    }
    async sign(message2) {
      return hashAndSign$i(this._key, message2);
    }
    get public() {
      return new Secp256k1PublicKey$6(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$7.encode({
        Type: KeyType$7.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$8.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$6(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Secp256k1$6 = Object.freeze({
    __proto__: null,
    Secp256k1PrivateKey: Secp256k1PrivateKey$6,
    Secp256k1PublicKey: Secp256k1PublicKey$6,
    generateKeyPair: generateKeyPair$k,
    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey$6,
    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey$6
  });
  var supportedKeys$6 = {
    rsa: RSA$6,
    ed25519: Ed25519$6,
    secp256k1: Secp256k1$6
  };
  var src$b = base$c;
  var _brrp__multiformats_scope_baseX$b = src$b;
  var equals$3 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0;ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce$b = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var fromString$2 = (str) => new TextEncoder().encode(str);
  var toString$7 = (b) => new TextDecoder().decode(b);
  var Encoder$c = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$c = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$c(this, decoder);
    }
  };
  var ComposedDecoder$b = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$c(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$c = (left2, right2) => new ComposedDecoder$b({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$b = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$c(name2, prefix, baseEncode);
      this.decoder = new Decoder$c(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$j = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$b(name2, prefix, encode3, decode3);
  var baseX$b = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$b(alphabet2, name2);
    return from$j({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$b(decode3(text))
    });
  };
  var decode$s = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$x = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$b = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$j({
      prefix,
      name: name2,
      encode(input) {
        return encode$x(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$s(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base58btc$a = baseX$b({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr$1 = baseX$b({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base58$1 = Object.freeze({
    __proto__: null,
    base58btc: base58btc$a,
    base58flickr: base58flickr$1
  });
  var base10$2 = baseX$b({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });
  var base10$3 = Object.freeze({
    __proto__: null,
    base10: base10$2
  });
  var base16$2 = rfc4648$b({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper$1 = rfc4648$b({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
  var base16$3 = Object.freeze({
    __proto__: null,
    base16: base16$2,
    base16upper: base16upper$1
  });
  var base2$2 = rfc4648$b({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });
  var base2$3 = Object.freeze({
    __proto__: null,
    base2: base2$2
  });
  var alphabet$1 = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42");
  var alphabetBytesToChars$1 = alphabet$1.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes$1 = alphabet$1.reduce((p, c, i) => {
    p[c.codePointAt(0)] = i;
    return p;
  }, []);
  var base256emoji$2 = from$j({
    prefix: "\uD83D\uDE80",
    name: "base256emoji",
    encode: encode$w,
    decode: decode$r
  });
  var base256emoji$3 = Object.freeze({
    __proto__: null,
    base256emoji: base256emoji$2
  });
  var base32$c = rfc4648$b({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper$1 = rfc4648$b({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad$1 = rfc4648$b({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper$1 = rfc4648$b({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex$1 = rfc4648$b({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper$1 = rfc4648$b({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad$1 = rfc4648$b({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper$1 = rfc4648$b({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z$1 = rfc4648$b({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base32$d = Object.freeze({
    __proto__: null,
    base32: base32$c,
    base32hex: base32hex$1,
    base32hexpad: base32hexpad$1,
    base32hexpadupper: base32hexpadupper$1,
    base32hexupper: base32hexupper$1,
    base32pad: base32pad$1,
    base32padupper: base32padupper$1,
    base32upper: base32upper$1,
    base32z: base32z$1
  });
  var base36$2 = baseX$b({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper$1 = baseX$b({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
  var base36$3 = Object.freeze({
    __proto__: null,
    base36: base36$2,
    base36upper: base36upper$1
  });
  var base64$b = rfc4648$b({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad$1 = rfc4648$b({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url$1 = rfc4648$b({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad$1 = rfc4648$b({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var base64$c = Object.freeze({
    __proto__: null,
    base64: base64$b,
    base64pad: base64pad$1,
    base64url: base64url$1,
    base64urlpad: base64urlpad$1
  });
  var base8$2 = rfc4648$b({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });
  var base8$3 = Object.freeze({
    __proto__: null,
    base8: base8$2
  });
  var identity$8 = from$j({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString$7(buf),
    decode: (str) => fromString$2(str)
  });
  var identityBase$1 = Object.freeze({
    __proto__: null,
    identity: identity$8
  });
  new TextEncoder;
  new TextDecoder;
  var encode_1$6 = encode$v;
  var MSB$8 = 128;
  var REST$8 = 127;
  var MSBALL$6 = ~REST$8;
  var INT$6 = Math.pow(2, 31);
  var decode$q = read$7;
  var MSB$1$6 = 128;
  var REST$1$6 = 127;
  var N1$6 = Math.pow(2, 7);
  var N2$6 = Math.pow(2, 14);
  var N3$6 = Math.pow(2, 21);
  var N4$6 = Math.pow(2, 28);
  var N5$6 = Math.pow(2, 35);
  var N6$6 = Math.pow(2, 42);
  var N7$6 = Math.pow(2, 49);
  var N8$6 = Math.pow(2, 56);
  var N9$6 = Math.pow(2, 63);
  var length$6 = function(value) {
    return value < N1$6 ? 1 : value < N2$6 ? 2 : value < N3$6 ? 3 : value < N4$6 ? 4 : value < N5$6 ? 5 : value < N6$6 ? 6 : value < N7$6 ? 7 : value < N8$6 ? 8 : value < N9$6 ? 9 : 10;
  };
  var varint$6 = {
    encode: encode_1$6,
    decode: decode$q,
    encodingLength: length$6
  };
  var _brrp_varint$6 = varint$6;
  var decode$p = (data, offset = 0) => {
    const code2 = _brrp_varint$6.decode(data, offset);
    return [code2, _brrp_varint$6.decode.bytes];
  };
  var encodeTo$6 = (int, target, offset = 0) => {
    _brrp_varint$6.encode(int, target, offset);
    return target;
  };
  var encodingLength$8 = (int) => {
    return _brrp_varint$6.encodingLength(int);
  };
  var create$c = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength$8(code2);
    const digestOffset = sizeOffset + encodingLength$8(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo$6(code2, bytes2, 0);
    encodeTo$6(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest$6(code2, size, digest2, bytes2);
  };
  var decode$o = (multihash) => {
    const bytes2 = coerce$b(multihash);
    const [code2, sizeOffset] = decode$p(bytes2);
    const [size, digestOffset] = decode$p(bytes2.subarray(sizeOffset));
    const digest2 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest2.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest$6(code2, size, digest2, bytes2);
  };
  var equals$2 = (a, b) => {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals$3(a.bytes, data.bytes);
    }
  };
  var Digest$6 = class Digest2 {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  };
  var code$6 = 0;
  var name$7 = "identity";
  var encode$u = coerce$b;
  var digest$6 = (input) => create$c(code$6, encode$u(input));
  var identity$7 = { code: code$6, name: name$7, encode: encode$u, digest: digest$6 };
  var from$i = ({ name: name2, code: code2, encode: encode3 }) => new Hasher$6(name2, code2, encode3);
  var Hasher$6 = class Hasher2 {
    constructor(name2, code2, encode3) {
      this.name = name2;
      this.code = code2;
      this.encode = encode3;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create$c(this.code, result) : result.then((digest2) => create$c(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var sha$6 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
  var sha256$7 = from$i({
    name: "sha2-256",
    code: 18,
    encode: sha$6("SHA-256")
  });
  var format$4 = (link, base3) => {
    const { bytes: bytes2, version: version2 } = link;
    switch (version2) {
      case 0:
        return toStringV0$1(bytes2, baseCache$1(link), base3 || base58btc$a.encoder);
      default:
        return toStringV1$1(bytes2, baseCache$1(link), base3 || base32$c.encoder);
    }
  };
  var cache$2 = new WeakMap;
  var baseCache$1 = (cid) => {
    const baseCache2 = cache$2.get(cid);
    if (baseCache2 == null) {
      const baseCache3 = new Map;
      cache$2.set(cid, baseCache3);
      return baseCache3;
    }
    return baseCache2;
  };
  var CID$1 = class CID2 {
    constructor(version2, code2, multihash, bytes2) {
      this.code = code2;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    get asCID() {
      return this;
    }
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code2, multihash } = this;
          if (code2 !== DAG_PB_CODE$1) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE$1) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID2.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code2, digest: digest2 } = this.multihash;
          const multihash = create$c(code2, digest2);
          return CID2.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return CID2.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown && self2.code === unknown.code && self2.version === unknown.version && equals$2(self2.multihash, unknown.multihash);
    }
    toString(base3) {
      return format$4(this, base3);
    }
    toJSON() {
      return { "/": format$4(this) };
    }
    link() {
      return this;
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof CID2) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
        return new CID2(version2, code2, multihash, bytes2 || encodeCID$1(version2, code2, multihash.bytes));
      } else if (value[cidSymbol$1] === true) {
        const { version: version2, multihash, code: code2 } = value;
        const digest2 = decode$o(multihash);
        return CID2.create(version2, code2, digest2);
      } else {
        return null;
      }
    }
    static create(version2, code2, digest2) {
      if (typeof code2 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest2.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version2) {
        case 0: {
          if (code2 !== DAG_PB_CODE$1) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$1}) block encoding`);
          } else {
            return new CID2(version2, code2, digest2, digest2.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID$1(version2, code2, digest2.bytes);
          return new CID2(version2, code2, digest2, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest2) {
      return CID2.create(0, DAG_PB_CODE$1, digest2);
    }
    static createV1(code2, digest2) {
      return CID2.create(1, code2, digest2);
    }
    static decode(bytes2) {
      const [cid, remainder] = CID2.decodeFirst(bytes2);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes2) {
      const specs = CID2.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce$b(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest2 = new Digest$6(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? CID2.createV0(digest2) : CID2.createV1(specs.codec, digest2);
      return [cid, bytes2.subarray(specs.size)];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length2] = decode$p(initialBytes.subarray(offset));
        offset += length2;
        return i;
      };
      let version2 = next();
      let codec2 = DAG_PB_CODE$1;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else {
        codec2 = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version2, codec: codec2, multihashCode, digestSize, multihashSize, size };
    }
    static parse(source2, base3) {
      const [prefix, bytes2] = parseCIDtoBytes$1(source2, base3);
      const cid = CID2.decode(bytes2);
      if (cid.version === 0 && source2[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache$1(cid).set(prefix, source2);
      return cid;
    }
  };
  var parseCIDtoBytes$1 = (source2, base3) => {
    switch (source2[0]) {
      case "Q": {
        const decoder = base3 || base58btc$a;
        return [
          base58btc$a.prefix,
          decoder.decode(`${base58btc$a.prefix}${source2}`)
        ];
      }
      case base58btc$a.prefix: {
        const decoder = base3 || base58btc$a;
        return [base58btc$a.prefix, decoder.decode(source2)];
      }
      case base32$c.prefix: {
        const decoder = base3 || base32$c;
        return [base32$c.prefix, decoder.decode(source2)];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source2[0], base3.decode(source2)];
      }
    }
  };
  var toStringV0$1 = (bytes2, cache2, base3) => {
    const { prefix } = base3;
    if (prefix !== base58btc$a.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes2).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV1$1 = (bytes2, cache2, base3) => {
    const { prefix } = base3;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes2);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE$1 = 112;
  var SHA_256_CODE$1 = 18;
  var encodeCID$1 = (version2, code2, multihash) => {
    const codeOffset = encodingLength$8(version2);
    const hashOffset = codeOffset + encodingLength$8(code2);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo$6(version2, bytes2, 0);
    encodeTo$6(code2, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  };
  var cidSymbol$1 = Symbol.for("@ipld/js-cid/CID");
  var bases$1 = { ...identityBase$1, ...base2$3, ...base8$3, ...base10$3, ...base16$3, ...base32$d, ...base36$3, ...base58$1, ...base64$c, ...base256emoji$3 };
  var inspect$1 = Symbol.for("nodejs.util.inspect.custom");
  var baseDecoder = Object.values(bases$1).map((codec2) => codec2.decoder).reduce((acc, curr) => acc.or(curr), bases$1.identity.decoder);
  var LIBP2P_KEY_CODE = 114;
  var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
  var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;

  class PeerIdImpl {
    constructor(init2) {
      this[_j] = true;
      this.type = init2.type;
      this.multihash = init2.multihash;
      this.privateKey = init2.privateKey;
      Object.defineProperty(this, "string", {
        enumerable: false,
        writable: true
      });
    }
    get [Symbol.toStringTag]() {
      return `PeerId(${this.toString()})`;
    }
    toString() {
      if (this.string == null) {
        this.string = base58btc$a.encode(this.multihash.bytes).slice(1);
      }
      return this.string;
    }
    toCID() {
      return CID$1.createV1(LIBP2P_KEY_CODE, this.multihash);
    }
    toBytes() {
      return this.multihash.bytes;
    }
    toJSON() {
      return this.toString();
    }
    equals(id) {
      if (id instanceof Uint8Array) {
        return equals$4(this.multihash.bytes, id);
      } else if (typeof id === "string") {
        return peerIdFromString(id).equals(this);
      } else if (id?.multihash?.bytes != null) {
        return equals$4(this.multihash.bytes, id.multihash.bytes);
      } else {
        throw new Error("not valid Id");
      }
    }
    [(_j = symbol$5, inspect$1)]() {
      return `PeerId(${this.toString()})`;
    }
  }

  class RSAPeerIdImpl extends PeerIdImpl {
    constructor(init2) {
      super({ ...init2, type: "RSA" });
      this.type = "RSA";
      this.publicKey = init2.publicKey;
    }
  }

  class Ed25519PeerIdImpl extends PeerIdImpl {
    constructor(init2) {
      super({ ...init2, type: "Ed25519" });
      this.type = "Ed25519";
      this.publicKey = init2.multihash.digest;
    }
  }

  class Secp256k1PeerIdImpl extends PeerIdImpl {
    constructor(init2) {
      super({ ...init2, type: "secp256k1" });
      this.type = "secp256k1";
      this.publicKey = init2.multihash.digest;
    }
  }
  var NoiseExtensions;
  (function(NoiseExtensions2) {
    let _codec;
    NoiseExtensions2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.webtransportCerthashes != null) {
            for (const value of obj.webtransportCerthashes) {
              w.uint32(10);
              w.bytes(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            webtransportCerthashes: []
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.webtransportCerthashes.push(reader2.bytes());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseExtensions2.encode = (obj) => {
      return encodeMessage(obj, NoiseExtensions2.codec());
    };
    NoiseExtensions2.decode = (buf) => {
      return decodeMessage$1(buf, NoiseExtensions2.codec());
    };
  })(NoiseExtensions || (NoiseExtensions = {}));
  var NoiseHandshakePayload;
  (function(NoiseHandshakePayload2) {
    let _codec;
    NoiseHandshakePayload2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (opts.writeDefaults === true || obj.identityKey != null && obj.identityKey.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.identityKey ?? new Uint8Array(0));
          }
          if (opts.writeDefaults === true || obj.identitySig != null && obj.identitySig.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.identitySig ?? new Uint8Array(0));
          }
          if (obj.extensions != null) {
            w.uint32(34);
            NoiseExtensions.codec().encode(obj.extensions, w, {
              writeDefaults: false
            });
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            identityKey: new Uint8Array(0),
            identitySig: new Uint8Array(0)
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.identityKey = reader2.bytes();
                break;
              case 2:
                obj.identitySig = reader2.bytes();
                break;
              case 4:
                obj.extensions = NoiseExtensions.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseHandshakePayload2.encode = (obj) => {
      return encodeMessage(obj, NoiseHandshakePayload2.codec());
    };
    NoiseHandshakePayload2.decode = (buf) => {
      return decodeMessage$1(buf, NoiseHandshakePayload2.codec());
    };
  })(NoiseHandshakePayload || (NoiseHandshakePayload = {}));
  var base32$b = rfc4648$c({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  rfc4648$c({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  rfc4648$c({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  rfc4648$c({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  rfc4648$c({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  rfc4648$c({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  rfc4648$c({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  rfc4648$c({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  rfc4648$c({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  debug.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc$b.baseEncode(v);
  };
  debug.formatters.t = (v) => {
    return v == null ? "undefined" : base32$b.baseEncode(v);
  };
  debug.formatters.m = (v) => {
    return v == null ? "undefined" : base64$d.baseEncode(v);
  };
  debug.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  var log$z = logger$9("libp2p:noise");
  var keyLogger;
  if (DUMP_SESSION_KEYS) {
    keyLogger = log$z;
  } else {
    keyLogger = Object.assign(() => {
    }, {
      enabled: false,
      trace: () => {
      },
      error: () => {
      }
    });
  }
  var MIN_NONCE = 0;
  var MAX_NONCE = 4294967295;
  var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";

  class Nonce {
    constructor(n = MIN_NONCE) {
      this.n = n;
      this.bytes = new Uint8Array(12);
      this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
      this.view.setUint32(4, n, true);
    }
    increment() {
      this.n++;
      this.view.setUint32(4, this.n, true);
    }
    getBytes() {
      return this.bytes;
    }
    getUint64() {
      return this.n;
    }
    assertValue() {
      if (this.n > MAX_NONCE) {
        throw new Error(ERR_MAX_NONCE);
      }
    }
  }

  class AbstractHandshake {
    constructor(crypto2) {
      this.crypto = crypto2;
    }
    encryptWithAd(cs, ad, plaintext) {
      const e = this.encrypt(cs.k, cs.n, ad, plaintext);
      cs.n.increment();
      return e;
    }
    decryptWithAd(cs, ad, ciphertext, dst) {
      const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst);
      if (valid)
        cs.n.increment();
      return { plaintext, valid };
    }
    hasKey(cs) {
      return !this.isEmptyKey(cs.k);
    }
    createEmptyKey() {
      return new Uint8Array(32);
    }
    isEmptyKey(k) {
      const emptyKey = this.createEmptyKey();
      return equals$4(emptyKey, k);
    }
    encrypt(k, n, ad, plaintext) {
      n.assertValue();
      return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);
    }
    encryptAndHash(ss, plaintext) {
      let ciphertext;
      if (this.hasKey(ss.cs)) {
        ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
      } else {
        ciphertext = plaintext;
      }
      this.mixHash(ss, ciphertext);
      return ciphertext;
    }
    decrypt(k, n, ad, ciphertext, dst) {
      n.assertValue();
      const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst);
      if (encryptedMessage) {
        return {
          plaintext: encryptedMessage,
          valid: true
        };
      } else {
        return {
          plaintext: new Uint8Array(0),
          valid: false
        };
      }
    }
    decryptAndHash(ss, ciphertext) {
      let plaintext;
      let valid = true;
      if (this.hasKey(ss.cs)) {
        ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
      } else {
        plaintext = ciphertext;
      }
      this.mixHash(ss, ciphertext);
      return { plaintext, valid };
    }
    dh(privateKey, publicKey) {
      try {
        const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);
        if (derivedU8.length === 32) {
          return derivedU8;
        }
        return derivedU8.subarray(0, 32);
      } catch (e) {
        const err = e;
        log$z.error(err);
        return new Uint8Array(32);
      }
    }
    mixHash(ss, data) {
      ss.h = this.getHash(ss.h, data);
    }
    getHash(a, b) {
      const u = this.crypto.hashSHA256(concat$1([a, b], a.length + b.length));
      return u;
    }
    mixKey(ss, ikm) {
      const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);
      ss.cs = this.initializeKey(tempK);
      ss.ck = ck;
    }
    initializeKey(k) {
      return { k, n: new Nonce };
    }
    initializeSymmetric(protocolName) {
      const protocolNameBytes = fromString$3(protocolName, "utf-8");
      const h = this.hashProtocolName(protocolNameBytes);
      const ck = h;
      const key = this.createEmptyKey();
      const cs = this.initializeKey(key);
      return { cs, ck, h };
    }
    hashProtocolName(protocolName) {
      if (protocolName.length <= 32) {
        const h = new Uint8Array(32);
        h.set(protocolName);
        return h;
      } else {
        return this.getHash(protocolName, new Uint8Array(0));
      }
    }
    split(ss) {
      const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));
      const cs1 = this.initializeKey(tempk1);
      const cs2 = this.initializeKey(tempk2);
      return { cs1, cs2 };
    }
    writeMessageRegular(cs, payload) {
      const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);
      const ne = this.createEmptyKey();
      const ns = new Uint8Array(0);
      return { ne, ns, ciphertext };
    }
    readMessageRegular(cs, message2) {
      return this.decryptWithAd(cs, new Uint8Array(0), message2.ciphertext);
    }
  }

  class XX extends AbstractHandshake {
    initializeInitiator(prologue, s2, rs, psk) {
      const name2 = "Noise_XX_25519_ChaChaPoly_SHA256";
      const ss = this.initializeSymmetric(name2);
      this.mixHash(ss, prologue);
      const re = new Uint8Array(32);
      return { ss, s: s2, rs, psk, re };
    }
    initializeResponder(prologue, s2, rs, psk) {
      const name2 = "Noise_XX_25519_ChaChaPoly_SHA256";
      const ss = this.initializeSymmetric(name2);
      this.mixHash(ss, prologue);
      const re = new Uint8Array(32);
      return { ss, s: s2, rs, psk, re };
    }
    writeMessageA(hs, payload, e) {
      const ns = new Uint8Array(0);
      if (e !== undefined) {
        hs.e = e;
      } else {
        hs.e = this.crypto.generateX25519KeyPair();
      }
      const ne = hs.e.publicKey;
      this.mixHash(hs.ss, ne);
      const ciphertext = this.encryptAndHash(hs.ss, payload);
      return { ne, ns, ciphertext };
    }
    writeMessageB(hs, payload) {
      hs.e = this.crypto.generateX25519KeyPair();
      const ne = hs.e.publicKey;
      this.mixHash(hs.ss, ne);
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
      const spk = hs.s.publicKey;
      const ns = this.encryptAndHash(hs.ss, spk);
      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
      const ciphertext = this.encryptAndHash(hs.ss, payload);
      return { ne, ns, ciphertext };
    }
    writeMessageC(hs, payload) {
      const spk = hs.s.publicKey;
      const ns = this.encryptAndHash(hs.ss, spk);
      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
      const ciphertext = this.encryptAndHash(hs.ss, payload);
      const ne = this.createEmptyKey();
      const messageBuffer = { ne, ns, ciphertext };
      const { cs1, cs2 } = this.split(hs.ss);
      return { h: hs.ss.h, messageBuffer, cs1, cs2 };
    }
    readMessageA(hs, message2) {
      if (isValidPublicKey(message2.ne)) {
        hs.re = message2.ne;
      }
      this.mixHash(hs.ss, hs.re);
      return this.decryptAndHash(hs.ss, message2.ciphertext);
    }
    readMessageB(hs, message2) {
      if (isValidPublicKey(message2.ne)) {
        hs.re = message2.ne;
      }
      this.mixHash(hs.ss, hs.re);
      if (!hs.e) {
        throw new Error("Handshake state `e` param is missing.");
      }
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
      const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
      if (valid1 && isValidPublicKey(ns)) {
        hs.rs = ns;
      }
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
      const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
      return { plaintext, valid: valid1 && valid2 };
    }
    readMessageC(hs, message2) {
      const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
      if (valid1 && isValidPublicKey(ns)) {
        hs.rs = ns;
      }
      if (!hs.e) {
        throw new Error("Handshake state `e` param is missing.");
      }
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
      const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
      const { cs1, cs2 } = this.split(hs.ss);
      return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
    }
    initSession(initiator, prologue, s2) {
      const psk = this.createEmptyKey();
      const rs = new Uint8Array(32);
      let hs;
      if (initiator) {
        hs = this.initializeInitiator(prologue, s2, rs, psk);
      } else {
        hs = this.initializeResponder(prologue, s2, rs, psk);
      }
      return {
        hs,
        i: initiator,
        mc: 0
      };
    }
    sendMessage(session, message2, ephemeral) {
      let messageBuffer;
      if (session.mc === 0) {
        messageBuffer = this.writeMessageA(session.hs, message2, ephemeral);
      } else if (session.mc === 1) {
        messageBuffer = this.writeMessageB(session.hs, message2);
      } else if (session.mc === 2) {
        const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message2);
        messageBuffer = resultingBuffer;
        session.h = h;
        session.cs1 = cs1;
        session.cs2 = cs2;
      } else if (session.mc > 2) {
        if (session.i) {
          if (!session.cs1) {
            throw new Error("CS1 (cipher state) is not defined");
          }
          messageBuffer = this.writeMessageRegular(session.cs1, message2);
        } else {
          if (!session.cs2) {
            throw new Error("CS2 (cipher state) is not defined");
          }
          messageBuffer = this.writeMessageRegular(session.cs2, message2);
        }
      } else {
        throw new Error("Session invalid.");
      }
      session.mc++;
      return messageBuffer;
    }
    recvMessage(session, message2) {
      let plaintext = new Uint8Array(0);
      let valid = false;
      if (session.mc === 0) {
        ({ plaintext, valid } = this.readMessageA(session.hs, message2));
      } else if (session.mc === 1) {
        ({ plaintext, valid } = this.readMessageB(session.hs, message2));
      } else if (session.mc === 2) {
        const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message2);
        plaintext = resultingPlaintext;
        valid = resultingValid;
        session.h = h;
        session.cs1 = cs1;
        session.cs2 = cs2;
      }
      session.mc++;
      return { plaintext, valid };
    }
  }

  class XXHandshake {
    constructor(isInitiator, payload, prologue, crypto2, staticKeypair, connection, remotePeer, handshake2) {
      this.remoteExtensions = { webtransportCerthashes: [] };
      this.isInitiator = isInitiator;
      this.payload = payload;
      this.prologue = prologue;
      this.staticKeypair = staticKeypair;
      this.connection = connection;
      if (remotePeer) {
        this.remotePeer = remotePeer;
      }
      this.xx = handshake2 ?? new XX(crypto2);
      this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
    }
    async propose() {
      logLocalStaticKeys(this.session.hs.s);
      if (this.isInitiator) {
        log$z.trace("Stage 0 - Initiator starting to send first message.");
        const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));
        await this.connection.write(encode0(messageBuffer));
        log$z.trace("Stage 0 - Initiator finished sending first message.");
        logLocalEphemeralKeys(this.session.hs.e);
      } else {
        log$z.trace("Stage 0 - Responder waiting to receive first message...");
        const receivedMessageBuffer = decode0((await this.connection.read()).subarray());
        const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
        if (!valid) {
          throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");
        }
        log$z.trace("Stage 0 - Responder received first message.");
        logRemoteEphemeralKey(this.session.hs.re);
      }
    }
    async exchange() {
      if (this.isInitiator) {
        log$z.trace("Stage 1 - Initiator waiting to receive first message from responder...");
        const receivedMessageBuffer = decode1((await this.connection.read()).subarray());
        const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
        if (!valid) {
          throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");
        }
        log$z.trace("Stage 1 - Initiator received the message.");
        logRemoteEphemeralKey(this.session.hs.re);
        logRemoteStaticKey(this.session.hs.rs);
        log$z.trace("Initiator going to check remote's signature...");
        try {
          const decodedPayload = decodePayload(plaintext);
          this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
          await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
          this.setRemoteNoiseExtension(decodedPayload.extensions);
        } catch (e) {
          const err = e;
          throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);
        }
        log$z.trace("All good with the signature!");
      } else {
        log$z.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
        const messageBuffer = this.xx.sendMessage(this.session, this.payload);
        await this.connection.write(encode1(messageBuffer));
        log$z.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
        logLocalEphemeralKeys(this.session.hs.e);
      }
    }
    async finish() {
      if (this.isInitiator) {
        log$z.trace("Stage 2 - Initiator sending third handshake message.");
        const messageBuffer = this.xx.sendMessage(this.session, this.payload);
        await this.connection.write(encode2(messageBuffer));
        log$z.trace("Stage 2 - Initiator sent message with signed payload.");
      } else {
        log$z.trace("Stage 2 - Responder waiting for third handshake message...");
        const receivedMessageBuffer = decode2((await this.connection.read()).subarray());
        const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
        if (!valid) {
          throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");
        }
        log$z.trace("Stage 2 - Responder received the message, finished handshake.");
        try {
          const decodedPayload = decodePayload(plaintext);
          this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
          await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
          this.setRemoteNoiseExtension(decodedPayload.extensions);
        } catch (e) {
          const err = e;
          throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);
        }
      }
      logCipherState(this.session);
    }
    encrypt(plaintext, session) {
      const cs = this.getCS(session);
      return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);
    }
    decrypt(ciphertext, session, dst) {
      const cs = this.getCS(session, false);
      return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst);
    }
    getRemoteStaticKey() {
      return this.session.hs.rs;
    }
    getCS(session, encryption = true) {
      if (!session.cs1 || !session.cs2) {
        throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");
      }
      if (this.isInitiator) {
        return encryption ? session.cs1 : session.cs2;
      } else {
        return encryption ? session.cs2 : session.cs1;
      }
    }
    setRemoteNoiseExtension(e) {
      if (e) {
        this.remoteExtensions = e;
      }
    }
  }

  class Noise {
    constructor(init2 = {}) {
      this.protocol = "/noise";
      const { staticNoiseKey, extensions, crypto: crypto2, prologueBytes, metrics } = init2;
      this.crypto = crypto2 ?? pureJsCrypto;
      this.extensions = extensions;
      this.metrics = metrics ? registerMetrics(metrics) : undefined;
      if (staticNoiseKey) {
        this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
      } else {
        this.staticKeys = this.crypto.generateX25519KeyPair();
      }
      this.prologue = prologueBytes ?? new Uint8Array(0);
    }
    async secureOutbound(localPeer, connection, remotePeer) {
      const wrappedConnection = lpStream(connection, {
        lengthEncoder: uint16BEEncode,
        lengthDecoder: uint16BEDecode,
        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake2 = await this.performHandshake({
        connection: wrappedConnection,
        isInitiator: true,
        localPeer,
        remotePeer
      });
      const conn = await this.createSecureConnection(wrappedConnection, handshake2);
      return {
        conn,
        remoteExtensions: handshake2.remoteExtensions,
        remotePeer: handshake2.remotePeer
      };
    }
    async secureInbound(localPeer, connection, remotePeer) {
      const wrappedConnection = lpStream(connection, {
        lengthEncoder: uint16BEEncode,
        lengthDecoder: uint16BEDecode,
        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake2 = await this.performHandshake({
        connection: wrappedConnection,
        isInitiator: false,
        localPeer,
        remotePeer
      });
      const conn = await this.createSecureConnection(wrappedConnection, handshake2);
      return {
        conn,
        remotePeer: handshake2.remotePeer,
        remoteExtensions: handshake2.remoteExtensions
      };
    }
    async performHandshake(params) {
      const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions);
      return this.performXXHandshake(params, payload);
    }
    async performXXHandshake(params, payload) {
      const { isInitiator, remotePeer, connection } = params;
      const handshake2 = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);
      try {
        await handshake2.propose();
        await handshake2.exchange();
        await handshake2.finish();
        this.metrics?.xxHandshakeSuccesses.increment();
      } catch (e) {
        this.metrics?.xxHandshakeErrors.increment();
        if (e instanceof Error) {
          e.message = `Error occurred during XX handshake: ${e.message}`;
          throw e;
        }
      }
      return handshake2;
    }
    async createSecureConnection(connection, handshake2) {
      const [secure, user] = duplexPair();
      const network = connection.unwrap();
      await pipe(secure, encryptStream(handshake2, this.metrics), network, (source2) => decode$v(source2, { lengthDecoder: uint16BEDecode }), decryptStream(handshake2, this.metrics), secure);
      return user;
    }
  }
  var src$a = base$b;
  var _brrp__multiformats_scope_baseX$a = src$a;
  var coerce$a = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$b = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$b = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$b(this, decoder);
    }
  };
  var ComposedDecoder$a = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$b(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$b = (left2, right2) => new ComposedDecoder$a({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$a = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$b(name2, prefix, baseEncode);
      this.decoder = new Decoder$b(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$h = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$a(name2, prefix, encode3, decode3);
  var baseX$a = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$a(alphabet2, name2);
    return from$h({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$a(decode3(text))
    });
  };
  var decode$n = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$t = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$a = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$h({
      prefix,
      name: name2,
      encode(input) {
        return encode$t(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$n(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base32$a = rfc4648$a({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  rfc4648$a({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  rfc4648$a({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  rfc4648$a({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  rfc4648$a({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  rfc4648$a({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  rfc4648$a({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  rfc4648$a({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  rfc4648$a({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base58btc$9 = baseX$a({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$a({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base64$a = rfc4648$a({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$a({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$a({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$a({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  debug.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc$9.baseEncode(v);
  };
  debug.formatters.t = (v) => {
    return v == null ? "undefined" : base32$a.baseEncode(v);
  };
  debug.formatters.m = (v) => {
    return v == null ? "undefined" : base64$a.baseEncode(v);
  };
  debug.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  var AbortError$4 = class AbortError2 extends Error {
    constructor(message2, code2) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.code = code2 ?? "ABORT_ERR";
    }
  };
  var RateLimiterAbstract_1$1 = class RateLimiterAbstract2 {
    constructor(opts = {}) {
      this.points = opts.points;
      this.duration = opts.duration;
      this.blockDuration = opts.blockDuration;
      this.execEvenly = opts.execEvenly;
      this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;
      this.keyPrefix = opts.keyPrefix;
    }
    get points() {
      return this._points;
    }
    set points(value) {
      this._points = value >= 0 ? value : 4;
    }
    get duration() {
      return this._duration;
    }
    set duration(value) {
      this._duration = typeof value === "undefined" ? 1 : value;
    }
    get msDuration() {
      return this.duration * 1000;
    }
    get blockDuration() {
      return this._blockDuration;
    }
    set blockDuration(value) {
      this._blockDuration = typeof value === "undefined" ? 0 : value;
    }
    get msBlockDuration() {
      return this.blockDuration * 1000;
    }
    get execEvenly() {
      return this._execEvenly;
    }
    set execEvenly(value) {
      this._execEvenly = typeof value === "undefined" ? false : Boolean(value);
    }
    get execEvenlyMinDelayMs() {
      return this._execEvenlyMinDelayMs;
    }
    set execEvenlyMinDelayMs(value) {
      this._execEvenlyMinDelayMs = typeof value === "undefined" ? Math.ceil(this.msDuration / this.points) : value;
    }
    get keyPrefix() {
      return this._keyPrefix;
    }
    set keyPrefix(value) {
      if (typeof value === "undefined") {
        value = "rlflx";
      }
      if (typeof value !== "string") {
        throw new Error("keyPrefix must be string");
      }
      this._keyPrefix = value;
    }
    _getKeySecDuration(options = {}) {
      return options && options.customDuration >= 0 ? options.customDuration : this.duration;
    }
    getKey(key) {
      return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
    }
    parseKey(rlKey) {
      return rlKey.substring(this.keyPrefix.length);
    }
    consume() {
      throw new Error("You have to implement the method 'consume'!");
    }
    penalty() {
      throw new Error("You have to implement the method 'penalty'!");
    }
    reward() {
      throw new Error("You have to implement the method 'reward'!");
    }
    get() {
      throw new Error("You have to implement the method 'get'!");
    }
    set() {
      throw new Error("You have to implement the method 'set'!");
    }
    block() {
      throw new Error("You have to implement the method 'block'!");
    }
    delete() {
      throw new Error("You have to implement the method 'delete'!");
    }
  };
  var BlockedKeys_1$3 = class BlockedKeys2 {
    constructor() {
      this._keys = {};
      this._addedKeysAmount = 0;
    }
    collectExpired() {
      const now = Date.now();
      Object.keys(this._keys).forEach((key) => {
        if (this._keys[key] <= now) {
          delete this._keys[key];
        }
      });
      this._addedKeysAmount = Object.keys(this._keys).length;
    }
    add(key, sec) {
      this.addMs(key, sec * 1000);
    }
    addMs(key, ms2) {
      this._keys[key] = Date.now() + ms2;
      this._addedKeysAmount++;
      if (this._addedKeysAmount > 999) {
        this.collectExpired();
      }
    }
    msBeforeExpire(key) {
      const expire = this._keys[key];
      if (expire && expire >= Date.now()) {
        this.collectExpired();
        const now = Date.now();
        return expire >= now ? expire - now : 0;
      }
      return 0;
    }
    delete(key) {
      if (key) {
        delete this._keys[key];
      } else {
        Object.keys(this._keys).forEach((key2) => {
          delete this._keys[key2];
        });
      }
    }
  };
  var BlockedKeys$3 = BlockedKeys_1$3;
  var BlockedKeys_1$2 = BlockedKeys$3;
  var RateLimiterRes_1$1 = class RateLimiterRes2 {
    constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {
      this.remainingPoints = typeof remainingPoints === "undefined" ? 0 : remainingPoints;
      this.msBeforeNext = typeof msBeforeNext === "undefined" ? 0 : msBeforeNext;
      this.consumedPoints = typeof consumedPoints === "undefined" ? 0 : consumedPoints;
      this.isFirstInDuration = typeof isFirstInDuration === "undefined" ? false : isFirstInDuration;
    }
    get msBeforeNext() {
      return this._msBeforeNext;
    }
    set msBeforeNext(ms2) {
      this._msBeforeNext = ms2;
      return this;
    }
    get remainingPoints() {
      return this._remainingPoints;
    }
    set remainingPoints(p) {
      this._remainingPoints = p;
      return this;
    }
    get consumedPoints() {
      return this._consumedPoints;
    }
    set consumedPoints(p) {
      this._consumedPoints = p;
      return this;
    }
    get isFirstInDuration() {
      return this._isFirstInDuration;
    }
    set isFirstInDuration(value) {
      this._isFirstInDuration = Boolean(value);
    }
    _getDecoratedProperties() {
      return {
        remainingPoints: this.remainingPoints,
        msBeforeNext: this.msBeforeNext,
        consumedPoints: this.consumedPoints,
        isFirstInDuration: this.isFirstInDuration
      };
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this._getDecoratedProperties();
    }
    toString() {
      return JSON.stringify(this._getDecoratedProperties());
    }
    toJSON() {
      return this._getDecoratedProperties();
    }
  };
  var RateLimiterAbstract$7 = RateLimiterAbstract_1$1;
  var BlockedKeys$2 = BlockedKeys_1$2;
  var RateLimiterRes$n = RateLimiterRes_1$1;
  var RateLimiterStoreAbstract_1$1 = class RateLimiterStoreAbstract2 extends RateLimiterAbstract$7 {
    constructor(opts = {}) {
      super(opts);
      this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;
      this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;
      this.insuranceLimiter = opts.insuranceLimiter;
      this._inMemoryBlockedKeys = new BlockedKeys$2;
    }
    get client() {
      return this._client;
    }
    set client(value) {
      if (typeof value === "undefined") {
        throw new Error("storeClient is not set");
      }
      this._client = value;
    }
    _afterConsume(resolve5, reject, rlKey, changedPoints, storeResult, options = {}) {
      const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);
      if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
        this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);
        if (res.consumedPoints > this.points) {
          return reject(res);
        } else {
          return resolve5(res);
        }
      } else if (res.consumedPoints > this.points) {
        let blockPromise = Promise.resolve();
        if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {
          res.msBeforeNext = this.msBlockDuration;
          blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);
        }
        if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
          this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);
          res.msBeforeNext = this.msInMemoryBlockDuration;
        }
        blockPromise.then(() => {
          reject(res);
        }).catch((err) => {
          reject(err);
        });
      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
        let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
        if (delay < this.execEvenlyMinDelayMs) {
          delay = res.consumedPoints * this.execEvenlyMinDelayMs;
        }
        setTimeout(resolve5, delay, res);
      } else {
        resolve5(res);
      }
    }
    _handleError(err, funcName, resolve5, reject, key, data = false, options = {}) {
      if (!(this.insuranceLimiter instanceof RateLimiterAbstract$7)) {
        reject(err);
      } else {
        this.insuranceLimiter[funcName](key, data, options).then((res) => {
          resolve5(res);
        }).catch((res) => {
          reject(res);
        });
      }
    }
    get _inmemoryBlockedKeys() {
      return this._inMemoryBlockedKeys;
    }
    getInmemoryBlockMsBeforeExpire(rlKey) {
      return this.getInMemoryBlockMsBeforeExpire(rlKey);
    }
    get inmemoryBlockOnConsumed() {
      return this.inMemoryBlockOnConsumed;
    }
    set inmemoryBlockOnConsumed(value) {
      this.inMemoryBlockOnConsumed = value;
    }
    get inmemoryBlockDuration() {
      return this.inMemoryBlockDuration;
    }
    set inmemoryBlockDuration(value) {
      this.inMemoryBlockDuration = value;
    }
    get msInmemoryBlockDuration() {
      return this.inMemoryBlockDuration * 1000;
    }
    getInMemoryBlockMsBeforeExpire(rlKey) {
      if (this.inMemoryBlockOnConsumed > 0) {
        return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);
      }
      return 0;
    }
    get inMemoryBlockOnConsumed() {
      return this._inMemoryBlockOnConsumed;
    }
    set inMemoryBlockOnConsumed(value) {
      this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;
      if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {
        throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
      }
    }
    get inMemoryBlockDuration() {
      return this._inMemoryBlockDuration;
    }
    set inMemoryBlockDuration(value) {
      this._inMemoryBlockDuration = value ? parseInt(value) : 0;
      if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {
        throw new Error("inMemoryBlockOnConsumed option must be set up");
      }
    }
    get msInMemoryBlockDuration() {
      return this._inMemoryBlockDuration * 1000;
    }
    get insuranceLimiter() {
      return this._insuranceLimiter;
    }
    set insuranceLimiter(value) {
      if (typeof value !== "undefined" && !(value instanceof RateLimiterAbstract$7)) {
        throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
      }
      this._insuranceLimiter = value;
      if (this._insuranceLimiter) {
        this._insuranceLimiter.blockDuration = this.blockDuration;
        this._insuranceLimiter.execEvenly = this.execEvenly;
      }
    }
    block(key, secDuration, options = {}) {
      const msDuration = secDuration * 1000;
      return this._block(this.getKey(key), this.points + 1, msDuration, options);
    }
    set(key, points, secDuration, options = {}) {
      const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;
      return this._block(this.getKey(key), points, msDuration, options);
    }
    consume(key, pointsToConsume = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const rlKey = this.getKey(key);
        const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);
        if (inMemoryBlockMsBeforeExpire > 0) {
          return reject(new RateLimiterRes$n(0, inMemoryBlockMsBeforeExpire));
        }
        this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options).then((res) => {
          this._afterConsume(resolve5, reject, rlKey, pointsToConsume, res);
        }).catch((err) => {
          this._handleError(err, "consume", resolve5, reject, key, pointsToConsume, options);
        });
      });
    }
    penalty(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5, reject) => {
        this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options).then((res) => {
          resolve5(this._getRateLimiterRes(rlKey, points, res));
        }).catch((err) => {
          this._handleError(err, "penalty", resolve5, reject, key, points, options);
        });
      });
    }
    reward(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5, reject) => {
        this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options).then((res) => {
          resolve5(this._getRateLimiterRes(rlKey, -points, res));
        }).catch((err) => {
          this._handleError(err, "reward", resolve5, reject, key, points, options);
        });
      });
    }
    get(key, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5, reject) => {
        this._get(rlKey, options).then((res) => {
          if (res === null || typeof res === "undefined") {
            resolve5(null);
          } else {
            resolve5(this._getRateLimiterRes(rlKey, 0, res));
          }
        }).catch((err) => {
          this._handleError(err, "get", resolve5, reject, key, options);
        });
      });
    }
    delete(key, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5, reject) => {
        this._delete(rlKey, options).then((res) => {
          this._inMemoryBlockedKeys.delete(rlKey);
          resolve5(res);
        }).catch((err) => {
          this._handleError(err, "delete", resolve5, reject, key, options);
        });
      });
    }
    deleteInMemoryBlockedAll() {
      this._inMemoryBlockedKeys.delete();
    }
    _getRateLimiterRes(rlKey, changedPoints, storeResult) {
      throw new Error("You have to implement the method '_getRateLimiterRes'!");
    }
    _block(rlKey, initPoints, msDuration, options = {}) {
      return new Promise((resolve5, reject) => {
        this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {
          resolve5(new RateLimiterRes$n(0, msDuration > 0 ? msDuration : -1, initPoints));
        }).catch((err) => {
          this._handleError(err, "block", resolve5, reject, this.parseKey(rlKey), msDuration / 1000, options);
        });
      });
    }
    _get(rlKey, options = {}) {
      throw new Error("You have to implement the method '_get'!");
    }
    _delete(rlKey, options = {}) {
      throw new Error("You have to implement the method '_delete'!");
    }
    _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
      throw new Error("You have to implement the method '_upsert'!");
    }
  };
  var RateLimiterStoreAbstract$9 = RateLimiterStoreAbstract_1$1;
  var RateLimiterRes$m = RateLimiterRes_1$1;
  var incrTtlLuaScript$1 = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} `;
  var RateLimiterRedis$3 = class RateLimiterRedis2 extends RateLimiterStoreAbstract$9 {
    constructor(opts) {
      super(opts);
      if (opts.redis) {
        this.client = opts.redis;
      } else {
        this.client = opts.storeClient;
      }
      this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;
      if (typeof this.client.defineCommand === "function") {
        this.client.defineCommand("rlflxIncr", {
          numberOfKeys: 1,
          lua: incrTtlLuaScript$1
        });
      }
    }
    _isRedisReady() {
      if (!this._rejectIfRedisNotReady) {
        return true;
      }
      if (this.client.status && this.client.status !== "ready") {
        return false;
      }
      if (typeof this.client.isReady === "function" && !this.client.isReady()) {
        return false;
      }
      return true;
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      let [consumed, resTtlMs] = result;
      if (Array.isArray(consumed)) {
        [, consumed] = consumed;
        [, resTtlMs] = resTtlMs;
      }
      const res = new RateLimiterRes$m;
      res.consumedPoints = parseInt(consumed);
      res.isFirstInDuration = res.consumedPoints === changedPoints;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = resTtlMs;
      return res;
    }
    _upsert(rlKey, points, msDuration, forceExpire = false) {
      return new Promise((resolve5, reject) => {
        if (!this._isRedisReady()) {
          return reject(new Error("Redis connection is not ready"));
        }
        const secDuration = Math.floor(msDuration / 1000);
        const multi = this.client.multi();
        if (forceExpire) {
          if (secDuration > 0) {
            multi.set(rlKey, points, "EX", secDuration);
          } else {
            multi.set(rlKey, points);
          }
          multi.pttl(rlKey).exec((err, res) => {
            if (err) {
              return reject(err);
            }
            return resolve5(res);
          });
        } else {
          if (secDuration > 0) {
            const incrCallback = function(err, result) {
              if (err) {
                return reject(err);
              }
              return resolve5(result);
            };
            if (typeof this.client.rlflxIncr === "function") {
              this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);
            } else {
              this.client.eval(incrTtlLuaScript$1, 1, rlKey, points, secDuration, incrCallback);
            }
          } else {
            multi.incrby(rlKey, points).pttl(rlKey).exec((err, res) => {
              if (err) {
                return reject(err);
              }
              return resolve5(res);
            });
          }
        }
      });
    }
    _get(rlKey) {
      return new Promise((resolve5, reject) => {
        if (!this._isRedisReady()) {
          return reject(new Error("Redis connection is not ready"));
        }
        this.client.multi().get(rlKey).pttl(rlKey).exec((err, res) => {
          if (err) {
            reject(err);
          } else {
            const [points] = res;
            if (points === null) {
              return resolve5(null);
            }
            resolve5(res);
          }
        });
      });
    }
    _delete(rlKey) {
      return new Promise((resolve5, reject) => {
        this.client.del(rlKey, (err, res) => {
          if (err) {
            reject(err);
          } else {
            resolve5(res > 0);
          }
        });
      });
    }
  };
  var RateLimiterRedis_1$1 = RateLimiterRedis$3;
  var RateLimiterStoreAbstract$8 = RateLimiterStoreAbstract_1$1;
  var RateLimiterRes$l = RateLimiterRes_1$1;
  var RateLimiterMongo$3 = class RateLimiterMongo2 extends RateLimiterStoreAbstract$8 {
    constructor(opts) {
      super(opts);
      this.dbName = opts.dbName;
      this.tableName = opts.tableName;
      this.indexKeyPrefix = opts.indexKeyPrefix;
      if (opts.mongo) {
        this.client = opts.mongo;
      } else {
        this.client = opts.storeClient;
      }
      if (typeof this.client.then === "function") {
        this.client.then((conn) => {
          this.client = conn;
          this._initCollection();
          this._driverVersion = getDriverVersion$1(this.client);
        });
      } else {
        this._initCollection();
        this._driverVersion = getDriverVersion$1(this.client);
      }
    }
    get dbName() {
      return this._dbName;
    }
    set dbName(value) {
      this._dbName = typeof value === "undefined" ? RateLimiterMongo2.getDbName() : value;
    }
    static getDbName() {
      return "node-rate-limiter-flexible";
    }
    get tableName() {
      return this._tableName;
    }
    set tableName(value) {
      this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
    }
    get client() {
      return this._client;
    }
    set client(value) {
      if (typeof value === "undefined") {
        throw new Error("mongo is not set");
      }
      this._client = value;
    }
    get indexKeyPrefix() {
      return this._indexKeyPrefix;
    }
    set indexKeyPrefix(obj) {
      this._indexKeyPrefix = obj || {};
    }
    _initCollection() {
      const db = typeof this.client.db === "function" ? this.client.db(this.dbName) : this.client;
      const collection = db.collection(this.tableName);
      collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });
      collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });
      this._collection = collection;
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      const res = new RateLimiterRes$l;
      let doc;
      if (typeof result.value === "undefined") {
        doc = result;
      } else {
        doc = result.value;
      }
      res.isFirstInDuration = doc.points === changedPoints;
      res.consumedPoints = doc.points;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;
      return res;
    }
    _upsert(key, points, msDuration, forceExpire = false, options = {}) {
      if (!this._collection) {
        return Promise.reject(Error("Mongo connection is not established"));
      }
      const docAttrs = options.attrs || {};
      let where;
      let upsertData;
      if (forceExpire) {
        where = { key };
        where = Object.assign(where, docAttrs);
        upsertData = {
          $set: {
            key,
            points,
            expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
          }
        };
        upsertData.$set = Object.assign(upsertData.$set, docAttrs);
      } else {
        where = {
          $or: [
            { expire: { $gt: new Date } },
            { expire: { $eq: null } }
          ],
          key
        };
        where = Object.assign(where, docAttrs);
        upsertData = {
          $setOnInsert: {
            key,
            expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
          },
          $inc: { points }
        };
        upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);
      }
      const upsertOptions = {
        upsert: true
      };
      if (this._driverVersion.major >= 4 || (this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7)) {
        upsertOptions.returnDocument = "after";
      } else {
        upsertOptions.returnOriginal = false;
      }
      return new Promise((resolve5, reject) => {
        this._collection.findOneAndUpdate(where, upsertData, upsertOptions).then((res) => {
          resolve5(res);
        }).catch((errUpsert) => {
          if (errUpsert && errUpsert.code === 11000) {
            const replaceWhere = Object.assign({
              $or: [
                { expire: { $lte: new Date } },
                { expire: { $eq: null } }
              ],
              key
            }, docAttrs);
            const replaceTo = {
              $set: Object.assign({
                key,
                points,
                expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
              }, docAttrs)
            };
            this._collection.findOneAndUpdate(replaceWhere, replaceTo, upsertOptions).then((res) => {
              resolve5(res);
            }).catch((errReplace) => {
              if (errReplace && errReplace.code === 11000) {
                this._upsert(key, points, msDuration, forceExpire).then((res) => resolve5(res)).catch((err) => reject(err));
              } else {
                reject(errReplace);
              }
            });
          } else {
            reject(errUpsert);
          }
        });
      });
    }
    _get(rlKey, options = {}) {
      if (!this._collection) {
        return Promise.reject(Error("Mongo connection is not established"));
      }
      const docAttrs = options.attrs || {};
      const where = Object.assign({
        key: rlKey,
        $or: [
          { expire: { $gt: new Date } },
          { expire: { $eq: null } }
        ]
      }, docAttrs);
      return this._collection.findOne(where);
    }
    _delete(rlKey, options = {}) {
      if (!this._collection) {
        return Promise.reject(Error("Mongo connection is not established"));
      }
      const docAttrs = options.attrs || {};
      const where = Object.assign({ key: rlKey }, docAttrs);
      return this._collection.deleteOne(where).then((res) => res.deletedCount > 0);
    }
  };
  var RateLimiterMongo_1$1 = RateLimiterMongo$3;
  var RateLimiterStoreAbstract$7 = RateLimiterStoreAbstract_1$1;
  var RateLimiterRes$k = RateLimiterRes_1$1;
  var RateLimiterMySQL$3 = class RateLimiterMySQL2 extends RateLimiterStoreAbstract$7 {
    constructor(opts, cb = null) {
      super(opts);
      this.client = opts.storeClient;
      this.clientType = opts.storeType;
      this.dbName = opts.dbName;
      this.tableName = opts.tableName;
      this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
      this.tableCreated = opts.tableCreated;
      if (!this.tableCreated) {
        this._createDbAndTable().then(() => {
          this.tableCreated = true;
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }).catch((err) => {
          if (typeof cb === "function") {
            cb(err);
          } else {
            throw err;
          }
        });
      } else {
        if (this.clearExpiredByTimeout) {
          this._clearExpiredHourAgo();
        }
        if (typeof cb === "function") {
          cb();
        }
      }
    }
    clearExpired(expire) {
      return new Promise((resolve5) => {
        this._getConnection().then((conn) => {
          conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {
            this._releaseConnection(conn);
            resolve5();
          });
        }).catch(() => {
          resolve5();
        });
      });
    }
    _clearExpiredHourAgo() {
      if (this._clearExpiredTimeoutId) {
        clearTimeout(this._clearExpiredTimeoutId);
      }
      this._clearExpiredTimeoutId = setTimeout(() => {
        this.clearExpired(Date.now() - 3600000).then(() => {
          this._clearExpiredHourAgo();
        });
      }, 300000);
      this._clearExpiredTimeoutId.unref();
    }
    _getConnection() {
      switch (this.clientType) {
        case "pool":
          return new Promise((resolve5, reject) => {
            this.client.getConnection((errConn, conn) => {
              if (errConn) {
                return reject(errConn);
              }
              resolve5(conn);
            });
          });
        case "sequelize":
          return this.client.connectionManager.getConnection();
        case "knex":
          return this.client.client.acquireConnection();
        default:
          return Promise.resolve(this.client);
      }
    }
    _releaseConnection(conn) {
      switch (this.clientType) {
        case "pool":
          return conn.release();
        case "sequelize":
          return this.client.connectionManager.releaseConnection(conn);
        case "knex":
          return this.client.client.releaseConnection(conn);
        default:
          return true;
      }
    }
    _createDbAndTable() {
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          conn.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (errDb) => {
            if (errDb) {
              this._releaseConnection(conn);
              return reject(errDb);
            }
            conn.query(this._getCreateTableStmt(), (err) => {
              if (err) {
                this._releaseConnection(conn);
                return reject(err);
              }
              this._releaseConnection(conn);
              resolve5();
            });
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _getCreateTableStmt() {
      return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (` + "`key` VARCHAR(255) CHARACTER SET utf8 NOT NULL,`points` INT(9) NOT NULL default 0,`expire` BIGINT UNSIGNED,PRIMARY KEY (`key`)) ENGINE = INNODB;";
    }
    get clientType() {
      return this._clientType;
    }
    set clientType(value) {
      if (typeof value === "undefined") {
        if (this.client.constructor.name === "Connection") {
          value = "connection";
        } else if (this.client.constructor.name === "Pool") {
          value = "pool";
        } else if (this.client.constructor.name === "Sequelize") {
          value = "sequelize";
        } else {
          throw new Error("storeType is not defined");
        }
      }
      this._clientType = value.toLowerCase();
    }
    get dbName() {
      return this._dbName;
    }
    set dbName(value) {
      this._dbName = typeof value === "undefined" ? "rtlmtrflx" : value;
    }
    get tableName() {
      return this._tableName;
    }
    set tableName(value) {
      this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
    }
    get tableCreated() {
      return this._tableCreated;
    }
    set tableCreated(value) {
      this._tableCreated = typeof value === "undefined" ? false : !!value;
    }
    get clearExpiredByTimeout() {
      return this._clearExpiredByTimeout;
    }
    set clearExpiredByTimeout(value) {
      this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      const res = new RateLimiterRes$k;
      const [row] = result;
      res.isFirstInDuration = changedPoints === row.points;
      res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
      return res;
    }
    _upsertTransaction(conn, key, points, msDuration, forceExpire) {
      return new Promise((resolve5, reject) => {
        conn.query("BEGIN", (errBegin) => {
          if (errBegin) {
            conn.rollback();
            return reject(errBegin);
          }
          const dateNow = Date.now();
          const newExpire = msDuration > 0 ? dateNow + msDuration : null;
          let q;
          let values;
          if (forceExpire) {
            q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`;
            values = [
              this.dbName,
              this.tableName,
              key,
              points,
              newExpire,
              points,
              newExpire
            ];
          } else {
            q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`;
            values = [
              this.dbName,
              this.tableName,
              key,
              points,
              newExpire,
              dateNow,
              points,
              points,
              dateNow,
              newExpire
            ];
          }
          conn.query(q, values, (errUpsert) => {
            if (errUpsert) {
              conn.rollback();
              return reject(errUpsert);
            }
            conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, key], (errSelect, res) => {
              if (errSelect) {
                conn.rollback();
                return reject(errSelect);
              }
              conn.query("COMMIT", (err) => {
                if (err) {
                  conn.rollback();
                  return reject(err);
                }
                resolve5(res);
              });
            });
          });
        });
      });
    }
    _upsert(key, points, msDuration, forceExpire = false) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          this._upsertTransaction(conn, key, points, msDuration, forceExpire).then((res) => {
            resolve5(res);
            this._releaseConnection(conn);
          }).catch((err) => {
            reject(err);
            this._releaseConnection(conn);
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _get(rlKey) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)", [this.dbName, this.tableName, rlKey, Date.now()], (err, res) => {
            if (err) {
              reject(err);
            } else if (res.length === 0) {
              resolve5(null);
            } else {
              resolve5(res);
            }
            this._releaseConnection(conn);
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _delete(rlKey) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          conn.query("DELETE FROM ??.?? WHERE `key` = ?", [this.dbName, this.tableName, rlKey], (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve5(res.affectedRows > 0);
            }
            this._releaseConnection(conn);
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
  };
  var RateLimiterMySQL_1$1 = RateLimiterMySQL$3;
  var RateLimiterStoreAbstract$6 = RateLimiterStoreAbstract_1$1;
  var RateLimiterRes$j = RateLimiterRes_1$1;
  var RateLimiterPostgres$3 = class RateLimiterPostgres2 extends RateLimiterStoreAbstract$6 {
    constructor(opts, cb = null) {
      super(opts);
      this.client = opts.storeClient;
      this.clientType = opts.storeType;
      this.tableName = opts.tableName;
      this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
      this.tableCreated = opts.tableCreated;
      if (!this.tableCreated) {
        this._createTable().then(() => {
          this.tableCreated = true;
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }).catch((err) => {
          if (typeof cb === "function") {
            cb(err);
          } else {
            throw err;
          }
        });
      } else {
        if (typeof cb === "function") {
          cb();
        }
      }
    }
    clearExpired(expire) {
      return new Promise((resolve5) => {
        const q = {
          name: "rlflx-clear-expired",
          text: `DELETE FROM ${this.tableName} WHERE expire < \$1`,
          values: [expire]
        };
        this._query(q).then(() => {
          resolve5();
        }).catch(() => {
          resolve5();
        });
      });
    }
    _clearExpiredHourAgo() {
      if (this._clearExpiredTimeoutId) {
        clearTimeout(this._clearExpiredTimeoutId);
      }
      this._clearExpiredTimeoutId = setTimeout(() => {
        this.clearExpired(Date.now() - 3600000).then(() => {
          this._clearExpiredHourAgo();
        });
      }, 300000);
      this._clearExpiredTimeoutId.unref();
    }
    _getConnection() {
      switch (this.clientType) {
        case "pool":
          return Promise.resolve(this.client);
        case "sequelize":
          return this.client.connectionManager.getConnection();
        case "knex":
          return this.client.client.acquireConnection();
        case "typeorm":
          return Promise.resolve(this.client.driver.master);
        default:
          return Promise.resolve(this.client);
      }
    }
    _releaseConnection(conn) {
      switch (this.clientType) {
        case "pool":
          return true;
        case "sequelize":
          return this.client.connectionManager.releaseConnection(conn);
        case "knex":
          return this.client.client.releaseConnection(conn);
        case "typeorm":
          return true;
        default:
          return true;
      }
    }
    _createTable() {
      return new Promise((resolve5, reject) => {
        this._query({
          text: this._getCreateTableStmt()
        }).then(() => {
          resolve5();
        }).catch((err) => {
          if (err.code === "23505") {
            resolve5();
          } else {
            reject(err);
          }
        });
      });
    }
    _getCreateTableStmt() {
      return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
    }
    get clientType() {
      return this._clientType;
    }
    set clientType(value) {
      const constructorName = this.client.constructor.name;
      if (typeof value === "undefined") {
        if (constructorName === "Client") {
          value = "client";
        } else if (constructorName === "Pool" || constructorName === "BoundPool") {
          value = "pool";
        } else if (constructorName === "Sequelize") {
          value = "sequelize";
        } else {
          throw new Error("storeType is not defined");
        }
      }
      this._clientType = value.toLowerCase();
    }
    get tableName() {
      return this._tableName;
    }
    set tableName(value) {
      this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
    }
    get tableCreated() {
      return this._tableCreated;
    }
    set tableCreated(value) {
      this._tableCreated = typeof value === "undefined" ? false : !!value;
    }
    get clearExpiredByTimeout() {
      return this._clearExpiredByTimeout;
    }
    set clearExpiredByTimeout(value) {
      this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      const res = new RateLimiterRes$j;
      const row = result.rows[0];
      res.isFirstInDuration = changedPoints === row.points;
      res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
      return res;
    }
    _query(q) {
      const prefix = this.tableName.toLowerCase();
      const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          conn.query(queryObj).then((res) => {
            resolve5(res);
            this._releaseConnection(conn);
          }).catch((err) => {
            reject(err);
            this._releaseConnection(conn);
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _upsert(key, points, msDuration, forceExpire = false) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      const newExpire = msDuration > 0 ? Date.now() + msDuration : null;
      const expireQ = forceExpire ? " $3 " : ` CASE
             WHEN ${this.tableName}.expire <= \$4 THEN \$3
             ELSE ${this.tableName}.expire
            END `;
      return this._query({
        name: forceExpire ? "rlflx-upsert-force" : "rlflx-upsert",
        text: `
            INSERT INTO ${this.tableName} VALUES (\$1, \$2, \$3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= \$4 OR 1=${forceExpire ? 1 : 0}) THEN \$2
                          ELSE ${this.tableName}.points + (\$2)
                         END,
                expire = ${expireQ}
            RETURNING points, expire;`,
        values: [key, points, newExpire, Date.now()]
      });
    }
    _get(rlKey) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return new Promise((resolve5, reject) => {
        this._query({
          name: "rlflx-get",
          text: `
            SELECT points, expire FROM ${this.tableName} WHERE key = \$1 AND (expire > \$2 OR expire IS NULL);`,
          values: [rlKey, Date.now()]
        }).then((res) => {
          if (res.rowCount === 0) {
            res = null;
          }
          resolve5(res);
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _delete(rlKey) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return this._query({
        name: "rlflx-delete",
        text: `DELETE FROM ${this.tableName} WHERE key = \$1`,
        values: [rlKey]
      }).then((res) => res.rowCount > 0);
    }
  };
  var RateLimiterPostgres_1$1 = RateLimiterPostgres$3;
  var Record_1$1 = class Record2 {
    constructor(value, expiresAt, timeoutId = null) {
      this.value = value;
      this.expiresAt = expiresAt;
      this.timeoutId = timeoutId;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      this._value = parseInt(value);
    }
    get expiresAt() {
      return this._expiresAt;
    }
    set expiresAt(value) {
      if (!(value instanceof Date) && Number.isInteger(value)) {
        value = new Date(value);
      }
      this._expiresAt = value;
    }
    get timeoutId() {
      return this._timeoutId;
    }
    set timeoutId(value) {
      this._timeoutId = value;
    }
  };
  var Record$1 = Record_1$1;
  var RateLimiterRes$i = RateLimiterRes_1$1;
  var MemoryStorage_1$1 = class MemoryStorage2 {
    constructor() {
      this._storage = {};
    }
    incrby(key, value, durationSec) {
      if (this._storage[key]) {
        const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
        if (msBeforeExpires !== 0) {
          this._storage[key].value = this._storage[key].value + value;
          return new RateLimiterRes$i(0, msBeforeExpires, this._storage[key].value, false);
        }
        return this.set(key, value, durationSec);
      }
      return this.set(key, value, durationSec);
    }
    set(key, value, durationSec) {
      const durationMs = durationSec * 1000;
      if (this._storage[key] && this._storage[key].timeoutId) {
        clearTimeout(this._storage[key].timeoutId);
      }
      this._storage[key] = new Record$1(value, durationMs > 0 ? new Date(Date.now() + durationMs) : null);
      if (durationMs > 0) {
        this._storage[key].timeoutId = setTimeout(() => {
          delete this._storage[key];
        }, durationMs);
        if (this._storage[key].timeoutId.unref) {
          this._storage[key].timeoutId.unref();
        }
      }
      return new RateLimiterRes$i(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);
    }
    get(key) {
      if (this._storage[key]) {
        const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
        return new RateLimiterRes$i(0, msBeforeExpires, this._storage[key].value, false);
      }
      return null;
    }
    delete(key) {
      if (this._storage[key]) {
        if (this._storage[key].timeoutId) {
          clearTimeout(this._storage[key].timeoutId);
        }
        delete this._storage[key];
        return true;
      }
      return false;
    }
  };
  var RateLimiterAbstract$6 = RateLimiterAbstract_1$1;
  var MemoryStorage$1 = MemoryStorage_1$1;
  var RateLimiterRes$h = RateLimiterRes_1$1;
  var RateLimiterMemory$5 = class RateLimiterMemory2 extends RateLimiterAbstract$6 {
    constructor(opts = {}) {
      super(opts);
      this._memoryStorage = new MemoryStorage$1;
    }
    consume(key, pointsToConsume = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const rlKey = this.getKey(key);
        const secDuration = this._getKeySecDuration(options);
        let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        if (res.consumedPoints > this.points) {
          if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
            res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
          }
          reject(res);
        } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
          let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
          if (delay < this.execEvenlyMinDelayMs) {
            delay = res.consumedPoints * this.execEvenlyMinDelayMs;
          }
          setTimeout(resolve5, delay, res);
        } else {
          resolve5(res);
        }
      });
    }
    penalty(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5) => {
        const secDuration = this._getKeySecDuration(options);
        const res = this._memoryStorage.incrby(rlKey, points, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        resolve5(res);
      });
    }
    reward(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5) => {
        const secDuration = this._getKeySecDuration(options);
        const res = this._memoryStorage.incrby(rlKey, -points, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        resolve5(res);
      });
    }
    block(key, secDuration) {
      const msDuration = secDuration * 1000;
      const initPoints = this.points + 1;
      this._memoryStorage.set(this.getKey(key), initPoints, secDuration);
      return Promise.resolve(new RateLimiterRes$h(0, msDuration === 0 ? -1 : msDuration, initPoints));
    }
    set(key, points, secDuration) {
      const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;
      this._memoryStorage.set(this.getKey(key), points, secDuration);
      return Promise.resolve(new RateLimiterRes$h(0, msDuration === 0 ? -1 : msDuration, points));
    }
    get(key) {
      const res = this._memoryStorage.get(this.getKey(key));
      if (res !== null) {
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      }
      return Promise.resolve(res);
    }
    delete(key) {
      return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));
    }
  };
  var RateLimiterMemory_1$1 = RateLimiterMemory$5;
  var cluster$1 = require$$1;
  var crypto$2 = require$$1;
  var RateLimiterAbstract$5 = RateLimiterAbstract_1$1;
  var RateLimiterMemory$4 = RateLimiterMemory_1$1;
  var RateLimiterRes$g = RateLimiterRes_1$1;
  var channel$1 = "rate_limiter_flexible";
  var masterInstance$1 = null;
  var masterSendToWorker$1 = function(worker, msg, type, res) {
    let data;
    if (res === null || res === true || res === false) {
      data = res;
    } else {
      data = {
        remainingPoints: res.remainingPoints,
        msBeforeNext: res.msBeforeNext,
        consumedPoints: res.consumedPoints,
        isFirstInDuration: res.isFirstInDuration
      };
    }
    worker.send({
      channel: channel$1,
      keyPrefix: msg.keyPrefix,
      promiseId: msg.promiseId,
      type,
      data
    });
  };
  var workerWaitInit$1 = function(payload) {
    setTimeout(() => {
      if (this._initiated) {
        process.send(payload);
      } else if (typeof this._promises[payload.promiseId] !== "undefined") {
        workerWaitInit$1.call(this, payload);
      }
    }, 30);
  };
  var workerSendToMaster$1 = function(func, promiseId, key, arg, opts) {
    const payload = {
      channel: channel$1,
      keyPrefix: this.keyPrefix,
      func,
      promiseId,
      data: {
        key,
        arg,
        opts
      }
    };
    if (!this._initiated) {
      workerWaitInit$1.call(this, payload);
    } else {
      process.send(payload);
    }
  };
  var masterProcessMsg$1 = function(worker, msg) {
    if (!msg || msg.channel !== channel$1 || typeof this._rateLimiters[msg.keyPrefix] === "undefined") {
      return false;
    }
    let promise;
    switch (msg.func) {
      case "consume":
        promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);
        break;
      case "penalty":
        promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);
        break;
      case "reward":
        promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);
        break;
      case "block":
        promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);
        break;
      case "get":
        promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);
        break;
      case "delete":
        promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);
        break;
      default:
        return false;
    }
    if (promise) {
      promise.then((res) => {
        masterSendToWorker$1(worker, msg, "resolve", res);
      }).catch((rejRes) => {
        masterSendToWorker$1(worker, msg, "reject", rejRes);
      });
    }
  };
  var workerProcessMsg$1 = function(msg) {
    if (!msg || msg.channel !== channel$1 || msg.keyPrefix !== this.keyPrefix) {
      return false;
    }
    if (this._promises[msg.promiseId]) {
      clearTimeout(this._promises[msg.promiseId].timeoutId);
      let res;
      if (msg.data === null || msg.data === true || msg.data === false) {
        res = msg.data;
      } else {
        res = new RateLimiterRes$g(msg.data.remainingPoints, msg.data.msBeforeNext, msg.data.consumedPoints, msg.data.isFirstInDuration);
      }
      switch (msg.type) {
        case "resolve":
          this._promises[msg.promiseId].resolve(res);
          break;
        case "reject":
          this._promises[msg.promiseId].reject(res);
          break;
        default:
          throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);
      }
      delete this._promises[msg.promiseId];
    }
  };
  var getOpts$1 = function() {
    return {
      points: this.points,
      duration: this.duration,
      blockDuration: this.blockDuration,
      execEvenly: this.execEvenly,
      execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
      keyPrefix: this.keyPrefix
    };
  };
  var savePromise$1 = function(resolve5, reject) {
    const hrtime = process.hrtime();
    let promiseId = hrtime[0].toString() + hrtime[1].toString();
    if (typeof this._promises[promiseId] !== "undefined") {
      promiseId += crypto$2.randomBytes(12).toString("base64");
    }
    this._promises[promiseId] = {
      resolve: resolve5,
      reject,
      timeoutId: setTimeout(() => {
        delete this._promises[promiseId];
        reject(new Error("RateLimiterCluster timeout: no answer from master in time"));
      }, this.timeoutMs)
    };
    return promiseId;
  };
  var RateLimiterClusterMaster$3 = class RateLimiterClusterMaster2 {
    constructor() {
      if (masterInstance$1) {
        return masterInstance$1;
      }
      this._rateLimiters = {};
      cluster$1.setMaxListeners(0);
      cluster$1.on("message", (worker, msg) => {
        if (msg && msg.channel === channel$1 && msg.type === "init") {
          if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory$4(msg.opts);
          }
          worker.send({
            channel: channel$1,
            type: "init",
            keyPrefix: msg.opts.keyPrefix
          });
        } else {
          masterProcessMsg$1.call(this, worker, msg);
        }
      });
      masterInstance$1 = this;
    }
  };
  var RateLimiterClusterMasterPM2$3 = class RateLimiterClusterMasterPM22 {
    constructor(pm2) {
      if (masterInstance$1) {
        return masterInstance$1;
      }
      this._rateLimiters = {};
      pm2.launchBus((err, pm2Bus) => {
        pm2Bus.on("process:msg", (packet2) => {
          const msg = packet2.raw;
          if (msg && msg.channel === channel$1 && msg.type === "init") {
            if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
              this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory$4(msg.opts);
            }
            pm2.sendDataToProcessId(packet2.process.pm_id, {
              data: {},
              topic: channel$1,
              channel: channel$1,
              type: "init",
              keyPrefix: msg.opts.keyPrefix
            }, (sendErr, res) => {
              if (sendErr) {
                console.log(sendErr, res);
              }
            });
          } else {
            const worker = {
              send: (msgData) => {
                const pm2Message = msgData;
                pm2Message.topic = channel$1;
                if (typeof pm2Message.data === "undefined") {
                  pm2Message.data = {};
                }
                pm2.sendDataToProcessId(packet2.process.pm_id, pm2Message, (sendErr, res) => {
                  if (sendErr) {
                    console.log(sendErr, res);
                  }
                });
              }
            };
            masterProcessMsg$1.call(this, worker, msg);
          }
        });
      });
      masterInstance$1 = this;
    }
  };
  var RateLimiterClusterWorker$1 = class RateLimiterClusterWorker2 extends RateLimiterAbstract$5 {
    get timeoutMs() {
      return this._timeoutMs;
    }
    set timeoutMs(value) {
      this._timeoutMs = typeof value === "undefined" ? 5000 : Math.abs(parseInt(value));
    }
    constructor(opts = {}) {
      super(opts);
      process.setMaxListeners(0);
      this.timeoutMs = opts.timeoutMs;
      this._initiated = false;
      process.on("message", (msg) => {
        if (msg && msg.channel === channel$1 && msg.type === "init" && msg.keyPrefix === this.keyPrefix) {
          this._initiated = true;
        } else {
          workerProcessMsg$1.call(this, msg);
        }
      });
      process.send({
        channel: channel$1,
        type: "init",
        opts: getOpts$1.call(this)
      });
      this._promises = {};
    }
    consume(key, pointsToConsume = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise$1.call(this, resolve5, reject);
        workerSendToMaster$1.call(this, "consume", promiseId, key, pointsToConsume, options);
      });
    }
    penalty(key, points = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise$1.call(this, resolve5, reject);
        workerSendToMaster$1.call(this, "penalty", promiseId, key, points, options);
      });
    }
    reward(key, points = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise$1.call(this, resolve5, reject);
        workerSendToMaster$1.call(this, "reward", promiseId, key, points, options);
      });
    }
    block(key, secDuration, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise$1.call(this, resolve5, reject);
        workerSendToMaster$1.call(this, "block", promiseId, key, secDuration, options);
      });
    }
    get(key, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise$1.call(this, resolve5, reject);
        workerSendToMaster$1.call(this, "get", promiseId, key, options);
      });
    }
    delete(key, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise$1.call(this, resolve5, reject);
        workerSendToMaster$1.call(this, "delete", promiseId, key, options);
      });
    }
  };
  var RateLimiterCluster$3 = {
    RateLimiterClusterMaster: RateLimiterClusterMaster$3,
    RateLimiterClusterMasterPM2: RateLimiterClusterMasterPM2$3,
    RateLimiterCluster: RateLimiterClusterWorker$1
  };
  var RateLimiterStoreAbstract$5 = RateLimiterStoreAbstract_1$1;
  var RateLimiterRes$f = RateLimiterRes_1$1;
  var RateLimiterMemcache$3 = class RateLimiterMemcache2 extends RateLimiterStoreAbstract$5 {
    constructor(opts) {
      super(opts);
      this.client = opts.storeClient;
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      const res = new RateLimiterRes$f;
      res.consumedPoints = parseInt(result.consumedPoints);
      res.isFirstInDuration = result.consumedPoints === changedPoints;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = result.msBeforeNext;
      return res;
    }
    _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
      return new Promise((resolve5, reject) => {
        const nowMs = Date.now();
        const secDuration = Math.floor(msDuration / 1000);
        if (forceExpire) {
          this.client.set(rlKey, points, secDuration, (err) => {
            if (!err) {
              this.client.set(`${rlKey}_expire`, secDuration > 0 ? nowMs + secDuration * 1000 : -1, secDuration, () => {
                const res = {
                  consumedPoints: points,
                  msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1
                };
                resolve5(res);
              });
            } else {
              reject(err);
            }
          });
        } else {
          this.client.incr(rlKey, points, (err, consumedPoints) => {
            if (err || consumedPoints === false) {
              this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {
                if (errAddKey || !createdNew) {
                  if (typeof options.attemptNumber === "undefined" || options.attemptNumber < 3) {
                    const nextOptions = Object.assign({}, options);
                    nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;
                    this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then((resUpsert) => resolve5(resUpsert)).catch((errUpsert) => reject(errUpsert));
                  } else {
                    reject(new Error("Can not add key"));
                  }
                } else {
                  this.client.add(`${rlKey}_expire`, secDuration > 0 ? nowMs + secDuration * 1000 : -1, secDuration, () => {
                    const res = {
                      consumedPoints: points,
                      msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1
                    };
                    resolve5(res);
                  });
                }
              });
            } else {
              this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                if (errGetExpire) {
                  reject(errGetExpire);
                } else {
                  const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                  const res = {
                    consumedPoints,
                    msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                  };
                  resolve5(res);
                }
              });
            }
          });
        }
      });
    }
    _get(rlKey) {
      return new Promise((resolve5, reject) => {
        const nowMs = Date.now();
        this.client.get(rlKey, (err, consumedPoints) => {
          if (!consumedPoints) {
            resolve5(null);
          } else {
            this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
              if (errGetExpire) {
                reject(errGetExpire);
              } else {
                const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                const res = {
                  consumedPoints,
                  msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                };
                resolve5(res);
              }
            });
          }
        });
      });
    }
    _delete(rlKey) {
      return new Promise((resolve5, reject) => {
        this.client.del(rlKey, (err, res) => {
          if (err) {
            reject(err);
          } else if (res === false) {
            resolve5(res);
          } else {
            this.client.del(`${rlKey}_expire`, (errDelExpire) => {
              if (errDelExpire) {
                reject(errDelExpire);
              } else {
                resolve5(res);
              }
            });
          }
        });
      });
    }
  };
  var RateLimiterMemcache_1$1 = RateLimiterMemcache$3;
  var RateLimiterRes$e = RateLimiterRes_1$1;
  var RLWrapperBlackAndWhite_1$1 = class RLWrapperBlackAndWhite2 {
    constructor(opts = {}) {
      this.limiter = opts.limiter;
      this.blackList = opts.blackList;
      this.whiteList = opts.whiteList;
      this.isBlackListed = opts.isBlackListed;
      this.isWhiteListed = opts.isWhiteListed;
      this.runActionAnyway = opts.runActionAnyway;
    }
    get limiter() {
      return this._limiter;
    }
    set limiter(value) {
      if (typeof value === "undefined") {
        throw new Error("limiter is not set");
      }
      this._limiter = value;
    }
    get runActionAnyway() {
      return this._runActionAnyway;
    }
    set runActionAnyway(value) {
      this._runActionAnyway = typeof value === "undefined" ? false : value;
    }
    get blackList() {
      return this._blackList;
    }
    set blackList(value) {
      this._blackList = Array.isArray(value) ? value : [];
    }
    get isBlackListed() {
      return this._isBlackListed;
    }
    set isBlackListed(func) {
      if (typeof func === "undefined") {
        func = () => false;
      }
      if (typeof func !== "function") {
        throw new Error("isBlackListed must be function");
      }
      this._isBlackListed = func;
    }
    get whiteList() {
      return this._whiteList;
    }
    set whiteList(value) {
      this._whiteList = Array.isArray(value) ? value : [];
    }
    get isWhiteListed() {
      return this._isWhiteListed;
    }
    set isWhiteListed(func) {
      if (typeof func === "undefined") {
        func = () => false;
      }
      if (typeof func !== "function") {
        throw new Error("isWhiteListed must be function");
      }
      this._isWhiteListed = func;
    }
    isBlackListedSomewhere(key) {
      return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);
    }
    isWhiteListedSomewhere(key) {
      return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);
    }
    getBlackRes() {
      return new RateLimiterRes$e(0, Number.MAX_SAFE_INTEGER, 0, false);
    }
    getWhiteRes() {
      return new RateLimiterRes$e(Number.MAX_SAFE_INTEGER, 0, 0, false);
    }
    rejectBlack() {
      return Promise.reject(this.getBlackRes());
    }
    resolveBlack() {
      return Promise.resolve(this.getBlackRes());
    }
    resolveWhite() {
      return Promise.resolve(this.getWhiteRes());
    }
    consume(key, pointsToConsume = 1) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.rejectBlack();
      }
      if (typeof res === "undefined") {
        return this.limiter.consume(key, pointsToConsume);
      }
      if (this.runActionAnyway) {
        this.limiter.consume(key, pointsToConsume).catch(() => {
        });
      }
      return res;
    }
    block(key, secDuration) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.resolveBlack();
      }
      if (typeof res === "undefined") {
        return this.limiter.block(key, secDuration);
      }
      if (this.runActionAnyway) {
        this.limiter.block(key, secDuration).catch(() => {
        });
      }
      return res;
    }
    penalty(key, points) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.resolveBlack();
      }
      if (typeof res === "undefined") {
        return this.limiter.penalty(key, points);
      }
      if (this.runActionAnyway) {
        this.limiter.penalty(key, points).catch(() => {
        });
      }
      return res;
    }
    reward(key, points) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.resolveBlack();
      }
      if (typeof res === "undefined") {
        return this.limiter.reward(key, points);
      }
      if (this.runActionAnyway) {
        this.limiter.reward(key, points).catch(() => {
        });
      }
      return res;
    }
    get(key) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.resolveBlack();
      }
      if (typeof res === "undefined" || this.runActionAnyway) {
        return this.limiter.get(key);
      }
      return res;
    }
    delete(key) {
      return this.limiter.delete(key);
    }
  };
  var RateLimiterAbstract$4 = RateLimiterAbstract_1$1;
  var RateLimiterUnion_1$1 = class RateLimiterUnion2 {
    constructor(...limiters) {
      if (limiters.length < 1) {
        throw new Error("RateLimiterUnion: at least one limiter have to be passed");
      }
      limiters.forEach((limiter) => {
        if (!(limiter instanceof RateLimiterAbstract$4)) {
          throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
        }
      });
      this._limiters = limiters;
    }
    consume(key, points = 1) {
      return new Promise((resolve5, reject) => {
        const promises = [];
        this._limiters.forEach((limiter) => {
          promises.push(limiter.consume(key, points).catch((rej) => ({ rejected: true, rej })));
        });
        Promise.all(promises).then((res) => {
          const resObj = {};
          let rejected = false;
          res.forEach((item) => {
            if (item.rejected === true) {
              rejected = true;
            }
          });
          for (let i = 0;i < res.length; i++) {
            if (rejected && res[i].rejected === true) {
              resObj[this._limiters[i].keyPrefix] = res[i].rej;
            } else if (!rejected) {
              resObj[this._limiters[i].keyPrefix] = res[i];
            }
          }
          if (rejected) {
            reject(resObj);
          } else {
            resolve5(resObj);
          }
        });
      });
    }
  };
  var RateLimiterQueueError_1$1 = class RateLimiterQueueError2 extends Error {
    constructor(message2, extra) {
      super();
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "CustomError";
      this.message = message2;
      if (extra) {
        this.extra = extra;
      }
    }
  };
  var RateLimiterQueueError$1 = RateLimiterQueueError_1$1;
  var MAX_QUEUE_SIZE$1 = 4294967295;
  var KEY_DEFAULT$1 = "limiter";
  var RateLimiterQueue_1$1 = class RateLimiterQueue2 {
    constructor(limiterFlexible, opts = {
      maxQueueSize: MAX_QUEUE_SIZE$1
    }) {
      this._queueLimiters = {
        KEY_DEFAULT: new RateLimiterQueueInternal$1(limiterFlexible, opts)
      };
      this._limiterFlexible = limiterFlexible;
      this._maxQueueSize = opts.maxQueueSize;
    }
    getTokensRemaining(key = KEY_DEFAULT$1) {
      if (this._queueLimiters[key]) {
        return this._queueLimiters[key].getTokensRemaining();
      } else {
        return Promise.resolve(this._limiterFlexible.points);
      }
    }
    removeTokens(tokens, key = KEY_DEFAULT$1) {
      if (!this._queueLimiters[key]) {
        this._queueLimiters[key] = new RateLimiterQueueInternal$1(this._limiterFlexible, {
          key,
          maxQueueSize: this._maxQueueSize
        });
      }
      return this._queueLimiters[key].removeTokens(tokens);
    }
  };
  var RateLimiterQueueInternal$1 = class RateLimiterQueueInternal2 {
    constructor(limiterFlexible, opts = {
      maxQueueSize: MAX_QUEUE_SIZE$1,
      key: KEY_DEFAULT$1
    }) {
      this._key = opts.key;
      this._waitTimeout = null;
      this._queue = [];
      this._limiterFlexible = limiterFlexible;
      this._maxQueueSize = opts.maxQueueSize;
    }
    getTokensRemaining() {
      return this._limiterFlexible.get(this._key).then((rlRes) => {
        return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;
      });
    }
    removeTokens(tokens) {
      const _this = this;
      return new Promise((resolve5, reject) => {
        if (tokens > _this._limiterFlexible.points) {
          reject(new RateLimiterQueueError$1(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));
          return;
        }
        if (_this._queue.length > 0) {
          _this._queueRequest.call(_this, resolve5, reject, tokens);
        } else {
          _this._limiterFlexible.consume(_this._key, tokens).then((res) => {
            resolve5(res.remainingPoints);
          }).catch((rej) => {
            if (rej instanceof Error) {
              reject(rej);
            } else {
              _this._queueRequest.call(_this, resolve5, reject, tokens);
              if (_this._waitTimeout === null) {
                _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
              }
            }
          });
        }
      });
    }
    _queueRequest(resolve5, reject, tokens) {
      const _this = this;
      if (_this._queue.length < _this._maxQueueSize) {
        _this._queue.push({ resolve: resolve5, reject, tokens });
      } else {
        reject(new RateLimiterQueueError$1(`Number of requests reached it's maximum ${_this._maxQueueSize}`));
      }
    }
    _processFIFO() {
      const _this = this;
      if (_this._waitTimeout !== null) {
        clearTimeout(_this._waitTimeout);
        _this._waitTimeout = null;
      }
      if (_this._queue.length === 0) {
        return;
      }
      const item = _this._queue.shift();
      _this._limiterFlexible.consume(_this._key, item.tokens).then((res) => {
        item.resolve(res.remainingPoints);
        _this._processFIFO.call(_this);
      }).catch((rej) => {
        if (rej instanceof Error) {
          item.reject(rej);
          _this._processFIFO.call(_this);
        } else {
          _this._queue.unshift(item);
          if (_this._waitTimeout === null) {
            _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
          }
        }
      });
    }
  };
  var RateLimiterRes$d = RateLimiterRes_1$1;
  var BurstyRateLimiter_1$1 = class BurstyRateLimiter2 {
    constructor(rateLimiter, burstLimiter) {
      this._rateLimiter = rateLimiter;
      this._burstLimiter = burstLimiter;
    }
    _combineRes(rlRes, blRes) {
      return new RateLimiterRes$d(rlRes.remainingPoints, Math.min(rlRes.msBeforeNext, blRes.msBeforeNext), rlRes.consumedPoints, rlRes.isFirstInDuration);
    }
    consume(key, pointsToConsume = 1, options = {}) {
      return this._rateLimiter.consume(key, pointsToConsume, options).catch((rlRej) => {
        if (rlRej instanceof RateLimiterRes$d) {
          return this._burstLimiter.consume(key, pointsToConsume, options).then((blRes) => {
            return Promise.resolve(this._combineRes(rlRej, blRes));
          }).catch((blRej) => {
            if (blRej instanceof RateLimiterRes$d) {
              return Promise.reject(this._combineRes(rlRej, blRej));
            } else {
              return Promise.reject(blRej);
            }
          });
        } else {
          return Promise.reject(rlRej);
        }
      });
    }
    get(key) {
      return Promise.all([
        this._rateLimiter.get(key),
        this._burstLimiter.get(key)
      ]).then(([rlRes, blRes]) => {
        return this._combineRes(rlRes, blRes);
      });
    }
    get points() {
      return this._rateLimiter.points;
    }
  };
  var RateLimiterRedis$2 = RateLimiterRedis_1$1;
  var RateLimiterMongo$2 = RateLimiterMongo_1$1;
  var RateLimiterMySQL$2 = RateLimiterMySQL_1$1;
  var RateLimiterPostgres$2 = RateLimiterPostgres_1$1;
  var { RateLimiterClusterMaster: RateLimiterClusterMaster$2, RateLimiterClusterMasterPM2: RateLimiterClusterMasterPM2$2, RateLimiterCluster: RateLimiterCluster$2 } = RateLimiterCluster$3;
  var RateLimiterMemory$3 = RateLimiterMemory_1$1;
  var RateLimiterMemcache$2 = RateLimiterMemcache_1$1;
  var RLWrapperBlackAndWhite$1 = RLWrapperBlackAndWhite_1$1;
  var RateLimiterUnion$1 = RateLimiterUnion_1$1;
  var RateLimiterQueue$1 = RateLimiterQueue_1$1;
  var BurstyRateLimiter$1 = BurstyRateLimiter_1$1;
  var RateLimiterRes$c = RateLimiterRes_1$1;
  var rateLimiterFlexible$1 = {
    RateLimiterRedis: RateLimiterRedis$2,
    RateLimiterMongo: RateLimiterMongo$2,
    RateLimiterMySQL: RateLimiterMySQL$2,
    RateLimiterPostgres: RateLimiterPostgres$2,
    RateLimiterMemory: RateLimiterMemory$3,
    RateLimiterMemcache: RateLimiterMemcache$2,
    RateLimiterClusterMaster: RateLimiterClusterMaster$2,
    RateLimiterClusterMasterPM2: RateLimiterClusterMasterPM2$2,
    RateLimiterCluster: RateLimiterCluster$2,
    RLWrapperBlackAndWhite: RLWrapperBlackAndWhite$1,
    RateLimiterUnion: RateLimiterUnion$1,
    RateLimiterQueue: RateLimiterQueue$1,
    BurstyRateLimiter: BurstyRateLimiter$1,
    RateLimiterRes: RateLimiterRes$c
  };
  var MessageTypes;
  (function(MessageTypes2) {
    MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
    MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
    MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
    MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
    MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
    MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
    MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
  })(MessageTypes || (MessageTypes = {}));
  var MessageTypeNames = Object.freeze({
    0: "NEW_STREAM",
    1: "MESSAGE_RECEIVER",
    2: "MESSAGE_INITIATOR",
    3: "CLOSE_RECEIVER",
    4: "CLOSE_INITIATOR",
    5: "RESET_RECEIVER",
    6: "RESET_INITIATOR"
  });
  var InitiatorMessageTypes = Object.freeze({
    NEW_STREAM: MessageTypes.NEW_STREAM,
    MESSAGE: MessageTypes.MESSAGE_INITIATOR,
    CLOSE: MessageTypes.CLOSE_INITIATOR,
    RESET: MessageTypes.RESET_INITIATOR
  });
  var ReceiverMessageTypes = Object.freeze({
    MESSAGE: MessageTypes.MESSAGE_RECEIVER,
    CLOSE: MessageTypes.CLOSE_RECEIVER,
    RESET: MessageTypes.RESET_RECEIVER
  });
  var MAX_MSG_SIZE = 1 << 20;
  var MAX_MSG_QUEUE_SIZE = 4 << 20;
  var Decoder$a = class Decoder2 {
    constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
      this._buffer = new Uint8ArrayList;
      this._headerInfo = null;
      this._maxMessageSize = maxMessageSize;
      this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
    }
    write(chunk) {
      if (chunk == null || chunk.length === 0) {
        return [];
      }
      this._buffer.append(chunk);
      if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
        throw Object.assign(new Error("unprocessed message queue size too large!"), { code: "ERR_MSG_QUEUE_TOO_BIG" });
      }
      const msgs = [];
      while (this._buffer.length !== 0) {
        if (this._headerInfo == null) {
          try {
            this._headerInfo = this._decodeHeader(this._buffer);
          } catch (err) {
            if (err.code === "ERR_MSG_TOO_BIG") {
              throw err;
            }
            break;
          }
        }
        const { id, type, length: length2, offset } = this._headerInfo;
        const bufferedDataLength = this._buffer.length - offset;
        if (bufferedDataLength < length2) {
          break;
        }
        const msg = {
          id,
          type
        };
        if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
          msg.data = this._buffer.sublist(offset, offset + length2);
        }
        msgs.push(msg);
        this._buffer.consume(offset + length2);
        this._headerInfo = null;
      }
      return msgs;
    }
    _decodeHeader(data) {
      const { value: h, offset } = readVarInt(data);
      const { value: length2, offset: end } = readVarInt(data, offset);
      const type = h & 7;
      if (MessageTypeNames[type] == null) {
        throw new Error(`Invalid type received: ${type}`);
      }
      if (length2 > this._maxMessageSize) {
        throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
      }
      return { id: h >> 3, type, offset: offset + end, length: length2 };
    }
  };
  var MSB$7 = 128;
  var REST$7 = 127;
  var DEFAULT_BATCH_SIZE = 1024 * 1024;
  var DEFAULT_SERIALIZE = (buf, list) => {
    list.append(buf);
  };
  var POOL_SIZE = 10 * 1024;
  var Encoder$a = class Encoder2 {
    constructor() {
      this._pool = allocUnsafe(POOL_SIZE);
      this._poolOffset = 0;
    }
    write(msg, list) {
      const pool = this._pool;
      let offset = this._poolOffset;
      varint$9.encode(msg.id << 3 | msg.type, pool, offset);
      offset += varint$9.encode.bytes ?? 0;
      if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
        varint$9.encode(msg.data.length, pool, offset);
      } else {
        varint$9.encode(0, pool, offset);
      }
      offset += varint$9.encode.bytes ?? 0;
      const header2 = pool.subarray(this._poolOffset, offset);
      if (POOL_SIZE - offset < 100) {
        this._pool = allocUnsafe(POOL_SIZE);
        this._poolOffset = 0;
      } else {
        this._poolOffset = offset;
      }
      list.append(header2);
      if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
        list.append(msg.data);
      }
    }
  };
  var encoder = new Encoder$a;
  var ERR_STREAM_RESET = "ERR_STREAM_RESET";
  var ERR_SINK_INVALID_STATE = "ERR_SINK_INVALID_STATE";

  class AbstractStream {
    constructor(init2) {
      this.sinkController = new AbortController;
      this.sinkEnd = pDefer();
      this.log = init2.log;
      this.status = "open";
      this.readStatus = "ready";
      this.writeStatus = "ready";
      this.id = init2.id;
      this.metadata = init2.metadata ?? {};
      this.direction = init2.direction;
      this.timeline = {
        open: Date.now()
      };
      this.onEnd = init2.onEnd;
      this.onCloseRead = init2?.onCloseRead;
      this.onCloseWrite = init2?.onCloseWrite;
      this.onReset = init2?.onReset;
      this.onAbort = init2?.onAbort;
      this.source = this.streamSource = pushable({
        onEnd: (err) => {
          if (err != null) {
            this.log.trace("source ended with error", err);
          } else {
            this.log.trace("source ended");
          }
          this.readStatus = "closed";
          this.onSourceEnd(err);
        }
      });
      this.sink = this.sink.bind(this);
    }
    async sink(source2) {
      if (this.writeStatus !== "ready") {
        throw new CodeError$3(`writable end state is "${this.writeStatus}" not "ready"`, ERR_SINK_INVALID_STATE);
      }
      try {
        this.writeStatus = "writing";
        const options = {
          signal: this.sinkController.signal
        };
        if (this.direction === "outbound") {
          const res = this.sendNewStream(options);
          if (isPromise$1(res)) {
            await res;
          }
        }
        source2 = abortableSource(source2, this.sinkController.signal, {
          returnOnAbort: true
        });
        this.log.trace("sink reading from source");
        for await (let data of source2) {
          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
          const res = this.sendData(data, options);
          if (isPromise$1(res)) {
            await res;
          }
        }
        this.log.trace("sink finished reading from source");
        this.writeStatus = "done";
        this.log.trace("sink calling closeWrite");
        await this.closeWrite(options);
        this.onSinkEnd();
      } catch (err) {
        this.log.trace("sink ended with error, calling abort with error", err);
        this.abort(err);
        throw err;
      } finally {
        this.log.trace("resolve sink end");
        this.sinkEnd.resolve();
      }
    }
    onSourceEnd(err) {
      if (this.timeline.closeRead != null) {
        return;
      }
      this.timeline.closeRead = Date.now();
      if (err != null && this.endErr == null) {
        this.endErr = err;
      }
      this.onCloseRead?.();
      if (this.timeline.closeWrite != null) {
        this.log.trace("source and sink ended");
        this.timeline.close = Date.now();
        if (this.onEnd != null) {
          this.onEnd(this.endErr);
        }
      } else {
        this.log.trace("source ended, waiting for sink to end");
      }
    }
    onSinkEnd(err) {
      if (this.timeline.closeWrite != null) {
        return;
      }
      this.timeline.closeWrite = Date.now();
      if (err != null && this.endErr == null) {
        this.endErr = err;
      }
      this.onCloseWrite?.();
      if (this.timeline.closeRead != null) {
        this.log.trace("sink and source ended");
        this.timeline.close = Date.now();
        if (this.onEnd != null) {
          this.onEnd(this.endErr);
        }
      } else {
        this.log.trace("sink ended, waiting for source to end");
      }
    }
    async close(options) {
      this.log.trace("closing gracefully");
      this.status = "closing";
      await Promise.all([
        this.closeRead(options),
        this.closeWrite(options)
      ]);
      this.status = "closed";
      this.log.trace("closed gracefully");
    }
    async closeRead(options = {}) {
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        return;
      }
      this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
      const readStatus = this.readStatus;
      this.readStatus = "closing";
      if (readStatus === "ready") {
        this.log.trace("ending internal source queue");
        this.streamSource.end();
      }
      if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
        this.log.trace("send close read to remote");
        await this.sendCloseRead(options);
      }
      this.log.trace("closed readable end of stream");
    }
    async closeWrite(options = {}) {
      if (this.writeStatus === "closing" || this.writeStatus === "closed") {
        return;
      }
      this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
      const writeStatus = this.writeStatus;
      if (this.writeStatus === "ready") {
        this.log.trace("sink was never sunk, sink an empty array");
        await this.sink([]);
      }
      this.writeStatus = "closing";
      if (writeStatus === "writing") {
        await new Promise((resolve5, reject) => {
          queueMicrotask(() => {
            this.log.trace("aborting source passed to .sink");
            this.sinkController.abort();
            this.sinkEnd.promise.then(resolve5, reject);
          });
        });
      }
      if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeWrite == null) {
        this.log.trace("send close write to remote");
        await this.sendCloseWrite(options);
      }
      this.writeStatus = "closed";
      this.log.trace("closed writable end of stream");
    }
    abort(err) {
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        return;
      }
      this.log("abort with error", err);
      this.log("try to send reset to remote");
      const res = this.sendReset();
      if (isPromise$1(res)) {
        res.catch((err2) => {
          this.log.error("error sending reset message", err2);
        });
      }
      this.status = "aborted";
      this.timeline.abort = Date.now();
      this._closeSinkAndSource(err);
      this.onAbort?.(err);
    }
    reset() {
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        return;
      }
      const err = new CodeError$3("stream reset", ERR_STREAM_RESET);
      this.status = "reset";
      this._closeSinkAndSource(err);
      this.onReset?.();
    }
    _closeSinkAndSource(err) {
      this._closeSink(err);
      this._closeSource(err);
    }
    _closeSink(err) {
      if (this.writeStatus === "writing") {
        this.log.trace("end sink source");
        this.sinkController.abort();
      }
      this.onSinkEnd(err);
    }
    _closeSource(err) {
      if (this.readStatus !== "closing" && this.readStatus !== "closed") {
        this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
        this.readStatus = "closing";
        this.streamSource.end(err);
      }
    }
    remoteCloseWrite() {
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        this.log("received remote close write but local source is already closed");
        return;
      }
      this.log.trace("remote close write");
      this._closeSource();
    }
    remoteCloseRead() {
      if (this.writeStatus === "closing" || this.writeStatus === "closed") {
        this.log("received remote close read but local sink is already closed");
        return;
      }
      this.log.trace("remote close read");
      this._closeSink();
    }
    destroy() {
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        this.log("received destroy but we are already closed");
        return;
      }
      this.log.trace("muxer destroyed");
      this._closeSinkAndSource();
    }
    sourcePush(data) {
      this.streamSource.push(data);
    }
    sourceReadableLength() {
      return this.streamSource.readableLength;
    }
  }

  class MplexStream extends AbstractStream {
    constructor(init2) {
      super(init2);
      this.types = init2.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
      this.send = init2.send;
      this.name = init2.name;
      this.streamId = init2.streamId;
      this.maxDataSize = init2.maxDataSize;
    }
    async sendNewStream() {
      await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString$3(this.name)) });
    }
    async sendData(data) {
      data = data.sublist();
      while (data.byteLength > 0) {
        const toSend = Math.min(data.byteLength, this.maxDataSize);
        await this.send({
          id: this.streamId,
          type: this.types.MESSAGE,
          data: data.sublist(0, toSend)
        });
        data.consume(toSend);
      }
    }
    async sendReset() {
      await this.send({ id: this.streamId, type: this.types.RESET });
    }
    async sendCloseWrite() {
      await this.send({ id: this.streamId, type: this.types.CLOSE });
    }
    async sendCloseRead() {
    }
  }
  var log$y = logger$8("libp2p:mplex");
  var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
  var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
  var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
  var DISCONNECT_THRESHOLD = 5;
  var CLOSE_TIMEOUT$2 = 500;

  class MplexStreamMuxer {
    constructor(init2) {
      this.protocol = "/mplex/6.7.0";
      init2 = init2 ?? {};
      this._streamId = 0;
      this._streams = {
        initiators: new Map,
        receivers: new Map
      };
      this._init = init2;
      this.closeTimeout = init2.closeTimeout ?? CLOSE_TIMEOUT$2;
      this.sink = this._createSink();
      this._source = pushableV({
        objectMode: true,
        onEnd: () => {
          for (const stream of this._streams.initiators.values()) {
            stream.destroy();
          }
          for (const stream of this._streams.receivers.values()) {
            stream.destroy();
          }
        }
      });
      this.source = pipe(this._source, (source2) => encode$s(source2, this._init.minSendBytes));
      this.closeController = new AbortController;
      this.rateLimiter = new rateLimiterFlexible$1.RateLimiterMemory({
        points: init2.disconnectThreshold ?? DISCONNECT_THRESHOLD,
        duration: 1
      });
    }
    get streams() {
      const streams = [];
      for (const stream of this._streams.initiators.values()) {
        streams.push(stream);
      }
      for (const stream of this._streams.receivers.values()) {
        streams.push(stream);
      }
      return streams;
    }
    newStream(name2) {
      if (this.closeController.signal.aborted) {
        throw new Error("Muxer already closed");
      }
      const id = this._streamId++;
      name2 = name2 == null ? id.toString() : name2.toString();
      const registry = this._streams.initiators;
      return this._newStream({ id, name: name2, type: "initiator", registry });
    }
    async close(options) {
      if (this.closeController.signal.aborted) {
        return;
      }
      const signal = options?.signal ?? AbortSignal.timeout(this.closeTimeout);
      try {
        await Promise.all(this.streams.map(async (s2) => s2.close({
          signal
        })));
        this._source.end();
        await this._source.onEmpty({
          signal
        });
        this.closeController.abort();
      } catch (err) {
        this.abort(err);
      }
    }
    abort(err) {
      if (this.closeController.signal.aborted) {
        return;
      }
      this.streams.forEach((s2) => {
        s2.abort(err);
      });
      this.closeController.abort(err);
    }
    _newReceiverStream(options) {
      const { id, name: name2 } = options;
      const registry = this._streams.receivers;
      return this._newStream({ id, name: name2, type: "receiver", registry });
    }
    _newStream(options) {
      const { id, name: name2, type, registry } = options;
      log$y("new %s stream %s", type, id);
      if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
        throw new CodeError$3("Too many outbound streams open", "ERR_TOO_MANY_OUTBOUND_STREAMS");
      }
      if (registry.has(id)) {
        throw new Error(`${type} stream ${id} already exists!`);
      }
      const send = async (msg) => {
        if (log$y.enabled) {
          log$y.trace("%s stream %s send", type, id, printMessage(msg));
        }
        this._source.push(msg);
      };
      const onEnd = () => {
        log$y("%s stream with id %s and protocol %s ended", type, id, stream.protocol);
        registry.delete(id);
        if (this._init.onStreamEnd != null) {
          this._init.onStreamEnd(stream);
        }
      };
      const stream = createStream({ id, name: name2, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });
      registry.set(id, stream);
      return stream;
    }
    _createSink() {
      const sink2 = async (source2) => {
        try {
          source2 = abortableSource(source2, this.closeController.signal, {
            returnOnAbort: true
          });
          const decoder = new Decoder$a(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
          for await (const chunk of source2) {
            for (const msg of decoder.write(chunk)) {
              await this._handleIncoming(msg);
            }
          }
          this._source.end();
        } catch (err) {
          log$y("error in sink", err);
          this._source.end(err);
        }
      };
      return sink2;
    }
    async _handleIncoming(message2) {
      const { id, type } = message2;
      if (log$y.enabled) {
        log$y.trace("incoming message", printMessage(message2));
      }
      if (message2.type === MessageTypes.NEW_STREAM) {
        if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
          log$y("too many inbound streams open");
          this._source.push({
            id,
            type: MessageTypes.RESET_RECEIVER
          });
          try {
            await this.rateLimiter.consume("new-stream", 1);
          } catch {
            log$y("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
            this.abort(new Error("Too many open streams"));
            return;
          }
          return;
        }
        const stream2 = this._newReceiverStream({ id, name: toString$9(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
        if (this._init.onIncomingStream != null) {
          this._init.onIncomingStream(stream2);
        }
        return;
      }
      const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
      const stream = list.get(id);
      if (stream == null) {
        log$y("missing stream %s for message type %s", id, MessageTypeNames[type]);
        try {
          await this.rateLimiter.consume("missing-stream", 1);
        } catch {
          log$y("rate limit hit when receiving messages for streams that do not exist - closing remote connection");
          this.abort(new Error("Too many messages for missing streams"));
          return;
        }
        return;
      }
      const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
      try {
        switch (type) {
          case MessageTypes.MESSAGE_INITIATOR:
          case MessageTypes.MESSAGE_RECEIVER:
            if (stream.sourceReadableLength() > maxBufferSize) {
              this._source.push({
                id: message2.id,
                type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
              });
              throw new CodeError$3("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers", "ERR_STREAM_INPUT_BUFFER_FULL");
            }
            stream.sourcePush(message2.data);
            break;
          case MessageTypes.CLOSE_INITIATOR:
          case MessageTypes.CLOSE_RECEIVER:
            stream.remoteCloseWrite();
            break;
          case MessageTypes.RESET_INITIATOR:
          case MessageTypes.RESET_RECEIVER:
            stream.reset();
            break;
          default:
            log$y("unknown message type %s", type);
        }
      } catch (err) {
        log$y.error("error while processing message", err);
        stream.abort(err);
      }
    }
  }

  class Mplex {
    constructor(init2 = {}) {
      this.protocol = "/mplex/6.7.0";
      this._init = init2;
    }
    createStreamMuxer(init2 = {}) {
      return new MplexStreamMuxer({
        ...init2,
        ...this._init
      });
    }
  }
  var symbol$2 = Symbol.for("@libp2p/transport");
  var FaultTolerance;
  (function(FaultTolerance2) {
    FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
    FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
  })(FaultTolerance || (FaultTolerance = {}));
  var src$9 = base$a;
  var _brrp__multiformats_scope_baseX$9 = src$9;
  var coerce$9 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$9 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$9 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$a(this, decoder);
    }
  };
  var ComposedDecoder$9 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$a(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$a = (left2, right2) => new ComposedDecoder$9({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$9 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$9(name2, prefix, baseEncode);
      this.decoder = new Decoder$9(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$g = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$9(name2, prefix, encode3, decode3);
  var baseX$9 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$9(alphabet2, name2);
    return from$g({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$9(decode3(text))
    });
  };
  var decode$m = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$r = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$9 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$g({
      prefix,
      name: name2,
      encode(input) {
        return encode$r(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$m(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base32$9 = rfc4648$9({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  rfc4648$9({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  rfc4648$9({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  rfc4648$9({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  rfc4648$9({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  rfc4648$9({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  rfc4648$9({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  rfc4648$9({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  rfc4648$9({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base58btc$8 = baseX$9({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$9({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base64$9 = rfc4648$9({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$9({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$9({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$9({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  debug.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc$8.baseEncode(v);
  };
  debug.formatters.t = (v) => {
    return v == null ? "undefined" : base32$9.baseEncode(v);
  };
  debug.formatters.m = (v) => {
    return v == null ? "undefined" : base64$9.baseEncode(v);
  };
  debug.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  var isV4 = isIPv4;
  var isV6 = isIPv6;
  var toBytes = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4(ip)) {
      const bytes2 = new Uint8Array(offset + 4);
      ip.split(/\./g).forEach((byte) => {
        bytes2[offset++] = parseInt(byte, 10) & 255;
      });
      return bytes2;
    }
    if (isV6(ip)) {
      const sections = ip.split(":", 8);
      let i;
      for (i = 0;i < sections.length; i++) {
        const isv4 = isV4(sections[i]);
        let v4Buffer;
        if (isv4) {
          v4Buffer = toBytes(sections[i]);
          sections[i] = toString$9(v4Buffer.slice(0, 2), "base16");
        }
        if (v4Buffer != null && ++i < 8) {
          sections.splice(i, 0, toString$9(v4Buffer.slice(2, 4), "base16"));
        }
      }
      if (sections[0] === "") {
        while (sections.length < 8)
          sections.unshift("0");
      } else if (sections[sections.length - 1] === "") {
        while (sections.length < 8)
          sections.push("0");
      } else if (sections.length < 8) {
        for (i = 0;i < sections.length && sections[i] !== ""; i++)
          ;
        const argv = [i, 1];
        for (i = 9 - sections.length;i > 0; i--) {
          argv.push("0");
        }
        sections.splice.apply(sections, argv);
      }
      const bytes2 = new Uint8Array(offset + 16);
      for (i = 0;i < sections.length; i++) {
        const word2 = parseInt(sections[i], 16);
        bytes2[offset++] = word2 >> 8 & 255;
        bytes2[offset++] = word2 & 255;
      }
      return bytes2;
    }
    throw new Error("invalid ip address");
  };
  var toString$6 = function(buf, offset = 0, length2) {
    offset = ~~offset;
    length2 = length2 ?? buf.length - offset;
    const view = new DataView(buf.buffer);
    if (length2 === 4) {
      const result = [];
      for (let i = 0;i < length2; i++) {
        result.push(buf[offset + i]);
      }
      return result.join(".");
    }
    if (length2 === 16) {
      const result = [];
      for (let i = 0;i < length2; i += 2) {
        result.push(view.getUint16(offset + i).toString(16));
      }
      return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
    }
    return "";
  };
  var V = -1;
  var names = {};
  var codes$4 = {};
  var table = [
    [4, 32, "ip4"],
    [6, 16, "tcp"],
    [33, 16, "dccp"],
    [41, 128, "ip6"],
    [42, V, "ip6zone"],
    [43, 8, "ipcidr"],
    [53, V, "dns", true],
    [54, V, "dns4", true],
    [55, V, "dns6", true],
    [56, V, "dnsaddr", true],
    [132, 16, "sctp"],
    [273, 16, "udp"],
    [275, 0, "p2p-webrtc-star"],
    [276, 0, "p2p-webrtc-direct"],
    [277, 0, "p2p-stardust"],
    [280, 0, "webrtc"],
    [281, 0, "webrtc-w3c"],
    [290, 0, "p2p-circuit"],
    [301, 0, "udt"],
    [302, 0, "utp"],
    [400, V, "unix", false, true],
    [421, V, "ipfs"],
    [421, V, "p2p"],
    [443, 0, "https"],
    [444, 96, "onion"],
    [445, 296, "onion3"],
    [446, V, "garlic64"],
    [448, 0, "tls"],
    [449, V, "sni"],
    [460, 0, "quic"],
    [461, 0, "quic-v1"],
    [465, 0, "webtransport"],
    [466, V, "certhash"],
    [477, 0, "ws"],
    [478, 0, "wss"],
    [479, 0, "p2p-websocket-star"],
    [480, 0, "http"],
    [777, V, "memory"]
  ];
  table.forEach((row) => {
    const proto = createProtocol(...row);
    codes$4[proto.code] = proto;
    names[proto.name] = proto;
  });
  var encode_1$5 = encode$q;
  var MSB$6 = 128;
  var REST$6 = 127;
  var MSBALL$5 = ~REST$6;
  var INT$5 = Math.pow(2, 31);
  var decode$l = read$6;
  var MSB$1$5 = 128;
  var REST$1$5 = 127;
  var N1$5 = Math.pow(2, 7);
  var N2$5 = Math.pow(2, 14);
  var N3$5 = Math.pow(2, 21);
  var N4$5 = Math.pow(2, 28);
  var N5$5 = Math.pow(2, 35);
  var N6$5 = Math.pow(2, 42);
  var N7$5 = Math.pow(2, 49);
  var N8$5 = Math.pow(2, 56);
  var N9$5 = Math.pow(2, 63);
  var length$5 = function(value) {
    return value < N1$5 ? 1 : value < N2$5 ? 2 : value < N3$5 ? 3 : value < N4$5 ? 4 : value < N5$5 ? 5 : value < N6$5 ? 6 : value < N7$5 ? 7 : value < N8$5 ? 8 : value < N9$5 ? 9 : 10;
  };
  var varint$5 = {
    encode: encode_1$5,
    decode: decode$l,
    encodingLength: length$5
  };
  var _brrp_varint$5 = varint$5;
  var decode$k = (data, offset = 0) => {
    const code2 = _brrp_varint$5.decode(data, offset);
    return [code2, _brrp_varint$5.decode.bytes];
  };
  var encodeTo$5 = (int, target, offset = 0) => {
    _brrp_varint$5.encode(int, target, offset);
    return target;
  };
  var encodingLength$7 = (int) => {
    return _brrp_varint$5.encodingLength(int);
  };
  var equals$1 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0;ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce$8 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var fromString$1 = (str) => new TextEncoder().encode(str);
  var toString$5 = (b) => new TextDecoder().decode(b);
  var create$b = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength$7(code2);
    const digestOffset = sizeOffset + encodingLength$7(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo$5(code2, bytes2, 0);
    encodeTo$5(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest$5(code2, size, digest2, bytes2);
  };
  var decode$j = (multihash) => {
    const bytes2 = coerce$8(multihash);
    const [code2, sizeOffset] = decode$k(bytes2);
    const [size, digestOffset] = decode$k(bytes2.subarray(sizeOffset));
    const digest2 = bytes2.subarray(sizeOffset + digestOffset);
    if (digest2.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest$5(code2, size, digest2, bytes2);
  };
  var equals = (a, b) => {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals$1(a.bytes, data.bytes);
    }
  };
  var Digest$5 = class Digest2 {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  };
  var src$8 = base$9;
  var _brrp__multiformats_scope_baseX$8 = src$8;
  var Encoder$8 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$8 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$9(this, decoder);
    }
  };
  var ComposedDecoder$8 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$9(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$9 = (left2, right2) => new ComposedDecoder$8({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$8 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$8(name2, prefix, baseEncode);
      this.decoder = new Decoder$8(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$f = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$8(name2, prefix, encode3, decode3);
  var baseX$8 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$8(alphabet2, name2);
    return from$f({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$8(decode3(text))
    });
  };
  var decode$i = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$p = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$8 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$f({
      prefix,
      name: name2,
      encode(input) {
        return encode$p(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$i(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base58btc$7 = baseX$8({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr = baseX$8({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base58 = Object.freeze({
    __proto__: null,
    base58btc: base58btc$7,
    base58flickr
  });
  var base32$7 = rfc4648$8({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper = rfc4648$8({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad = rfc4648$8({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper = rfc4648$8({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex = rfc4648$8({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648$8({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648$8({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648$8({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z = rfc4648$8({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base32$8 = Object.freeze({
    __proto__: null,
    base32: base32$7,
    base32hex,
    base32hexpad,
    base32hexpadupper,
    base32hexupper,
    base32pad,
    base32padupper,
    base32upper,
    base32z
  });
  var format$3 = (link, base3) => {
    const { bytes: bytes2, version: version2 } = link;
    switch (version2) {
      case 0:
        return toStringV0(bytes2, baseCache(link), base3 || base58btc$7.encoder);
      default:
        return toStringV1(bytes2, baseCache(link), base3 || base32$7.encoder);
    }
  };
  var cache$1 = new WeakMap;
  var baseCache = (cid) => {
    const baseCache2 = cache$1.get(cid);
    if (baseCache2 == null) {
      const baseCache3 = new Map;
      cache$1.set(cid, baseCache3);
      return baseCache3;
    }
    return baseCache2;
  };

  class CID {
    constructor(version2, code2, multihash, bytes2) {
      this.code = code2;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes2;
      this["/"] = bytes2;
    }
    get asCID() {
      return this;
    }
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code2, multihash } = this;
          if (code2 !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code2, digest: digest2 } = this.multihash;
          const multihash = create$b(code2, digest2);
          return CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown && self2.code === unknown.code && self2.version === unknown.version && equals(self2.multihash, unknown.multihash);
    }
    toString(base3) {
      return format$3(this, base3);
    }
    toJSON() {
      return { "/": format$3(this) };
    }
    link() {
      return this;
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
        return new CID(version2, code2, multihash, bytes2 || encodeCID(version2, code2, multihash.bytes));
      } else if (value[cidSymbol] === true) {
        const { version: version2, multihash, code: code2 } = value;
        const digest2 = decode$j(multihash);
        return CID.create(version2, code2, digest2);
      } else {
        return null;
      }
    }
    static create(version2, code2, digest2) {
      if (typeof code2 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest2.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version2) {
        case 0: {
          if (code2 !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new CID(version2, code2, digest2, digest2.bytes);
          }
        }
        case 1: {
          const bytes2 = encodeCID(version2, code2, digest2.bytes);
          return new CID(version2, code2, digest2, bytes2);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest2) {
      return CID.create(0, DAG_PB_CODE, digest2);
    }
    static createV1(code2, digest2) {
      return CID.create(1, code2, digest2);
    }
    static decode(bytes2) {
      const [cid, remainder] = CID.decodeFirst(bytes2);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes2) {
      const specs = CID.inspectBytes(bytes2);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce$8(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest2 = new Digest$5(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
      return [cid, bytes2.subarray(specs.size)];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length2] = decode$k(initialBytes.subarray(offset));
        offset += length2;
        return i;
      };
      let version2 = next();
      let codec2 = DAG_PB_CODE;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else {
        codec2 = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version2, codec: codec2, multihashCode, digestSize, multihashSize, size };
    }
    static parse(source2, base3) {
      const [prefix, bytes2] = parseCIDtoBytes(source2, base3);
      const cid = CID.decode(bytes2);
      if (cid.version === 0 && source2[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache(cid).set(prefix, source2);
      return cid;
    }
  }
  var parseCIDtoBytes = (source2, base3) => {
    switch (source2[0]) {
      case "Q": {
        const decoder = base3 || base58btc$7;
        return [
          base58btc$7.prefix,
          decoder.decode(`${base58btc$7.prefix}${source2}`)
        ];
      }
      case base58btc$7.prefix: {
        const decoder = base3 || base58btc$7;
        return [base58btc$7.prefix, decoder.decode(source2)];
      }
      case base32$7.prefix: {
        const decoder = base3 || base32$7;
        return [base32$7.prefix, decoder.decode(source2)];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source2[0], base3.decode(source2)];
      }
    }
  };
  var toStringV0 = (bytes2, cache2, base3) => {
    const { prefix } = base3;
    if (prefix !== base58btc$7.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes2).slice(1);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV1 = (bytes2, cache2, base3) => {
    const { prefix } = base3;
    const cid = cache2.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes2);
      cache2.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE = 112;
  var SHA_256_CODE = 18;
  var encodeCID = (version2, code2, multihash) => {
    const codeOffset = encodingLength$7(version2);
    const hashOffset = codeOffset + encodingLength$7(code2);
    const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo$5(version2, bytes2, 0);
    encodeTo$5(code2, bytes2, codeOffset);
    bytes2.set(multihash, hashOffset);
    return bytes2;
  };
  var cidSymbol = Symbol.for("@ipld/js-cid/CID");
  var identity$6 = from$f({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString$5(buf),
    decode: (str) => fromString$1(str)
  });
  var identityBase = Object.freeze({
    __proto__: null,
    identity: identity$6
  });
  var base2 = rfc4648$8({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });
  var base2$1 = Object.freeze({
    __proto__: null,
    base2
  });
  var base8 = rfc4648$8({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });
  var base8$1 = Object.freeze({
    __proto__: null,
    base8
  });
  var base10 = baseX$8({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });
  var base10$1 = Object.freeze({
    __proto__: null,
    base10
  });
  var base16 = rfc4648$8({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper = rfc4648$8({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
  var base16$1 = Object.freeze({
    __proto__: null,
    base16,
    base16upper
  });
  var base36 = baseX$8({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper = baseX$8({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
  var base36$1 = Object.freeze({
    __proto__: null,
    base36,
    base36upper
  });
  var base64$7 = rfc4648$8({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad = rfc4648$8({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url = rfc4648$8({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad = rfc4648$8({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var base64$8 = Object.freeze({
    __proto__: null,
    base64: base64$7,
    base64pad,
    base64url,
    base64urlpad
  });
  var alphabet = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42");
  var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
    p[c.codePointAt(0)] = i;
    return p;
  }, []);
  var base256emoji = from$f({
    prefix: "\uD83D\uDE80",
    name: "base256emoji",
    encode: encode$o,
    decode: decode$h
  });
  var base256emoji$1 = Object.freeze({
    __proto__: null,
    base256emoji
  });
  var from$e = ({ name: name2, code: code2, encode: encode3 }) => new Hasher$5(name2, code2, encode3);
  var Hasher$5 = class Hasher2 {
    constructor(name2, code2, encode3) {
      this.name = name2;
      this.code = code2;
      this.encode = encode3;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create$b(this.code, result) : result.then((digest2) => create$b(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var sha$5 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
  var sha256$6 = from$e({
    name: "sha2-256",
    code: 18,
    encode: sha$5("SHA-256")
  });
  var code$5 = 0;
  var name$6 = "identity";
  var encode$n = coerce$8;
  var digest$5 = (input) => create$b(code$5, encode$n(input));
  var identity$5 = { code: code$5, name: name$6, encode: encode$n, digest: digest$5 };
  new TextEncoder;
  new TextDecoder;
  var bases = { ...identityBase, ...base2$1, ...base8$1, ...base10$1, ...base16$1, ...base32$8, ...base36$1, ...base58, ...base64$8, ...base256emoji$1 };
  var decoders = Object.values(bases).map((c) => c.decoder);
  var anybaseDecoder = function() {
    let acc = decoders[0].or(decoders[1]);
    decoders.slice(2).forEach((d) => acc = acc.or(d));
    return acc;
  }();
  var __classPrivateFieldGet$2 = function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet$1 = function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _DefaultMultiaddr_string;
  var _DefaultMultiaddr_tuples;
  var _DefaultMultiaddr_stringTuples;
  var _a2;
  var inspect2 = Symbol.for("nodejs.util.inspect.custom");
  var DNS_CODES = [
    getProtocol("dns").code,
    getProtocol("dns4").code,
    getProtocol("dns6").code,
    getProtocol("dnsaddr").code
  ];
  var resolvers$1 = new Map;
  var symbol$1 = Symbol.for("@multiformats/js-multiaddr/multiaddr");

  class DefaultMultiaddr {
    constructor(addr) {
      _DefaultMultiaddr_string.set(this, undefined);
      _DefaultMultiaddr_tuples.set(this, undefined);
      _DefaultMultiaddr_stringTuples.set(this, undefined);
      this[_a2] = true;
      if (addr == null) {
        addr = "";
      }
      if (addr instanceof Uint8Array) {
        this.bytes = fromBytes(addr);
      } else if (typeof addr === "string") {
        if (addr.length > 0 && addr.charAt(0) !== "/") {
          throw new Error(`multiaddr "${addr}" must start with a "/"`);
        }
        this.bytes = fromString(addr);
      } else if (isMultiaddr(addr)) {
        this.bytes = fromBytes(addr.bytes);
      } else {
        throw new Error("addr must be a string, Buffer, or another Multiaddr");
      }
    }
    toString() {
      if (__classPrivateFieldGet$2(this, _DefaultMultiaddr_string, "f") == null) {
        __classPrivateFieldSet$1(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f");
      }
      return __classPrivateFieldGet$2(this, _DefaultMultiaddr_string, "f");
    }
    toJSON() {
      return this.toString();
    }
    toOptions() {
      let family;
      let transport;
      let host;
      let port;
      let zone = "";
      const tcp = getProtocol("tcp");
      const udp = getProtocol("udp");
      const ip4 = getProtocol("ip4");
      const ip6 = getProtocol("ip6");
      const dns6 = getProtocol("dns6");
      const ip6zone = getProtocol("ip6zone");
      for (const [code2, value] of this.stringTuples()) {
        if (code2 === ip6zone.code) {
          zone = `%${value ?? ""}`;
        }
        if (DNS_CODES.includes(code2)) {
          transport = tcp.name;
          port = 443;
          host = `${value ?? ""}${zone}`;
          family = code2 === dns6.code ? 6 : 4;
        }
        if (code2 === tcp.code || code2 === udp.code) {
          transport = getProtocol(code2).name;
          port = parseInt(value ?? "");
        }
        if (code2 === ip4.code || code2 === ip6.code) {
          transport = getProtocol(code2).name;
          host = `${value ?? ""}${zone}`;
          family = code2 === ip6.code ? 6 : 4;
        }
      }
      if (family == null || transport == null || host == null || port == null) {
        throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
      }
      const opts = {
        family,
        host,
        transport,
        port
      };
      return opts;
    }
    protos() {
      return this.protoCodes().map((code2) => Object.assign({}, getProtocol(code2)));
    }
    protoCodes() {
      const codes2 = [];
      const buf = this.bytes;
      let i = 0;
      while (i < buf.length) {
        const code2 = varint$9.decode(buf, i);
        const n = varint$9.decode.bytes ?? 0;
        const p = getProtocol(code2);
        const size = sizeForAddr(p, buf.slice(i + n));
        i += size + n;
        codes2.push(code2);
      }
      return codes2;
    }
    protoNames() {
      return this.protos().map((proto) => proto.name);
    }
    tuples() {
      if (__classPrivateFieldGet$2(this, _DefaultMultiaddr_tuples, "f") == null) {
        __classPrivateFieldSet$1(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f");
      }
      return __classPrivateFieldGet$2(this, _DefaultMultiaddr_tuples, "f");
    }
    stringTuples() {
      if (__classPrivateFieldGet$2(this, _DefaultMultiaddr_stringTuples, "f") == null) {
        __classPrivateFieldSet$1(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f");
      }
      return __classPrivateFieldGet$2(this, _DefaultMultiaddr_stringTuples, "f");
    }
    encapsulate(addr) {
      addr = new DefaultMultiaddr(addr);
      return new DefaultMultiaddr(this.toString() + addr.toString());
    }
    decapsulate(addr) {
      const addrString = addr.toString();
      const s2 = this.toString();
      const i = s2.lastIndexOf(addrString);
      if (i < 0) {
        throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
      }
      return new DefaultMultiaddr(s2.slice(0, i));
    }
    decapsulateCode(code2) {
      const tuples = this.tuples();
      for (let i = tuples.length - 1;i >= 0; i--) {
        if (tuples[i][0] === code2) {
          return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));
        }
      }
      return this;
    }
    getPeerId() {
      try {
        const tuples = this.stringTuples().filter((tuple2) => {
          if (tuple2[0] === names.ipfs.code) {
            return true;
          }
          return false;
        });
        const tuple = tuples.pop();
        if (tuple?.[1] != null) {
          const peerIdStr = tuple[1];
          if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
            return toString$9(base58btc$7.decode(`z${peerIdStr}`), "base58btc");
          }
          return toString$9(CID.parse(peerIdStr).multihash.bytes, "base58btc");
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    getPath() {
      let path = null;
      try {
        path = this.stringTuples().filter((tuple) => {
          const proto = getProtocol(tuple[0]);
          if (proto.path === true) {
            return true;
          }
          return false;
        })[0][1];
        if (path == null) {
          path = null;
        }
      } catch {
        path = null;
      }
      return path;
    }
    equals(addr) {
      return equals$4(this.bytes, addr.bytes);
    }
    async resolve(options) {
      const resolvableProto = this.protos().find((p) => p.resolvable);
      if (resolvableProto == null) {
        return [this];
      }
      const resolver = resolvers$1.get(resolvableProto.name);
      if (resolver == null) {
        throw errCode$1(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
      }
      const addresses = await resolver(this, options);
      return addresses.map((a) => new DefaultMultiaddr(a));
    }
    nodeAddress() {
      const options = this.toOptions();
      if (options.transport !== "tcp" && options.transport !== "udp") {
        throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
      }
      return {
        family: options.family,
        address: options.host,
        port: options.port
      };
    }
    isThinWaistAddress(addr) {
      const protos = (addr ?? this).protos();
      if (protos.length !== 2) {
        return false;
      }
      if (protos[0].code !== 4 && protos[0].code !== 41) {
        return false;
      }
      if (protos[1].code !== 6 && protos[1].code !== 273) {
        return false;
      }
      return true;
    }
    [(_DefaultMultiaddr_string = new WeakMap, _DefaultMultiaddr_tuples = new WeakMap, _DefaultMultiaddr_stringTuples = new WeakMap, _a2 = symbol$1, inspect2)]() {
      return `Multiaddr(${bytesToString(this.bytes)})`;
    }
  }
  var reduceValue = (_, v) => v;
  var tcpUri = (str, port, parts, opts) => {
    if (opts != null && opts.assumeHttp === false)
      return `tcp://${str}:${port}`;
    let protocol = "tcp";
    let explicitPort = `:${port}`;
    const last = parts[parts.length - 1];
    if (last.protocol === "tcp") {
      protocol = port === "443" ? "https" : "http";
      explicitPort = port === "443" || port === "80" ? "" : explicitPort;
    }
    return `${protocol}://${str}${explicitPort}`;
  };
  var Reducers = {
    ip4: reduceValue,
    ip6: (str, content, i, parts) => parts.length === 1 && parts[0].protocol === "ip6" ? content : `[${content}]`,
    tcp: (str, content, i, parts, opts) => parts.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts, opts),
    udp: (str, content) => `udp://${str}:${content}`,
    dnsaddr: reduceValue,
    dns4: reduceValue,
    dns6: reduceValue,
    ipfs: (str, content) => `${str}/ipfs/${content}`,
    p2p: (str, content) => `${str}/p2p/${content}`,
    http: (str) => `http://${str}`,
    https: (str) => `https://${str}`,
    ws: (str) => `ws://${str}`,
    wss: (str) => `wss://${str}`,
    "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
    "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
    "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
  };
  var ready = async (socket) => {
    if (socket.readyState >= 2) {
      throw new Error("socket closed");
    }
    if (socket.readyState === 1) {
      return;
    }
    await new Promise((resolve5, reject) => {
      function cleanup() {
        socket.removeEventListener("open", handleOpen);
        socket.removeEventListener("error", handleErr);
      }
      function handleOpen() {
        cleanup();
        resolve5();
      }
      function handleErr(event) {
        cleanup();
        reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
      }
      socket.addEventListener("open", handleOpen);
      socket.addEventListener("error", handleErr);
    });
  };
  var sink = (socket, options) => {
    options = options ?? {};
    options.closeOnEnd = options.closeOnEnd !== false;
    const sink2 = async (source2) => {
      for await (const data of source2) {
        try {
          await ready(socket);
        } catch (err) {
          if (err.message === "socket closed")
            break;
          throw err;
        }
        if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
          break;
        }
        socket.send(data);
      }
      if (options.closeOnEnd != null && socket.readyState <= 1) {
        await new Promise((resolve5, reject) => {
          socket.addEventListener("close", (event) => {
            if (event.wasClean || event.code === 1006) {
              resolve5();
            } else {
              const err = Object.assign(new Error("ws error"), { event });
              reject(err);
            }
          });
          setTimeout(() => {
            socket.close();
          });
        });
      }
    };
    return sink2;
  };
  var dom = {};
  var eventIterator = {};
  Object.defineProperty(eventIterator, "__esModule", { value: true });

  class EventQueue {
    constructor() {
      this.pullQueue = [];
      this.pushQueue = [];
      this.eventHandlers = {};
      this.isPaused = false;
      this.isStopped = false;
    }
    push(value) {
      if (this.isStopped)
        return;
      const resolution = { value, done: false };
      if (this.pullQueue.length) {
        const placeholder = this.pullQueue.shift();
        if (placeholder)
          placeholder.resolve(resolution);
      } else {
        this.pushQueue.push(Promise.resolve(resolution));
        if (this.highWaterMark !== undefined && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
          this.isPaused = true;
          if (this.eventHandlers.highWater) {
            this.eventHandlers.highWater();
          } else if (console) {
            console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
          }
        }
      }
    }
    stop() {
      if (this.isStopped)
        return;
      this.isStopped = true;
      this.remove();
      for (const placeholder of this.pullQueue) {
        placeholder.resolve({ value: undefined, done: true });
      }
      this.pullQueue.length = 0;
    }
    fail(error) {
      if (this.isStopped)
        return;
      this.isStopped = true;
      this.remove();
      if (this.pullQueue.length) {
        for (const placeholder of this.pullQueue) {
          placeholder.reject(error);
        }
        this.pullQueue.length = 0;
      } else {
        const rejection = Promise.reject(error);
        rejection.catch(() => {
        });
        this.pushQueue.push(rejection);
      }
    }
    remove() {
      Promise.resolve().then(() => {
        if (this.removeCallback)
          this.removeCallback();
      });
    }
    [Symbol.asyncIterator]() {
      return {
        next: (value) => {
          const result = this.pushQueue.shift();
          if (result) {
            if (this.lowWaterMark !== undefined && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
              this.isPaused = false;
              if (this.eventHandlers.lowWater) {
                this.eventHandlers.lowWater();
              }
            }
            return result;
          } else if (this.isStopped) {
            return Promise.resolve({ value: undefined, done: true });
          } else {
            return new Promise((resolve5, reject) => {
              this.pullQueue.push({ resolve: resolve5, reject });
            });
          }
        },
        return: () => {
          this.isStopped = true;
          this.pushQueue.length = 0;
          this.remove();
          return Promise.resolve({ value: undefined, done: true });
        }
      };
    }
  }
  var EventIterator$1 = class EventIterator2 {
    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
      const queue = new EventQueue;
      queue.highWaterMark = highWaterMark;
      queue.lowWaterMark = lowWaterMark;
      queue.removeCallback = listen({
        push: (value) => queue.push(value),
        stop: () => queue.stop(),
        fail: (error) => queue.fail(error),
        on: (event, fn) => {
          queue.eventHandlers[event] = fn;
        }
      }) || (() => {
      });
      this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
      Object.freeze(this);
    }
  };
  eventIterator.EventIterator = EventIterator$1;
  eventIterator.default = EventIterator$1;
  Object.defineProperty(dom, "__esModule", { value: true });
  var event_iterator_1 = eventIterator;
  var EventIterator = dom.EventIterator = event_iterator_1.EventIterator;
  dom.subscribe = subscribe;
  dom.default = event_iterator_1.EventIterator;
  var source = (socket) => {
    socket.binaryType = "arraybuffer";
    const connected = async () => {
      await new Promise((resolve5, reject) => {
        if (isConnected) {
          resolve5();
          return;
        }
        if (connError != null) {
          reject(connError);
          return;
        }
        const cleanUp = (cont) => {
          socket.removeEventListener("open", onOpen);
          socket.removeEventListener("error", onError);
          cont();
        };
        const onOpen = () => {
          cleanUp(resolve5);
        };
        const onError = (event) => {
          cleanUp(() => {
            reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
          });
        };
        socket.addEventListener("open", onOpen);
        socket.addEventListener("error", onError);
      });
    };
    const source2 = async function* () {
      const messages2 = new EventIterator(({ push, stop, fail }) => {
        const onMessage = (event) => {
          let data = null;
          if (typeof event.data === "string") {
            data = fromString$3(event.data);
          }
          if (isArrayBuffer(event.data)) {
            data = new Uint8Array(event.data);
          }
          if (event.data instanceof Uint8Array) {
            data = event.data;
          }
          if (data == null) {
            return;
          }
          push(data);
        };
        const onError = (event) => {
          fail(event.error ?? new Error("Socket error"));
        };
        socket.addEventListener("message", onMessage);
        socket.addEventListener("error", onError);
        socket.addEventListener("close", stop);
        return () => {
          socket.removeEventListener("message", onMessage);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("close", stop);
        };
      }, { highWaterMark: Infinity });
      await connected();
      for await (const chunk of messages2) {
        yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
      }
    }();
    let isConnected = socket.readyState === 1;
    let connError;
    socket.addEventListener("open", () => {
      isConnected = true;
      connError = null;
    });
    socket.addEventListener("close", () => {
      isConnected = false;
      connError = null;
    });
    socket.addEventListener("error", (event) => {
      if (!isConnected) {
        connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
      }
    });
    return Object.assign(source2, {
      connected
    });
  };
  var duplex = (socket, options) => {
    options = options ?? {};
    const connectedSource = source(socket);
    let remoteAddress = options.remoteAddress;
    let remotePort = options.remotePort;
    if (socket.url != null) {
      try {
        const url = new URL(socket.url);
        remoteAddress = url.hostname;
        remotePort = parseInt(url.port, 10);
      } catch {
      }
    }
    if (remoteAddress == null || remotePort == null) {
      throw new Error("Remote connection did not have address and/or port");
    }
    const duplex2 = {
      sink: sink(socket, options),
      source: connectedSource,
      connected: async () => {
        await connectedSource.connected();
      },
      close: async () => {
        if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
          await new Promise((resolve5) => {
            socket.addEventListener("close", () => {
              resolve5();
            });
            socket.close();
          });
        }
      },
      destroy: () => {
        if (socket.terminate != null) {
          socket.terminate();
        } else {
          socket.close();
        }
      },
      remoteAddress,
      remotePort,
      socket
    };
    return duplex2;
  };
  var WebSocket$1 = WebSocket;
  var isReactNative$1 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
  var URL$2 = self.URL;
  var defaultBase$1 = getDefaultBase();
  var URLWithLegacySupport$2 = class URLWithLegacySupport2 {
    constructor(url = "", base3 = defaultBase$1) {
      this.super = new URL$2(url, base3);
      this.path = this.pathname + this.search;
      this.auth = this.username && this.password ? this.username + ":" + this.password : null;
      this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
    }
    get hash() {
      return this.super.hash;
    }
    get host() {
      return this.super.host;
    }
    get hostname() {
      return this.super.hostname;
    }
    get href() {
      return this.super.href;
    }
    get origin() {
      return this.super.origin;
    }
    get password() {
      return this.super.password;
    }
    get pathname() {
      return this.super.pathname;
    }
    get port() {
      return this.super.port;
    }
    get protocol() {
      return this.super.protocol;
    }
    get search() {
      return this.super.search;
    }
    get searchParams() {
      return this.super.searchParams;
    }
    get username() {
      return this.super.username;
    }
    set hash(hash2) {
      this.super.hash = hash2;
    }
    set host(host) {
      this.super.host = host;
    }
    set hostname(hostname) {
      this.super.hostname = hostname;
    }
    set href(href) {
      this.super.href = href;
    }
    set password(password) {
      this.super.password = password;
    }
    set pathname(pathname) {
      this.super.pathname = pathname;
    }
    set port(port) {
      this.super.port = port;
    }
    set protocol(protocol) {
      this.super.protocol = protocol;
    }
    set search(search) {
      this.super.search = search;
    }
    set username(username) {
      this.super.username = username;
    }
    static createObjectURL(o) {
      return URL$2.createObjectURL(o);
    }
    static revokeObjectURL(o) {
      URL$2.revokeObjectURL(o);
    }
    toJSON() {
      return this.super.toJSON();
    }
    toString() {
      return this.super.toString();
    }
    format() {
      return this.toString();
    }
  };
  var urlBrowser = {
    URLWithLegacySupport: URLWithLegacySupport$2,
    URLSearchParams: self.URLSearchParams,
    defaultBase: defaultBase$1,
    format: format$2
  };
  var { URLWithLegacySupport: URLWithLegacySupport$1, format: format$1 } = urlBrowser;
  var relative$1 = (url, location = {}, protocolMap = {}, defaultProtocol) => {
    let protocol = location.protocol ? location.protocol.replace(":", "") : "http";
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
    let urlParsed;
    try {
      urlParsed = new URLWithLegacySupport$1(url);
    } catch (err) {
      urlParsed = {};
    }
    const base3 = Object.assign({}, location, {
      protocol: protocol || urlParsed.protocol,
      host: location.host || urlParsed.host
    });
    return new URLWithLegacySupport$1(url, format$1(base3)).toString();
  };
  var { URLWithLegacySupport, format: format3, URLSearchParams, defaultBase } = urlBrowser;
  var relative2 = relative$1;
  var isoUrl = {
    URL: URLWithLegacySupport,
    URLSearchParams,
    format: format3,
    relative: relative2,
    defaultBase
  };
  var map$1 = { http: "ws", https: "wss" };
  var def = "ws";
  var wsurl = (url, location) => isoUrl.relative(url, location, map$1, def);
  var isElectron_1 = isElectron$1;
  var detectElectron = getDefaultExportFromCjs(isElectron_1);
  var isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
  var isElectron = detectElectron();
  var isBrowser = isEnvWithDom && !isElectron;
  var isElectronMain = isElectron && !isEnvWithDom;
  var isElectronRenderer = isElectron && isEnvWithDom;
  var isNode = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
  var isWebWorker = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
  typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"];
  var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
  var DNS4 = base$8("dns4");
  var DNS6 = base$8("dns6");
  var DNSADDR = base$8("dnsaddr");
  var DNS = or$8(base$8("dns"), DNSADDR, DNS4, DNS6);
  var IP = or$8(base$8("ip4"), base$8("ip6"));
  var TCP = or$8(and(IP, base$8("tcp")), and(DNS, base$8("tcp")));
  var _WebSockets = or$8(and(TCP, base$8("ws")), and(DNS, base$8("ws")));
  var WebSockets$1 = or$8(and(_WebSockets, base$8("p2p")), _WebSockets);
  var _WebSocketsSecure = or$8(and(TCP, base$8("wss")), and(DNS, base$8("wss")), and(TCP, base$8("tls"), base$8("ws")), and(DNS, base$8("tls"), base$8("ws")));
  var WebSocketsSecure = or$8(and(_WebSocketsSecure, base$8("p2p")), _WebSocketsSecure);
  var CODE_P2P = 421;
  var CODE_CIRCUIT = 290;
  var CLOSE_TIMEOUT$1 = 500;
  var log$x = logger$7("libp2p:websockets:socket");
  var log$w = logger$7("libp2p:websockets");

  class WebSockets {
    constructor(init2) {
      this[_l] = "@libp2p/websockets";
      this[_o] = true;
      this.init = init2;
    }
    async dial(ma, options) {
      log$w("dialing %s", ma);
      options = options ?? {};
      const socket = await this._connect(ma, options);
      const maConn = socketToMaConn(socket, ma);
      log$w("new outbound connection %s", maConn.remoteAddr);
      const conn = await options.upgrader.upgradeOutbound(maConn);
      log$w("outbound connection %s upgraded", maConn.remoteAddr);
      return conn;
    }
    async _connect(ma, options) {
      if (options?.signal?.aborted === true) {
        throw new AbortError$8;
      }
      const cOpts = ma.toOptions();
      log$w("dialing %s:%s", cOpts.host, cOpts.port);
      const errorPromise = pDefer();
      const rawSocket = connect(multiaddrToUri(ma), this.init);
      rawSocket.socket.addEventListener("error", () => {
        const err = new CodeError$3(`Could not connect to ${ma.toString()}`, "ERR_CONNECTION_FAILED");
        log$w.error("connection error:", err);
        errorPromise.reject(err);
      });
      if (options.signal == null) {
        await Promise.race([rawSocket.connected(), errorPromise.promise]);
        log$w("connected %s", ma);
        return rawSocket;
      }
      let onAbort;
      const abort = new Promise((resolve5, reject) => {
        onAbort = () => {
          reject(new AbortError$8);
          rawSocket.close().catch((err) => {
            log$w.error("error closing raw socket", err);
          });
        };
        if (options?.signal?.aborted === true) {
          onAbort();
          return;
        }
        options?.signal?.addEventListener("abort", onAbort);
      });
      try {
        await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
      } finally {
        if (onAbort != null) {
          options?.signal?.removeEventListener("abort", onAbort);
        }
      }
      log$w("connected %s", ma);
      return rawSocket;
    }
    createListener(options) {
      return createListener({ ...this.init, ...options });
    }
    filter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      if (this.init?.filter != null) {
        return this.init?.filter(multiaddrs);
      }
      if (isBrowser || isWebWorker) {
        return wss(multiaddrs);
      }
      return all(multiaddrs);
    }
  }
  _l = Symbol.toStringTag, _o = symbol$2;
  var EventEmitter$2 = (_p = class EventEmitter2 extends EventTarget {
    constructor() {
      super(...arguments);
      _EventEmitter_listeners_1.set(this, new Map);
    }
    listenerCount(type) {
      const listeners = __classPrivateFieldGet2(this, _EventEmitter_listeners_1, "f").get(type);
      if (listeners == null) {
        return 0;
      }
      return listeners.length;
    }
    addEventListener(type, listener, options) {
      super.addEventListener(type, listener, options);
      let list = __classPrivateFieldGet2(this, _EventEmitter_listeners_1, "f").get(type);
      if (list == null) {
        list = [];
        __classPrivateFieldGet2(this, _EventEmitter_listeners_1, "f").set(type, list);
      }
      list.push({
        callback: listener,
        once: (options !== true && options !== false && options?.once) ?? false
      });
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type.toString(), listener ?? null, options);
      let list = __classPrivateFieldGet2(this, _EventEmitter_listeners_1, "f").get(type);
      if (list == null) {
        return;
      }
      list = list.filter(({ callback }) => callback !== listener);
      __classPrivateFieldGet2(this, _EventEmitter_listeners_1, "f").set(type, list);
    }
    dispatchEvent(event) {
      const result = super.dispatchEvent(event);
      let list = __classPrivateFieldGet2(this, _EventEmitter_listeners_1, "f").get(event.type);
      if (list == null) {
        return result;
      }
      list = list.filter(({ once: once2 }) => !once2);
      __classPrivateFieldGet2(this, _EventEmitter_listeners_1, "f").set(event.type, list);
      return result;
    }
    safeDispatchEvent(type, detail) {
      return this.dispatchEvent(new CustomEvent(type, detail));
    }
  }, _EventEmitter_listeners_1 = new WeakMap, _p);

  class CustomEventPolyfill extends Event {
    constructor(message2, data) {
      super(message2, data);
      this.detail = data?.detail;
    }
  }
  var CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;
  var peerDiscovery = Symbol.for("@libp2p/peer-discovery");
  var enrTree = {
    TEST: "enrtree://AOGECG2SPND25EEFMAJ5WF3KSGJNSGV356DSTL2YVLLZWIV6SAYBM@test.waku.nodes.status.im",
    PROD: "enrtree://AOGECG2SPND25EEFMAJ5WF3KSGJNSGV356DSTL2YVLLZWIV6SAYBM@prod.waku.nodes.status.im"
  };
  var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
  var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
  var DEFAULT_BOOTSTRAP_TAG_TTL = 1e8;
  var DEFAULT_NODE_REQUIREMENTS$1 = {
    store: 2,
    filter: 1,
    lightPush: 1
  };
  var ERR_INVALID_ID = "Invalid record id";
  var MULTIADDR_LENGTH_SIZE = 2;
  var sha3$1 = { exports: {} };
  (function(module2) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = commonjsGlobal;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module2.exports;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits3, padding, outputType) {
        return function(message2) {
          return new Keccak(bits3, padding, bits3).update(message2)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits3, padding, outputType) {
        return function(message2, outputBits) {
          return new Keccak(bits3, padding, outputBits).update(message2)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits3, padding, outputType) {
        return function(message2, outputBits, n, s2) {
          return methods2["cshake" + bits3].update(message2, outputBits, n, s2)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits3, padding, outputType) {
        return function(key, message2, outputBits, s2) {
          return methods2["kmac" + bits3].update(key, message2, outputBits, s2)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits3, padding) {
        for (var i2 = 0;i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits3, padding, type);
        }
        return method;
      };
      var createMethod = function(bits3, padding) {
        var method = createOutputMethod(bits3, padding, "hex");
        method.create = function() {
          return new Keccak(bits3, padding, bits3);
        };
        method.update = function(message2) {
          return method.create().update(message2);
        };
        return createOutputMethods(method, createOutputMethod, bits3, padding);
      };
      var createShakeMethod = function(bits3, padding) {
        var method = createShakeOutputMethod(bits3, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits3, padding, outputBits);
        };
        method.update = function(message2, outputBits) {
          return method.create(outputBits).update(message2);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits3, padding);
      };
      var createCshakeMethod = function(bits3, padding) {
        var w = CSHAKE_BYTEPAD[bits3];
        var method = createCshakeOutputMethod(bits3, padding, "hex");
        method.create = function(outputBits, n, s2) {
          if (!n && !s2) {
            return methods2["shake" + bits3].create(outputBits);
          } else {
            return new Keccak(bits3, padding, outputBits).bytepad([n, s2], w);
          }
        };
        method.update = function(message2, outputBits, n, s2) {
          return method.create(outputBits, n, s2).update(message2);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits3, padding);
      };
      var createKmacMethod = function(bits3, padding) {
        var w = CSHAKE_BYTEPAD[bits3];
        var method = createKmacOutputMethod(bits3, padding, "hex");
        method.create = function(key, outputBits, s2) {
          return new Kmac(bits3, padding, outputBits).bytepad(["KMAC", s2], w).bytepad([key], w);
        };
        method.update = function(key, message2, outputBits, s2) {
          return method.create(key, outputBits, s2).update(message2);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits3, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods2 = {}, methodNames = [];
      for (var i = 0;i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits2 = algorithm.bits;
        for (var j = 0;j < bits2.length; ++j) {
          var methodName = algorithm.name + "_" + bits2[j];
          methodNames.push(methodName);
          methods2[methodName] = algorithm.createMethod(bits2[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits2[j];
            methodNames.push(newMethodName);
            methods2[newMethodName] = methods2[methodName];
          }
        }
      }
      function Keccak(bits3, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits3 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0;i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message2) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message2;
        if (type !== "string") {
          if (type === "object") {
            if (message2 === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message2.constructor === ArrayBuffer) {
              message2 = new Uint8Array(message2);
            } else if (!Array.isArray(message2)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message2)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message2.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i2, code2;
        while (index2 < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1;i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start;index2 < length2 && i2 < byteCount; ++index2) {
              blocks[i2 >> 2] |= message2[index2] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start;index2 < length2 && i2 < byteCount; ++index2) {
              code2 = message2.charCodeAt(index2);
              if (code2 < 128) {
                blocks[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
              } else if (code2 < 2048) {
                blocks[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message2.charCodeAt(++index2) & 1023);
                blocks[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0;i2 < blockCount; ++i2) {
              s2[i2] ^= blocks[i2];
            }
            f(s2);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right2) {
        var o = x & 255, n = 1;
        var bytes2 = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes2.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right2) {
          bytes2.push(n);
        } else {
          bytes2.unshift(n);
        }
        this.update(bytes2);
        return bytes2.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes2 = 0, length2 = str.length;
        if (notString) {
          bytes2 = length2;
        } else {
          for (var i2 = 0;i2 < str.length; ++i2) {
            var code2 = str.charCodeAt(i2);
            if (code2 < 128) {
              bytes2 += 1;
            } else if (code2 < 2048) {
              bytes2 += 2;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes2 += 3;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes2 += 4;
            }
          }
        }
        bytes2 += this.encode(bytes2 * 8);
        this.update(str);
        return bytes2;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes2 = this.encode(w);
        for (var i2 = 0;i2 < strs.length; ++i2) {
          bytes2 += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes2 % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1;i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0;i2 < blockCount; ++i2) {
          s2[i2] ^= blocks[i2];
        }
        f(s2);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0;i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s2[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s2);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s2[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes2 = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes2);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0;i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s2[i2];
          }
          if (j2 % blockCount === 0) {
            f(s2);
          }
        }
        if (extraBytes) {
          array[i2] = s2[i2];
          buffer = buffer.slice(0, bytes2);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0;i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s2[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s2);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s2[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits3, padding, outputBits) {
        Keccak.call(this, bits3, padding, outputBits);
      }
      Kmac.prototype = new Keccak;
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s2) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0;n < 48; n += 2) {
          c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
          c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
          c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
          c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
          c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
          c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
          c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
          c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
          c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
          c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s2[0] ^= h;
          s2[1] ^= l;
          s2[10] ^= h;
          s2[11] ^= l;
          s2[20] ^= h;
          s2[21] ^= l;
          s2[30] ^= h;
          s2[31] ^= l;
          s2[40] ^= h;
          s2[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s2[2] ^= h;
          s2[3] ^= l;
          s2[12] ^= h;
          s2[13] ^= l;
          s2[22] ^= h;
          s2[23] ^= l;
          s2[32] ^= h;
          s2[33] ^= l;
          s2[42] ^= h;
          s2[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s2[4] ^= h;
          s2[5] ^= l;
          s2[14] ^= h;
          s2[15] ^= l;
          s2[24] ^= h;
          s2[25] ^= l;
          s2[34] ^= h;
          s2[35] ^= l;
          s2[44] ^= h;
          s2[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s2[6] ^= h;
          s2[7] ^= l;
          s2[16] ^= h;
          s2[17] ^= l;
          s2[26] ^= h;
          s2[27] ^= l;
          s2[36] ^= h;
          s2[37] ^= l;
          s2[46] ^= h;
          s2[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s2[8] ^= h;
          s2[9] ^= l;
          s2[18] ^= h;
          s2[19] ^= l;
          s2[28] ^= h;
          s2[29] ^= l;
          s2[38] ^= h;
          s2[39] ^= l;
          s2[48] ^= h;
          s2[49] ^= l;
          b0 = s2[0];
          b1 = s2[1];
          b32 = s2[11] << 4 | s2[10] >>> 28;
          b33 = s2[10] << 4 | s2[11] >>> 28;
          b14 = s2[20] << 3 | s2[21] >>> 29;
          b15 = s2[21] << 3 | s2[20] >>> 29;
          b46 = s2[31] << 9 | s2[30] >>> 23;
          b47 = s2[30] << 9 | s2[31] >>> 23;
          b28 = s2[40] << 18 | s2[41] >>> 14;
          b29 = s2[41] << 18 | s2[40] >>> 14;
          b20 = s2[2] << 1 | s2[3] >>> 31;
          b21 = s2[3] << 1 | s2[2] >>> 31;
          b2 = s2[13] << 12 | s2[12] >>> 20;
          b3 = s2[12] << 12 | s2[13] >>> 20;
          b34 = s2[22] << 10 | s2[23] >>> 22;
          b35 = s2[23] << 10 | s2[22] >>> 22;
          b16 = s2[33] << 13 | s2[32] >>> 19;
          b17 = s2[32] << 13 | s2[33] >>> 19;
          b48 = s2[42] << 2 | s2[43] >>> 30;
          b49 = s2[43] << 2 | s2[42] >>> 30;
          b40 = s2[5] << 30 | s2[4] >>> 2;
          b41 = s2[4] << 30 | s2[5] >>> 2;
          b22 = s2[14] << 6 | s2[15] >>> 26;
          b23 = s2[15] << 6 | s2[14] >>> 26;
          b4 = s2[25] << 11 | s2[24] >>> 21;
          b5 = s2[24] << 11 | s2[25] >>> 21;
          b36 = s2[34] << 15 | s2[35] >>> 17;
          b37 = s2[35] << 15 | s2[34] >>> 17;
          b18 = s2[45] << 29 | s2[44] >>> 3;
          b19 = s2[44] << 29 | s2[45] >>> 3;
          b10 = s2[6] << 28 | s2[7] >>> 4;
          b11 = s2[7] << 28 | s2[6] >>> 4;
          b42 = s2[17] << 23 | s2[16] >>> 9;
          b43 = s2[16] << 23 | s2[17] >>> 9;
          b24 = s2[26] << 25 | s2[27] >>> 7;
          b25 = s2[27] << 25 | s2[26] >>> 7;
          b6 = s2[36] << 21 | s2[37] >>> 11;
          b7 = s2[37] << 21 | s2[36] >>> 11;
          b38 = s2[47] << 24 | s2[46] >>> 8;
          b39 = s2[46] << 24 | s2[47] >>> 8;
          b30 = s2[8] << 27 | s2[9] >>> 5;
          b31 = s2[9] << 27 | s2[8] >>> 5;
          b12 = s2[18] << 20 | s2[19] >>> 12;
          b13 = s2[19] << 20 | s2[18] >>> 12;
          b44 = s2[29] << 7 | s2[28] >>> 25;
          b45 = s2[28] << 7 | s2[29] >>> 25;
          b26 = s2[38] << 8 | s2[39] >>> 24;
          b27 = s2[39] << 8 | s2[38] >>> 24;
          b8 = s2[48] << 14 | s2[49] >>> 18;
          b9 = s2[49] << 14 | s2[48] >>> 18;
          s2[0] = b0 ^ ~b2 & b4;
          s2[1] = b1 ^ ~b3 & b5;
          s2[10] = b10 ^ ~b12 & b14;
          s2[11] = b11 ^ ~b13 & b15;
          s2[20] = b20 ^ ~b22 & b24;
          s2[21] = b21 ^ ~b23 & b25;
          s2[30] = b30 ^ ~b32 & b34;
          s2[31] = b31 ^ ~b33 & b35;
          s2[40] = b40 ^ ~b42 & b44;
          s2[41] = b41 ^ ~b43 & b45;
          s2[2] = b2 ^ ~b4 & b6;
          s2[3] = b3 ^ ~b5 & b7;
          s2[12] = b12 ^ ~b14 & b16;
          s2[13] = b13 ^ ~b15 & b17;
          s2[22] = b22 ^ ~b24 & b26;
          s2[23] = b23 ^ ~b25 & b27;
          s2[32] = b32 ^ ~b34 & b36;
          s2[33] = b33 ^ ~b35 & b37;
          s2[42] = b42 ^ ~b44 & b46;
          s2[43] = b43 ^ ~b45 & b47;
          s2[4] = b4 ^ ~b6 & b8;
          s2[5] = b5 ^ ~b7 & b9;
          s2[14] = b14 ^ ~b16 & b18;
          s2[15] = b15 ^ ~b17 & b19;
          s2[24] = b24 ^ ~b26 & b28;
          s2[25] = b25 ^ ~b27 & b29;
          s2[34] = b34 ^ ~b36 & b38;
          s2[35] = b35 ^ ~b37 & b39;
          s2[44] = b44 ^ ~b46 & b48;
          s2[45] = b45 ^ ~b47 & b49;
          s2[6] = b6 ^ ~b8 & b0;
          s2[7] = b7 ^ ~b9 & b1;
          s2[16] = b16 ^ ~b18 & b10;
          s2[17] = b17 ^ ~b19 & b11;
          s2[26] = b26 ^ ~b28 & b20;
          s2[27] = b27 ^ ~b29 & b21;
          s2[36] = b36 ^ ~b38 & b30;
          s2[37] = b37 ^ ~b39 & b31;
          s2[46] = b46 ^ ~b48 & b40;
          s2[47] = b47 ^ ~b49 & b41;
          s2[8] = b8 ^ ~b0 & b2;
          s2[9] = b9 ^ ~b1 & b3;
          s2[18] = b18 ^ ~b10 & b12;
          s2[19] = b19 ^ ~b11 & b13;
          s2[28] = b28 ^ ~b20 & b22;
          s2[29] = b29 ^ ~b21 & b23;
          s2[38] = b38 ^ ~b30 & b32;
          s2[39] = b39 ^ ~b31 & b33;
          s2[48] = b48 ^ ~b40 & b42;
          s2[49] = b49 ^ ~b41 & b43;
          s2[0] ^= RC[n];
          s2[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods2;
      } else {
        for (i = 0;i < methodNames.length; ++i) {
          root[methodNames[i]] = methods2[methodNames[i]];
        }
      }
    })();
  })(sha3$1);
  var sha3Exports = sha3$1.exports;
  var sha3 = getDefaultExportFromCjs(sha3Exports);

  class CodeError extends Error {
    constructor(message2, code2, props) {
      super(message2);
      this.code = code2;
      this.name = props?.name ?? "CodeError";
      this.props = props ?? {};
    }
  }
  var PUBLIC_KEY_BYTE_LENGTH$5 = 32;
  var PRIVATE_KEY_BYTE_LENGTH$5 = 64;
  var KEYS_BYTE_LENGTH$5 = 32;
  var webcrypto$5 = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto == null || nativeCrypto.subtle == null) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    }
  };
  var derivedEmptyPasswordKey$5 = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
  var KeyType$6;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["Secp256k1"] = "Secp256k1";
  })(KeyType$6 || (KeyType$6 = {}));
  var __KeyTypeValues$6;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
  })(__KeyTypeValues$6 || (__KeyTypeValues$6 = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues$6);
    };
  })(KeyType$6 || (KeyType$6 = {}));
  var PublicKey$6;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$6.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$6.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf) => {
      return decodeMessage$1(buf, PublicKey2.codec());
    };
  })(PublicKey$6 || (PublicKey$6 = {}));
  var PrivateKey$6;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$6.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$6.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf) => {
      return decodeMessage$1(buf, PrivateKey2.codec());
    };
  })(PrivateKey$6 || (PrivateKey$6 = {}));
  var Ed25519PublicKey$5 = class Ed25519PublicKey2 {
    constructor(key) {
      this._key = ensureKey$5(key, PUBLIC_KEY_BYTE_LENGTH$5);
    }
    async verify(data, sig) {
      return hashAndVerify$h(this._key, sig, data);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PublicKey$6.encode({
        Type: KeyType$6.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$6.digest(this.bytes);
      return bytes2;
    }
  };
  var Ed25519PrivateKey$5 = class Ed25519PrivateKey2 {
    constructor(key, publicKey) {
      this._key = ensureKey$5(key, PRIVATE_KEY_BYTE_LENGTH$5);
      this._publicKey = ensureKey$5(publicKey, PUBLIC_KEY_BYTE_LENGTH$5);
    }
    async sign(message2) {
      return hashAndSign$h(this._key, message2);
    }
    get public() {
      return new Ed25519PublicKey$5(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$6.encode({
        Type: KeyType$6.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$6.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const encoding = identity$5.digest(this.public.bytes);
      return base58btc$7.encode(encoding.bytes).substring(1);
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$5(this.bytes, password);
      } else {
        throw new CodeError(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Ed25519$5 = Object.freeze({
    __proto__: null,
    Ed25519PrivateKey: Ed25519PrivateKey$5,
    Ed25519PublicKey: Ed25519PublicKey$5,
    generateKeyPair: generateKeyPair$j,
    generateKeyPairFromSeed: generateKeyPairFromSeed$5,
    unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey$5,
    unmarshalEd25519PublicKey: unmarshalEd25519PublicKey$5
  });
  var bits$6 = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  var curveTypes$6 = Object.keys(bits$6);
  curveTypes$6.join(" / ");
  var RsaPublicKey$5 = class RsaPublicKey2 {
    constructor(key) {
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$g(this._key, sig, data);
    }
    marshal() {
      return jwkToPkix$5(this._key);
    }
    get bytes() {
      return PublicKey$6.encode({
        Type: KeyType$6.RSA,
        Data: this.marshal()
      }).subarray();
    }
    encrypt(bytes2) {
      return encrypt$5(this._key, bytes2);
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$6.digest(this.bytes);
      return bytes2;
    }
  };
  var RsaPrivateKey$5 = class RsaPrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey;
    }
    genSecret() {
      return randomBytes$5(16);
    }
    async sign(message2) {
      return hashAndSign$g(this._key, message2);
    }
    get public() {
      if (this._publicKey == null) {
        throw new CodeError("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
      }
      return new RsaPublicKey$5(this._publicKey);
    }
    decrypt(bytes2) {
      return decrypt$5(this._key, bytes2);
    }
    marshal() {
      return jwkToPkcs1$5(this._key);
    }
    get bytes() {
      return PrivateKey$6.encode({
        Type: KeyType$6.RSA,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$6.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "pkcs-8") {
      if (format4 === "pkcs-8") {
        const buffer = new forge$n.util.ByteBuffer(this.marshal());
        const asn12 = forge$n.asn1.fromDer(buffer);
        const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
        const options = {
          algorithm: "aes256",
          count: 1e4,
          saltSize: 128 / 8,
          prfAlgorithm: "sha512"
        };
        return forge$n.pki.encryptRsaPrivateKey(privateKey, password, options);
      } else if (format4 === "libp2p-key") {
        return exporter$5(this.bytes, password);
      } else {
        throw new CodeError(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var RSA$5 = Object.freeze({
    __proto__: null,
    RsaPrivateKey: RsaPrivateKey$5,
    RsaPublicKey: RsaPublicKey$5,
    fromJwk: fromJwk$5,
    generateKeyPair: generateKeyPair$i,
    unmarshalRsaPrivateKey: unmarshalRsaPrivateKey$5,
    unmarshalRsaPublicKey: unmarshalRsaPublicKey$5
  });
  var Secp256k1PublicKey$5 = class Secp256k1PublicKey2 {
    constructor(key) {
      validatePublicKey$5(key);
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$f(this._key, sig, data);
    }
    marshal() {
      return compressPublicKey$5(this._key);
    }
    get bytes() {
      return PublicKey$6.encode({
        Type: KeyType$6.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$6.digest(this.bytes);
      return bytes2;
    }
  };
  var Secp256k1PrivateKey$5 = class Secp256k1PrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey ?? computePublicKey$5(key);
      validatePrivateKey$5(this._key);
      validatePublicKey$5(this._publicKey);
    }
    async sign(message2) {
      return hashAndSign$f(this._key, message2);
    }
    get public() {
      return new Secp256k1PublicKey$5(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$6.encode({
        Type: KeyType$6.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$6.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$5(this.bytes, password);
      } else {
        throw new CodeError(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Secp256k1$5 = Object.freeze({
    __proto__: null,
    Secp256k1PrivateKey: Secp256k1PrivateKey$5,
    Secp256k1PublicKey: Secp256k1PublicKey$5,
    generateKeyPair: generateKeyPair$h,
    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey$5,
    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey$5
  });
  var supportedKeys$5 = {
    rsa: RSA$5,
    ed25519: Ed25519$5,
    secp256k1: Secp256k1$5
  };

  class RawEnr extends Map {
    constructor(kvs = {}, seq = BigInt(1), signature) {
      super(Object.entries(kvs));
      this.seq = seq;
      this.signature = signature;
    }
    set(k, v) {
      this.signature = undefined;
      this.seq++;
      return super.set(k, v);
    }
    get id() {
      const id = this.get("id");
      if (!id)
        throw new Error("id not found.");
      return bytesToUtf8(id);
    }
    get publicKey() {
      switch (this.id) {
        case "v4":
          return this.get("secp256k1");
        default:
          throw new Error(ERR_INVALID_ID);
      }
    }
    get ip() {
      return getStringValue(this, "ip", "ip4");
    }
    set ip(ip) {
      setStringValue(this, "ip", "ip4", ip);
    }
    get tcp() {
      return getNumberAsStringValue(this, "tcp", "tcp");
    }
    set tcp(port) {
      setNumberAsStringValue(this, "tcp", "tcp", port);
    }
    get udp() {
      return getNumberAsStringValue(this, "udp", "udp");
    }
    set udp(port) {
      setNumberAsStringValue(this, "udp", "udp", port);
    }
    get ip6() {
      return getStringValue(this, "ip6", "ip6");
    }
    set ip6(ip) {
      setStringValue(this, "ip6", "ip6", ip);
    }
    get tcp6() {
      return getNumberAsStringValue(this, "tcp6", "tcp");
    }
    set tcp6(port) {
      setNumberAsStringValue(this, "tcp6", "tcp", port);
    }
    get udp6() {
      return getNumberAsStringValue(this, "udp6", "udp");
    }
    set udp6(port) {
      setNumberAsStringValue(this, "udp6", "udp", port);
    }
    get multiaddrs() {
      const raw = this.get("multiaddrs");
      if (raw)
        return decodeMultiaddrs(raw);
      return;
    }
    set multiaddrs(multiaddrs) {
      deleteUndefined(this, "multiaddrs", multiaddrs, encodeMultiaddrs);
    }
    get waku2() {
      const raw = this.get("waku2");
      if (raw)
        return decodeWaku2(raw[0]);
      return;
    }
    set waku2(waku2) {
      deleteUndefined(this, "waku2", waku2, (w) => new Uint8Array([encodeWaku2(w)]));
    }
  }
  var log$v = debug("waku:enr");
  var TransportProtocol;
  (function(TransportProtocol2) {
    TransportProtocol2["TCP"] = "tcp";
    TransportProtocol2["UDP"] = "udp";
  })(TransportProtocol || (TransportProtocol = {}));
  var TransportProtocolPerIpVersion;
  (function(TransportProtocolPerIpVersion2) {
    TransportProtocolPerIpVersion2["TCP4"] = "tcp4";
    TransportProtocolPerIpVersion2["UDP4"] = "udp4";
    TransportProtocolPerIpVersion2["TCP6"] = "tcp6";
    TransportProtocolPerIpVersion2["UDP6"] = "udp6";
  })(TransportProtocolPerIpVersion || (TransportProtocolPerIpVersion = {}));

  class ENR extends RawEnr {
    constructor() {
      super(...arguments);
      this.getLocationMultiaddr = locationMultiaddrFromEnrFields.bind({}, this);
    }
    static async create(kvs = {}, seq = BigInt(1), signature) {
      const enr = new ENR(kvs, seq, signature);
      try {
        const publicKey = enr.publicKey;
        if (publicKey) {
          enr.peerId = await createPeerIdFromPublicKey(publicKey);
        }
      } catch (e) {
        log$v("Could not calculate peer id for ENR", e);
      }
      return enr;
    }
    get nodeId() {
      switch (this.id) {
        case "v4":
          return this.publicKey ? nodeId(this.publicKey) : undefined;
        default:
          throw new Error(ERR_INVALID_ID);
      }
    }
    setLocationMultiaddr(multiaddr2) {
      const protoNames = multiaddr2.protoNames();
      if (protoNames.length !== 2 && protoNames[1] !== "udp" && protoNames[1] !== "tcp") {
        throw new Error("Invalid multiaddr");
      }
      const tuples = multiaddr2.tuples();
      if (!tuples[0][1] || !tuples[1][1]) {
        throw new Error("Invalid multiaddr");
      }
      if (tuples[0][0] === 4) {
        this.set("ip", tuples[0][1]);
        this.set(protoNames[1], tuples[1][1]);
      } else {
        this.set("ip6", tuples[0][1]);
        this.set(protoNames[1] + "6", tuples[1][1]);
      }
    }
    getAllLocationMultiaddrs() {
      const multiaddrs = [];
      for (const protocol of Object.values(TransportProtocolPerIpVersion)) {
        const ma = this.getLocationMultiaddr(protocol);
        if (ma)
          multiaddrs.push(ma);
      }
      const _multiaddrs = this.multiaddrs ?? [];
      return multiaddrs.concat(_multiaddrs);
    }
    get peerInfo() {
      const id = this.peerId;
      if (!id)
        return;
      return {
        id,
        multiaddrs: this.getAllLocationMultiaddrs(),
        protocols: []
      };
    }
    getFullMultiaddr(protocol) {
      if (this.peerId) {
        const locationMultiaddr = this.getLocationMultiaddr(protocol);
        if (locationMultiaddr) {
          return locationMultiaddr.encapsulate(`/p2p/${this.peerId.toString()}`);
        }
      }
      return;
    }
    getFullMultiaddrs() {
      if (this.peerId && this.multiaddrs) {
        const peerId = this.peerId;
        return this.multiaddrs.map((ma) => {
          return ma.encapsulate(`/p2p/${peerId.toString()}`);
        });
      }
      return [];
    }
    verify(data, signature) {
      if (!this.get("id") || this.id !== "v4") {
        throw new Error(ERR_INVALID_ID);
      }
      if (!this.publicKey) {
        throw new Error("Failed to verify ENR: No public key");
      }
      return verifySignature(signature, keccak256(data), this.publicKey);
    }
    async sign(data, privateKey) {
      switch (this.id) {
        case "v4":
          this.signature = await sign(privateKey, data);
          break;
        default:
          throw new Error(ERR_INVALID_ID);
      }
      return this.signature;
    }
  }
  ENR.RECORD_PREFIX = "enr:";
  var version$3 = "logger/5.7.0";
  var _permanentCensorErrors = false;
  var _censorErrors = false;
  var LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
  var _logLevel = LogLevels["default"];
  var _globalLogger = null;
  var _normalizeError = _checkNormalize();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2["DEBUG"] = "DEBUG";
    LogLevel2["INFO"] = "INFO";
    LogLevel2["WARNING"] = "WARNING";
    LogLevel2["ERROR"] = "ERROR";
    LogLevel2["OFF"] = "OFF";
  })(LogLevel || (LogLevel = {}));
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
    ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
    ErrorCode2["TIMEOUT"] = "TIMEOUT";
    ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
    ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
  })(ErrorCode || (ErrorCode = {}));
  var HEX = "0123456789abcdef";

  class Logger {
    constructor(version2) {
      Object.defineProperty(this, "version", {
        enumerable: true,
        value: version2,
        writable: false
      });
    }
    _log(logLevel, args) {
      const level = logLevel.toLowerCase();
      if (LogLevels[level] == null) {
        this.throwArgumentError("invalid log level name", "logLevel", logLevel);
      }
      if (_logLevel > LogLevels[level]) {
        return;
      }
      console.log.apply(console, args);
    }
    debug(...args) {
      this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
      this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
      this._log(Logger.levels.WARNING, args);
    }
    makeError(message2, code2, params) {
      if (_censorErrors) {
        return this.makeError("censored error", code2, {});
      }
      if (!code2) {
        code2 = Logger.errors.UNKNOWN_ERROR;
      }
      if (!params) {
        params = {};
      }
      const messageDetails = [];
      Object.keys(params).forEach((key) => {
        const value = params[key];
        try {
          if (value instanceof Uint8Array) {
            let hex = "";
            for (let i = 0;i < value.length; i++) {
              hex += HEX[value[i] >> 4];
              hex += HEX[value[i] & 15];
            }
            messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
          } else {
            messageDetails.push(key + "=" + JSON.stringify(value));
          }
        } catch (error2) {
          messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
        }
      });
      messageDetails.push(`code=${code2}`);
      messageDetails.push(`version=${this.version}`);
      const reason = message2;
      let url = "";
      switch (code2) {
        case ErrorCode.NUMERIC_FAULT: {
          url = "NUMERIC_FAULT";
          const fault = message2;
          switch (fault) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              url += "-" + fault;
              break;
            case "negative-power":
            case "negative-width":
              url += "-unsupported";
              break;
            case "unbound-bitwise-result":
              url += "-unbound-result";
              break;
          }
          break;
        }
        case ErrorCode.CALL_EXCEPTION:
        case ErrorCode.INSUFFICIENT_FUNDS:
        case ErrorCode.MISSING_NEW:
        case ErrorCode.NONCE_EXPIRED:
        case ErrorCode.REPLACEMENT_UNDERPRICED:
        case ErrorCode.TRANSACTION_REPLACED:
        case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
          url = code2;
          break;
      }
      if (url) {
        message2 += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
      }
      if (messageDetails.length) {
        message2 += " (" + messageDetails.join(", ") + ")";
      }
      const error = new Error(message2);
      error.reason = reason;
      error.code = code2;
      Object.keys(params).forEach(function(key) {
        error[key] = params[key];
      });
      return error;
    }
    throwError(message2, code2, params) {
      throw this.makeError(message2, code2, params);
    }
    throwArgumentError(message2, name2, value) {
      return this.throwError(message2, Logger.errors.INVALID_ARGUMENT, {
        argument: name2,
        value
      });
    }
    assert(condition, message2, code2, params) {
      if (!!condition) {
        return;
      }
      this.throwError(message2, code2, params);
    }
    assertArgument(condition, message2, name2, value) {
      if (!!condition) {
        return;
      }
      this.throwArgumentError(message2, name2, value);
    }
    checkNormalize(message2) {
      if (_normalizeError) {
        this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "String.prototype.normalize",
          form: _normalizeError
        });
      }
    }
    checkSafeUint53(value, message2) {
      if (typeof value !== "number") {
        return;
      }
      if (message2 == null) {
        message2 = "value not safe";
      }
      if (value < 0 || value >= 9007199254740991) {
        this.throwError(message2, Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value
        });
      }
      if (value % 1) {
        this.throwError(message2, Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value
        });
      }
    }
    checkArgumentCount(count, expectedCount, message2) {
      if (message2) {
        message2 = ": " + message2;
      } else {
        message2 = "";
      }
      if (count < expectedCount) {
        this.throwError("missing argument" + message2, Logger.errors.MISSING_ARGUMENT, {
          count,
          expectedCount
        });
      }
      if (count > expectedCount) {
        this.throwError("too many arguments" + message2, Logger.errors.UNEXPECTED_ARGUMENT, {
          count,
          expectedCount
        });
      }
    }
    checkNew(target, kind) {
      if (target === Object || target == null) {
        this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    checkAbstract(target, kind) {
      if (target === kind) {
        this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
      } else if (target === Object || target == null) {
        this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    static globalLogger() {
      if (!_globalLogger) {
        _globalLogger = new Logger(version$3);
      }
      return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
      if (!censorship && permanent) {
        this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      if (_permanentCensorErrors) {
        if (!censorship) {
          return;
        }
        this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      _censorErrors = !!censorship;
      _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
      const level = LogLevels[logLevel.toLowerCase()];
      if (level == null) {
        Logger.globalLogger().warn("invalid log level - " + logLevel);
        return;
      }
      _logLevel = level;
    }
    static from(version2) {
      return new Logger(version2);
    }
  }
  Logger.errors = ErrorCode;
  Logger.levels = LogLevel;
  var version$2 = "bytes/5.7.0";
  var logger$6 = new Logger(version$2);
  var HexCharacters = "0123456789abcdef";
  var version$1 = "rlp/5.7.0";
  var logger$5 = new Logger(version$1);

  class EnrDecoder {
    static fromString(encoded) {
      if (!encoded.startsWith(ENR.RECORD_PREFIX)) {
        throw new Error(`"string encoded ENR must start with '${ENR.RECORD_PREFIX}'`);
      }
      return EnrDecoder.fromRLP(fromString$3(encoded.slice(4), "base64url"));
    }
    static fromRLP(encoded) {
      const decoded = decode$g(encoded).map(hexToBytes$3);
      return fromValues(decoded);
    }
  }
  var v4Regex$1 = /^(\d{1,3}\.){3,3}\d{1,3}$/;
  var v4Size = 4;
  var v6Regex$1 = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
  var v6Size = 16;
  var v4$1 = {
    name: "v4",
    size: v4Size,
    isFormat: (ip) => v4Regex$1.test(ip),
    encode(ip, buff, offset) {
      offset = ~~offset;
      buff = buff || new Uint8Array(offset + v4Size);
      const max = ip.length;
      let n = 0;
      for (let i = 0;i < max; ) {
        const c = ip.charCodeAt(i++);
        if (c === 46) {
          buff[offset++] = n;
          n = 0;
        } else {
          n = n * 10 + (c - 48);
        }
      }
      buff[offset] = n;
      return buff;
    },
    decode(buff, offset) {
      offset = ~~offset;
      return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`;
    }
  };
  var v6$1 = {
    name: "v6",
    size: v6Size,
    isFormat: (ip) => ip.length > 0 && v6Regex$1.test(ip),
    encode(ip, buff, offset) {
      offset = ~~offset;
      let end = offset + v6Size;
      let fill = -1;
      let hexN = 0;
      let decN = 0;
      let prevColon = true;
      let useDec = false;
      buff = buff || new Uint8Array(offset + v6Size);
      for (let i = 0;i < ip.length; i++) {
        let c = ip.charCodeAt(i);
        if (c === 58) {
          if (prevColon) {
            if (fill !== -1) {
              if (offset < end)
                buff[offset] = 0;
              if (offset < end - 1)
                buff[offset + 1] = 0;
              offset += 2;
            } else if (offset < end) {
              fill = offset;
            }
          } else {
            if (useDec === true) {
              if (offset < end)
                buff[offset] = decN;
              offset++;
            } else {
              if (offset < end)
                buff[offset] = hexN >> 8;
              if (offset < end - 1)
                buff[offset + 1] = hexN & 255;
              offset += 2;
            }
            hexN = 0;
            decN = 0;
          }
          prevColon = true;
          useDec = false;
        } else if (c === 46) {
          if (offset < end)
            buff[offset] = decN;
          offset++;
          decN = 0;
          hexN = 0;
          prevColon = false;
          useDec = true;
        } else {
          prevColon = false;
          if (c >= 97) {
            c -= 87;
          } else if (c >= 65) {
            c -= 55;
          } else {
            c -= 48;
            decN = decN * 10 + c;
          }
          hexN = (hexN << 4) + c;
        }
      }
      if (prevColon === false) {
        if (useDec === true) {
          if (offset < end)
            buff[offset] = decN;
          offset++;
        } else {
          if (offset < end)
            buff[offset] = hexN >> 8;
          if (offset < end - 1)
            buff[offset + 1] = hexN & 255;
          offset += 2;
        }
      } else if (fill === 0) {
        if (offset < end)
          buff[offset] = 0;
        if (offset < end - 1)
          buff[offset + 1] = 0;
        offset += 2;
      } else if (fill !== -1) {
        offset += 2;
        for (let i = Math.min(offset - 1, end - 1);i >= fill + 2; i--) {
          buff[i] = buff[i - 2];
        }
        buff[fill] = 0;
        buff[fill + 1] = 0;
        fill = offset;
      }
      if (fill !== offset && fill !== -1) {
        if (offset > end - 2) {
          offset = end - 2;
        }
        while (end > fill) {
          buff[--end] = offset < end && offset > fill ? buff[--offset] : 0;
        }
      } else {
        while (offset < end) {
          buff[offset++] = 0;
        }
      }
      return buff;
    },
    decode(buff, offset) {
      offset = ~~offset;
      let result = "";
      for (let i = 0;i < v6Size; i += 2) {
        if (i !== 0) {
          result += ":";
        }
        result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16);
      }
      return result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
    }
  };
  var SURROGATE_A = 55296;
  var SURROGATE_B = 56320;
  encode$k.bytes = 0;
  decode$e.bytes = 0;
  var isU8Arr = (input) => input instanceof Uint8Array;
  var P_24 = Math.pow(2, 24);
  var P_16 = Math.pow(2, 16);
  var P_8 = Math.pow(2, 8);
  var readUInt32BE = (buf, offset) => buf[offset] * P_24 + buf[offset + 1] * P_16 + buf[offset + 2] * P_8 + buf[offset + 3];
  var readUInt16BE = (buf, offset) => buf[offset] << 8 | buf[offset + 1];
  var writeUInt32BE = (buf, value, offset) => {
    value = +value;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
  };
  var writeUInt16BE = (buf, value, offset) => {
    buf[offset] = value >> 8;
    buf[offset + 1] = value & 255;
    return offset + 2;
  };
  var QUERY_FLAG = 0;
  var RESPONSE_FLAG = 1 << 15;
  var FLUSH_MASK = 1 << 15;
  var NOT_FLUSH_MASK = ~FLUSH_MASK;
  var QU_MASK = 1 << 15;
  var NOT_QU_MASK = ~QU_MASK;
  var name$5 = codec({
    encode(str, buf, offset) {
      if (!buf)
        buf = new Uint8Array(name$5.encodingLength(str));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const n = str.replace(/^\.|\.$/gm, "");
      if (n.length) {
        const list = n.split(".");
        for (let i = 0;i < list.length; i++) {
          const len = write$1(buf, list[i], offset + 1);
          buf[offset] = len;
          offset += len + 1;
        }
      }
      buf[offset++] = 0;
      name$5.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const list = [];
      let oldOffset = offset;
      let totalLength = 0;
      let consumedBytes = 0;
      let jumped = false;
      while (true) {
        if (offset >= buf.length) {
          throw new Error("Cannot decode name (buffer overflow)");
        }
        const len = buf[offset++];
        consumedBytes += jumped ? 0 : 1;
        if (len === 0) {
          break;
        } else if ((len & 192) === 0) {
          if (offset + len > buf.length) {
            throw new Error("Cannot decode name (buffer overflow)");
          }
          totalLength += len + 1;
          if (totalLength > 254) {
            throw new Error("Cannot decode name (name too long)");
          }
          list.push(decode$e(buf, offset, offset + len));
          offset += len;
          consumedBytes += jumped ? 0 : len;
        } else if ((len & 192) === 192) {
          if (offset + 1 > buf.length) {
            throw new Error("Cannot decode name (buffer overflow)");
          }
          const jumpOffset = readUInt16BE(buf, offset - 1) - 49152;
          if (jumpOffset >= oldOffset) {
            throw new Error("Cannot decode name (bad pointer)");
          }
          offset = jumpOffset;
          oldOffset = jumpOffset;
          consumedBytes += jumped ? 0 : 1;
          jumped = true;
        } else {
          throw new Error("Cannot decode name (bad label)");
        }
      }
      name$5.decode.bytes = consumedBytes;
      return list.length === 0 ? "." : list.join(".");
    },
    encodingLength(n) {
      if (n === "." || n === "..")
        return 1;
      return bytelength(n.replace(/^\.|\.$/gm, "")) + 2;
    }
  });
  var string = codec({
    encode(s2, buf, offset) {
      if (!buf)
        buf = new Uint8Array(string.encodingLength(s2));
      if (!offset)
        offset = 0;
      const len = write$1(buf, s2, offset + 1);
      buf[offset] = len;
      string.encode.bytes = len + 1;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const len = buf[offset];
      const s2 = decode$e(buf, offset + 1, offset + 1 + len);
      string.decode.bytes = len + 1;
      return s2;
    },
    encodingLength(s2) {
      return bytelength(s2) + 1;
    }
  });
  var header = codec({
    bytes: 12,
    encode(h, buf, offset) {
      if (!buf)
        buf = new Uint8Array(header.encodingLength(h));
      if (!offset)
        offset = 0;
      const flags = (h.flags || 0) & 32767;
      const type = h.type === "response" ? RESPONSE_FLAG : QUERY_FLAG;
      writeUInt16BE(buf, h.id || 0, offset);
      writeUInt16BE(buf, flags | type, offset + 2);
      writeUInt16BE(buf, h.questions.length, offset + 4);
      writeUInt16BE(buf, h.answers.length, offset + 6);
      writeUInt16BE(buf, h.authorities.length, offset + 8);
      writeUInt16BE(buf, h.additionals.length, offset + 10);
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      if (buf.length < 12)
        throw new Error("Header must be 12 bytes");
      const flags = readUInt16BE(buf, offset + 2);
      return {
        id: readUInt16BE(buf, offset),
        type: flags & RESPONSE_FLAG ? "response" : "query",
        flags: flags & 32767,
        flag_qr: (flags >> 15 & 1) === 1,
        opcode: toString$2(flags >> 11 & 15),
        flag_aa: (flags >> 10 & 1) === 1,
        flag_tc: (flags >> 9 & 1) === 1,
        flag_rd: (flags >> 8 & 1) === 1,
        flag_ra: (flags >> 7 & 1) === 1,
        flag_z: (flags >> 6 & 1) === 1,
        flag_ad: (flags >> 5 & 1) === 1,
        flag_cd: (flags >> 4 & 1) === 1,
        rcode: toString$3(flags & 15),
        questions: new Array(readUInt16BE(buf, offset + 4)),
        answers: new Array(readUInt16BE(buf, offset + 6)),
        authorities: new Array(readUInt16BE(buf, offset + 8)),
        additionals: new Array(readUInt16BE(buf, offset + 10))
      };
    },
    encodingLength() {
      return 12;
    }
  });
  var runknown = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(runknown.encodingLength(data));
      if (!offset)
        offset = 0;
      const dLen = data.length;
      writeUInt16BE(buf, dLen, offset);
      copy(data, buf, offset + 2, 0, dLen);
      runknown.encode.bytes = dLen + 2;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const len = readUInt16BE(buf, offset);
      const data = buf.slice(offset + 2, offset + 2 + len);
      runknown.decode.bytes = len + 2;
      return data;
    },
    encodingLength(data) {
      return data.length + 2;
    }
  });
  var rns = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rns.encodingLength(data));
      if (!offset)
        offset = 0;
      name$5.encode(data, buf, offset + 2);
      writeUInt16BE(buf, name$5.encode.bytes, offset);
      rns.encode.bytes = name$5.encode.bytes + 2;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const len = readUInt16BE(buf, offset);
      const dd = name$5.decode(buf, offset + 2);
      rns.decode.bytes = len + 2;
      return dd;
    },
    encodingLength(data) {
      return name$5.encodingLength(data) + 2;
    }
  });
  var rsoa = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rsoa.encodingLength(data));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      offset += 2;
      name$5.encode(data.mname, buf, offset);
      offset += name$5.encode.bytes;
      name$5.encode(data.rname, buf, offset);
      offset += name$5.encode.bytes;
      writeUInt32BE(buf, data.serial || 0, offset);
      offset += 4;
      writeUInt32BE(buf, data.refresh || 0, offset);
      offset += 4;
      writeUInt32BE(buf, data.retry || 0, offset);
      offset += 4;
      writeUInt32BE(buf, data.expire || 0, offset);
      offset += 4;
      writeUInt32BE(buf, data.minimum || 0, offset);
      offset += 4;
      writeUInt16BE(buf, offset - oldOffset - 2, oldOffset);
      rsoa.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const data = {};
      offset += 2;
      data.mname = name$5.decode(buf, offset);
      offset += name$5.decode.bytes;
      data.rname = name$5.decode(buf, offset);
      offset += name$5.decode.bytes;
      data.serial = readUInt32BE(buf, offset);
      offset += 4;
      data.refresh = readUInt32BE(buf, offset);
      offset += 4;
      data.retry = readUInt32BE(buf, offset);
      offset += 4;
      data.expire = readUInt32BE(buf, offset);
      offset += 4;
      data.minimum = readUInt32BE(buf, offset);
      offset += 4;
      rsoa.decode.bytes = offset - oldOffset;
      return data;
    },
    encodingLength(data) {
      return 22 + name$5.encodingLength(data.mname) + name$5.encodingLength(data.rname);
    }
  });
  var rtxt = codec({
    encode(data, buf, offset) {
      if (!Array.isArray(data))
        data = [data];
      for (let i = 0;i < data.length; i++) {
        if (typeof data[i] === "string") {
          data[i] = from$d(data[i]);
        }
        if (!isU8Arr(data[i])) {
          throw new Error("Must be a Buffer");
        }
      }
      if (!buf)
        buf = new Uint8Array(rtxt.encodingLength(data));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      offset += 2;
      data.forEach(function(d) {
        buf[offset++] = d.length;
        copy(d, buf, offset, 0, d.length);
        offset += d.length;
      });
      writeUInt16BE(buf, offset - oldOffset - 2, oldOffset);
      rtxt.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      let remaining = readUInt16BE(buf, offset);
      offset += 2;
      const data = [];
      while (remaining > 0) {
        const len = buf[offset++];
        --remaining;
        if (remaining < len) {
          throw new Error("Buffer overflow");
        }
        data.push(buf.slice(offset, offset + len));
        offset += len;
        remaining -= len;
      }
      rtxt.decode.bytes = offset - oldOffset;
      return data;
    },
    encodingLength(data) {
      if (!Array.isArray(data))
        data = [data];
      let length2 = 2;
      data.forEach(function(buf) {
        if (typeof buf === "string") {
          length2 += bytelength(buf) + 1;
        } else {
          length2 += buf.length + 1;
        }
      });
      return length2;
    }
  });
  var rnull = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rnull.encodingLength(data));
      if (!offset)
        offset = 0;
      if (typeof data === "string")
        data = from$d(data);
      if (!data)
        data = new Uint8Array(0);
      const oldOffset = offset;
      offset += 2;
      const len = data.length;
      copy(data, buf, offset, 0, len);
      offset += len;
      writeUInt16BE(buf, offset - oldOffset - 2, oldOffset);
      rnull.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const len = readUInt16BE(buf, offset);
      offset += 2;
      const data = buf.slice(offset, offset + len);
      offset += len;
      rnull.decode.bytes = offset - oldOffset;
      return data;
    },
    encodingLength(data) {
      if (!data)
        return 2;
      return (isU8Arr(data) ? data.length : bytelength(data)) + 2;
    }
  });
  var rhinfo = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rhinfo.encodingLength(data));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      offset += 2;
      string.encode(data.cpu, buf, offset);
      offset += string.encode.bytes;
      string.encode(data.os, buf, offset);
      offset += string.encode.bytes;
      writeUInt16BE(buf, offset - oldOffset - 2, oldOffset);
      rhinfo.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const data = {};
      offset += 2;
      data.cpu = string.decode(buf, offset);
      offset += string.decode.bytes;
      data.os = string.decode(buf, offset);
      offset += string.decode.bytes;
      rhinfo.decode.bytes = offset - oldOffset;
      return data;
    },
    encodingLength(data) {
      return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2;
    }
  });
  var rptr = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rptr.encodingLength(data));
      if (!offset)
        offset = 0;
      name$5.encode(data, buf, offset + 2);
      writeUInt16BE(buf, name$5.encode.bytes, offset);
      rptr.encode.bytes = name$5.encode.bytes + 2;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const data = name$5.decode(buf, offset + 2);
      rptr.decode.bytes = name$5.decode.bytes + 2;
      return data;
    },
    encodingLength(data) {
      return name$5.encodingLength(data) + 2;
    }
  });
  var rsrv = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rsrv.encodingLength(data));
      if (!offset)
        offset = 0;
      writeUInt16BE(buf, data.priority || 0, offset + 2);
      writeUInt16BE(buf, data.weight || 0, offset + 4);
      writeUInt16BE(buf, data.port || 0, offset + 6);
      name$5.encode(data.target, buf, offset + 8);
      const len = name$5.encode.bytes + 6;
      writeUInt16BE(buf, len, offset);
      rsrv.encode.bytes = len + 2;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const len = readUInt16BE(buf, offset);
      const data = {};
      data.priority = readUInt16BE(buf, offset + 2);
      data.weight = readUInt16BE(buf, offset + 4);
      data.port = readUInt16BE(buf, offset + 6);
      data.target = name$5.decode(buf, offset + 8);
      rsrv.decode.bytes = len + 2;
      return data;
    },
    encodingLength(data) {
      return 8 + name$5.encodingLength(data.target);
    }
  });
  var rcaa = codec({
    encode(data, buf, offset) {
      const len = rcaa.encodingLength(data);
      if (!buf)
        buf = new Uint8Array(rcaa.encodingLength(data));
      if (!offset)
        offset = 0;
      if (data.issuerCritical) {
        data.flags = rcaa.ISSUER_CRITICAL;
      }
      writeUInt16BE(buf, len - 2, offset);
      offset += 2;
      buf[offset] = data.flags || 0;
      offset += 1;
      string.encode(data.tag, buf, offset);
      offset += string.encode.bytes;
      write$1(buf, data.value, offset);
      offset += bytelength(data.value);
      rcaa.encode.bytes = len;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const len = readUInt16BE(buf, offset);
      offset += 2;
      const oldOffset = offset;
      const data = {};
      data.flags = buf[offset];
      offset += 1;
      data.tag = string.decode(buf, offset);
      offset += string.decode.bytes;
      data.value = decode$e(buf, offset, oldOffset + len);
      data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL);
      rcaa.decode.bytes = len + 2;
      return data;
    },
    encodingLength(data) {
      return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2;
    }
  });
  rcaa.ISSUER_CRITICAL = 1 << 7;
  var rmx = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rmx.encodingLength(data));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      offset += 2;
      writeUInt16BE(buf, data.preference || 0, offset);
      offset += 2;
      name$5.encode(data.exchange, buf, offset);
      offset += name$5.encode.bytes;
      writeUInt16BE(buf, offset - oldOffset - 2, oldOffset);
      rmx.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const data = {};
      offset += 2;
      data.preference = readUInt16BE(buf, offset);
      offset += 2;
      data.exchange = name$5.decode(buf, offset);
      offset += name$5.decode.bytes;
      rmx.decode.bytes = offset - oldOffset;
      return data;
    },
    encodingLength(data) {
      return 4 + name$5.encodingLength(data.exchange);
    }
  });
  var ra = codec({
    encode(host, buf, offset) {
      if (!buf)
        buf = new Uint8Array(ra.encodingLength(host));
      if (!offset)
        offset = 0;
      writeUInt16BE(buf, 4, offset);
      offset += 2;
      v4$1.encode(host, buf, offset);
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      offset += 2;
      const host = v4$1.decode(buf, offset);
      return host;
    },
    bytes: 6
  });
  var raaaa = codec({
    encode(host, buf, offset) {
      if (!buf)
        buf = new Uint8Array(raaaa.encodingLength(host));
      if (!offset)
        offset = 0;
      writeUInt16BE(buf, 16, offset);
      offset += 2;
      v6$1.encode(host, buf, offset);
      raaaa.encode.bytes = 18;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      offset += 2;
      const host = v6$1.decode(buf, offset);
      raaaa.decode.bytes = 18;
      return host;
    },
    bytes: 18
  });
  var alloc = (size) => new Uint8Array(size);
  var roption = codec({
    encode(option, buf, offset) {
      if (!buf)
        buf = new Uint8Array(roption.encodingLength(option));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const code2 = toCode(option.code);
      writeUInt16BE(buf, code2, offset);
      offset += 2;
      if (option.data) {
        writeUInt16BE(buf, option.data.length, offset);
        offset += 2;
        copy(option.data, buf, offset);
        offset += option.data.length;
      } else {
        switch (code2) {
          case 8:
            {
              const spl = option.sourcePrefixLength || 0;
              const fam = option.family || familyOf(option.ip);
              const ipBuf = encode$l(option.ip, alloc);
              const ipLen = Math.ceil(spl / 8);
              writeUInt16BE(buf, ipLen + 4, offset);
              offset += 2;
              writeUInt16BE(buf, fam, offset);
              offset += 2;
              buf[offset++] = spl;
              buf[offset++] = option.scopePrefixLength || 0;
              copy(ipBuf, buf, offset, 0, ipLen);
              offset += ipLen;
            }
            break;
          case 11:
            if (option.timeout) {
              writeUInt16BE(buf, 2, offset);
              offset += 2;
              writeUInt16BE(buf, option.timeout, offset);
              offset += 2;
            } else {
              writeUInt16BE(buf, 0, offset);
              offset += 2;
            }
            break;
          case 12:
            {
              const len = option.length || 0;
              writeUInt16BE(buf, len, offset);
              offset += 2;
              buf.fill(0, offset, offset + len);
              offset += len;
            }
            break;
          case 14:
            {
              const tagsLen = option.tags.length * 2;
              writeUInt16BE(buf, tagsLen, offset);
              offset += 2;
              for (const tag of option.tags) {
                writeUInt16BE(buf, tag, offset);
                offset += 2;
              }
            }
            break;
          default:
            throw new Error(`Unknown roption code: ${option.code}`);
        }
      }
      roption.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const option = {};
      option.code = readUInt16BE(buf, offset);
      option.type = toString(option.code);
      offset += 2;
      const len = readUInt16BE(buf, offset);
      offset += 2;
      option.data = buf.slice(offset, offset + len);
      switch (option.code) {
        case 8:
          option.family = readUInt16BE(buf, offset);
          offset += 2;
          option.sourcePrefixLength = buf[offset++];
          option.scopePrefixLength = buf[offset++];
          {
            const padded = new Uint8Array(option.family === 1 ? 4 : 16);
            copy(buf, padded, 0, offset, offset + len - 4);
            option.ip = decode$f(padded);
          }
          break;
        case 11:
          if (len > 0) {
            option.timeout = readUInt16BE(buf, offset);
            offset += 2;
          }
          break;
        case 14:
          option.tags = [];
          for (let i = 0;i < len; i += 2) {
            option.tags.push(readUInt16BE(buf, offset));
            offset += 2;
          }
      }
      roption.decode.bytes = len + 4;
      return option;
    },
    encodingLength(option) {
      if (option.data) {
        return option.data.length + 4;
      }
      const code2 = toCode(option.code);
      switch (code2) {
        case 8: {
          const spl = option.sourcePrefixLength || 0;
          return Math.ceil(spl / 8) + 8;
        }
        case 11:
          return typeof option.timeout === "number" ? 6 : 4;
        case 12:
          return option.length + 4;
        case 14:
          return 4 + option.tags.length * 2;
      }
      throw new Error(`Unknown roption code: ${option.code}`);
    }
  });
  var ropt = codec({
    encode(options, buf, offset) {
      if (!buf)
        buf = new Uint8Array(ropt.encodingLength(options));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const rdlen = encodingLengthList(options, roption);
      writeUInt16BE(buf, rdlen, offset);
      offset = encodeList(options, roption, buf, offset + 2);
      ropt.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const options = [];
      let rdlen = readUInt16BE(buf, offset);
      offset += 2;
      let o = 0;
      while (rdlen > 0) {
        options[o++] = roption.decode(buf, offset);
        offset += roption.decode.bytes;
        rdlen -= roption.decode.bytes;
      }
      ropt.decode.bytes = offset - oldOffset;
      return options;
    },
    encodingLength(options) {
      return 2 + encodingLengthList(options || [], roption);
    }
  });
  var rdnskey = codec({
    encode(key, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rdnskey.encodingLength(key));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const keydata = key.key;
      if (!isU8Arr(keydata)) {
        throw new Error("Key must be a Buffer");
      }
      offset += 2;
      writeUInt16BE(buf, key.flags, offset);
      offset += 2;
      buf[offset] = rdnskey.PROTOCOL_DNSSEC;
      offset += 1;
      buf[offset] = key.algorithm;
      offset += 1;
      copy(keydata, buf, offset, 0, keydata.length);
      offset += keydata.length;
      rdnskey.encode.bytes = offset - oldOffset;
      writeUInt16BE(buf, rdnskey.encode.bytes - 2, oldOffset);
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const key = {};
      const length2 = readUInt16BE(buf, offset);
      offset += 2;
      key.flags = readUInt16BE(buf, offset);
      offset += 2;
      if (buf[offset] !== rdnskey.PROTOCOL_DNSSEC) {
        throw new Error("Protocol must be 3");
      }
      offset += 1;
      key.algorithm = buf[offset];
      offset += 1;
      key.key = buf.slice(offset, oldOffset + length2 + 2);
      offset += key.key.length;
      rdnskey.decode.bytes = offset - oldOffset;
      return key;
    },
    encodingLength(key) {
      return 6 + bytelength(key.key);
    }
  });
  rdnskey.PROTOCOL_DNSSEC = 3;
  rdnskey.ZONE_KEY = 128;
  rdnskey.SECURE_ENTRYPOINT = 32768;
  var rrrsig = codec({
    encode(sig, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rrrsig.encodingLength(sig));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const signature = sig.signature;
      if (!isU8Arr(signature)) {
        throw new Error("Signature must be a Buffer");
      }
      offset += 2;
      writeUInt16BE(buf, toType(sig.typeCovered), offset);
      offset += 2;
      buf[offset] = sig.algorithm;
      offset += 1;
      buf[offset] = sig.labels;
      offset += 1;
      writeUInt32BE(buf, sig.originalTTL, offset);
      offset += 4;
      writeUInt32BE(buf, sig.expiration, offset);
      offset += 4;
      writeUInt32BE(buf, sig.inception, offset);
      offset += 4;
      writeUInt16BE(buf, sig.keyTag, offset);
      offset += 2;
      name$5.encode(sig.signersName, buf, offset);
      offset += name$5.encode.bytes;
      copy(signature, buf, offset, 0, signature.length);
      offset += signature.length;
      rrrsig.encode.bytes = offset - oldOffset;
      writeUInt16BE(buf, rrrsig.encode.bytes - 2, oldOffset);
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const sig = {};
      const length2 = readUInt16BE(buf, offset);
      offset += 2;
      sig.typeCovered = toString$4(readUInt16BE(buf, offset));
      offset += 2;
      sig.algorithm = buf[offset];
      offset += 1;
      sig.labels = buf[offset];
      offset += 1;
      sig.originalTTL = readUInt32BE(buf, offset);
      offset += 4;
      sig.expiration = readUInt32BE(buf, offset);
      offset += 4;
      sig.inception = readUInt32BE(buf, offset);
      offset += 4;
      sig.keyTag = readUInt16BE(buf, offset);
      offset += 2;
      sig.signersName = name$5.decode(buf, offset);
      offset += name$5.decode.bytes;
      sig.signature = buf.slice(offset, oldOffset + length2 + 2);
      offset += sig.signature.length;
      rrrsig.decode.bytes = offset - oldOffset;
      return sig;
    },
    encodingLength(sig) {
      return 20 + name$5.encodingLength(sig.signersName) + bytelength(sig.signature);
    }
  });
  var rrp = codec({
    encode(data, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rrp.encodingLength(data));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      offset += 2;
      name$5.encode(data.mbox || ".", buf, offset);
      offset += name$5.encode.bytes;
      name$5.encode(data.txt || ".", buf, offset);
      offset += name$5.encode.bytes;
      rrp.encode.bytes = offset - oldOffset;
      writeUInt16BE(buf, rrp.encode.bytes - 2, oldOffset);
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const data = {};
      offset += 2;
      data.mbox = name$5.decode(buf, offset) || ".";
      offset += name$5.decode.bytes;
      data.txt = name$5.decode(buf, offset) || ".";
      offset += name$5.decode.bytes;
      rrp.decode.bytes = offset - oldOffset;
      return data;
    },
    encodingLength(data) {
      return 2 + name$5.encodingLength(data.mbox || ".") + name$5.encodingLength(data.txt || ".");
    }
  });
  var typebitmap = codec({
    encode(typelist, buf, offset) {
      if (!buf)
        buf = new Uint8Array(typebitmap.encodingLength(typelist));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const typesByWindow = [];
      for (let i = 0;i < typelist.length; i++) {
        const typeid = toType(typelist[i]);
        if (typesByWindow[typeid >> 8] === undefined) {
          typesByWindow[typeid >> 8] = [];
        }
        typesByWindow[typeid >> 8][typeid >> 3 & 31] |= 1 << 7 - (typeid & 7);
      }
      for (let i = 0;i < typesByWindow.length; i++) {
        if (typesByWindow[i] !== undefined) {
          const windowBuf = from$d(typesByWindow[i]);
          buf[offset] = i;
          offset += 1;
          buf[offset] = windowBuf.length;
          offset += 1;
          copy(windowBuf, buf, offset, 0, windowBuf.length);
          offset += windowBuf.length;
        }
      }
      typebitmap.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset, length2) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const typelist = [];
      while (offset - oldOffset < length2) {
        const window2 = buf[offset];
        offset += 1;
        const windowLength = buf[offset];
        offset += 1;
        for (let i = 0;i < windowLength; i++) {
          const b = buf[offset + i];
          for (let j = 0;j < 8; j++) {
            if (b & 1 << 7 - j) {
              const typeid = toString$4(window2 << 8 | i << 3 | j);
              typelist.push(typeid);
            }
          }
        }
        offset += windowLength;
      }
      typebitmap.decode.bytes = offset - oldOffset;
      return typelist;
    },
    encodingLength(typelist) {
      const extents = [];
      for (let i = 0;i < typelist.length; i++) {
        const typeid = toType(typelist[i]);
        extents[typeid >> 8] = Math.max(extents[typeid >> 8] || 0, typeid & 255);
      }
      let len = 0;
      for (let i = 0;i < extents.length; i++) {
        if (extents[i] !== undefined) {
          len += 2 + Math.ceil((extents[i] + 1) / 8);
        }
      }
      return len;
    }
  });
  var rnsec = codec({
    encode(record, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rnsec.encodingLength(record));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      offset += 2;
      name$5.encode(record.nextDomain, buf, offset);
      offset += name$5.encode.bytes;
      typebitmap.encode(record.rrtypes, buf, offset);
      offset += typebitmap.encode.bytes;
      rnsec.encode.bytes = offset - oldOffset;
      writeUInt16BE(buf, rnsec.encode.bytes - 2, oldOffset);
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const record = {};
      const length2 = readUInt16BE(buf, offset);
      offset += 2;
      record.nextDomain = name$5.decode(buf, offset);
      offset += name$5.decode.bytes;
      record.rrtypes = typebitmap.decode(buf, offset, length2 - (offset - oldOffset));
      offset += typebitmap.decode.bytes;
      rnsec.decode.bytes = offset - oldOffset;
      return record;
    },
    encodingLength(record) {
      return 2 + name$5.encodingLength(record.nextDomain) + typebitmap.encodingLength(record.rrtypes);
    }
  });
  var rnsec3 = codec({
    encode(record, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rnsec3.encodingLength(record));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const salt = record.salt;
      if (!isU8Arr(salt)) {
        throw new Error("salt must be a Buffer");
      }
      const nextDomain = record.nextDomain;
      if (!isU8Arr(nextDomain)) {
        throw new Error("nextDomain must be a Buffer");
      }
      offset += 2;
      buf[offset] = record.algorithm;
      offset += 1;
      buf[offset] = record.flags;
      offset += 1;
      writeUInt16BE(buf, record.iterations, offset);
      offset += 2;
      buf[offset] = salt.length;
      offset += 1;
      copy(salt, buf, offset, 0, salt.length);
      offset += salt.length;
      buf[offset] = nextDomain.length;
      offset += 1;
      copy(nextDomain, buf, offset, 0, nextDomain.length);
      offset += nextDomain.length;
      typebitmap.encode(record.rrtypes, buf, offset);
      offset += typebitmap.encode.bytes;
      rnsec3.encode.bytes = offset - oldOffset;
      writeUInt16BE(buf, rnsec3.encode.bytes - 2, oldOffset);
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const record = {};
      const length2 = readUInt16BE(buf, offset);
      offset += 2;
      record.algorithm = buf[offset];
      offset += 1;
      record.flags = buf[offset];
      offset += 1;
      record.iterations = readUInt16BE(buf, offset);
      offset += 2;
      const saltLength = buf[offset];
      offset += 1;
      record.salt = buf.slice(offset, offset + saltLength);
      offset += saltLength;
      const hashLength = buf[offset];
      offset += 1;
      record.nextDomain = buf.slice(offset, offset + hashLength);
      offset += hashLength;
      record.rrtypes = typebitmap.decode(buf, offset, length2 - (offset - oldOffset));
      offset += typebitmap.decode.bytes;
      rnsec3.decode.bytes = offset - oldOffset;
      return record;
    },
    encodingLength(record) {
      return 8 + record.salt.length + record.nextDomain.length + typebitmap.encodingLength(record.rrtypes);
    }
  });
  var rds = codec({
    encode(digest2, buf, offset) {
      if (!buf)
        buf = new Uint8Array(rds.encodingLength(digest2));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const digestdata = digest2.digest;
      if (!isU8Arr(digestdata)) {
        throw new Error("Digest must be a Buffer");
      }
      offset += 2;
      writeUInt16BE(buf, digest2.keyTag, offset);
      offset += 2;
      buf[offset] = digest2.algorithm;
      offset += 1;
      buf[offset] = digest2.digestType;
      offset += 1;
      copy(digestdata, buf, offset, 0, digestdata.length);
      offset += digestdata.length;
      rds.encode.bytes = offset - oldOffset;
      writeUInt16BE(buf, rds.encode.bytes - 2, oldOffset);
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const digest2 = {};
      const length2 = readUInt16BE(buf, offset);
      offset += 2;
      digest2.keyTag = readUInt16BE(buf, offset);
      offset += 2;
      digest2.algorithm = buf[offset];
      offset += 1;
      digest2.digestType = buf[offset];
      offset += 1;
      digest2.digest = buf.slice(offset, oldOffset + length2 + 2);
      offset += digest2.digest.length;
      rds.decode.bytes = offset - oldOffset;
      return digest2;
    },
    encodingLength(digest2) {
      return 6 + bytelength(digest2.digest);
    }
  });
  var answer = codec({
    encode(a, buf, offset) {
      if (!buf)
        buf = new Uint8Array(answer.encodingLength(a));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      name$5.encode(a.name, buf, offset);
      offset += name$5.encode.bytes;
      writeUInt16BE(buf, toType(a.type), offset);
      if (a.type.toUpperCase() === "OPT") {
        if (a.name !== ".") {
          throw new Error("OPT name must be root.");
        }
        writeUInt16BE(buf, a.udpPayloadSize || 4096, offset + 2);
        buf[offset + 4] = a.extendedRcode || 0;
        buf[offset + 5] = a.ednsVersion || 0;
        writeUInt16BE(buf, a.flags || 0, offset + 6);
        offset += 8;
        ropt.encode(a.options || [], buf, offset);
        offset += ropt.encode.bytes;
      } else {
        let klass = toClass(a.class === undefined ? "IN" : a.class);
        if (a.flush)
          klass |= FLUSH_MASK;
        writeUInt16BE(buf, klass, offset + 2);
        writeUInt32BE(buf, a.ttl || 0, offset + 4);
        offset += 8;
        const enc = renc(a.type);
        enc.encode(a.data, buf, offset);
        offset += enc.encode.bytes;
      }
      answer.encode.bytes = offset - oldOffset;
      return buf;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const a = {};
      const oldOffset = offset;
      a.name = name$5.decode(buf, offset);
      offset += name$5.decode.bytes;
      a.type = toString$4(readUInt16BE(buf, offset));
      if (a.type === "OPT") {
        a.udpPayloadSize = readUInt16BE(buf, offset + 2);
        a.extendedRcode = buf[offset + 4];
        a.ednsVersion = buf[offset + 5];
        a.flags = readUInt16BE(buf, offset + 6);
        a.flag_do = (a.flags >> 15 & 1) === 1;
        a.options = ropt.decode(buf, offset + 8);
        offset += 8 + ropt.decode.bytes;
      } else {
        const klass = readUInt16BE(buf, offset + 2);
        a.ttl = readUInt32BE(buf, offset + 4);
        a.class = toString$1(klass & NOT_FLUSH_MASK);
        a.flush = !!(klass & FLUSH_MASK);
        const enc = renc(a.type);
        a.data = enc.decode(buf, offset + 8);
        offset += 8 + enc.decode.bytes;
      }
      answer.decode.bytes = offset - oldOffset;
      return a;
    },
    encodingLength(a) {
      const data = a.data !== null && a.data !== undefined ? a.data : a.options;
      return name$5.encodingLength(a.name) + 8 + renc(a.type).encodingLength(data);
    }
  });
  var question = codec({
    encode(q, buf, offset) {
      if (!buf)
        buf = new Uint8Array(question.encodingLength(q));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      name$5.encode(q.name, buf, offset);
      offset += name$5.encode.bytes;
      writeUInt16BE(buf, toType(q.type), offset);
      offset += 2;
      writeUInt16BE(buf, toClass(q.class === undefined ? "IN" : q.class), offset);
      offset += 2;
      question.encode.bytes = offset - oldOffset;
      return q;
    },
    decode(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const q = {};
      q.name = name$5.decode(buf, offset);
      offset += name$5.decode.bytes;
      q.type = toString$4(readUInt16BE(buf, offset));
      offset += 2;
      q.class = toString$1(readUInt16BE(buf, offset));
      offset += 2;
      const qu = !!(q.class & QU_MASK);
      if (qu)
        q.class &= NOT_QU_MASK;
      question.decode.bytes = offset - oldOffset;
      return q;
    },
    encodingLength(q) {
      return name$5.encodingLength(q.name) + 4;
    }
  });
  var RECURSION_DESIRED = 1 << 8;
  var packet = {
    encode: function(result, buf, offset) {
      const allocing = !buf;
      if (allocing)
        buf = new Uint8Array(encodingLength$5(result));
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      if (!result.questions)
        result.questions = [];
      if (!result.answers)
        result.answers = [];
      if (!result.authorities)
        result.authorities = [];
      if (!result.additionals)
        result.additionals = [];
      header.encode(result, buf, offset);
      offset += header.encode.bytes;
      offset = encodeList(result.questions, question, buf, offset);
      offset = encodeList(result.answers, answer, buf, offset);
      offset = encodeList(result.authorities, answer, buf, offset);
      offset = encodeList(result.additionals, answer, buf, offset);
      packet.encode.bytes = offset - oldOffset;
      if (allocing && encode$j.bytes !== buf.length) {
        return buf.slice(0, encode$j.bytes);
      }
      return buf;
    },
    decode: function(buf, offset) {
      if (!offset)
        offset = 0;
      const oldOffset = offset;
      const result = header.decode(buf, offset);
      offset += header.decode.bytes;
      offset = decodeList(result.questions, question, buf, offset);
      offset = decodeList(result.answers, answer, buf, offset);
      offset = decodeList(result.authorities, answer, buf, offset);
      offset = decodeList(result.additionals, answer, buf, offset);
      packet.decode.bytes = offset - oldOffset;
      return result;
    },
    encodingLength: function(result) {
      return header.encodingLength(result) + encodingLengthList(result.questions || [], question) + encodingLengthList(result.answers || [], answer) + encodingLengthList(result.authorities || [], answer) + encodingLengthList(result.additionals || [], answer);
    }
  };
  packet.encode.bytes = 0;
  packet.decode.bytes = 0;
  var encode$j = packet.encode;
  var decode$d = packet.decode;
  var encodingLength$5 = packet.encodingLength;
  var PREFERS_PADDING = 1;
  var PREFERS_NO_PADDING = 2;
  make("base64", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "=", PREFERS_PADDING);
  var base64URL = make("base64-url", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", "=", PREFERS_NO_PADDING);
  var AbortError$3 = typeof global !== "undefined" ? global.AbortError : typeof window !== "undefined" ? window.AbortError : null;
  if (!AbortError$3) {
    AbortError$3 = class AbortError2 extends Error {
      constructor(message2 = "Request aborted.") {
        super(message2);
      }
    };
  }
  AbortError$3.prototype.name = "AbortError";
  AbortError$3.prototype.code = "ABORT_ERR";
  var URL$1 = typeof globalThis !== "undefined" && globalThis.URL || import.meta.require("url").URL;

  class HTTPStatusError extends Error {
    constructor(uri, code2, method) {
      super("status=" + code2 + " while requesting " + uri + " [" + method + "]");
      this.uri = uri;
      this.status = code2;
      this.method = method;
    }
    toJSON() {
      return {
        code: this.code,
        uri: this.uri,
        status: this.status,
        method: this.method,
        endpoint: this.endpoint
      };
    }
  }
  HTTPStatusError.prototype.name = "HTTPStatusError";
  HTTPStatusError.prototype.code = "HTTP_STATUS";

  class ResponseError extends Error {
    constructor(message2, cause) {
      super(message2);
      this.cause = cause;
    }
    toJSON() {
      return {
        message: this.message,
        endpoint: this.endpoint,
        code: this.code,
        cause: reduceError(this.cause)
      };
    }
  }
  ResponseError.prototype.name = "ResponseError";
  ResponseError.prototype.code = "RESPONSE_ERR";
  var TimeoutError$2 = class TimeoutError2 extends Error {
    constructor(timeout) {
      super("Timeout (t=" + timeout + ").");
      this.timeout = timeout;
    }
    toJSON() {
      return {
        code: this.code,
        endpoint: this.endpoint,
        timeout: this.timeout
      };
    }
  };
  TimeoutError$2.prototype.name = "TimeoutError";
  TimeoutError$2.prototype.code = "ETIMEOUT";
  var v4Regex = /^((\d{1,3}\.){3,3}\d{1,3})(:(\d{2,5}))?$/;
  var v6Regex = /^((::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?)(:(\d{2,5}))?$/i;
  var baseParts = /^(([a-z0-9]+:)\/\/)?([^/[\s:]+|\[[^\]]+\])?(:([^/\s]+))?(\/[^\s]*)?(.*)$/;
  var httpFlags = /\[(post|get|((ipv4|ipv6|name)=([^\]]+)))\]/ig;
  var updFlags = /\[(((pk|name)=([^\]]+)))\]/ig;

  class InvalidProtocolError extends Error {
    constructor(protocol, endpoint) {
      super(`Invalid Endpoint: unsupported protocol "${protocol}" for endpoint: ${endpoint}, supported protocols: ${supportedProtocols.join(", ")}`);
      this.protocol = protocol;
      this.endpoint = endpoint;
    }
    toJSON() {
      return {
        code: this.code,
        endpoint: this.endpoint,
        timeout: this.timeout
      };
    }
  }
  InvalidProtocolError.prototype.name = "InvalidProtocolError";
  InvalidProtocolError.prototype.code = "EPROTOCOL";
  var supportedProtocols = ["http:", "https:", "udp4:", "udp6:"];

  class BaseEndpoint {
    constructor(opts, isHTTP) {
      this.name = opts.name || null;
      this.protocol = opts.protocol;
      const port = typeof opts.port === "string" ? opts.port = parseInt(opts.port, 10) : opts.port;
      if (port === undefined || port === null) {
        this.port = isHTTP ? this.protocol === "https:" ? 443 : 80 : opts.pk ? 443 : 53;
      } else if (typeof port !== "number" && !isNaN(port)) {
        throw new Error(`Invalid Endpoint: port "${opts.port}" needs to be a number: ${JSON.stringify(opts)}`);
      } else {
        this.port = port;
      }
    }
    toJSON() {
      return this.toString();
    }
  }

  class UDPEndpoint extends BaseEndpoint {
    constructor(opts) {
      super(opts, false);
      this.pk = opts.pk || null;
    }
    toString() {
      const port = this.port !== (this.pk ? 443 : 53) ? `:${this.port}` : "";
      const pk = this.pk ? ` [pk=${this.pk}]` : "";
      const name2 = this.name ? ` [name=${this.name}]` : "";
      return `udp://${this.ipv4 || `[${this.ipv6}]`}${port}${pk}${name2}`;
    }
  }

  class UDP4Endpoint extends UDPEndpoint {
    constructor(opts) {
      super(Object.assign({ protocol: "udp4:" }, opts));
      if (!opts.ipv4 || typeof opts.ipv4 !== "string") {
        throw new Error(`Invalid Endpoint: .ipv4 "${opts.ipv4}" needs to be set: ${JSON.stringify(opts)}`);
      }
      this.ipv4 = opts.ipv4;
    }
  }

  class UDP6Endpoint extends UDPEndpoint {
    constructor(opts) {
      super(Object.assign({ protocol: "udp6:" }, opts));
      if (!opts.ipv6 || typeof opts.ipv6 !== "string") {
        throw new Error(`Invalid Endpoint: .ipv6 "${opts.ipv6}" needs to be set: ${JSON.stringify(opts)}`);
      }
      this.ipv6 = opts.ipv6;
    }
  }

  class HTTPEndpoint extends BaseEndpoint {
    constructor(opts) {
      super(Object.assign({ protocol: "https:" }, opts), true);
      if (!opts.host) {
        if (opts.ipv4) {
          opts.host = opts.ipv4;
        }
        if (opts.ipv6) {
          opts.host = `[${opts.ipv6}]`;
        }
      }
      if (!opts.host || typeof opts.host !== "string") {
        throw new Error(`Invalid Endpoint: host "${opts.path}" needs to be set: ${JSON.stringify(opts)}`);
      }
      this.host = opts.host;
      this.path = opts.path || "/dns-query";
      this.method = /^post$/i.test(opts.method) ? "POST" : "GET";
      this.ipv4 = opts.ipv4;
      this.ipv6 = opts.ipv6;
      if (!this.ipv6) {
        const v6Parts = v6Regex.exec(this.host);
        if (v6Parts) {
          this.ipv6 = v6Parts[1];
        }
      }
      if (!this.ipv4) {
        if (v4Regex.test(this.host)) {
          this.ipv4 = this.host;
        }
      }
      const url = `${this.protocol}//${safeHost(this.host)}:${this.port}${this.path}`;
      try {
        this.url = new URL$1(url);
      } catch (err) {
        throw new Error(err.message + ` [${url}]`);
      }
    }
    toString() {
      const protocol = this.protocol === "https:" ? "" : "http://";
      const port = this.port !== (this.protocol === "https:" ? 443 : 80) ? `:${this.port}` : "";
      const method = this.method !== "GET" ? " [post]" : "";
      const path = this.path === "/dns-query" ? "" : this.path;
      const name2 = this.name ? ` [name=${this.name}]` : "";
      const ipv4 = this.ipv4 && this.ipv4 !== this.host ? ` [ipv4=${this.ipv4}]` : "";
      const ipv6 = this.ipv6 && this.ipv6 !== this.host ? ` [ipv6=${this.ipv6}]` : "";
      return `${protocol}${safeHost(this.host)}${port}${path}${method}${ipv4}${ipv6}${name2}`;
    }
  }
  var contentType = "application/dns-message";
  var resolvers = {
    data: [
      {
        name: "adfree.usableprivacy.net",
        endpoint: {
          protocol: "https:",
          host: "adfree.usableprivacy.net"
        },
        description: "Public updns DoH service with advertising, tracker and malware filters.\nHosted in Europe by @usableprivacy, details see: https://docs.usableprivacy.com",
        country: "Germany",
        location: {
          lat: 51.2993,
          long: 9.491
        },
        filter: true
      },
      {
        name: "adguard-dns-doh",
        endpoint: {
          protocol: "https:",
          host: "dns.adguard.com",
          ipv4: "94.140.15.15"
        },
        description: "Remove ads and protect your computer from malware (over DoH)",
        country: "France",
        location: {
          lat: 48.8582,
          long: 2.3387
        },
        filter: true
      },
      {
        name: "adguard-dns-family-doh",
        endpoint: {
          protocol: "https:",
          host: "dns-family.adguard.com",
          ipv4: "94.140.15.16"
        },
        description: "Adguard DNS with safesearch and adult content blocking (over DoH)",
        country: "France",
        location: {
          lat: 48.8582,
          long: 2.3387
        },
        filter: true
      },
      {
        name: "adguard-dns-unfiltered-doh",
        endpoint: {
          protocol: "https:",
          host: "dns-unfiltered.adguard.com",
          ipv4: "94.140.14.140"
        },
        description: "AdGuard public DNS servers without filters (over DoH)",
        country: "France",
        location: {
          lat: 48.8582,
          long: 2.3387
        }
      },
      {
        name: "ahadns-doh-chi",
        endpoint: {
          protocol: "https:",
          host: "doh.chi.ahadns.net",
          cors: true
        },
        description: "A zero logging DNS with support for DNS-over-HTTPS (DoH) & DNS-over-TLS (DoT). Blocks ads, malware, trackers, viruses, ransomware, telemetry and more. No persistent logs. DNSSEC. Hosted in Chicago, USA. By https://ahadns.com/\nServer statistics can be seen at: https://statistics.ahadns.com/?server=chi",
        country: "United States",
        location: {
          lat: 41.8483,
          long: -87.6517
        },
        filter: true,
        cors: true
      },
      {
        name: "ahadns-doh-in",
        endpoint: {
          protocol: "https:",
          host: "doh.in.ahadns.net",
          cors: true
        },
        description: "A zero logging DNS with support for DNS-over-HTTPS (DoH) & DNS-over-TLS (DoT). Blocks ads, malware, trackers, viruses, ransomware, telemetry and more. No persistent logs. DNSSEC. Hosted in Mumbai, India. By https://ahadns.com/\nServer statistics can be seen at: https://statistics.ahadns.com/?server=in",
        country: "India",
        location: {
          lat: 19.0748,
          long: 72.8856
        },
        filter: true,
        cors: true
      },
      {
        name: "ahadns-doh-la",
        endpoint: {
          protocol: "https:",
          host: "doh.la.ahadns.net",
          cors: true
        },
        description: "A zero logging DNS with support for DNS-over-HTTPS (DoH) & DNS-over-TLS (DoT). Blocks ads, malware, trackers, viruses, ransomware, telemetry and more. No persistent logs. DNSSEC. Hosted in Los Angeles, USA. By https://ahadns.com/\nServer statistics can be seen at: https://statistics.ahadns.com/?server=la",
        country: "United States",
        location: {
          lat: 34.0549,
          long: -118.2578
        },
        filter: true,
        cors: true
      },
      {
        name: "ahadns-doh-nl",
        endpoint: {
          protocol: "https:",
          host: "doh.nl.ahadns.net",
          cors: true
        },
        description: "A zero logging DNS with support for DNS-over-HTTPS (DoH) & DNS-over-TLS (DoT). Blocks ads, malware, trackers, viruses, ransomware, telemetry and more. No persistent logs. DNSSEC. Hosted in Amsterdam, Netherlands. By https://ahadns.com/\nServer statistics can be seen at: https://statistics.ahadns.com/?server=nl",
        country: "Netherlands",
        location: {
          lat: 52.3824,
          long: 4.8995
        },
        filter: true,
        cors: true
      },
      {
        name: "ahadns-doh-ny",
        endpoint: {
          protocol: "https:",
          host: "doh.ny.ahadns.net",
          cors: true
        },
        description: "A zero logging DNS with support for DNS-over-HTTPS (DoH) & DNS-over-TLS (DoT). Blocks ads, malware, trackers, viruses, ransomware, telemetry and more. No persistent logs. DNSSEC. Hosted in New York. By https://ahadns.com/\nServer statistics can be seen at: https://statistics.ahadns.com/?server=ny",
        country: "United States",
        location: {
          lat: 40.7308,
          long: -73.9975
        },
        filter: true,
        cors: true
      },
      {
        name: "ahadns-doh-pl",
        endpoint: {
          protocol: "https:",
          host: "doh.pl.ahadns.net",
          cors: true
        },
        description: "A zero logging DNS with support for DNS-over-HTTPS (DoH) & DNS-over-TLS (DoT). Blocks ads, malware, trackers, viruses, ransomware, telemetry and more. No persistent logs. DNSSEC. Hosted in Poland. By https://ahadns.com/\nServer statistics can be seen at: https://statistics.ahadns.com/?server=pl",
        country: "Netherlands",
        location: {
          lat: 52.3824,
          long: 4.8995
        },
        filter: true,
        cors: true
      },
      {
        name: "alidns-doh",
        endpoint: {
          protocol: "https:",
          host: "dns.alidns.com",
          ipv4: "223.5.5.5",
          cors: true
        },
        description: "A public DNS resolver that supports DoH/DoT in mainland China, provided by Alibaba-Cloud.\nWarning: GFW filtering rules are applied by that resolver.\nHomepage: https://alidns.com/",
        country: "China",
        location: {
          lat: 34.7725,
          long: 113.7266
        },
        filter: true,
        log: true,
        cors: true
      },
      {
        name: "ams-ads-doh-nl",
        endpoint: {
          protocol: "https:",
          host: "dnsnl-noads.alekberg.net"
        },
        description: "Resolver in Amsterdam. DoH protocol. Non-logging. Blocks ads, malware and trackers. DNSSEC enabled.",
        country: "Romania",
        location: {
          lat: 45.9968,
          long: 24.997
        },
        filter: true
      },
      {
        name: "ams-doh-nl",
        endpoint: {
          protocol: "https:",
          host: "dnsnl.alekberg.net"
        },
        description: "Resolver in Amsterdam. DoH protocol. Non-logging, non-filtering, DNSSEC.",
        country: "Romania",
        location: {
          lat: 45.9968,
          long: 24.997
        }
      },
      {
        name: "att",
        endpoint: {
          protocol: "https:",
          host: "dohtrial.att.net"
        },
        description: "AT&T test DoH server.",
        log: true
      },
      {
        name: "bcn-ads-doh",
        endpoint: {
          protocol: "https:",
          host: "dnses-noads.alekberg.net"
        },
        description: "Resolver in Spain. DoH protocol. Non-logging, remove ads and malware, DNSSEC.",
        country: "Spain",
        location: {
          lat: 41.3891,
          long: 2.1611
        },
        filter: true
      },
      {
        name: "bcn-doh",
        endpoint: {
          protocol: "https:",
          host: "dnses.alekberg.net"
        },
        description: "Resolver in Spain. DoH protocol. Non-logging, non-filtering, DNSSEC.",
        country: "Spain",
        location: {
          lat: 41.3891,
          long: 2.1611
        }
      },
      {
        name: "brahma-world",
        endpoint: {
          protocol: "https:",
          host: "dns.brahma.world"
        },
        description: "DNS-over-HTTPS server. Non Logging, filters ads, trackers and malware. DNSSEC ready, QNAME Minimization, No EDNS Client-Subnet.\nHosted in Stockholm, Sweden. (https://dns.brahma.world)",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        filter: true
      },
      {
        name: "cisco-doh",
        endpoint: {
          protocol: "https:",
          host: "doh.opendns.com",
          ipv4: "146.112.41.2"
        },
        description: "Remove your DNS blind spot (DoH protocol)\nWarning: modifies your queries to include a copy of your network\naddress when forwarding them to a selection of companies and organizations.",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        filter: true,
        log: true
      },
      {
        name: "cloudflare",
        endpoint: {
          protocol: "https:",
          host: "dns.cloudflare.com",
          ipv4: "1.0.0.1",
          cors: true
        },
        description: "Cloudflare DNS (anycast) - aka 1.1.1.1 / 1.0.0.1",
        country: "Australia",
        location: {
          lat: -33.494,
          long: 143.2104
        },
        cors: true
      },
      {
        name: "cloudflare-family",
        endpoint: {
          protocol: "https:",
          host: "family.cloudflare-dns.com",
          ipv4: "1.0.0.3",
          cors: true
        },
        description: "Cloudflare DNS (anycast) with malware protection and parental control - aka 1.1.1.3 / 1.0.0.3",
        country: "Australia",
        location: {
          lat: -33.494,
          long: 143.2104
        },
        filter: true,
        cors: true
      },
      {
        name: "cloudflare-ipv6",
        endpoint: {
          protocol: "https:",
          host: "1dot1dot1dot1.cloudflare-dns.com",
          cors: true
        },
        description: "Cloudflare DNS over IPv6 (anycast)",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        cors: true
      },
      {
        name: "cloudflare-security",
        endpoint: {
          protocol: "https:",
          host: "security.cloudflare-dns.com",
          ipv4: "1.0.0.2",
          cors: true
        },
        description: "Cloudflare DNS (anycast) with malware blocking - aka 1.1.1.2 / 1.0.0.2",
        country: "Australia",
        location: {
          lat: -33.494,
          long: 143.2104
        },
        filter: true,
        cors: true
      },
      {
        name: "controld-block-malware",
        endpoint: {
          protocol: "https:",
          host: "freedns.controld.com",
          path: "/p1"
        },
        description: "ControlD Free DNS. Take CONTROL of your Internet. Block unwanted content, bypass geo-restrictions and be more productive. DoH protocol and No logging. - https://controld.com/free-dns\nThis DNS blocks Malware domains.",
        country: "Canada",
        location: {
          lat: 43.6319,
          long: -79.3716
        },
        filter: true
      },
      {
        name: "controld-block-malware-ad",
        endpoint: {
          protocol: "https:",
          host: "freedns.controld.com",
          path: "/p2"
        },
        description: "ControlD Free DNS. Take CONTROL of your Internet. Block unwanted content, bypass geo-restrictions and be more productive. DoH protocol and No logging. - https://controld.com/free-dns\nThis DNS blocks Malware, Ads & Tracking domains.",
        country: "Canada",
        location: {
          lat: 43.6319,
          long: -79.3716
        },
        filter: true
      },
      {
        name: "controld-block-malware-ad-social",
        endpoint: {
          protocol: "https:",
          host: "freedns.controld.com",
          path: "/p3"
        },
        description: "ControlD Free DNS. Take CONTROL of your Internet. Block unwanted content, bypass geo-restrictions and be more productive. DoH protocol and No logging. - https://controld.com/free-dns\nThis DNS blocks Malware, Ads & Tracking and Social Networks domains.",
        country: "Canada",
        location: {
          lat: 43.6319,
          long: -79.3716
        },
        filter: true
      },
      {
        name: "controld-family-friendly",
        endpoint: {
          protocol: "https:",
          host: "freedns.controld.com",
          path: "/family"
        },
        description: "ControlD Free DNS. Take CONTROL of your Internet. Block unwanted content, bypass geo-restrictions and be more productive. DoH protocol and No logging. - https://controld.com/free-dns\nThis DNS blocks Malware, Ads & Tracking, Adult Content and Drugs domains.",
        country: "Canada",
        location: {
          lat: 43.6319,
          long: -79.3716
        },
        filter: true
      },
      {
        name: "controld-uncensored",
        endpoint: {
          protocol: "https:",
          host: "freedns.controld.com",
          path: "/uncensored"
        },
        description: "ControlD Free DNS. Take CONTROL of your Internet. Block unwanted content, bypass geo-restrictions and be more productive. DoH protocol and No logging. - https://controld.com/free-dns\nThis DNS unblocks censored domains from various countries.",
        country: "Canada",
        location: {
          lat: 43.6319,
          long: -79.3716
        }
      },
      {
        name: "controld-unfiltered",
        endpoint: {
          protocol: "https:",
          host: "freedns.controld.com",
          path: "/p0"
        },
        description: "ControlD Free DNS. Take CONTROL of your Internet. Block unwanted content, bypass geo-restrictions and be more productive. DoH protocol and No logging. - https://controld.com/free-dns\nThis is a Unfiltered DNS, no DNS record blocking or manipulation here, if you want to block Malware, Ads & Tracking or Social Network domains, use the other ControlD DNS configs.",
        country: "Canada",
        location: {
          lat: 43.6319,
          long: -79.3716
        }
      },
      {
        name: "dns.digitale-gesellschaft.ch",
        endpoint: {
          protocol: "https:",
          host: "dns.digitale-gesellschaft.ch"
        },
        description: "Public DoH resolver operated by the Digital Society (https://www.digitale-gesellschaft.ch).\nHosted in Zurich, Switzerland.\nNon-logging, non-filtering, supports DNSSEC.",
        country: "Switzerland",
        location: {
          lat: 47.1449,
          long: 8.1551
        }
      },
      {
        name: "dns.ryan-palmer",
        endpoint: {
          protocol: "https:",
          host: "dns1.ryan-palmer.com"
        },
        description: "Non-logging, non-filtering, DNSSEC DoH Server. Hosted in the UK.",
        country: "United Kingdom",
        location: {
          lat: 51.5164,
          long: -0.093
        }
      },
      {
        name: "dns.sb",
        endpoint: {
          protocol: "https:",
          host: "doh.sb",
          ipv4: "185.222.222.222",
          cors: true
        },
        description: "DNSSEC-enabled DoH server by https://xtom.com/\nhttps://dns.sb/doh/",
        country: "Unknown",
        location: {
          lat: 47,
          long: 8
        },
        cors: true
      },
      {
        name: "dns.therifleman.name",
        endpoint: {
          protocol: "https:",
          host: "dns.therifleman.name"
        },
        description: "DNS-over-HTTPS DNS forwarder from Mumbai, India. Blocks web and Android trackers and ads.\nIP addresses are not logged, but queries are logged for 24 hours for debugging.\nReport issues, send suggestions @ joker349 at protonmail.com.\nAlso supports DoT (for android) @ dns.therifleman.name and plain DNS @ 172.104.206.174",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        filter: true
      },
      {
        name: "dnsforfamily-doh",
        endpoint: {
          protocol: "https:",
          host: "dns-doh.dnsforfamily.com"
        },
        description: "(DoH Protocol) (Now supports DNSSEC). Block adult websites, gambling websites, malwares and advertisements.\nIt also enforces safe search in: Google, YouTube, Bing, DuckDuckGo and Yandex.\nSocial websites like Facebook and Instagram are not blocked. No DNS queries are logged.\nAs of 26-May-2022 5.9 million websites are blocked and new websites are added to blacklist daily.\nCompletely free, no ads or any commercial motive. Operating for 4 years now.\nProvided by: https://dnsforfamily.com",
        country: "Finland",
        location: {
          lat: 60.1758,
          long: 24.9349
        },
        filter: true
      },
      {
        name: "dnsforfamily-doh-no-safe-search",
        endpoint: {
          protocol: "https:",
          host: "dns-doh-no-safe-search.dnsforfamily.com"
        },
        description: "(DoH Protocol) (Now supports DNSSEC) Block adult websites, gambling websites, malwares and advertisements.\nUnlike other dnsforfamily servers, this one does not enforces safe search. So Google, YouTube, Bing, DuckDuckGo and Yandex are completely accessible without any restriction.\nSocial websites like Facebook and Instagram are not blocked. No DNS queries are logged.\nAs of 26-May-2022 5.9 million websites are blocked and new websites are added to blacklist daily.\nCompletely free, no ads or any commercial motive. Operating for 4 years now.\nWarning: This server is incompatible with anonymization.\nProvided by: https://dnsforfamily.com",
        country: "Finland",
        location: {
          lat: 60.1758,
          long: 24.9349
        },
        filter: true
      },
      {
        name: "dnsforge.de",
        endpoint: {
          protocol: "https:",
          host: "dnsforge.de",
          cors: true
        },
        description: "Public DoH resolver running with Pihole for Adblocking (https://dnsforge.de).\nNon-logging, AD-filtering, supports DNSSEC. Hosted in Germany.",
        country: "Germany",
        location: {
          lat: 52.2998,
          long: 9.447
        },
        filter: true,
        cors: true
      },
      {
        name: "dnshome-doh",
        endpoint: {
          protocol: "https:",
          host: "dns.dnshome.de"
        },
        description: "https://www.dnshome.de/ public resolver in Germany"
      },
      {
        name: "dnspod-doh",
        endpoint: {
          protocol: "https:",
          host: "doh.pub",
          cors: true
        },
        description: "A public DNS resolver in mainland China provided by DNSPod (Tencent Cloud).\nhttps://www.dnspod.cn/Products/Public.DNS?lang=en",
        filter: true,
        log: true,
        cors: true
      },
      {
        name: "dnswarden-asia-adblock-dohv4",
        endpoint: {
          protocol: "https:",
          host: "doh.asia.dnswarden.com",
          path: "/adblock"
        },
        description: "Hosted in Singapore. For more information look [here](https://github.com/bhanupratapys/dnswarden) or [here](https://dnswarden.com).",
        country: "Singapore",
        location: {
          lat: 1.2929,
          long: 103.8547
        },
        filter: true
      },
      {
        name: "dnswarden-asia-adultfilter-dohv4",
        endpoint: {
          protocol: "https:",
          host: "doh.asia.dnswarden.com",
          path: "/adultfilter"
        },
        description: "Hosted in Singapore. For more information look [here](https://github.com/bhanupratapys/dnswarden) or [here](https://dnswarden.com).",
        country: "Singapore",
        location: {
          lat: 1.2929,
          long: 103.8547
        },
        filter: true
      },
      {
        name: "dnswarden-asia-uncensor-dohv4",
        endpoint: {
          protocol: "https:",
          host: "doh.asia.dnswarden.com",
          path: "/uncensored"
        },
        description: "Hosted in Singapore. For more information look [here](https://github.com/bhanupratapys/dnswarden) or [here](https://dnswarden.com).",
        country: "Singapore",
        location: {
          lat: 1.2929,
          long: 103.8547
        }
      },
      {
        name: "dnswarden-eu-adblock-dohv4",
        endpoint: {
          protocol: "https:",
          host: "doh.eu.dnswarden.com"
        },
        description: "Hosted in Germany. For more information look [here](https://github.com/bhanupratapys/dnswarden) or [here](https://dnswarden.com).",
        country: "Germany",
        location: {
          lat: 50.1103,
          long: 8.7147
        },
        filter: true
      },
      {
        name: "dnswarden-us-adblock-dohv4",
        endpoint: {
          protocol: "https:",
          host: "doh.us.dnswarden.com"
        },
        description: "Hosted in USA (Dallas) . For more information look [here](https://github.com/bhanupratapys/dnswarden) or [here](https://dnswarden.com).",
        country: "United States",
        location: {
          lat: 32.7889,
          long: -96.8021
        },
        filter: true
      },
      {
        name: "doh-ch-blahdns",
        endpoint: {
          protocol: "https:",
          host: "doh-ch.blahdns.com",
          cors: true
        },
        description: "Blocks ad and Tracking, no Logging, DNSSEC, Hosted in Switzerland. By https://blahdns.com/",
        country: "Netherlands",
        location: {
          lat: 52.3824,
          long: 4.8995
        },
        filter: true,
        cors: true
      },
      {
        name: "doh-cleanbrowsing-adult",
        endpoint: {
          protocol: "https:",
          host: "doh.cleanbrowsing.org",
          path: "/doh/adult-filter/",
          cors: true
        },
        description: "Blocks access to all adult, pornographic and explicit sites. It does\nnot block proxy or VPNs, nor mixed-content sites. Sites like Reddit\nare allowed. Google and Bing are set to the Safe Mode.\nBy https://cleanbrowsing.org/",
        filter: true,
        cors: true
      },
      {
        name: "doh-cleanbrowsing-family",
        endpoint: {
          protocol: "https:",
          host: "doh.cleanbrowsing.org",
          path: "/doh/family-filter/",
          cors: true
        },
        description: "Blocks access to all adult, pornographic and explicit sites. It also\nblocks proxy and VPN domains that are used to bypass the filters.\nMixed content sites (like Reddit) are also blocked. Google, Bing and\nYoutube are set to the Safe Mode.\nBy https://cleanbrowsing.org/",
        filter: true,
        cors: true
      },
      {
        name: "doh-cleanbrowsing-security",
        endpoint: {
          protocol: "https:",
          host: "doh.cleanbrowsing.org",
          path: "/doh/security-filter/",
          cors: true
        },
        description: "Block access to phishing, malware and malicious domains. It does not block adult content.\nBy https://cleanbrowsing.org/",
        filter: true,
        cors: true
      },
      {
        name: "doh-crypto-sx",
        endpoint: {
          protocol: "https:",
          host: "doh.crypto.sx",
          cors: true
        },
        description: "DNS-over-HTTPS server. Anycast, no logs, no censorship, DNSSEC.\nBackend hosted by Scaleway, globally cached via Cloudflare.\nMaintained by Frank Denis.",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        cors: true
      },
      {
        name: "doh-crypto-sx-ipv6",
        endpoint: {
          protocol: "https:",
          host: "doh-ipv6.crypto.sx",
          cors: true
        },
        description: "DNS-over-HTTPS server accessible over IPv6. Anycast, no logs, no censorship, DNSSEC.\nBackend hosted by Scaleway, globally cached via Cloudflare.\nMaintained by Frank Denis.",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        cors: true
      },
      {
        name: "doh-de-blahdns",
        endpoint: {
          protocol: "https:",
          host: "doh-de.blahdns.com",
          cors: true
        },
        description: "Blocks ad and Tracking, no Logging, DNSSEC, Hosted in Germany. By https://blahdns.com/",
        country: "Germany",
        location: {
          lat: 51.2993,
          long: 9.491
        },
        filter: true,
        cors: true
      },
      {
        name: "doh-fi-blahdns",
        endpoint: {
          protocol: "https:",
          host: "doh-fi.blahdns.com",
          cors: true
        },
        description: "Blocks ad and Tracking, no Logging, DNSSEC, Hosted in Finland. By https://blahdns.com/",
        country: "Finland",
        location: {
          lat: 60.1758,
          long: 24.9349
        },
        filter: true,
        cors: true
      },
      {
        name: "doh-ibksturm",
        endpoint: {
          protocol: "https:",
          host: "ibksturm.synology.me"
        },
        description: "DoH & DoT Server, No Logging, No Filters, DNSSEC\nRunning privately by ibksturm in Thurgau, Switzerland"
      },
      {
        name: "doh-jp-blahdns",
        endpoint: {
          protocol: "https:",
          host: "doh-jp.blahdns.com",
          cors: true
        },
        description: "Blocks ad and Tracking, no Logging, DNSSEC, Hosted in Japan. By https://blahdns.com/",
        country: "Japan",
        location: {
          lat: 35.6882,
          long: 139.7532
        },
        filter: true,
        cors: true
      },
      {
        name: "doh.ffmuc.net",
        endpoint: {
          protocol: "https:",
          host: "doh.ffmuc.net"
        },
        description: "An open (non-logging, non-filtering, non-censoring) DoH resolver operated by Freifunk Munich with nodes in DE.\nhttps://ffmuc.net/",
        country: "Germany",
        location: {
          lat: 51.2993,
          long: 9.491
        }
      },
      {
        name: "doh.tiarap.org",
        endpoint: {
          protocol: "https:",
          host: "doh.tiarap.org"
        },
        description: "Non-Logging DNS-over-HTTPS server, cached via Cloudflare.\nFilters out ads, trackers and malware, NO ECS, supports DNSSEC.",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        filter: true
      },
      {
        name: "google",
        endpoint: {
          protocol: "https:",
          host: "dns.google",
          ipv4: "8.8.8.8",
          cors: true
        },
        description: "Google DNS (anycast)",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        log: true,
        cors: true
      },
      {
        name: "hdns",
        endpoint: {
          protocol: "https:",
          host: "query.hdns.io",
          cors: true
        },
        description: "HDNS is a public DNS resolver that supports Handshake domains.\nhttps://www.hdns.io",
        country: "United States",
        location: {
          lat: 37.7771,
          long: -122.406
        },
        cors: true
      },
      {
        name: "he",
        endpoint: {
          protocol: "https:",
          host: "ordns.he.net"
        },
        description: "Hurricane Electric DoH server (anycast)\nUnknown logging policy.",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        log: true
      },
      {
        name: "id-gmail-doh",
        endpoint: {
          protocol: "https:",
          host: "doh.tiar.app"
        },
        description: "Non-Logging DNS-over-HTTPS server located in Singapore.\nFilters out ads, trackers and malware, supports DNSSEC, provided by id-gmail.",
        country: "Singapore",
        location: {
          lat: 1.2929,
          long: 103.8547
        },
        filter: true
      },
      {
        name: "iij",
        endpoint: {
          protocol: "https:",
          host: "public.dns.iij.jp"
        },
        description: "DoH server operated by Internet Initiative Japan in Tokyo.\nhttps://www.iij.ad.jp/",
        country: "Japan",
        location: {
          lat: 35.69,
          long: 139.69
        },
        log: true
      },
      {
        name: "iqdns-doh",
        endpoint: {
          protocol: "https:",
          host: "a.passcloud.xyz"
        },
        description: 'Non-logging DoH service runned by V2EX.com user johnsonwil.\nReturns "no such domain" for anti-Chinese government websites. Supports DNSSEC.\nFor more information: https://www.v2ex.com/t/785666',
        filter: true
      },
      {
        name: "jp.tiar.app-doh",
        endpoint: {
          protocol: "https:",
          host: "jp.tiar.app"
        },
        description: "Non-Logging, Non-Filtering DNS-over-HTTPS server in Japan.\nNo ECS, Support DNSSEC",
        country: "Japan",
        location: {
          lat: 35.6882,
          long: 139.7532
        }
      },
      {
        name: "jp.tiarap.org",
        endpoint: {
          protocol: "https:",
          host: "jp.tiarap.org"
        },
        description: "DNS-over-HTTPS Server. Non-Logging, Non-Filtering, No ECS, Support DNSSEC.\nCached via Cloudflare."
      },
      {
        name: "libredns",
        endpoint: {
          protocol: "https:",
          host: "doh.libredns.gr"
        },
        description: "DoH server in Germany. No logging, but no DNS padding and no DNSSEC support.\nhttps://libredns.gr/",
        country: "Germany",
        location: {
          lat: 51.2993,
          long: 9.491
        }
      },
      {
        name: "nextdns",
        endpoint: {
          protocol: "https:",
          host: "anycsast.dns.nextdns.io"
        },
        description: "NextDNS is a cloud-based private DNS service that gives you full control\nover what is allowed and what is blocked on the Internet.\nDNSSEC, Anycast, Non-logging, NoFilters\nhttps://www.nextdns.io/",
        country: "Netherlands",
        location: {
          lat: 52.3891,
          long: 4.6563
        }
      },
      {
        name: "nextdns-ultralow",
        endpoint: {
          protocol: "https:",
          host: "dns.nextdns.io",
          path: "/dnscrypt-proxy"
        },
        description: 'NextDNS is a cloud-based private DNS service that gives you full control\nover what is allowed and what is blocked on the Internet.\nhttps://www.nextdns.io/\nTo select the server location, the "-ultralow" variant relies on bootstrap servers\ninstead of anycast.'
      },
      {
        name: "njalla-doh",
        endpoint: {
          protocol: "https:",
          host: "dns.njal.la",
          cors: true
        },
        description: "Non-logging DoH server in Sweden operated by Njalla.\nhttps://dns.njal.la/",
        country: "Sweden",
        location: {
          lat: 59.3247,
          long: 18.056
        },
        cors: true
      },
      {
        name: "odoh-cloudflare",
        endpoint: {
          protocol: "https:",
          host: "odoh.cloudflare-dns.com",
          cors: true
        },
        description: "Cloudflare ODoH server.\nhttps://cloudflare.com",
        cors: true
      },
      {
        name: "odoh-crypto-sx",
        endpoint: {
          protocol: "https:",
          host: "odoh.crypto.sx",
          cors: true
        },
        description: "ODoH target server. Anycast, no logs.\nBackend hosted by Scaleway. Maintained by Frank Denis.",
        cors: true
      },
      {
        name: "odoh-id-gmail",
        endpoint: {
          protocol: "https:",
          host: "doh.tiar.app",
          path: "/odoh"
        },
        description: "ODoH target server. Based in Singapore, no logs.\nFilter ads, trackers and malware.",
        filter: true
      },
      {
        name: "odoh-jp.tiar.app",
        endpoint: {
          protocol: "https:",
          host: "jp.tiar.app",
          path: "/odoh"
        },
        description: "ODoH target server. no logs."
      },
      {
        name: "odoh-jp.tiarap.org",
        endpoint: {
          protocol: "https:",
          host: "jp.tiarap.org",
          path: "/odoh"
        },
        description: "ODoH target server via Cloudflare, no logs."
      },
      {
        name: "odoh-resolver4.dns.openinternet.io",
        endpoint: {
          protocol: "https:",
          host: "resolver4.dns.openinternet.io"
        },
        description: "ODoH target server. no logs, no filter, DNSSEC.\nRunning on dedicated hardware colocated at Sonic.net in Santa Rosa, CA in the United States.\nUses Sonic's recusrive DNS servers as upstream resolvers (but is not affiliated with Sonic\nin any way). Provided by https://openinternet.io"
      },
      {
        name: "odoh-tiarap.org",
        endpoint: {
          protocol: "https:",
          host: "doh.tiarap.org",
          path: "/odoh"
        },
        description: "ODoH target server via Cloudflare, no logs.\nFilter ads, trackers and malware.",
        filter: true
      },
      {
        name: "publicarray-au2-doh",
        endpoint: {
          protocol: "https:",
          host: "doh-2.seby.io",
          cors: true
        },
        description: `DNSSEC \u2022 OpenNIC \u2022 Non-logging \u2022 Uncensored - hosted on ovh.com.au
Maintained by publicarray - https://dns.seby.io`,
        country: "Australia",
        location: {
          lat: -33.8591,
          long: 151.2002
        },
        cors: true
      },
      {
        name: "puredns-doh",
        endpoint: {
          protocol: "https:",
          host: "puredns.org",
          ipv4: "146.190.6.13",
          cors: true
        },
        description: "Public uncensored DNS resolver in Singapore - https://puredns.org\n** Only available in Indonesia and Singapore **",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        cors: true
      },
      {
        name: "quad101",
        endpoint: {
          protocol: "https:",
          host: "dns.twnic.tw",
          cors: true
        },
        description: "DNSSEC-aware public resolver by the Taiwan Network Information Center (TWNIC)\nhttps://101.101.101.101/index_en.html",
        cors: true
      },
      {
        name: "quad9-doh-ip4-port443-filter-ecs-pri",
        endpoint: {
          protocol: "https:",
          host: "dns11.quad9.net",
          ipv4: "149.112.112.11"
        },
        description: "Quad9 (anycast) dnssec/no-log/filter/ecs 9.9.9.11 - 149.112.112.11",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        filter: true
      },
      {
        name: "quad9-doh-ip4-port443-filter-pri",
        endpoint: {
          protocol: "https:",
          host: "dns.quad9.net",
          ipv4: "149.112.112.112"
        },
        description: "Quad9 (anycast) dnssec/no-log/filter 9.9.9.9 - 149.112.112.9 - 149.112.112.112",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        filter: true
      },
      {
        name: "quad9-doh-ip4-port443-nofilter-ecs-pri",
        endpoint: {
          protocol: "https:",
          host: "dns12.quad9.net",
          ipv4: "9.9.9.12"
        },
        description: "Quad9 (anycast) no-dnssec/no-log/no-filter/ecs 9.9.9.12 - 149.112.112.12",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        }
      },
      {
        name: "quad9-doh-ip4-port443-nofilter-pri",
        endpoint: {
          protocol: "https:",
          host: "dns10.quad9.net",
          ipv4: "149.112.112.10"
        },
        description: "Quad9 (anycast) no-dnssec/no-log/no-filter 9.9.9.10 - 149.112.112.10",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        }
      },
      {
        name: "quad9-doh-ip6-port5053-filter-pri",
        endpoint: {
          protocol: "https:",
          host: "dns9.quad9.net"
        },
        description: "Quad9 (anycast) dnssec/no-log/filter 2620:fe::fe - 2620:fe::9 - 2620:fe::fe:9",
        country: "United States",
        location: {
          lat: 37.751,
          long: -97.822
        },
        filter: true
      },
      {
        name: "safesurfer-doh",
        endpoint: {
          protocol: "https:",
          host: "doh.safesurfer.io"
        },
        description: "Family safety focused blocklist for over 2 million adult sites, as well as phishing and malware and more.\nFree to use, paid for customizing blocking for more categories+sites and viewing usage at my.safesurfer.io. Logs taken for viewing\nusage, data never sold - https://safesurfer.io",
        filter: true,
        log: true
      },
      {
        name: "sth-ads-doh-se",
        endpoint: {
          protocol: "https:",
          host: "dnsse-noads.alekberg.net"
        },
        description: "Resolver in Stockholm, Sweden. DoH server. Non-logging, remove ads and malware, DNSSEC.",
        country: "Bulgaria",
        location: {
          lat: 42.696,
          long: 23.332
        },
        filter: true
      },
      {
        name: "sth-doh-se",
        endpoint: {
          protocol: "https:",
          host: "dnsse.alekberg.net"
        },
        description: "Resolver in Stockholm, Sweden. DoH server. Non-logging, non-filtering, DNSSEC.",
        country: "Bulgaria",
        location: {
          lat: 42.696,
          long: 23.332
        }
      },
      {
        name: "switch",
        endpoint: {
          protocol: "https:",
          host: "dns.switch.ch"
        },
        description: "Public DoH service provided by SWITCH in Switzerland\nhttps://www.switch.ch\nProvides protection against malware, but does not block ads.",
        filter: true
      },
      {
        name: "uncensoreddns-dk-ipv4",
        endpoint: {
          protocol: "https:",
          host: "unicast.uncensoreddns.org"
        },
        description: "Also known as censurfridns.\nDoH, no logs, no filter, DNSSEC, unicast hosted in Denmark - https://blog.uncensoreddns.org",
        country: "Denmark",
        location: {
          lat: 55.7123,
          long: 12.0564
        }
      },
      {
        name: "uncensoreddns-ipv4",
        endpoint: {
          protocol: "https:",
          host: "anycast.uncensoreddns.org"
        },
        description: "Also known as censurfridns.\nDoH, no logs, no filter, DNSSEC, anycast - https://blog.uncensoreddns.org",
        country: "Denmark",
        location: {
          lat: 55.7123,
          long: 12.0564
        }
      },
      {
        name: "v.dnscrypt.uk-doh-ipv4",
        endpoint: {
          protocol: "https:",
          host: "v.dnscrypt.uk"
        },
        description: "DoH, no logs, uncensored, DNSSEC. Hosted in London UK on Digital Ocean\nhttps://www.dnscrypt.uk",
        country: "United Kingdom",
        location: {
          lat: 51.4964,
          long: -0.1224
        }
      }
    ],
    time: 1654187067783
  };
  var backup = processResolvers(resolvers);
  var UPDATE_URL = new URL$1("https://martinheidegger.github.io/dns-query/resolvers.json");

  class Wellknown {
    constructor(opts) {
      this.opts = Object.assign({
        timeout: 5000,
        update: true,
        updateURL: UPDATE_URL,
        persist: false,
        localStoragePrefix: "dnsquery_",
        maxAge: 300000
      }, opts);
      this._dataP = null;
    }
    _data(force, outdated) {
      if (!force && this._dataP !== null) {
        return this._dataP.then((res) => {
          if (res.time < Date.now() - this.opts.maxAge) {
            return this._data(true, res);
          }
          return res;
        });
      }
      this._dataP = !this.opts.update ? Promise.resolve(backup) : loadJSON(this.opts.updateURL, this.opts.persist ? {
        name: "resolvers.json",
        localStoragePrefix: this.opts.localStoragePrefix,
        maxTime: Date.now() - this.opts.maxAge
      } : null, this.opts.timeout).then((res) => processResolvers({
        data: res.data.resolvers,
        time: res.time
      })).catch(() => outdated || backup);
      return this._dataP;
    }
    data() {
      return this._data(false).then((data) => data.data);
    }
    endpoints(input) {
      if (input === null || input === undefined) {
        return this.data().then((data) => data.endpoints);
      }
      if (input === "doh") {
        input = filterDoh;
      }
      if (input === "dns") {
        input = filterDns;
      }
      if (typeof input === "function") {
        return this.data().then((data) => data.endpoints.filter(input));
      }
      if (typeof input === "string" || typeof input[Symbol.iterator] !== "function") {
        return Promise.reject(new Error(`Endpoints (${input}) needs to be iterable (array).`));
      }
      input = Array.from(input).filter(Boolean);
      if (input.findIndex(isNameString) === -1) {
        try {
          return Promise.resolve(input.map(toEndpoint));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      return this.data().then((data) => input.map((entry) => {
        if (isNameString(entry)) {
          const found = data.endpointByName[entry.substring(1)];
          if (!found) {
            throw new Error(`Endpoint ${entry} is not known.`);
          }
          return found;
        }
        return toEndpoint(entry);
      }));
    }
  }
  var wellknown = new Wellknown;
  var log$u = debug("waku:dns-over-https");

  class DnsOverHttps {
    static async create(endpoints, retries) {
      const _endpoints = endpoints ?? await wellknown.endpoints("doh");
      return new DnsOverHttps(_endpoints, retries);
    }
    constructor(endpoints, retries = 3) {
      this.endpoints = endpoints;
      this.retries = retries;
    }
    async resolveTXT(domain) {
      let answers;
      try {
        const res = await query({
          question: { type: "TXT", name: domain }
        }, {
          endpoints: this.endpoints,
          retries: this.retries
        });
        answers = res.answers;
      } catch (error) {
        log$u("query failed: ", error);
        throw new Error("DNS query failed");
      }
      if (!answers)
        throw new Error(`Could not resolve ${domain}`);
      const data = answers.map((a) => a.data);
      const result = [];
      data.forEach((d) => {
        if (typeof d === "string") {
          result.push(d);
        } else if (Array.isArray(d)) {
          d.forEach((sd) => {
            if (typeof sd === "string") {
              result.push(sd);
            } else {
              result.push(bytesToUtf8(sd));
            }
          });
        } else {
          result.push(bytesToUtf8(d));
        }
      });
      return result;
    }
  }
  var base32$6 = { exports: {} };
  (function(module2) {
    (function() {
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = commonjsGlobal;
      }
      var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && true && module2.exports;
      var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
      var BASE32_DECODE_CHAR = {
        A: 0,
        B: 1,
        C: 2,
        D: 3,
        E: 4,
        F: 5,
        G: 6,
        H: 7,
        I: 8,
        J: 9,
        K: 10,
        L: 11,
        M: 12,
        N: 13,
        O: 14,
        P: 15,
        Q: 16,
        R: 17,
        S: 18,
        T: 19,
        U: 20,
        V: 21,
        W: 22,
        X: 23,
        Y: 24,
        Z: 25,
        "2": 26,
        "3": 27,
        "4": 28,
        "5": 29,
        "6": 30,
        "7": 31
      };
      var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
      var throwInvalidUtf8 = function(position, partial) {
        if (partial.length > 10) {
          partial = "..." + partial.substr(-10);
        }
        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
        err.position = position;
        throw err;
      };
      var toUtf8String = function(bytes2) {
        var str = "", length2 = bytes2.length, i = 0, followingChars = 0, b, c;
        while (i < length2) {
          b = bytes2[i++];
          if (b <= 127) {
            str += String.fromCharCode(b);
            continue;
          } else if (b > 191 && b <= 223) {
            c = b & 31;
            followingChars = 1;
          } else if (b <= 239) {
            c = b & 15;
            followingChars = 2;
          } else if (b <= 247) {
            c = b & 7;
            followingChars = 3;
          } else {
            throwInvalidUtf8(i, str);
          }
          for (var j = 0;j < followingChars; ++j) {
            b = bytes2[i++];
            if (b < 128 || b > 191) {
              throwInvalidUtf8(i, str);
            }
            c <<= 6;
            c += b & 63;
          }
          if (c >= 55296 && c <= 57343) {
            throwInvalidUtf8(i, str);
          }
          if (c > 1114111) {
            throwInvalidUtf8(i, str);
          }
          if (c <= 65535) {
            str += String.fromCharCode(c);
          } else {
            c -= 65536;
            str += String.fromCharCode((c >> 10) + 55296);
            str += String.fromCharCode((c & 1023) + 56320);
          }
        }
        return str;
      };
      var decodeAsBytes = function(base32Str) {
        if (base32Str === "") {
          return [];
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        base32Str = base32Str.replace(/=/g, "");
        var v1, v2, v3, v42, v5, v62, v7, v8, bytes2 = [], index2 = 0, length2 = base32Str.length;
        for (var i = 0, count = length2 >> 3 << 3;i < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v62 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes2[index2++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes2[index2++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
          bytes2[index2++] = (v42 << 4 | v5 >>> 1) & 255;
          bytes2[index2++] = (v5 << 7 | v62 << 2 | v7 >>> 3) & 255;
          bytes2[index2++] = (v7 << 5 | v8) & 255;
        }
        var remain = length2 - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes2[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes2[index2++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes2[index2++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes2[index2++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes2[index2++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
          bytes2[index2++] = (v42 << 4 | v5 >>> 1) & 255;
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v62 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes2[index2++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes2[index2++] = (v2 << 6 | v3 << 1 | v42 >>> 4) & 255;
          bytes2[index2++] = (v42 << 4 | v5 >>> 1) & 255;
          bytes2[index2++] = (v5 << 7 | v62 << 2 | v7 >>> 3) & 255;
        }
        return bytes2;
      };
      var encodeAscii = function(str) {
        var v1, v2, v3, v42, v5, base32Str = "", length2 = str.length;
        for (var i = 0, count = parseInt(length2 / 5) * 5;i < count; ) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i++);
          v42 = str.charCodeAt(i++);
          v5 = str.charCodeAt(i++);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length2 - count;
        if (remain === 1) {
          v1 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i++);
          v42 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encodeUtf8 = function(str) {
        var v1, v2, v3, v42, v5, code2, end = false, base32Str = "", index2 = 0, i, start = 0, length2 = str.length;
        if (str === "") {
          return base32Str;
        }
        do {
          blocks[0] = blocks[5];
          blocks[1] = blocks[6];
          blocks[2] = blocks[7];
          for (i = start;index2 < length2 && i < 5; ++index2) {
            code2 = str.charCodeAt(index2);
            if (code2 < 128) {
              blocks[i++] = code2;
            } else if (code2 < 2048) {
              blocks[i++] = 192 | code2 >> 6;
              blocks[i++] = 128 | code2 & 63;
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i++] = 224 | code2 >> 12;
              blocks[i++] = 128 | code2 >> 6 & 63;
              blocks[i++] = 128 | code2 & 63;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++index2) & 1023);
              blocks[i++] = 240 | code2 >> 18;
              blocks[i++] = 128 | code2 >> 12 & 63;
              blocks[i++] = 128 | code2 >> 6 & 63;
              blocks[i++] = 128 | code2 & 63;
            }
          }
          start = i - 5;
          if (index2 === length2) {
            ++index2;
          }
          if (index2 > length2 && i < 6) {
            end = true;
          }
          v1 = blocks[0];
          if (i > 4) {
            v2 = blocks[1];
            v3 = blocks[2];
            v42 = blocks[3];
            v5 = blocks[4];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          } else if (i === 1) {
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (i === 2) {
            v2 = blocks[1];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (i === 3) {
            v2 = blocks[1];
            v3 = blocks[2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else {
            v2 = blocks[1];
            v3 = blocks[2];
            v42 = blocks[3];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
          }
        } while (!end);
        return base32Str;
      };
      var encodeBytes = function(bytes2) {
        var v1, v2, v3, v42, v5, base32Str = "", length2 = bytes2.length;
        for (var i = 0, count = parseInt(length2 / 5) * 5;i < count; ) {
          v1 = bytes2[i++];
          v2 = bytes2[i++];
          v3 = bytes2[i++];
          v42 = bytes2[i++];
          v5 = bytes2[i++];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length2 - count;
        if (remain === 1) {
          v1 = bytes2[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = bytes2[i++];
          v2 = bytes2[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = bytes2[i++];
          v2 = bytes2[i++];
          v3 = bytes2[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = bytes2[i++];
          v2 = bytes2[i++];
          v3 = bytes2[i++];
          v42 = bytes2[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encode3 = function(input, asciiOnly) {
        var notString = typeof input !== "string";
        if (notString && input.constructor === ArrayBuffer) {
          input = new Uint8Array(input);
        }
        if (notString) {
          return encodeBytes(input);
        } else if (asciiOnly) {
          return encodeAscii(input);
        } else {
          return encodeUtf8(input);
        }
      };
      var decode3 = function(base32Str, asciiOnly) {
        if (!asciiOnly) {
          return toUtf8String(decodeAsBytes(base32Str));
        }
        if (base32Str === "") {
          return "";
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        var v1, v2, v3, v42, v5, v62, v7, v8, str = "", length2 = base32Str.indexOf("=");
        if (length2 === -1) {
          length2 = base32Str.length;
        }
        for (var i = 0, count = length2 >> 3 << 3;i < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v62 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v62 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
        }
        var remain = length2 - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255);
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255);
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v62 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v62 << 2 | v7 >>> 3) & 255);
        }
        return str;
      };
      var exports2 = {
        encode: encode3,
        decode: decode3
      };
      decode3.asBytes = decodeAsBytes;
      if (COMMON_JS) {
        module2.exports = exports2;
      } else {
        root.base32 = exports2;
      }
    })();
  })(base32$6);
  var base32Exports = base32$6.exports;
  var base32$5 = getDefaultExportFromCjs(base32Exports);

  class ENRTree {
    static parseAndVerifyRoot(root, publicKey) {
      if (!root.startsWith(this.ROOT_PREFIX))
        throw new Error(`ENRTree root entry must start with '${this.ROOT_PREFIX}'`);
      const rootValues = ENRTree.parseRootValues(root);
      const decodedPublicKey = base32$5.decode.asBytes(publicKey);
      const signedComponent = root.split(" sig")[0];
      const signedComponentBuffer = utf8ToBytes$4(signedComponent);
      const signatureBuffer = fromString$3(rootValues.signature, "base64url").slice(0, 64);
      const isVerified = verifySignature(signatureBuffer, keccak256(signedComponentBuffer), new Uint8Array(decodedPublicKey));
      if (!isVerified)
        throw new Error("Unable to verify ENRTree root signature");
      return rootValues.eRoot;
    }
    static parseRootValues(txt) {
      const matches = txt.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);
      if (!Array.isArray(matches))
        throw new Error("Could not parse ENRTree root entry");
      matches.shift();
      const [eRoot, lRoot, seq, signature] = matches;
      if (!eRoot)
        throw new Error("Could not parse 'e' value from ENRTree root entry");
      if (!lRoot)
        throw new Error("Could not parse 'l' value from ENRTree root entry");
      if (!seq)
        throw new Error("Could not parse 'seq' value from ENRTree root entry");
      if (!signature)
        throw new Error("Could not parse 'sig' value from ENRTree root entry");
      return { eRoot, lRoot, seq: Number(seq), signature };
    }
    static parseTree(tree) {
      if (!tree.startsWith(this.TREE_PREFIX))
        throw new Error(`ENRTree tree entry must start with '${this.TREE_PREFIX}'`);
      const matches = tree.match(/^enrtree:\/\/([^@]+)@(.+)$/);
      if (!Array.isArray(matches))
        throw new Error("Could not parse ENRTree tree entry");
      matches.shift();
      const [publicKey, domain] = matches;
      if (!publicKey)
        throw new Error("Could not parse public key from ENRTree tree entry");
      if (!domain)
        throw new Error("Could not parse domain from ENRTree tree entry");
      return { publicKey, domain };
    }
    static parseBranch(branch) {
      if (!branch.startsWith(this.BRANCH_PREFIX))
        throw new Error(`ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);
      return branch.split(this.BRANCH_PREFIX)[1].split(",");
    }
  }
  ENRTree.RECORD_PREFIX = ENR.RECORD_PREFIX;
  ENRTree.TREE_PREFIX = "enrtree:";
  ENRTree.BRANCH_PREFIX = "enrtree-branch:";
  ENRTree.ROOT_PREFIX = "enrtree-root:";
  var log$t = debug("waku:discovery:fetch_nodes");
  var log$s = debug("waku:discovery:dns");

  class DnsNodeDiscovery {
    static async dnsOverHttp(dnsClient) {
      if (!dnsClient) {
        dnsClient = await DnsOverHttps.create();
      }
      return new DnsNodeDiscovery(dnsClient);
    }
    async getPeers(enrTreeUrls, wantedNodeCapabilityCount) {
      const networkIndex = Math.floor(Math.random() * enrTreeUrls.length);
      const { publicKey, domain } = ENRTree.parseTree(enrTreeUrls[networkIndex]);
      const context = {
        domain,
        publicKey,
        visits: {}
      };
      const peers = await fetchNodesUntilCapabilitiesFulfilled(wantedNodeCapabilityCount, this._errorTolerance, () => this._search(domain, context));
      log$s("retrieved peers: ", peers.map((peer) => {
        return {
          id: peer.peerId?.toString(),
          multiaddrs: peer.multiaddrs?.map((ma) => ma.toString())
        };
      }));
      return peers;
    }
    constructor(dns) {
      this._errorTolerance = 10;
      this._DNSTreeCache = {};
      this.dns = dns;
    }
    async* getNextPeer(enrTreeUrls, wantedNodeCapabilityCount) {
      const networkIndex = Math.floor(Math.random() * enrTreeUrls.length);
      const { publicKey, domain } = ENRTree.parseTree(enrTreeUrls[networkIndex]);
      const context = {
        domain,
        publicKey,
        visits: {}
      };
      for await (const peer of yieldNodesUntilCapabilitiesFulfilled(wantedNodeCapabilityCount, this._errorTolerance, () => this._search(domain, context))) {
        yield peer;
      }
    }
    async _search(subdomain, context) {
      try {
        const entry = await this._getTXTRecord(subdomain, context);
        context.visits[subdomain] = true;
        let next;
        let branches;
        const entryType = getEntryType(entry);
        try {
          switch (entryType) {
            case ENRTree.ROOT_PREFIX:
              next = ENRTree.parseAndVerifyRoot(entry, context.publicKey);
              return await this._search(next, context);
            case ENRTree.BRANCH_PREFIX:
              branches = ENRTree.parseBranch(entry);
              next = selectRandomPath(branches, context);
              return await this._search(next, context);
            case ENRTree.RECORD_PREFIX:
              return EnrDecoder.fromString(entry);
            default:
              return null;
          }
        } catch (error) {
          log$s(`Failed to search DNS tree ${entryType} at subdomain ${subdomain}: ${error}`);
          return null;
        }
      } catch (error) {
        log$s(`Failed to retrieve TXT record at subdomain ${subdomain}: ${error}`);
        return null;
      }
    }
    async _getTXTRecord(subdomain, context) {
      if (this._DNSTreeCache[subdomain]) {
        return this._DNSTreeCache[subdomain];
      }
      const location = subdomain !== context.domain ? `${subdomain}.${context.domain}` : context.domain;
      const response = await this.dns.resolveTXT(location);
      if (!response.length)
        throw new Error("Received empty result array while fetching TXT record");
      if (!response[0].length)
        throw new Error("Received empty TXT record");
      const result = response.join("");
      this._DNSTreeCache[subdomain] = result;
      return result;
    }
  }
  var log$r = debug("waku:peer-discovery-dns");

  class PeerDiscoveryDns extends EventEmitter$2 {
    constructor(components, options) {
      super();
      this._started = false;
      this._components = components;
      this._options = options;
      const { enrUrls } = options;
      log$r("Use following EIP-1459 ENR Tree URLs: ", enrUrls);
    }
    async start() {
      log$r("Starting peer discovery via dns");
      this._started = true;
      if (this.nextPeer === undefined) {
        let { enrUrls } = this._options;
        if (!Array.isArray(enrUrls))
          enrUrls = [enrUrls];
        const { wantedNodeCapabilityCount } = this._options;
        const dns = await DnsNodeDiscovery.dnsOverHttp();
        this.nextPeer = dns.getNextPeer.bind(dns, enrUrls, wantedNodeCapabilityCount);
      }
      for await (const peerEnr of this.nextPeer()) {
        if (!this._started) {
          return;
        }
        const peerInfo = peerEnr.peerInfo;
        if (!peerInfo) {
          continue;
        }
        const tagsToUpdate = {
          tags: {
            [DEFAULT_BOOTSTRAP_TAG_NAME]: {
              value: this._options.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
              ttl: this._options.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
            }
          }
        };
        let isPeerChanged = false;
        const isPeerExists = await this._components.peerStore.has(peerInfo.id);
        if (isPeerExists) {
          const peer = await this._components.peerStore.get(peerInfo.id);
          const hasBootstrapTag = peer.tags.has(DEFAULT_BOOTSTRAP_TAG_NAME);
          if (!hasBootstrapTag) {
            isPeerChanged = true;
            await this._components.peerStore.merge(peerInfo.id, tagsToUpdate);
          }
        } else {
          isPeerChanged = true;
          await this._components.peerStore.save(peerInfo.id, tagsToUpdate);
        }
        if (isPeerChanged) {
          this.dispatchEvent(new CustomEvent("peer", { detail: peerInfo }));
        }
      }
    }
    stop() {
      this._started = false;
    }
    get [peerDiscovery]() {
      return true;
    }
    get [Symbol.toStringTag]() {
      return "@waku/bootstrap";
    }
  }

  class PeerExchangeRPC {
    constructor(proto) {
      this.proto = proto;
    }
    static createRequest(params) {
      const { numPeers } = params;
      return new PeerExchangeRPC({
        query: {
          numPeers
        },
        response: undefined
      });
    }
    encode() {
      return PeerExchangeRPC$1.encode(this.proto);
    }
    static decode(bytes2) {
      const res = PeerExchangeRPC$1.decode(bytes2);
      return new PeerExchangeRPC(res);
    }
    get query() {
      return this.proto.query;
    }
    get response() {
      return this.proto.response;
    }
  }
  var PeerExchangeCodec = "/vac/waku/peer-exchange/2.0.0-alpha1";
  var log$q = debug("waku:peer-exchange");

  class WakuPeerExchange extends BaseProtocol {
    constructor(components) {
      super(PeerExchangeCodec, components);
    }
    async query(params) {
      const { numPeers } = params;
      const rpcQuery = PeerExchangeRPC.createRequest({
        numPeers: BigInt(numPeers)
      });
      const peer = await this.getPeer(params.peerId);
      const stream = await this.getStream(peer);
      const res = await pipe([rpcQuery.encode()], encode$B, stream, decode$v, async (source2) => await all$1(source2));
      try {
        const bytes2 = new Uint8ArrayList;
        res.forEach((chunk) => {
          bytes2.append(chunk);
        });
        const { response } = PeerExchangeRPC.decode(bytes2);
        if (!response) {
          log$q("PeerExchangeRPC message did not contains a `response` field");
          return;
        }
        return Promise.all(response.peerInfos.map((peerInfo) => peerInfo.enr).filter(isDefined).map(async (enr) => {
          return { ENR: await EnrDecoder.fromRLP(enr) };
        }));
      } catch (err) {
        log$q("Failed to decode push reply", err);
        return;
      }
    }
  }
  var log$p = debug("waku:peer-exchange-discovery");
  var DEFAULT_PEER_EXCHANGE_REQUEST_NODES = 10;
  var DEFAULT_PEER_EXCHANGE_QUERY_INTERVAL_MS = 10 * 1000;
  var DEFAULT_MAX_RETRIES = 3;
  var DEFAULT_PEER_EXCHANGE_TAG_NAME = Tags.PEER_EXCHANGE;
  var DEFAULT_PEER_EXCHANGE_TAG_VALUE = 50;
  var DEFAULT_PEER_EXCHANGE_TAG_TTL = 1e8;

  class PeerExchangeDiscovery extends EventEmitter$2 {
    constructor(components, options = {}) {
      super();
      this.queryingPeers = new Set;
      this.queryAttempts = new Map;
      this.handleDiscoveredPeer = (event) => {
        const { protocols, peerId } = event.detail;
        if (!protocols.includes(PeerExchangeCodec) || this.queryingPeers.has(peerId.toString()))
          return;
        this.queryingPeers.add(peerId.toString());
        this.startRecurringQueries(peerId).catch((error) => log$p(`Error querying peer ${error}`));
      };
      this.startRecurringQueries = async (peerId) => {
        const peerIdStr = peerId.toString();
        const { queryInterval = DEFAULT_PEER_EXCHANGE_QUERY_INTERVAL_MS, maxRetries = DEFAULT_MAX_RETRIES } = this.options;
        log$p(`Querying peer: ${peerIdStr} (attempt ${this.queryAttempts.get(peerIdStr) ?? 1})`);
        await this.query(peerId);
        const currentAttempt = this.queryAttempts.get(peerIdStr) ?? 1;
        if (currentAttempt > maxRetries) {
          this.abortQueriesForPeer(peerIdStr);
          return;
        }
        setTimeout(() => {
          this.queryAttempts.set(peerIdStr, currentAttempt + 1);
          this.startRecurringQueries(peerId).catch((error) => {
            log$p(`Error in startRecurringQueries: ${error}`);
          });
        }, queryInterval * currentAttempt);
      };
      this.components = components;
      this.peerExchange = new WakuPeerExchange(components);
      this.options = options;
      this.isStarted = false;
    }
    start() {
      if (this.isStarted) {
        return;
      }
      log$p("Starting peer exchange node discovery, discovering peers");
      this.components.events.addEventListener("peer:identify", this.handleDiscoveredPeer);
    }
    stop() {
      if (!this.isStarted)
        return;
      log$p("Stopping peer exchange node discovery");
      this.isStarted = false;
      this.queryingPeers.clear();
      this.components.events.removeEventListener("peer:identify", this.handleDiscoveredPeer);
    }
    get [peerDiscovery]() {
      return true;
    }
    get [Symbol.toStringTag]() {
      return "@waku/peer-exchange";
    }
    async query(peerId) {
      const peerInfos = await this.peerExchange.query({
        numPeers: DEFAULT_PEER_EXCHANGE_REQUEST_NODES,
        peerId
      });
      if (!peerInfos) {
        log$p("Peer exchange query failed, no peer info returned");
        return;
      }
      for (const _peerInfo of peerInfos) {
        const { ENR: ENR2 } = _peerInfo;
        if (!ENR2) {
          log$p("No ENR in peerInfo object, skipping");
          continue;
        }
        const { peerId: peerId2, peerInfo } = ENR2;
        if (!peerId2 || !peerInfo) {
          continue;
        }
        const hasPeer = await this.components.peerStore.has(peerId2);
        if (hasPeer) {
          continue;
        }
        await this.components.peerStore.save(peerId2, {
          tags: {
            [DEFAULT_PEER_EXCHANGE_TAG_NAME]: {
              value: this.options.tagValue ?? DEFAULT_PEER_EXCHANGE_TAG_VALUE,
              ttl: this.options.tagTTL ?? DEFAULT_PEER_EXCHANGE_TAG_TTL
            }
          }
        });
        log$p(`Discovered peer: ${peerId2.toString()}`);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: {
            id: peerId2,
            protocols: [],
            multiaddrs: peerInfo.multiaddrs
          }
        }));
      }
    }
    abortQueriesForPeer(peerIdStr) {
      log$p(`Aborting queries for peer: ${peerIdStr}`);
      this.queryingPeers.delete(peerIdStr);
      this.queryAttempts.delete(peerIdStr);
    }
  }
  var src$7 = base$7;
  var _brrp__multiformats_scope_baseX$7 = src$7;
  var coerce$7 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$7 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$7 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$7(this, decoder);
    }
  };
  var ComposedDecoder$7 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$7(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$7 = (left2, right2) => new ComposedDecoder$7({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$7 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$7(name2, prefix, baseEncode);
      this.decoder = new Decoder$7(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$c = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$7(name2, prefix, encode3, decode3);
  var baseX$7 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$7(alphabet2, name2);
    return from$c({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$7(decode3(text))
    });
  };
  var decode$c = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$i = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$7 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$c({
      prefix,
      name: name2,
      encode(input) {
        return encode$i(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$c(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base32$4 = rfc4648$7({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  rfc4648$7({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  rfc4648$7({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  rfc4648$7({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  rfc4648$7({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  rfc4648$7({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  rfc4648$7({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  rfc4648$7({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  rfc4648$7({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base58btc$6 = baseX$7({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$7({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base64$6 = rfc4648$7({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$7({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$7({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$7({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  debug.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc$6.baseEncode(v);
  };
  debug.formatters.t = (v) => {
    return v == null ? "undefined" : base32$4.baseEncode(v);
  };
  debug.formatters.m = (v) => {
    return v == null ? "undefined" : base64$6.baseEncode(v);
  };
  debug.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };

  class MessageCache {
    constructor(gossip, historyCapacity, msgIdToStrFn) {
      this.msgs = new Map;
      this.history = [];
      this.notValidatedCount = 0;
      this.gossip = gossip;
      this.msgIdToStrFn = msgIdToStrFn;
      for (let i = 0;i < historyCapacity; i++) {
        this.history[i] = [];
      }
    }
    get size() {
      return this.msgs.size;
    }
    put(messageId, msg, validated = false) {
      const { msgIdStr } = messageId;
      if (this.msgs.has(msgIdStr)) {
        return false;
      }
      this.msgs.set(msgIdStr, {
        message: msg,
        validated,
        originatingPeers: new Set,
        iwantCounts: new Map
      });
      this.history[0].push({ ...messageId, topic: msg.topic });
      if (!validated) {
        this.notValidatedCount++;
      }
      return true;
    }
    observeDuplicate(msgId2, fromPeerIdStr) {
      const entry = this.msgs.get(msgId2);
      if (entry && !entry.validated) {
        entry.originatingPeers.add(fromPeerIdStr);
      }
    }
    get(msgId2) {
      return this.msgs.get(this.msgIdToStrFn(msgId2))?.message;
    }
    getWithIWantCount(msgIdStr, p) {
      const msg = this.msgs.get(msgIdStr);
      if (!msg) {
        return null;
      }
      const count = (msg.iwantCounts.get(p) ?? 0) + 1;
      msg.iwantCounts.set(p, count);
      return { msg: msg.message, count };
    }
    getGossipIDs(topics) {
      const msgIdsByTopic = new Map;
      for (let i = 0;i < this.gossip; i++) {
        this.history[i].forEach((entry) => {
          const msg = this.msgs.get(entry.msgIdStr);
          if (msg && msg.validated && topics.has(entry.topic)) {
            let msgIds = msgIdsByTopic.get(entry.topic);
            if (!msgIds) {
              msgIds = [];
              msgIdsByTopic.set(entry.topic, msgIds);
            }
            msgIds.push(entry.msgId);
          }
        });
      }
      return msgIdsByTopic;
    }
    validate(msgId2) {
      const entry = this.msgs.get(msgId2);
      if (!entry) {
        return null;
      }
      if (!entry.validated) {
        this.notValidatedCount--;
      }
      const { message: message2, originatingPeers } = entry;
      entry.validated = true;
      entry.originatingPeers = new Set;
      return { message: message2, originatingPeers };
    }
    shift() {
      const lastCacheEntries = this.history[this.history.length - 1];
      lastCacheEntries.forEach((cacheEntry) => {
        const entry = this.msgs.get(cacheEntry.msgIdStr);
        if (entry) {
          this.msgs.delete(cacheEntry.msgIdStr);
          if (!entry.validated) {
            this.notValidatedCount--;
          }
        }
      });
      this.history.pop();
      this.history.unshift([]);
    }
    remove(msgId2) {
      const entry = this.msgs.get(msgId2);
      if (!entry) {
        return null;
      }
      this.msgs.delete(msgId2);
      return entry;
    }
  }
  var rpc$1 = { exports: {} };
  var indexMinimal = {};
  var rpc = {};
  var service = Service;
  var util = requireMinimal();
  (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
    if (!request2)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return;
    }
    try {
      return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(), function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      });
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
  (function(exports2) {
    var rpc2 = exports2;
    rpc2.Service = service;
  })(rpc);
  var roots = {};
  (function(exports2) {
    var protobuf2 = exports2;
    protobuf2.build = "minimal";
    protobuf2.Writer = writer$1;
    protobuf2.BufferWriter = writer_buffer;
    protobuf2.Reader = reader$2;
    protobuf2.BufferReader = reader_buffer;
    protobuf2.util = requireMinimal();
    protobuf2.rpc = rpc;
    protobuf2.roots = roots;
    protobuf2.configure = configure2;
    function configure2() {
      protobuf2.util._configure();
      protobuf2.Writer._configure(protobuf2.BufferWriter);
      protobuf2.Reader._configure(protobuf2.BufferReader);
    }
    configure2();
  })(indexMinimal);
  var minimal = indexMinimal;
  var protobuf = getDefaultExportFromCjs(minimal);
  (function(module2) {
    (function(global2, factory) {
      if (typeof commonjsRequire === "function" && true && module2 && module2.exports)
        module2.exports = factory(minimal);
    })(commonjsGlobal, function($protobuf) {
      var { Reader: $Reader, Writer: $Writer, util: $util } = $protobuf;
      var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
      $root.RPC = function() {
        function RPC2(p) {
          this.subscriptions = [];
          this.messages = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        RPC2.prototype.subscriptions = $util.emptyArray;
        RPC2.prototype.messages = $util.emptyArray;
        RPC2.prototype.control = null;
        var $oneOfFields;
        Object.defineProperty(RPC2.prototype, "_control", {
          get: $util.oneOfGetter($oneOfFields = ["control"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        RPC2.encode = function encode(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.subscriptions != null && m.subscriptions.length) {
            for (var i = 0;i < m.subscriptions.length; ++i)
              $root.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();
          }
          if (m.messages != null && m.messages.length) {
            for (var i = 0;i < m.messages.length; ++i)
              $root.RPC.Message.encode(m.messages[i], w.uint32(18).fork()).ldelim();
          }
          if (m.control != null && Object.hasOwnProperty.call(m, "control"))
            $root.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();
          return w;
        };
        RPC2.decode = function decode(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC;
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.subscriptions && m.subscriptions.length))
                  m.subscriptions = [];
                m.subscriptions.push($root.RPC.SubOpts.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m.messages && m.messages.length))
                  m.messages = [];
                m.messages.push($root.RPC.Message.decode(r, r.uint32()));
                break;
              case 3:
                m.control = $root.RPC.ControlMessage.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        RPC2.fromObject = function fromObject(d) {
          if (d instanceof $root.RPC)
            return d;
          var m = new $root.RPC;
          if (d.subscriptions) {
            if (!Array.isArray(d.subscriptions))
              throw TypeError(".RPC.subscriptions: array expected");
            m.subscriptions = [];
            for (var i = 0;i < d.subscriptions.length; ++i) {
              if (typeof d.subscriptions[i] !== "object")
                throw TypeError(".RPC.subscriptions: object expected");
              m.subscriptions[i] = $root.RPC.SubOpts.fromObject(d.subscriptions[i]);
            }
          }
          if (d.messages) {
            if (!Array.isArray(d.messages))
              throw TypeError(".RPC.messages: array expected");
            m.messages = [];
            for (var i = 0;i < d.messages.length; ++i) {
              if (typeof d.messages[i] !== "object")
                throw TypeError(".RPC.messages: object expected");
              m.messages[i] = $root.RPC.Message.fromObject(d.messages[i]);
            }
          }
          if (d.control != null) {
            if (typeof d.control !== "object")
              throw TypeError(".RPC.control: object expected");
            m.control = $root.RPC.ControlMessage.fromObject(d.control);
          }
          return m;
        };
        RPC2.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.subscriptions = [];
            d.messages = [];
          }
          if (m.subscriptions && m.subscriptions.length) {
            d.subscriptions = [];
            for (var j = 0;j < m.subscriptions.length; ++j) {
              d.subscriptions[j] = $root.RPC.SubOpts.toObject(m.subscriptions[j], o);
            }
          }
          if (m.messages && m.messages.length) {
            d.messages = [];
            for (var j = 0;j < m.messages.length; ++j) {
              d.messages[j] = $root.RPC.Message.toObject(m.messages[j], o);
            }
          }
          if (m.control != null && m.hasOwnProperty("control")) {
            d.control = $root.RPC.ControlMessage.toObject(m.control, o);
            if (o.oneofs)
              d._control = "control";
          }
          return d;
        };
        RPC2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        RPC2.SubOpts = function() {
          function SubOpts(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          SubOpts.prototype.subscribe = null;
          SubOpts.prototype.topic = null;
          var $oneOfFields2;
          Object.defineProperty(SubOpts.prototype, "_subscribe", {
            get: $util.oneOfGetter($oneOfFields2 = ["subscribe"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(SubOpts.prototype, "_topic", {
            get: $util.oneOfGetter($oneOfFields2 = ["topic"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          SubOpts.encode = function encode(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
              w.uint32(8).bool(m.subscribe);
            if (m.topic != null && Object.hasOwnProperty.call(m, "topic"))
              w.uint32(18).string(m.topic);
            return w;
          };
          SubOpts.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.SubOpts;
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.subscribe = r.bool();
                  break;
                case 2:
                  m.topic = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          SubOpts.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.SubOpts)
              return d;
            var m = new $root.RPC.SubOpts;
            if (d.subscribe != null) {
              m.subscribe = Boolean(d.subscribe);
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            return m;
          };
          SubOpts.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
              d.subscribe = m.subscribe;
              if (o.oneofs)
                d._subscribe = "subscribe";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
              if (o.oneofs)
                d._topic = "topic";
            }
            return d;
          };
          SubOpts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return SubOpts;
        }();
        RPC2.Message = function() {
          function Message(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Message.prototype.from = null;
          Message.prototype.data = null;
          Message.prototype.seqno = null;
          Message.prototype.topic = "";
          Message.prototype.signature = null;
          Message.prototype.key = null;
          var $oneOfFields2;
          Object.defineProperty(Message.prototype, "_from", {
            get: $util.oneOfGetter($oneOfFields2 = ["from"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_data", {
            get: $util.oneOfGetter($oneOfFields2 = ["data"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_seqno", {
            get: $util.oneOfGetter($oneOfFields2 = ["seqno"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_signature", {
            get: $util.oneOfGetter($oneOfFields2 = ["signature"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_key", {
            get: $util.oneOfGetter($oneOfFields2 = ["key"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Message.encode = function encode(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.from != null && Object.hasOwnProperty.call(m, "from"))
              w.uint32(10).bytes(m.from);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
              w.uint32(18).bytes(m.data);
            if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
              w.uint32(26).bytes(m.seqno);
            w.uint32(34).string(m.topic);
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
              w.uint32(42).bytes(m.signature);
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
              w.uint32(50).bytes(m.key);
            return w;
          };
          Message.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.Message;
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.from = r.bytes();
                  break;
                case 2:
                  m.data = r.bytes();
                  break;
                case 3:
                  m.seqno = r.bytes();
                  break;
                case 4:
                  m.topic = r.string();
                  break;
                case 5:
                  m.signature = r.bytes();
                  break;
                case 6:
                  m.key = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            if (!m.hasOwnProperty("topic"))
              throw $util.ProtocolError("missing required 'topic'", { instance: m });
            return m;
          };
          Message.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.Message)
              return d;
            var m = new $root.RPC.Message;
            if (d.from != null) {
              if (typeof d.from === "string")
                $util.base64.decode(d.from, m.from = $util.newBuffer($util.base64.length(d.from)), 0);
              else if (d.from.length)
                m.from = d.from;
            }
            if (d.data != null) {
              if (typeof d.data === "string")
                $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);
              else if (d.data.length)
                m.data = d.data;
            }
            if (d.seqno != null) {
              if (typeof d.seqno === "string")
                $util.base64.decode(d.seqno, m.seqno = $util.newBuffer($util.base64.length(d.seqno)), 0);
              else if (d.seqno.length)
                m.seqno = d.seqno;
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            if (d.signature != null) {
              if (typeof d.signature === "string")
                $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);
              else if (d.signature.length)
                m.signature = d.signature;
            }
            if (d.key != null) {
              if (typeof d.key === "string")
                $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);
              else if (d.key.length)
                m.key = d.key;
            }
            return m;
          };
          Message.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              d.topic = "";
            }
            if (m.from != null && m.hasOwnProperty("from")) {
              d.from = o.bytes === String ? $util.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
              if (o.oneofs)
                d._from = "from";
            }
            if (m.data != null && m.hasOwnProperty("data")) {
              d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
              if (o.oneofs)
                d._data = "data";
            }
            if (m.seqno != null && m.hasOwnProperty("seqno")) {
              d.seqno = o.bytes === String ? $util.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
              if (o.oneofs)
                d._seqno = "seqno";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
            }
            if (m.signature != null && m.hasOwnProperty("signature")) {
              d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
              if (o.oneofs)
                d._signature = "signature";
            }
            if (m.key != null && m.hasOwnProperty("key")) {
              d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
              if (o.oneofs)
                d._key = "key";
            }
            return d;
          };
          Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Message;
        }();
        RPC2.ControlMessage = function() {
          function ControlMessage(p) {
            this.ihave = [];
            this.iwant = [];
            this.graft = [];
            this.prune = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlMessage.prototype.ihave = $util.emptyArray;
          ControlMessage.prototype.iwant = $util.emptyArray;
          ControlMessage.prototype.graft = $util.emptyArray;
          ControlMessage.prototype.prune = $util.emptyArray;
          ControlMessage.encode = function encode(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.ihave != null && m.ihave.length) {
              for (var i = 0;i < m.ihave.length; ++i)
                $root.RPC.ControlIHave.encode(m.ihave[i], w.uint32(10).fork()).ldelim();
            }
            if (m.iwant != null && m.iwant.length) {
              for (var i = 0;i < m.iwant.length; ++i)
                $root.RPC.ControlIWant.encode(m.iwant[i], w.uint32(18).fork()).ldelim();
            }
            if (m.graft != null && m.graft.length) {
              for (var i = 0;i < m.graft.length; ++i)
                $root.RPC.ControlGraft.encode(m.graft[i], w.uint32(26).fork()).ldelim();
            }
            if (m.prune != null && m.prune.length) {
              for (var i = 0;i < m.prune.length; ++i)
                $root.RPC.ControlPrune.encode(m.prune[i], w.uint32(34).fork()).ldelim();
            }
            return w;
          };
          ControlMessage.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlMessage;
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.ihave && m.ihave.length))
                    m.ihave = [];
                  m.ihave.push($root.RPC.ControlIHave.decode(r, r.uint32()));
                  break;
                case 2:
                  if (!(m.iwant && m.iwant.length))
                    m.iwant = [];
                  m.iwant.push($root.RPC.ControlIWant.decode(r, r.uint32()));
                  break;
                case 3:
                  if (!(m.graft && m.graft.length))
                    m.graft = [];
                  m.graft.push($root.RPC.ControlGraft.decode(r, r.uint32()));
                  break;
                case 4:
                  if (!(m.prune && m.prune.length))
                    m.prune = [];
                  m.prune.push($root.RPC.ControlPrune.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlMessage.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlMessage)
              return d;
            var m = new $root.RPC.ControlMessage;
            if (d.ihave) {
              if (!Array.isArray(d.ihave))
                throw TypeError(".RPC.ControlMessage.ihave: array expected");
              m.ihave = [];
              for (var i = 0;i < d.ihave.length; ++i) {
                if (typeof d.ihave[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.ihave: object expected");
                m.ihave[i] = $root.RPC.ControlIHave.fromObject(d.ihave[i]);
              }
            }
            if (d.iwant) {
              if (!Array.isArray(d.iwant))
                throw TypeError(".RPC.ControlMessage.iwant: array expected");
              m.iwant = [];
              for (var i = 0;i < d.iwant.length; ++i) {
                if (typeof d.iwant[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.iwant: object expected");
                m.iwant[i] = $root.RPC.ControlIWant.fromObject(d.iwant[i]);
              }
            }
            if (d.graft) {
              if (!Array.isArray(d.graft))
                throw TypeError(".RPC.ControlMessage.graft: array expected");
              m.graft = [];
              for (var i = 0;i < d.graft.length; ++i) {
                if (typeof d.graft[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.graft: object expected");
                m.graft[i] = $root.RPC.ControlGraft.fromObject(d.graft[i]);
              }
            }
            if (d.prune) {
              if (!Array.isArray(d.prune))
                throw TypeError(".RPC.ControlMessage.prune: array expected");
              m.prune = [];
              for (var i = 0;i < d.prune.length; ++i) {
                if (typeof d.prune[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.prune: object expected");
                m.prune[i] = $root.RPC.ControlPrune.fromObject(d.prune[i]);
              }
            }
            return m;
          };
          ControlMessage.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.ihave = [];
              d.iwant = [];
              d.graft = [];
              d.prune = [];
            }
            if (m.ihave && m.ihave.length) {
              d.ihave = [];
              for (var j = 0;j < m.ihave.length; ++j) {
                d.ihave[j] = $root.RPC.ControlIHave.toObject(m.ihave[j], o);
              }
            }
            if (m.iwant && m.iwant.length) {
              d.iwant = [];
              for (var j = 0;j < m.iwant.length; ++j) {
                d.iwant[j] = $root.RPC.ControlIWant.toObject(m.iwant[j], o);
              }
            }
            if (m.graft && m.graft.length) {
              d.graft = [];
              for (var j = 0;j < m.graft.length; ++j) {
                d.graft[j] = $root.RPC.ControlGraft.toObject(m.graft[j], o);
              }
            }
            if (m.prune && m.prune.length) {
              d.prune = [];
              for (var j = 0;j < m.prune.length; ++j) {
                d.prune[j] = $root.RPC.ControlPrune.toObject(m.prune[j], o);
              }
            }
            return d;
          };
          ControlMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlMessage;
        }();
        RPC2.ControlIHave = function() {
          function ControlIHave(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIHave.prototype.topicID = null;
          ControlIHave.prototype.messageIDs = $util.emptyArray;
          var $oneOfFields2;
          Object.defineProperty(ControlIHave.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlIHave.encode = function encode(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0;i < m.messageIDs.length; ++i)
                w.uint32(18).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIHave.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlIHave;
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIHave.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlIHave)
              return d;
            var m = new $root.RPC.ControlIHave;
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0;i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIHave.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0;j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIHave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlIHave;
        }();
        RPC2.ControlIWant = function() {
          function ControlIWant(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIWant.prototype.messageIDs = $util.emptyArray;
          ControlIWant.encode = function encode(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0;i < m.messageIDs.length; ++i)
                w.uint32(10).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIWant.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlIWant;
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIWant.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlIWant)
              return d;
            var m = new $root.RPC.ControlIWant;
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0;i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIWant.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0;j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIWant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlIWant;
        }();
        RPC2.ControlGraft = function() {
          function ControlGraft(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlGraft.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(ControlGraft.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlGraft.encode = function encode(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            return w;
          };
          ControlGraft.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlGraft;
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlGraft.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlGraft)
              return d;
            var m = new $root.RPC.ControlGraft;
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          ControlGraft.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          ControlGraft.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlGraft;
        }();
        RPC2.ControlPrune = function() {
          function ControlPrune(p) {
            this.peers = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlPrune.prototype.topicID = null;
          ControlPrune.prototype.peers = $util.emptyArray;
          ControlPrune.prototype.backoff = null;
          var $oneOfFields2;
          Object.defineProperty(ControlPrune.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(ControlPrune.prototype, "_backoff", {
            get: $util.oneOfGetter($oneOfFields2 = ["backoff"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlPrune.encode = function encode(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.peers != null && m.peers.length) {
              for (var i = 0;i < m.peers.length; ++i)
                $root.RPC.PeerInfo.encode(m.peers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.backoff != null && Object.hasOwnProperty.call(m, "backoff"))
              w.uint32(24).uint64(m.backoff);
            return w;
          };
          ControlPrune.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlPrune;
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.peers && m.peers.length))
                    m.peers = [];
                  m.peers.push($root.RPC.PeerInfo.decode(r, r.uint32()));
                  break;
                case 3:
                  m.backoff = r.uint64();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlPrune.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlPrune)
              return d;
            var m = new $root.RPC.ControlPrune;
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.peers) {
              if (!Array.isArray(d.peers))
                throw TypeError(".RPC.ControlPrune.peers: array expected");
              m.peers = [];
              for (var i = 0;i < d.peers.length; ++i) {
                if (typeof d.peers[i] !== "object")
                  throw TypeError(".RPC.ControlPrune.peers: object expected");
                m.peers[i] = $root.RPC.PeerInfo.fromObject(d.peers[i]);
              }
            }
            if (d.backoff != null) {
              if ($util.Long)
                (m.backoff = $util.Long.fromValue(d.backoff)).unsigned = true;
              else if (typeof d.backoff === "string")
                m.backoff = parseInt(d.backoff, 10);
              else if (typeof d.backoff === "number")
                m.backoff = d.backoff;
              else if (typeof d.backoff === "object")
                m.backoff = new $util.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);
            }
            return m;
          };
          ControlPrune.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.peers = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.peers && m.peers.length) {
              d.peers = [];
              for (var j = 0;j < m.peers.length; ++j) {
                d.peers[j] = $root.RPC.PeerInfo.toObject(m.peers[j], o);
              }
            }
            if (m.backoff != null && m.hasOwnProperty("backoff")) {
              if (typeof m.backoff === "number")
                d.backoff = o.longs === String ? String(m.backoff) : m.backoff;
              else
                d.backoff = o.longs === String ? $util.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;
              if (o.oneofs)
                d._backoff = "backoff";
            }
            return d;
          };
          ControlPrune.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlPrune;
        }();
        RPC2.PeerInfo = function() {
          function PeerInfo2(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0;i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          PeerInfo2.prototype.peerID = null;
          PeerInfo2.prototype.signedPeerRecord = null;
          var $oneOfFields2;
          Object.defineProperty(PeerInfo2.prototype, "_peerID", {
            get: $util.oneOfGetter($oneOfFields2 = ["peerID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(PeerInfo2.prototype, "_signedPeerRecord", {
            get: $util.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          PeerInfo2.encode = function encode(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.peerID != null && Object.hasOwnProperty.call(m, "peerID"))
              w.uint32(10).bytes(m.peerID);
            if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
              w.uint32(18).bytes(m.signedPeerRecord);
            return w;
          };
          PeerInfo2.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.PeerInfo;
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.peerID = r.bytes();
                  break;
                case 2:
                  m.signedPeerRecord = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          PeerInfo2.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.PeerInfo)
              return d;
            var m = new $root.RPC.PeerInfo;
            if (d.peerID != null) {
              if (typeof d.peerID === "string")
                $util.base64.decode(d.peerID, m.peerID = $util.newBuffer($util.base64.length(d.peerID)), 0);
              else if (d.peerID.length)
                m.peerID = d.peerID;
            }
            if (d.signedPeerRecord != null) {
              if (typeof d.signedPeerRecord === "string")
                $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);
              else if (d.signedPeerRecord.length)
                m.signedPeerRecord = d.signedPeerRecord;
            }
            return m;
          };
          PeerInfo2.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.peerID != null && m.hasOwnProperty("peerID")) {
              d.peerID = o.bytes === String ? $util.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;
              if (o.oneofs)
                d._peerID = "peerID";
            }
            if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
              d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
              if (o.oneofs)
                d._signedPeerRecord = "signedPeerRecord";
            }
            return d;
          };
          PeerInfo2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return PeerInfo2;
        }();
        return RPC2;
      }();
      return $root;
    });
  })(rpc$1);
  var rpcExports = rpc$1.exports;
  var cjs = getDefaultExportFromCjs(rpcExports);
  var { RPC } = cjs;
  var second = 1000;
  var minute = 60 * second;
  var FloodsubID = "/floodsub/1.0.0";
  var GossipsubIDv10 = "/meshsub/1.0.0";
  var GossipsubIDv11 = "/meshsub/1.1.0";
  var GossipsubD = 6;
  var GossipsubDlo = 4;
  var GossipsubDhi = 12;
  var GossipsubDscore = 4;
  var GossipsubDout = 2;
  var GossipsubHistoryLength = 5;
  var GossipsubHistoryGossip = 3;
  var GossipsubDlazy = 6;
  var GossipsubGossipFactor = 0.25;
  var GossipsubGossipRetransmission = 3;
  var GossipsubHeartbeatInitialDelay = 100;
  var GossipsubHeartbeatInterval = second;
  var GossipsubFanoutTTL = minute;
  var GossipsubPrunePeers = 16;
  var GossipsubPruneBackoff = minute;
  var GossipsubUnsubscribeBackoff = 10 * second;
  var GossipsubPruneBackoffTicks = 15;
  var GossipsubDirectConnectTicks = 300;
  var GossipsubDirectConnectInitialDelay = second;
  var GossipsubOpportunisticGraftTicks = 60;
  var GossipsubOpportunisticGraftPeers = 2;
  var GossipsubGraftFloodThreshold = 10 * second;
  var GossipsubMaxIHaveLength = 5000;
  var GossipsubMaxIHaveMessages = 10;
  var GossipsubIWantFollowupTime = 3 * second;
  var GossipsubSeenTTL = 2 * minute;
  var TimeCacheDuration = 120 * 1000;
  var ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
  var ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
  var ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
  var ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
  var ACCEPT_FROM_WHITELIST_DURATION_MS = 1000;
  var DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1000;
  var BACKOFF_SLACK = 1;
  var encode_1$4 = encode$h;
  var MSB$5 = 128;
  var REST$5 = 127;
  var MSBALL$4 = ~REST$5;
  var INT$4 = Math.pow(2, 31);
  var decode$b = read$5;
  var MSB$1$4 = 128;
  var REST$1$4 = 127;
  var N1$4 = Math.pow(2, 7);
  var N2$4 = Math.pow(2, 14);
  var N3$4 = Math.pow(2, 21);
  var N4$4 = Math.pow(2, 28);
  var N5$4 = Math.pow(2, 35);
  var N6$4 = Math.pow(2, 42);
  var N7$4 = Math.pow(2, 49);
  var N8$4 = Math.pow(2, 56);
  var N9$4 = Math.pow(2, 63);
  var length$4 = function(value) {
    return value < N1$4 ? 1 : value < N2$4 ? 2 : value < N3$4 ? 3 : value < N4$4 ? 4 : value < N5$4 ? 5 : value < N6$4 ? 6 : value < N7$4 ? 7 : value < N8$4 ? 8 : value < N9$4 ? 9 : 10;
  };
  var varint$4 = {
    encode: encode_1$4,
    decode: decode$b,
    encodingLength: length$4
  };
  var _brrp_varint$4 = varint$4;
  var encodeTo$4 = (int, target, offset = 0) => {
    _brrp_varint$4.encode(int, target, offset);
    return target;
  };
  var encodingLength$4 = (int) => {
    return _brrp_varint$4.encodingLength(int);
  };
  var create$9 = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength$4(code2);
    const digestOffset = sizeOffset + encodingLength$4(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo$4(code2, bytes2, 0);
    encodeTo$4(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest$4(code2, size, digest2, bytes2);
  };
  var Digest$4 = class Digest2 {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  };
  var code$4 = 0;
  var name$4 = "identity";
  var encode$g = coerce$7;
  var digest$4 = (input) => create$9(code$4, encode$g(input));
  var identity$4 = { code: code$4, name: name$4, encode: encode$g, digest: digest$4 };
  var from$b = ({ name: name2, code: code2, encode: encode3 }) => new Hasher$4(name2, code2, encode3);
  var Hasher$4 = class Hasher2 {
    constructor(name2, code2, encode3) {
      this.name = name2;
      this.code = code2;
      this.encode = encode3;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create$9(this.code, result) : result.then((digest2) => create$9(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var sha$4 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
  var sha256$5 = from$b({
    name: "sha2-256",
    code: 18,
    encode: sha$4("SHA-256")
  });
  var PUBLIC_KEY_BYTE_LENGTH$4 = 32;
  var PRIVATE_KEY_BYTE_LENGTH$4 = 64;
  var KEYS_BYTE_LENGTH$4 = 32;
  var webcrypto$4 = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto == null || nativeCrypto.subtle == null) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    }
  };
  var derivedEmptyPasswordKey$4 = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
  var KeyType$5;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["Secp256k1"] = "Secp256k1";
  })(KeyType$5 || (KeyType$5 = {}));
  var __KeyTypeValues$5;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
  })(__KeyTypeValues$5 || (__KeyTypeValues$5 = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues$5);
    };
  })(KeyType$5 || (KeyType$5 = {}));
  var PublicKey$5;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$5.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$5.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf) => {
      return decodeMessage$1(buf, PublicKey2.codec());
    };
  })(PublicKey$5 || (PublicKey$5 = {}));
  var PrivateKey$5;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$5.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$5.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf) => {
      return decodeMessage$1(buf, PrivateKey2.codec());
    };
  })(PrivateKey$5 || (PrivateKey$5 = {}));
  var Ed25519PublicKey$4 = class Ed25519PublicKey2 {
    constructor(key) {
      this._key = ensureKey$4(key, PUBLIC_KEY_BYTE_LENGTH$4);
    }
    async verify(data, sig) {
      return hashAndVerify$e(this._key, sig, data);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PublicKey$5.encode({
        Type: KeyType$5.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$5.digest(this.bytes);
      return bytes2;
    }
  };
  var Ed25519PrivateKey$4 = class Ed25519PrivateKey2 {
    constructor(key, publicKey) {
      this._key = ensureKey$4(key, PRIVATE_KEY_BYTE_LENGTH$4);
      this._publicKey = ensureKey$4(publicKey, PUBLIC_KEY_BYTE_LENGTH$4);
    }
    async sign(message2) {
      return hashAndSign$e(this._key, message2);
    }
    get public() {
      return new Ed25519PublicKey$4(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$5.encode({
        Type: KeyType$5.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$5.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const encoding = identity$4.digest(this.public.bytes);
      return base58btc$6.encode(encoding.bytes).substring(1);
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$4(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Ed25519$4 = Object.freeze({
    __proto__: null,
    Ed25519PrivateKey: Ed25519PrivateKey$4,
    Ed25519PublicKey: Ed25519PublicKey$4,
    generateKeyPair: generateKeyPair$g,
    generateKeyPairFromSeed: generateKeyPairFromSeed$4,
    unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey$4,
    unmarshalEd25519PublicKey: unmarshalEd25519PublicKey$4
  });
  var bits$5 = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  var curveTypes$5 = Object.keys(bits$5);
  curveTypes$5.join(" / ");
  var MAX_KEY_SIZE$4 = 8192;
  var RsaPublicKey$4 = class RsaPublicKey2 {
    constructor(key) {
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$d(this._key, sig, data);
    }
    marshal() {
      return jwkToPkix$4(this._key);
    }
    get bytes() {
      return PublicKey$5.encode({
        Type: KeyType$5.RSA,
        Data: this.marshal()
      }).subarray();
    }
    encrypt(bytes2) {
      return encrypt$4(this._key, bytes2);
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$5.digest(this.bytes);
      return bytes2;
    }
  };
  var RsaPrivateKey$4 = class RsaPrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey;
    }
    genSecret() {
      return randomBytes$4(16);
    }
    async sign(message2) {
      return hashAndSign$d(this._key, message2);
    }
    get public() {
      if (this._publicKey == null) {
        throw new CodeError$3("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
      }
      return new RsaPublicKey$4(this._publicKey);
    }
    decrypt(bytes2) {
      return decrypt$4(this._key, bytes2);
    }
    marshal() {
      return jwkToPkcs1$4(this._key);
    }
    get bytes() {
      return PrivateKey$5.encode({
        Type: KeyType$5.RSA,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$5.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "pkcs-8") {
      if (format4 === "pkcs-8") {
        const buffer = new forge$n.util.ByteBuffer(this.marshal());
        const asn12 = forge$n.asn1.fromDer(buffer);
        const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
        const options = {
          algorithm: "aes256",
          count: 1e4,
          saltSize: 128 / 8,
          prfAlgorithm: "sha512"
        };
        return forge$n.pki.encryptRsaPrivateKey(privateKey, password, options);
      } else if (format4 === "libp2p-key") {
        return exporter$4(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var RSA$4 = Object.freeze({
    __proto__: null,
    MAX_KEY_SIZE: MAX_KEY_SIZE$4,
    RsaPrivateKey: RsaPrivateKey$4,
    RsaPublicKey: RsaPublicKey$4,
    fromJwk: fromJwk$4,
    generateKeyPair: generateKeyPair$f,
    unmarshalRsaPrivateKey: unmarshalRsaPrivateKey$4,
    unmarshalRsaPublicKey: unmarshalRsaPublicKey$4
  });
  var Secp256k1PublicKey$4 = class Secp256k1PublicKey2 {
    constructor(key) {
      validatePublicKey$4(key);
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$c(this._key, sig, data);
    }
    marshal() {
      return compressPublicKey$4(this._key);
    }
    get bytes() {
      return PublicKey$5.encode({
        Type: KeyType$5.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$5.digest(this.bytes);
      return bytes2;
    }
  };
  var Secp256k1PrivateKey$4 = class Secp256k1PrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey ?? computePublicKey$4(key);
      validatePrivateKey$4(this._key);
      validatePublicKey$4(this._publicKey);
    }
    async sign(message2) {
      return hashAndSign$c(this._key, message2);
    }
    get public() {
      return new Secp256k1PublicKey$4(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$5.encode({
        Type: KeyType$5.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$5.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$4(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Secp256k1$4 = Object.freeze({
    __proto__: null,
    Secp256k1PrivateKey: Secp256k1PrivateKey$4,
    Secp256k1PublicKey: Secp256k1PublicKey$4,
    generateKeyPair: generateKeyPair$e,
    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey$4,
    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey$4
  });
  var supportedKeys$4 = {
    rsa: RSA$4,
    ed25519: Ed25519$4,
    secp256k1: Secp256k1$4
  };
  var StrictSign = "StrictSign";
  var StrictNoSign = "StrictNoSign";
  var TopicValidatorResult;
  (function(TopicValidatorResult2) {
    TopicValidatorResult2["Accept"] = "accept";
    TopicValidatorResult2["Ignore"] = "ignore";
    TopicValidatorResult2["Reject"] = "reject";
  })(TopicValidatorResult || (TopicValidatorResult = {}));
  var SignaturePolicy;
  (function(SignaturePolicy2) {
    SignaturePolicy2["StrictSign"] = "StrictSign";
    SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
  })(SignaturePolicy || (SignaturePolicy = {}));
  var PublishConfigType;
  (function(PublishConfigType2) {
    PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
    PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
  })(PublishConfigType || (PublishConfigType = {}));
  var RejectReason;
  (function(RejectReason2) {
    RejectReason2["Error"] = "error";
    RejectReason2["Ignore"] = "ignore";
    RejectReason2["Reject"] = "reject";
    RejectReason2["Blacklisted"] = "blacklisted";
  })(RejectReason || (RejectReason = {}));
  var ValidateError;
  (function(ValidateError2) {
    ValidateError2["InvalidSignature"] = "invalid_signature";
    ValidateError2["InvalidSeqno"] = "invalid_seqno";
    ValidateError2["InvalidPeerId"] = "invalid_peerid";
    ValidateError2["SignaturePresent"] = "signature_present";
    ValidateError2["SeqnoPresent"] = "seqno_present";
    ValidateError2["FromPresent"] = "from_present";
    ValidateError2["TransformFailed"] = "transform_failed";
  })(ValidateError || (ValidateError = {}));
  var MessageStatus;
  (function(MessageStatus2) {
    MessageStatus2["duplicate"] = "duplicate";
    MessageStatus2["invalid"] = "invalid";
    MessageStatus2["valid"] = "valid";
  })(MessageStatus || (MessageStatus = {}));
  var ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";
  var defaultPeerScoreParams = {
    topics: {},
    topicScoreCap: 10,
    appSpecificScore: () => 0,
    appSpecificWeight: 10,
    IPColocationFactorWeight: -5,
    IPColocationFactorThreshold: 10,
    IPColocationFactorWhitelist: new Set,
    behaviourPenaltyWeight: -10,
    behaviourPenaltyThreshold: 0,
    behaviourPenaltyDecay: 0.2,
    decayInterval: 1000,
    decayToZero: 0.1,
    retainScore: 3600 * 1000
  };
  var defaultTopicScoreParams = {
    topicWeight: 0.5,
    timeInMeshWeight: 1,
    timeInMeshQuantum: 1,
    timeInMeshCap: 3600,
    firstMessageDeliveriesWeight: 1,
    firstMessageDeliveriesDecay: 0.5,
    firstMessageDeliveriesCap: 2000,
    meshMessageDeliveriesWeight: -1,
    meshMessageDeliveriesDecay: 0.5,
    meshMessageDeliveriesCap: 100,
    meshMessageDeliveriesThreshold: 20,
    meshMessageDeliveriesWindow: 10,
    meshMessageDeliveriesActivation: 5000,
    meshFailurePenaltyWeight: -1,
    meshFailurePenaltyDecay: 0.5,
    invalidMessageDeliveriesWeight: -1,
    invalidMessageDeliveriesDecay: 0.3
  };
  var defaultPeerScoreThresholds = {
    gossipThreshold: -10,
    publishThreshold: -50,
    graylistThreshold: -80,
    acceptPXThreshold: 10,
    opportunisticGraftThreshold: 20
  };
  Denque.prototype.peekAt = function peekAt(index2) {
    var i = index2;
    if (i !== (i | 0)) {
      return;
    }
    var len = this.size();
    if (i >= len || i < -len)
      return;
    if (i < 0)
      i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail)
      return;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail)
      return 0;
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (arguments.length === 0)
      return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head)
      this._growArray();
    if (this._capacity && this.size() > this._capacity)
      this.pop();
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail)
      return;
    var item = this._list[head];
    this._list[head] = undefined;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (arguments.length === 0)
      return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head)
      return;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = undefined;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index2) {
    var i = index2;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size)
      return;
    if (i < 0)
      i += size;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index2 < size / 2) {
      for (k = index2;k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size - 1 - index2;k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index2, count) {
    var i = index2;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size || count < 1)
      return;
    if (i < 0)
      i += size;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size)
      count = size - i;
    var k;
    removed = new Array(count);
    for (k = 0;k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index2 + count === size) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (index2 === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (i < size / 2) {
      this._head = this._head + index2 + count + len & this._capacityMask;
      for (k = index2;k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
      if (index2 < 0)
        this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size - (count + index2);k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
      this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index2, count) {
    var i = index2;
    if (i !== (i | 0)) {
      return;
    }
    var size = this.size();
    if (i < 0)
      i += size;
    if (i > size)
      return;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size || i < size / 2) {
        temp = new Array(i);
        for (k = 0;k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i;k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size - (i + count));
        var leng = temp.length;
        for (k = 0;k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0;k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._list = new Array(this._list.length);
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    var length2 = array.length;
    var capacity = this._nextPowerOf2(length2);
    this._list = new Array(capacity);
    this._capacityMask = capacity - 1;
    this._tail = length2;
    for (var i = 0;i < length2; i++)
      this._list[i] = array[i];
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
    var src2 = this._list;
    var capacity = src2.length;
    var length2 = this.length;
    size = size | length2;
    if (size == length2 && this._head < this._tail) {
      return this._list.slice(this._head, this._tail);
    }
    var dest = new Array(size);
    var k = 0;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head;i < capacity; i++)
        dest[k++] = src2[i];
      for (i = 0;i < this._tail; i++)
        dest[k++] = src2[i];
    } else {
      for (i = this._head;i < this._tail; i++)
        dest[k++] = src2[i];
    }
    return dest;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head != 0) {
      var newList = this._copyArray(true, this._list.length << 1);
      this._tail = this._list.length;
      this._head = 0;
      this._list = newList;
    } else {
      this._tail = this._list.length;
      this._list.length <<= 1;
    }
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
    var log2 = Math.log(num) / Math.log(2);
    var nextPow2 = 1 << log2 + 1;
    return Math.max(nextPow2, 4);
  };
  var denque = Denque;
  var Denque$1 = getDefaultExportFromCjs(denque);
  var DeliveryRecordStatus;
  (function(DeliveryRecordStatus2) {
    DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
    DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
    DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
    DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
  })(DeliveryRecordStatus || (DeliveryRecordStatus = {}));

  class MessageDeliveries {
    constructor() {
      this.records = new Map;
      this.queue = new Denque$1;
    }
    getRecord(msgIdStr) {
      return this.records.get(msgIdStr);
    }
    ensureRecord(msgIdStr) {
      let drec = this.records.get(msgIdStr);
      if (drec) {
        return drec;
      }
      drec = {
        status: DeliveryRecordStatus.unknown,
        firstSeenTsMs: Date.now(),
        validated: 0,
        peers: new Set
      };
      this.records.set(msgIdStr, drec);
      const entry = {
        msgId: msgIdStr,
        expire: Date.now() + TimeCacheDuration
      };
      this.queue.push(entry);
      return drec;
    }
    gc() {
      const now = Date.now();
      let head = this.queue.peekFront();
      while (head && head.expire < now) {
        this.records.delete(head.msgId);
        this.queue.shift();
        head = this.queue.peekFront();
      }
    }
    clear() {
      this.records.clear();
      this.queue.clear();
    }
  }

  class MapDef extends Map {
    constructor(getDefault) {
      super();
      this.getDefault = getDefault;
    }
    getOrDefault(key) {
      let value = super.get(key);
      if (value === undefined) {
        value = this.getDefault();
        this.set(key, value);
      }
      return value;
    }
  }
  var log$o = logger$4("libp2p:gossipsub:score");

  class PeerScore {
    constructor(params, metrics, opts) {
      this.peerStats = new Map;
      this.peerIPs = new MapDef(() => new Set);
      this.scoreCache = new Map;
      this.deliveryRecords = new MessageDeliveries;
      this.params = params;
      this.metrics = metrics;
      validatePeerScoreParams(params);
      this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
      this.computeScore = opts.computeScore ?? computeScore;
    }
    get size() {
      return this.peerStats.size;
    }
    start() {
      if (this._backgroundInterval) {
        log$o("Peer score already running");
        return;
      }
      this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
      log$o("started");
    }
    stop() {
      if (!this._backgroundInterval) {
        log$o("Peer score already stopped");
        return;
      }
      clearInterval(this._backgroundInterval);
      delete this._backgroundInterval;
      this.peerIPs.clear();
      this.peerStats.clear();
      this.deliveryRecords.clear();
      log$o("stopped");
    }
    background() {
      this.refreshScores();
      this.deliveryRecords.gc();
    }
    dumpPeerScoreStats() {
      return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
    }
    messageFirstSeenTimestampMs(msgIdStr) {
      const drec = this.deliveryRecords.getRecord(msgIdStr);
      return drec ? drec.firstSeenTsMs : null;
    }
    refreshScores() {
      const now = Date.now();
      const decayToZero = this.params.decayToZero;
      this.peerStats.forEach((pstats, id) => {
        if (!pstats.connected) {
          if (now > pstats.expire) {
            this.removeIPsForPeer(id, pstats.knownIPs);
            this.peerStats.delete(id);
            this.scoreCache.delete(id);
          }
          return;
        }
        Object.entries(pstats.topics).forEach(([topic, tstats]) => {
          const tparams = this.params.topics[topic];
          if (tparams === undefined) {
            return;
          }
          tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
          if (tstats.firstMessageDeliveries < decayToZero) {
            tstats.firstMessageDeliveries = 0;
          }
          tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
          if (tstats.meshMessageDeliveries < decayToZero) {
            tstats.meshMessageDeliveries = 0;
          }
          tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
          if (tstats.meshFailurePenalty < decayToZero) {
            tstats.meshFailurePenalty = 0;
          }
          tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
          if (tstats.invalidMessageDeliveries < decayToZero) {
            tstats.invalidMessageDeliveries = 0;
          }
          if (tstats.inMesh) {
            tstats.meshTime = now - tstats.graftTime;
            if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
              tstats.meshMessageDeliveriesActive = true;
            }
          }
        });
        pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
        if (pstats.behaviourPenalty < decayToZero) {
          pstats.behaviourPenalty = 0;
        }
      });
    }
    score(id) {
      this.metrics?.scoreFnCalls.inc();
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return 0;
      }
      const now = Date.now();
      const cacheEntry = this.scoreCache.get(id);
      if (cacheEntry && cacheEntry.cacheUntil > now) {
        return cacheEntry.score;
      }
      this.metrics?.scoreFnRuns.inc();
      const score = this.computeScore(id, pstats, this.params, this.peerIPs);
      const cacheUntil = now + this.scoreCacheValidityMs;
      if (cacheEntry) {
        this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
        cacheEntry.score = score;
        cacheEntry.cacheUntil = cacheUntil;
      } else {
        this.scoreCache.set(id, { score, cacheUntil });
      }
      return score;
    }
    addPenalty(id, penalty, penaltyLabel) {
      const pstats = this.peerStats.get(id);
      if (pstats) {
        pstats.behaviourPenalty += penalty;
        this.metrics?.onScorePenalty(penaltyLabel);
      }
    }
    addPeer(id) {
      const pstats = {
        connected: true,
        expire: 0,
        topics: {},
        knownIPs: new Set,
        behaviourPenalty: 0
      };
      this.peerStats.set(id, pstats);
    }
    addIP(id, ip) {
      const pstats = this.peerStats.get(id);
      if (pstats) {
        pstats.knownIPs.add(ip);
      }
      this.peerIPs.getOrDefault(ip).add(id);
    }
    removeIP(id, ip) {
      const pstats = this.peerStats.get(id);
      if (pstats) {
        pstats.knownIPs.delete(ip);
      }
      const peersWithIP = this.peerIPs.get(ip);
      if (peersWithIP) {
        peersWithIP.delete(id);
        if (peersWithIP.size === 0) {
          this.peerIPs.delete(ip);
        }
      }
    }
    removePeer(id) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return;
      }
      if (this.score(id) > 0) {
        this.removeIPsForPeer(id, pstats.knownIPs);
        this.peerStats.delete(id);
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        tstats.firstMessageDeliveries = 0;
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.inMesh = false;
        tstats.meshMessageDeliveriesActive = false;
      });
      pstats.connected = false;
      pstats.expire = Date.now() + this.params.retainScore;
    }
    graft(id, topic) {
      const pstats = this.peerStats.get(id);
      if (pstats) {
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats) {
          tstats.inMesh = true;
          tstats.graftTime = Date.now();
          tstats.meshTime = 0;
          tstats.meshMessageDeliveriesActive = false;
        }
      }
    }
    prune(id, topic) {
      const pstats = this.peerStats.get(id);
      if (pstats) {
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats) {
          const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
          if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
            const deficit = threshold - tstats.meshMessageDeliveries;
            tstats.meshFailurePenalty += deficit * deficit;
          }
          tstats.meshMessageDeliveriesActive = false;
          tstats.inMesh = false;
        }
      }
    }
    validateMessage(msgIdStr) {
      this.deliveryRecords.ensureRecord(msgIdStr);
    }
    deliverMessage(from2, msgIdStr, topic) {
      this.markFirstMessageDelivery(from2, topic);
      const drec = this.deliveryRecords.ensureRecord(msgIdStr);
      const now = Date.now();
      if (drec.status !== DeliveryRecordStatus.unknown) {
        log$o("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from2, now - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
        return;
      }
      drec.status = DeliveryRecordStatus.valid;
      drec.validated = now;
      drec.peers.forEach((p) => {
        if (p !== from2.toString()) {
          this.markDuplicateMessageDelivery(p, topic);
        }
      });
    }
    rejectInvalidMessage(from2, topic) {
      this.markInvalidMessageDelivery(from2, topic);
    }
    rejectMessage(from2, msgIdStr, topic, reason) {
      switch (reason) {
        case RejectReason.Error:
          this.markInvalidMessageDelivery(from2, topic);
          return;
        case RejectReason.Blacklisted:
          return;
      }
      const drec = this.deliveryRecords.ensureRecord(msgIdStr);
      if (drec.status !== DeliveryRecordStatus.unknown) {
        log$o("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from2, Date.now() - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
        return;
      }
      if (reason === RejectReason.Ignore) {
        drec.status = DeliveryRecordStatus.ignored;
        drec.peers.clear();
        return;
      }
      drec.status = DeliveryRecordStatus.invalid;
      this.markInvalidMessageDelivery(from2, topic);
      drec.peers.forEach((p) => {
        this.markInvalidMessageDelivery(p, topic);
      });
      drec.peers.clear();
    }
    duplicateMessage(from2, msgIdStr, topic) {
      const drec = this.deliveryRecords.ensureRecord(msgIdStr);
      if (drec.peers.has(from2)) {
        return;
      }
      switch (drec.status) {
        case DeliveryRecordStatus.unknown:
          drec.peers.add(from2);
          break;
        case DeliveryRecordStatus.valid:
          drec.peers.add(from2);
          this.markDuplicateMessageDelivery(from2, topic, drec.validated);
          break;
        case DeliveryRecordStatus.invalid:
          this.markInvalidMessageDelivery(from2, topic);
          break;
        case DeliveryRecordStatus.ignored:
          break;
      }
    }
    markInvalidMessageDelivery(from2, topic) {
      const pstats = this.peerStats.get(from2);
      if (pstats) {
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats) {
          tstats.invalidMessageDeliveries += 1;
        }
      }
    }
    markFirstMessageDelivery(from2, topic) {
      const pstats = this.peerStats.get(from2);
      if (pstats) {
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats) {
          let cap = this.params.topics[topic].firstMessageDeliveriesCap;
          tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
          if (tstats.inMesh) {
            cap = this.params.topics[topic].meshMessageDeliveriesCap;
            tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
          }
        }
      }
    }
    markDuplicateMessageDelivery(from2, topic, validatedTime) {
      const pstats = this.peerStats.get(from2);
      if (pstats) {
        const now = validatedTime !== undefined ? Date.now() : 0;
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats && tstats.inMesh) {
          const tparams = this.params.topics[topic];
          if (validatedTime !== undefined) {
            const deliveryDelayMs = now - validatedTime;
            const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
            this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
            if (isLateDelivery) {
              return;
            }
          }
          const cap = tparams.meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
    removeIPsForPeer(id, ipsToRemove) {
      for (const ipToRemove of ipsToRemove) {
        const peerSet = this.peerIPs.get(ipToRemove);
        if (peerSet) {
          peerSet.delete(id);
          if (peerSet.size === 0) {
            this.peerIPs.delete(ipToRemove);
          }
        }
      }
    }
    getPtopicStats(pstats, topic) {
      let topicStats = pstats.topics[topic];
      if (topicStats !== undefined) {
        return topicStats;
      }
      if (this.params.topics[topic] !== undefined) {
        topicStats = {
          inMesh: false,
          graftTime: 0,
          meshTime: 0,
          firstMessageDeliveries: 0,
          meshMessageDeliveries: 0,
          meshMessageDeliveriesActive: false,
          meshFailurePenalty: 0,
          invalidMessageDeliveries: 0
        };
        pstats.topics[topic] = topicStats;
        return topicStats;
      }
      return null;
    }
  }

  class IWantTracer {
    constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
      this.promises = new Map;
      this.requestMsByMsg = new Map;
      this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
      this.msgIdToStrFn = msgIdToStrFn;
      this.metrics = metrics;
      this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
    }
    get size() {
      return this.promises.size;
    }
    get requestMsByMsgSize() {
      return this.requestMsByMsg.size;
    }
    addPromise(from2, msgIds) {
      const ix = Math.floor(Math.random() * msgIds.length);
      const msgId2 = msgIds[ix];
      const msgIdStr = this.msgIdToStrFn(msgId2);
      let expireByPeer = this.promises.get(msgIdStr);
      if (!expireByPeer) {
        expireByPeer = new Map;
        this.promises.set(msgIdStr, expireByPeer);
      }
      const now = Date.now();
      if (!expireByPeer.has(from2)) {
        expireByPeer.set(from2, now + this.gossipsubIWantFollowupMs);
        if (this.metrics) {
          this.metrics.iwantPromiseStarted.inc(1);
          if (!this.requestMsByMsg.has(msgIdStr)) {
            this.requestMsByMsg.set(msgIdStr, now);
          }
        }
      }
    }
    getBrokenPromises() {
      const now = Date.now();
      const result = new Map;
      let brokenPromises = 0;
      this.promises.forEach((expireByPeer, msgId2) => {
        expireByPeer.forEach((expire, p) => {
          if (expire < now) {
            result.set(p, (result.get(p) ?? 0) + 1);
            expireByPeer.delete(p);
            brokenPromises++;
          }
        });
        if (!expireByPeer.size) {
          this.promises.delete(msgId2);
        }
      });
      this.metrics?.iwantPromiseBroken.inc(brokenPromises);
      return result;
    }
    deliverMessage(msgIdStr, isDuplicate = false) {
      this.trackMessage(msgIdStr);
      const expireByPeer = this.promises.get(msgIdStr);
      if (expireByPeer) {
        this.promises.delete(msgIdStr);
        if (this.metrics) {
          this.metrics.iwantPromiseResolved.inc(1);
          if (isDuplicate)
            this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);
          this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
        }
      }
    }
    rejectMessage(msgIdStr, reason) {
      this.trackMessage(msgIdStr);
      switch (reason) {
        case RejectReason.Error:
          return;
      }
      this.promises.delete(msgIdStr);
    }
    clear() {
      this.promises.clear();
    }
    prune() {
      const maxMs = Date.now() - this.requestMsByMsgExpire;
      let count = 0;
      for (const [k, v] of this.requestMsByMsg.entries()) {
        if (v < maxMs) {
          this.requestMsByMsg.delete(k);
          count++;
        } else {
          break;
        }
      }
      this.metrics?.iwantMessagePruned.inc(count);
    }
    trackMessage(msgIdStr) {
      if (this.metrics) {
        const requestMs = this.requestMsByMsg.get(msgIdStr);
        if (requestMs !== undefined) {
          this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000);
          this.requestMsByMsg.delete(msgIdStr);
        }
      }
    }
  }

  class SimpleTimeCache {
    constructor(opts) {
      this.entries = new Map;
      this.validityMs = opts.validityMs;
    }
    get size() {
      return this.entries.size;
    }
    put(key, value) {
      if (this.entries.has(key)) {
        return true;
      }
      this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs });
      return false;
    }
    prune() {
      const now = Date.now();
      for (const [k, v] of this.entries.entries()) {
        if (v.validUntilMs < now) {
          this.entries.delete(k);
        } else {
          break;
        }
      }
    }
    has(key) {
      return this.entries.has(key);
    }
    get(key) {
      const value = this.entries.get(key);
      return value && value.validUntilMs >= Date.now() ? value.value : undefined;
    }
    clear() {
      this.entries.clear();
    }
  }
  var MessageSource;
  (function(MessageSource2) {
    MessageSource2["forward"] = "forward";
    MessageSource2["publish"] = "publish";
  })(MessageSource || (MessageSource = {}));
  var InclusionReason;
  (function(InclusionReason2) {
    InclusionReason2["Fanout"] = "fanout";
    InclusionReason2["Random"] = "random";
    InclusionReason2["Subscribed"] = "subscribed";
    InclusionReason2["Outbound"] = "outbound";
    InclusionReason2["NotEnough"] = "not_enough";
    InclusionReason2["Opportunistic"] = "opportunistic";
  })(InclusionReason || (InclusionReason = {}));
  var ChurnReason;
  (function(ChurnReason2) {
    ChurnReason2["Dc"] = "disconnected";
    ChurnReason2["BadScore"] = "bad_score";
    ChurnReason2["Prune"] = "prune";
    ChurnReason2["Excess"] = "excess";
  })(ChurnReason || (ChurnReason = {}));
  var ScorePenalty;
  (function(ScorePenalty2) {
    ScorePenalty2["GraftBackoff"] = "graft_backoff";
    ScorePenalty2["BrokenPromise"] = "broken_promise";
    ScorePenalty2["MessageDeficit"] = "message_deficit";
    ScorePenalty2["IPColocation"] = "IP_colocation";
  })(ScorePenalty || (ScorePenalty = {}));
  var IHaveIgnoreReason;
  (function(IHaveIgnoreReason2) {
    IHaveIgnoreReason2["LowScore"] = "low_score";
    IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
    IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
  })(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
  var ScoreThreshold;
  (function(ScoreThreshold2) {
    ScoreThreshold2["graylist"] = "graylist";
    ScoreThreshold2["publish"] = "publish";
    ScoreThreshold2["gossip"] = "gossip";
    ScoreThreshold2["mesh"] = "mesh";
  })(ScoreThreshold || (ScoreThreshold = {}));
  var SignPrefix = fromString$3("libp2p-pubsub:");
  var src$6 = base$6;
  var _brrp__multiformats_scope_baseX$6 = src$6;
  var coerce$6 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$6 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$6 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$6(this, decoder);
    }
  };
  var ComposedDecoder$6 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$6(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$6 = (left2, right2) => new ComposedDecoder$6({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$6 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$6(name2, prefix, baseEncode);
      this.decoder = new Decoder$6(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$a = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$6(name2, prefix, encode3, decode3);
  var baseX$6 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$6(alphabet2, name2);
    return from$a({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$6(decode3(text))
    });
  };
  var decode$a = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$f = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$6 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$a({
      prefix,
      name: name2,
      encode(input) {
        return encode$f(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$a(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  baseX$6({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$6({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  rfc4648$6({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$6({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$6({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$6({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var KeyType$4;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["Secp256k1"] = "Secp256k1";
  })(KeyType$4 || (KeyType$4 = {}));
  var __KeyTypeValues$4;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
  })(__KeyTypeValues$4 || (__KeyTypeValues$4 = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues$4);
    };
  })(KeyType$4 || (KeyType$4 = {}));
  var PublicKey$4;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$4.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$4.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf) => {
      return decodeMessage$1(buf, PublicKey2.codec());
    };
  })(PublicKey$4 || (PublicKey$4 = {}));
  var PrivateKey$4;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$4.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$4.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf) => {
      return decodeMessage$1(buf, PrivateKey2.codec());
    };
  })(PrivateKey$4 || (PrivateKey$4 = {}));
  var bits$4 = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  var curveTypes$4 = Object.keys(bits$4);
  curveTypes$4.join(" / ");
  var msgId = (key, seqno) => {
    const seqnoBytes = fromString$3(seqno.toString(16).padStart(16, "0"), "base16");
    const msgId2 = new Uint8Array(key.length + seqnoBytes.length);
    msgId2.set(key, 0);
    msgId2.set(seqnoBytes, key.length);
    return msgId2;
  };

  class OutboundStream {
    constructor(rawStream, errCallback, opts) {
      this.rawStream = rawStream;
      this.pushable = pushable({ objectMode: false });
      this.closeController = new AbortController;
      this.maxBufferSize = opts.maxBufferSize ?? Infinity;
      pipe(abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }), (source2) => encode$B(source2), this.rawStream).catch(errCallback);
    }
    get protocol() {
      return this.rawStream.protocol;
    }
    push(data) {
      if (this.pushable.readableLength > this.maxBufferSize) {
        throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
      }
      this.pushable.push(data);
    }
    close() {
      this.closeController.abort();
      this.pushable.return();
      this.rawStream.close();
    }
  }

  class InboundStream {
    constructor(rawStream, opts = {}) {
      this.rawStream = rawStream;
      this.closeController = new AbortController;
      this.source = abortableSource(pipe(this.rawStream, (source2) => decode$v(source2, opts)), this.closeController.signal, {
        returnOnAbort: true
      });
    }
    close() {
      this.closeController.abort();
      this.rawStream.close();
    }
  }
  var defaultDecodeRpcLimits = {
    maxSubscriptions: Infinity,
    maxMessages: Infinity,
    maxIhaveMessageIDs: Infinity,
    maxIwantMessageIDs: Infinity,
    maxControlMessages: Infinity,
    maxPeerInfos: Infinity
  };
  var Protocol;
  (function(Protocol2) {
    Protocol2[Protocol2["ip4"] = 4] = "ip4";
    Protocol2[Protocol2["ip6"] = 41] = "ip6";
  })(Protocol || (Protocol = {}));
  var GossipStatusCode;
  (function(GossipStatusCode2) {
    GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
    GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
  })(GossipStatusCode || (GossipStatusCode = {}));

  class GossipSub extends EventEmitter$2 {
    constructor(components, options = {}) {
      super();
      this.multicodecs = [GossipsubIDv11, GossipsubIDv10];
      this.peers = new Set;
      this.streamsInbound = new Map;
      this.streamsOutbound = new Map;
      this.outboundInflightQueue = pushable({ objectMode: true });
      this.direct = new Set;
      this.floodsubPeers = new Set;
      this.acceptFromWhitelist = new Map;
      this.topics = new Map;
      this.subscriptions = new Set;
      this.mesh = new Map;
      this.fanout = new Map;
      this.fanoutLastpub = new Map;
      this.gossip = new Map;
      this.control = new Map;
      this.peerhave = new Map;
      this.iasked = new Map;
      this.backoff = new Map;
      this.outbound = new Map;
      this.topicValidators = new Map;
      this.heartbeatTicks = 0;
      this.directPeerInitial = null;
      this.status = { code: GossipStatusCode.stopped };
      this.heartbeatTimer = null;
      this.runHeartbeat = () => {
        const timer = this.metrics?.heartbeatDuration.startTimer();
        this.heartbeat().catch((err) => {
          this.log("Error running heartbeat", err);
        }).finally(() => {
          if (timer != null) {
            timer();
          }
          if (this.status.code === GossipStatusCode.started) {
            clearTimeout(this.status.heartbeatTimeout);
            let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
            if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
              msToNextHeartbeat += this.opts.heartbeatInterval;
              this.metrics?.heartbeatSkipped.inc();
            }
            this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
          }
        });
      };
      const opts = {
        fallbackToFloodsub: true,
        floodPublish: true,
        doPX: false,
        directPeers: [],
        D: GossipsubD,
        Dlo: GossipsubDlo,
        Dhi: GossipsubDhi,
        Dscore: GossipsubDscore,
        Dout: GossipsubDout,
        Dlazy: GossipsubDlazy,
        heartbeatInterval: GossipsubHeartbeatInterval,
        fanoutTTL: GossipsubFanoutTTL,
        mcacheLength: GossipsubHistoryLength,
        mcacheGossip: GossipsubHistoryGossip,
        seenTTL: GossipsubSeenTTL,
        gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
        prunePeers: GossipsubPrunePeers,
        pruneBackoff: GossipsubPruneBackoff,
        unsubcribeBackoff: GossipsubUnsubscribeBackoff,
        graftFloodThreshold: GossipsubGraftFloodThreshold,
        opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
        opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
        directConnectTicks: GossipsubDirectConnectTicks,
        ...options,
        scoreParams: createPeerScoreParams(options.scoreParams),
        scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)
      };
      this.components = components;
      this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;
      this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
      if (opts.fallbackToFloodsub) {
        this.multicodecs.push(FloodsubID);
      }
      this.log = logger$4(opts.debugName ?? "libp2p:gossipsub");
      this.opts = opts;
      this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));
      this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
      this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
      if (options.msgIdFn) {
        this.msgIdFn = options.msgIdFn;
      } else {
        switch (this.globalSignaturePolicy) {
          case StrictSign:
            this.msgIdFn = msgIdFnStrictSign;
            break;
          case StrictNoSign:
            this.msgIdFn = msgIdFnStrictNoSign;
            break;
        }
      }
      if (options.fastMsgIdFn) {
        this.fastMsgIdFn = options.fastMsgIdFn;
        this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
      }
      this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;
      this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
      if (options.dataTransform) {
        this.dataTransform = options.dataTransform;
      }
      if (options.metricsRegister) {
        if (!options.metricsTopicStrToLabel) {
          throw Error("Must set metricsTopicStrToLabel with metrics");
        }
        const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
        const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {
          gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1000,
          behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
          maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1000
        });
        metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));
        for (const protocol of this.multicodecs) {
          metrics.protocolsEnabled.set({ protocol }, 1);
        }
        this.metrics = metrics;
      } else {
        this.metrics = null;
      }
      this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
      this.score = new PeerScore(this.opts.scoreParams, this.metrics, {
        scoreCacheValidityMs: opts.heartbeatInterval
      });
      this.maxInboundStreams = options.maxInboundStreams;
      this.maxOutboundStreams = options.maxOutboundStreams;
      this.allowedTopics = opts.allowedTopics ? new Set(opts.allowedTopics) : null;
    }
    getPeers() {
      return [...this.peers.keys()].map((str) => peerIdFromString(str));
    }
    isStarted() {
      return this.status.code === GossipStatusCode.started;
    }
    async start() {
      if (this.isStarted()) {
        return;
      }
      this.log("starting");
      this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId);
      this.outboundInflightQueue = pushable({ objectMode: true });
      pipe(this.outboundInflightQueue, async (source2) => {
        for await (const { peerId, connection } of source2) {
          await this.createOutboundStream(peerId, connection);
        }
      }).catch((e) => this.log.error("outbound inflight queue error", e));
      await Promise.all(this.opts.directPeers.map(async (p) => {
        await this.components.peerStore.merge(p.id, {
          multiaddrs: p.addrs
        });
      }));
      const registrar = this.components.registrar;
      await Promise.all(this.multicodecs.map((multicodec) => registrar.handle(multicodec, this.onIncomingStream.bind(this), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      })));
      const topology = {
        onConnect: this.onPeerConnected.bind(this),
        onDisconnect: this.onPeerDisconnected.bind(this)
      };
      const registrarTopologyIds = await Promise.all(this.multicodecs.map((multicodec) => registrar.register(multicodec, topology)));
      const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
      this.status = {
        code: GossipStatusCode.started,
        registrarTopologyIds,
        heartbeatTimeout,
        hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
      };
      this.score.start();
      this.directPeerInitial = setTimeout(() => {
        Promise.resolve().then(async () => {
          await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)));
        }).catch((err) => {
          this.log(err);
        });
      }, GossipsubDirectConnectInitialDelay);
      this.log("started");
    }
    async stop() {
      this.log("stopping");
      if (this.status.code !== GossipStatusCode.started) {
        return;
      }
      const { registrarTopologyIds } = this.status;
      this.status = { code: GossipStatusCode.stopped };
      const registrar = this.components.registrar;
      await Promise.all(this.multicodecs.map((multicodec) => registrar.unhandle(multicodec)));
      registrarTopologyIds.forEach((id) => registrar.unregister(id));
      this.outboundInflightQueue.end();
      for (const outboundStream of this.streamsOutbound.values()) {
        outboundStream.close();
      }
      this.streamsOutbound.clear();
      for (const inboundStream of this.streamsInbound.values()) {
        inboundStream.close();
      }
      this.streamsInbound.clear();
      this.peers.clear();
      this.subscriptions.clear();
      if (this.heartbeatTimer) {
        this.heartbeatTimer.cancel();
        this.heartbeatTimer = null;
      }
      this.score.stop();
      this.mesh.clear();
      this.fanout.clear();
      this.fanoutLastpub.clear();
      this.gossip.clear();
      this.control.clear();
      this.peerhave.clear();
      this.iasked.clear();
      this.backoff.clear();
      this.outbound.clear();
      this.gossipTracer.clear();
      this.seenCache.clear();
      if (this.fastMsgIdCache)
        this.fastMsgIdCache.clear();
      if (this.directPeerInitial)
        clearTimeout(this.directPeerInitial);
      this.log("stopped");
    }
    dumpPeerScoreStats() {
      return this.score.dumpPeerScoreStats();
    }
    onIncomingStream({ stream, connection }) {
      if (!this.isStarted()) {
        return;
      }
      const peerId = connection.remotePeer;
      this.addPeer(peerId, connection.direction, connection.remoteAddr);
      this.createInboundStream(peerId, stream);
      this.outboundInflightQueue.push({ peerId, connection });
    }
    onPeerConnected(peerId, connection) {
      this.metrics?.newConnectionCount.inc({ status: connection.status });
      if (!this.isStarted() || connection.status !== "open") {
        return;
      }
      this.addPeer(peerId, connection.direction, connection.remoteAddr);
      this.outboundInflightQueue.push({ peerId, connection });
    }
    onPeerDisconnected(peerId) {
      this.log("connection ended %p", peerId);
      this.removePeer(peerId);
    }
    async createOutboundStream(peerId, connection) {
      if (!this.isStarted()) {
        return;
      }
      const id = peerId.toString();
      if (!this.peers.has(id)) {
        return;
      }
      if (this.streamsOutbound.has(id)) {
        return;
      }
      try {
        const stream = new OutboundStream(await connection.newStream(this.multicodecs), (e) => this.log.error("outbound pipe error", e), { maxBufferSize: this.opts.maxOutboundBufferSize });
        this.log("create outbound stream %p", peerId);
        this.streamsOutbound.set(id, stream);
        const protocol = stream.protocol;
        if (protocol === FloodsubID) {
          this.floodsubPeers.add(id);
        }
        this.metrics?.peersPerProtocol.inc({ protocol }, 1);
        if (this.subscriptions.size > 0) {
          this.log("send subscriptions to", id);
          this.sendSubscriptions(id, Array.from(this.subscriptions), true);
        }
      } catch (e) {
        this.log.error("createOutboundStream error", e);
      }
    }
    async createInboundStream(peerId, stream) {
      if (!this.isStarted()) {
        return;
      }
      const id = peerId.toString();
      if (!this.peers.has(id)) {
        return;
      }
      const priorInboundStream = this.streamsInbound.get(id);
      if (priorInboundStream !== undefined) {
        this.log("replacing existing inbound steam %s", id);
        priorInboundStream.close();
      }
      this.log("create inbound stream %s", id);
      const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength });
      this.streamsInbound.set(id, inboundStream);
      this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => this.log(err));
    }
    addPeer(peerId, direction, addr) {
      const id = peerId.toString();
      if (!this.peers.has(id)) {
        this.log("new peer %p", peerId);
        this.peers.add(id);
        this.score.addPeer(id);
        const currentIP = multiaddrToIPStr(addr);
        if (currentIP !== null) {
          this.score.addIP(id, currentIP);
        } else {
          this.log("Added peer has no IP in current address %s %s", id, addr.toString());
        }
        if (!this.outbound.has(id)) {
          this.outbound.set(id, direction === "outbound");
        }
      }
    }
    removePeer(peerId) {
      const id = peerId.toString();
      if (!this.peers.has(id)) {
        return;
      }
      this.log("delete peer %p", peerId);
      this.peers.delete(id);
      const outboundStream = this.streamsOutbound.get(id);
      const inboundStream = this.streamsInbound.get(id);
      if (outboundStream) {
        this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
      }
      outboundStream?.close();
      inboundStream?.close();
      this.streamsOutbound.delete(id);
      this.streamsInbound.delete(id);
      for (const peers of this.topics.values()) {
        peers.delete(id);
      }
      for (const [topicStr, peers] of this.mesh) {
        if (peers.delete(id) === true) {
          this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
        }
      }
      for (const peers of this.fanout.values()) {
        peers.delete(id);
      }
      this.floodsubPeers.delete(id);
      this.gossip.delete(id);
      this.control.delete(id);
      this.outbound.delete(id);
      this.score.removePeer(id);
      this.acceptFromWhitelist.delete(id);
    }
    get started() {
      return this.status.code === GossipStatusCode.started;
    }
    getMeshPeers(topic) {
      const peersInTopic = this.mesh.get(topic);
      return peersInTopic ? Array.from(peersInTopic) : [];
    }
    getSubscribers(topic) {
      const peersInTopic = this.topics.get(topic);
      return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str));
    }
    getTopics() {
      return Array.from(this.subscriptions);
    }
    async pipePeerReadStream(peerId, stream) {
      try {
        await pipe(stream, async (source2) => {
          for await (const data of source2) {
            try {
              const rpcBytes = data.subarray();
              const rpc2 = decodeRpc(rpcBytes, this.decodeRpcLimits);
              this.metrics?.onRpcRecv(rpc2, rpcBytes.length);
              if (this.opts.awaitRpcHandler) {
                try {
                  await this.handleReceivedRpc(peerId, rpc2);
                } catch (err) {
                  this.metrics?.onRpcRecvError();
                  this.log(err);
                }
              } else {
                this.handleReceivedRpc(peerId, rpc2).catch((err) => {
                  this.metrics?.onRpcRecvError();
                  this.log(err);
                });
              }
            } catch (e) {
              this.metrics?.onRpcDataError();
              this.log(e);
            }
          }
        });
      } catch (err) {
        this.metrics?.onPeerReadStreamError();
        this.handlePeerReadStreamError(err, peerId);
      }
    }
    handlePeerReadStreamError(err, peerId) {
      this.log.error(err);
      this.onPeerDisconnected(peerId);
    }
    async handleReceivedRpc(from2, rpc2) {
      if (!this.acceptFrom(from2.toString())) {
        this.log("received message from unacceptable peer %p", from2);
        this.metrics?.rpcRecvNotAccepted.inc();
        return;
      }
      const subscriptions = rpc2.subscriptions ? rpc2.subscriptions.length : 0;
      const messages2 = rpc2.messages ? rpc2.messages.length : 0;
      let ihave = 0;
      let iwant = 0;
      let graft = 0;
      let prune = 0;
      if (rpc2.control) {
        if (rpc2.control.ihave)
          ihave = rpc2.control.ihave.length;
        if (rpc2.control.iwant)
          iwant = rpc2.control.iwant.length;
        if (rpc2.control.graft)
          graft = rpc2.control.graft.length;
        if (rpc2.control.prune)
          prune = rpc2.control.prune.length;
      }
      this.log(`rpc.from ${from2.toString()} subscriptions ${subscriptions} messages ${messages2} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`);
      if (rpc2.subscriptions && rpc2.subscriptions.length > 0) {
        const subscriptions2 = [];
        rpc2.subscriptions.forEach((subOpt) => {
          const topic = subOpt.topic;
          const subscribe2 = subOpt.subscribe === true;
          if (topic != null) {
            if (this.allowedTopics && !this.allowedTopics.has(topic)) {
              return;
            }
            this.handleReceivedSubscription(from2, topic, subscribe2);
            subscriptions2.push({ topic, subscribe: subscribe2 });
          }
        });
        this.dispatchEvent(new CustomEvent("subscription-change", {
          detail: { peerId: from2, subscriptions: subscriptions2 }
        }));
      }
      if (rpc2.messages) {
        for (const message2 of rpc2.messages) {
          if (this.allowedTopics && !this.allowedTopics.has(message2.topic)) {
            continue;
          }
          const handleReceivedMessagePromise = this.handleReceivedMessage(from2, message2).catch((err) => {
            this.metrics?.onMsgRecvError(message2.topic);
            this.log(err);
          });
          if (this.opts.awaitRpcMessageHandler) {
            await handleReceivedMessagePromise;
          }
        }
      }
      if (rpc2.control) {
        await this.handleControlMessage(from2.toString(), rpc2.control);
      }
    }
    handleReceivedSubscription(from2, topic, subscribe2) {
      this.log("subscription update from %p topic %s", from2, topic);
      let topicSet = this.topics.get(topic);
      if (topicSet == null) {
        topicSet = new Set;
        this.topics.set(topic, topicSet);
      }
      if (subscribe2) {
        topicSet.add(from2.toString());
      } else {
        topicSet.delete(from2.toString());
      }
    }
    async handleReceivedMessage(from2, rpcMsg) {
      this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);
      const validationResult = await this.validateReceivedMessage(from2, rpcMsg);
      this.metrics?.onPrevalidationResult(rpcMsg.topic, validationResult.code);
      switch (validationResult.code) {
        case MessageStatus.duplicate:
          this.score.duplicateMessage(from2.toString(), validationResult.msgIdStr, rpcMsg.topic);
          this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);
          this.mcache.observeDuplicate(validationResult.msgIdStr, from2.toString());
          return;
        case MessageStatus.invalid:
          if (validationResult.msgIdStr) {
            const msgIdStr = validationResult.msgIdStr;
            this.score.rejectMessage(from2.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
            this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
          } else {
            this.score.rejectInvalidMessage(from2.toString(), rpcMsg.topic);
          }
          this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);
          return;
        case MessageStatus.valid:
          this.score.validateMessage(validationResult.messageId.msgIdStr);
          this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
          this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
          if (this.subscriptions.has(rpcMsg.topic)) {
            const isFromSelf = this.components.peerId.equals(from2);
            if (!isFromSelf || this.opts.emitSelf) {
              super.dispatchEvent(new CustomEvent("gossipsub:message", {
                detail: {
                  propagationSource: from2,
                  msgId: validationResult.messageId.msgIdStr,
                  msg: validationResult.msg
                }
              }));
              super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
            }
          }
          if (!this.opts.asyncValidation) {
            this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from2.toString());
          }
      }
    }
    async validateReceivedMessage(propagationSource, rpcMsg) {
      const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);
      const msgIdCached = fastMsgIdStr !== undefined ? this.fastMsgIdCache?.get(fastMsgIdStr) : undefined;
      if (msgIdCached) {
        return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
      }
      const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
      if (!validationResult.valid) {
        return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
      }
      const msg = validationResult.message;
      try {
        if (this.dataTransform) {
          msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
        }
      } catch (e) {
        this.log("Invalid message, transform failed", e);
        return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
      }
      const msgId2 = await this.msgIdFn(msg);
      const msgIdStr = this.msgIdToStrFn(msgId2);
      const messageId = { msgId: msgId2, msgIdStr };
      if (fastMsgIdStr !== undefined && this.fastMsgIdCache) {
        const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);
        if (collision) {
          this.metrics?.fastMsgIdCacheCollision.inc();
        }
      }
      if (this.seenCache.has(msgIdStr)) {
        return { code: MessageStatus.duplicate, msgIdStr };
      } else {
        this.seenCache.put(msgIdStr);
      }
      const topicValidator = this.topicValidators.get(rpcMsg.topic);
      if (topicValidator != null) {
        let acceptance;
        try {
          acceptance = await topicValidator(propagationSource, msg);
        } catch (e) {
          const errCode2 = e.code;
          if (errCode2 === ERR_TOPIC_VALIDATOR_IGNORE)
            acceptance = TopicValidatorResult.Ignore;
          if (errCode2 === ERR_TOPIC_VALIDATOR_REJECT)
            acceptance = TopicValidatorResult.Reject;
          else
            acceptance = TopicValidatorResult.Ignore;
        }
        if (acceptance !== TopicValidatorResult.Accept) {
          return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
        }
      }
      return { code: MessageStatus.valid, messageId, msg };
    }
    getScore(peerId) {
      return this.score.score(peerId);
    }
    sendSubscriptions(toPeer, topics, subscribe2) {
      this.sendRpc(toPeer, {
        subscriptions: topics.map((topic) => ({ topic, subscribe: subscribe2 }))
      });
    }
    async handleControlMessage(id, controlMsg) {
      if (controlMsg === undefined) {
        return;
      }
      const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];
      const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];
      const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];
      controlMsg.prune && await this.handlePrune(id, controlMsg.prune);
      if (!iwant.length && !ihave.length && !prune.length) {
        return;
      }
      const sent = this.sendRpc(id, { messages: ihave, control: { iwant, prune } });
      const iwantMessageIds = iwant[0]?.messageIDs;
      if (iwantMessageIds) {
        if (sent) {
          this.gossipTracer.addPromise(id, iwantMessageIds);
        } else {
          this.metrics?.iwantPromiseUntracked.inc(1);
        }
      }
    }
    acceptFrom(id) {
      if (this.direct.has(id)) {
        return true;
      }
      const now = Date.now();
      const entry = this.acceptFromWhitelist.get(id);
      if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
        entry.messagesAccepted += 1;
        return true;
      }
      const score = this.score.score(id);
      if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
        this.acceptFromWhitelist.set(id, {
          messagesAccepted: 0,
          acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
        });
      } else {
        this.acceptFromWhitelist.delete(id);
      }
      return score >= this.opts.scoreThresholds.graylistThreshold;
    }
    handleIHave(id, ihave) {
      if (!ihave.length) {
        return [];
      }
      const score = this.score.score(id);
      if (score < this.opts.scoreThresholds.gossipThreshold) {
        this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
        this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
        return [];
      }
      const peerhave = (this.peerhave.get(id) ?? 0) + 1;
      this.peerhave.set(id, peerhave);
      if (peerhave > GossipsubMaxIHaveMessages) {
        this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
        this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
        return [];
      }
      const iasked = this.iasked.get(id) ?? 0;
      if (iasked >= GossipsubMaxIHaveLength) {
        this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
        this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
        return [];
      }
      const iwant = new Map;
      ihave.forEach(({ topicID, messageIDs }) => {
        if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
          return;
        }
        let idonthave = 0;
        messageIDs.forEach((msgId2) => {
          const msgIdStr = this.msgIdToStrFn(msgId2);
          if (!this.seenCache.has(msgIdStr)) {
            iwant.set(msgIdStr, msgId2);
            idonthave++;
          }
        });
        this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);
      });
      if (!iwant.size) {
        return [];
      }
      let iask = iwant.size;
      if (iask + iasked > GossipsubMaxIHaveLength) {
        iask = GossipsubMaxIHaveLength - iasked;
      }
      this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
      let iwantList = Array.from(iwant.values());
      shuffle(iwantList);
      iwantList = iwantList.slice(0, iask);
      this.iasked.set(id, iasked + iask);
      return [
        {
          messageIDs: iwantList
        }
      ];
    }
    handleIWant(id, iwant) {
      if (!iwant.length) {
        return [];
      }
      const score = this.score.score(id);
      if (score < this.opts.scoreThresholds.gossipThreshold) {
        this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
        return [];
      }
      const ihave = new Map;
      const iwantByTopic = new Map;
      let iwantDonthave = 0;
      iwant.forEach(({ messageIDs }) => {
        messageIDs && messageIDs.forEach((msgId2) => {
          const msgIdStr = this.msgIdToStrFn(msgId2);
          const entry = this.mcache.getWithIWantCount(msgIdStr, id);
          if (entry == null) {
            iwantDonthave++;
            return;
          }
          iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
          if (entry.count > GossipsubGossipRetransmission) {
            this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
            return;
          }
          ihave.set(msgIdStr, entry.msg);
        });
      });
      this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);
      if (!ihave.size) {
        this.log("IWANT: Could not provide any wanted messages to %s", id);
        return [];
      }
      this.log("IWANT: Sending %d messages to %s", ihave.size, id);
      return Array.from(ihave.values());
    }
    async handleGraft(id, graft) {
      const prune = [];
      const score = this.score.score(id);
      const now = Date.now();
      let doPX = this.opts.doPX;
      graft.forEach(({ topicID }) => {
        if (!topicID) {
          return;
        }
        const peersInMesh = this.mesh.get(topicID);
        if (!peersInMesh) {
          doPX = false;
          return;
        }
        if (peersInMesh.has(id)) {
          return;
        }
        if (this.direct.has(id)) {
          this.log("GRAFT: ignoring request from direct peer %s", id);
          prune.push(topicID);
          doPX = false;
          return;
        }
        const expire = this.backoff.get(topicID)?.get(id);
        if (typeof expire === "number" && now < expire) {
          this.log("GRAFT: ignoring backed off peer %s", id);
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
          doPX = false;
          const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
          if (now < floodCutoff) {
            this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
          }
          this.addBackoff(id, topicID);
          prune.push(topicID);
          return;
        }
        if (score < 0) {
          this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
          prune.push(topicID);
          doPX = false;
          this.addBackoff(id, topicID);
          return;
        }
        if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {
          prune.push(topicID);
          this.addBackoff(id, topicID);
          return;
        }
        this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
        this.score.graft(id, topicID);
        peersInMesh.add(id);
        this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
      });
      if (!prune.length) {
        return [];
      }
      const onUnsubscribe = false;
      return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX, onUnsubscribe)));
    }
    async handlePrune(id, prune) {
      const score = this.score.score(id);
      for (const { topicID, backoff, peers } of prune) {
        if (topicID == null) {
          continue;
        }
        const peersInMesh = this.mesh.get(topicID);
        if (!peersInMesh) {
          return;
        }
        this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
        this.score.prune(id, topicID);
        if (peersInMesh.has(id)) {
          peersInMesh.delete(id);
          this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Prune, 1);
        }
        if (typeof backoff === "number" && backoff > 0) {
          this.doAddBackoff(id, topicID, backoff * 1000);
        } else {
          this.addBackoff(id, topicID);
        }
        if (peers && peers.length) {
          if (score < this.opts.scoreThresholds.acceptPXThreshold) {
            this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
            continue;
          }
          await this.pxConnect(peers);
        }
      }
    }
    addBackoff(id, topic) {
      this.doAddBackoff(id, topic, this.opts.pruneBackoff);
    }
    doAddBackoff(id, topic, intervalMs) {
      let backoff = this.backoff.get(topic);
      if (!backoff) {
        backoff = new Map;
        this.backoff.set(topic, backoff);
      }
      const expire = Date.now() + intervalMs;
      const existingExpire = backoff.get(id) ?? 0;
      if (existingExpire < expire) {
        backoff.set(id, expire);
      }
    }
    applyIwantPenalties() {
      this.gossipTracer.getBrokenPromises().forEach((count, p) => {
        this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
        this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);
      });
    }
    clearBackoff() {
      if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
        return;
      }
      const now = Date.now();
      this.backoff.forEach((backoff, topic) => {
        backoff.forEach((expire, id) => {
          if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {
            backoff.delete(id);
          }
        });
        if (backoff.size === 0) {
          this.backoff.delete(topic);
        }
      });
    }
    async directConnect() {
      const toconnect = [];
      this.direct.forEach((id) => {
        if (!this.streamsOutbound.has(id)) {
          toconnect.push(id);
        }
      });
      await Promise.all(toconnect.map(async (id) => await this.connect(id)));
    }
    async pxConnect(peers) {
      if (peers.length > this.opts.prunePeers) {
        shuffle(peers);
        peers = peers.slice(0, this.opts.prunePeers);
      }
      const toconnect = [];
      await Promise.all(peers.map(async (pi) => {
        if (!pi.peerID) {
          return;
        }
        const peer = peerIdFromBytes(pi.peerID);
        const p = peer.toString();
        if (this.peers.has(p)) {
          return;
        }
        if (!pi.signedPeerRecord) {
          toconnect.push(p);
          return;
        }
        try {
          if (!await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer)) {
            this.log("bogus peer record obtained through px: could not add peer record to address book");
            return;
          }
          toconnect.push(p);
        } catch (e) {
          this.log("bogus peer record obtained through px: invalid signature or not a peer record");
        }
      }));
      if (!toconnect.length) {
        return;
      }
      await Promise.all(toconnect.map(async (id) => await this.connect(id)));
    }
    async connect(id) {
      this.log("Initiating connection with %s", id);
      const peerId = peerIdFromString(id);
      const connection = await this.components.connectionManager.openConnection(peerId);
      for (const multicodec of this.multicodecs) {
        for (const topology of this.components.registrar.getTopologies(multicodec)) {
          topology.onConnect?.(peerId, connection);
        }
      }
    }
    subscribe(topic) {
      if (this.status.code !== GossipStatusCode.started) {
        throw new Error("Pubsub has not started");
      }
      if (!this.subscriptions.has(topic)) {
        this.subscriptions.add(topic);
        for (const peerId of this.peers.keys()) {
          this.sendSubscriptions(peerId, [topic], true);
        }
      }
      this.join(topic);
    }
    unsubscribe(topic) {
      if (this.status.code !== GossipStatusCode.started) {
        throw new Error("Pubsub is not started");
      }
      const wasSubscribed = this.subscriptions.delete(topic);
      this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
      if (wasSubscribed) {
        for (const peerId of this.peers.keys()) {
          this.sendSubscriptions(peerId, [topic], false);
        }
      }
      this.leave(topic);
    }
    join(topic) {
      if (this.status.code !== GossipStatusCode.started) {
        throw new Error("Gossipsub has not started");
      }
      if (this.mesh.has(topic)) {
        return;
      }
      this.log("JOIN %s", topic);
      this.metrics?.onJoin(topic);
      const toAdd = new Set;
      const backoff = this.backoff.get(topic);
      const fanoutPeers = this.fanout.get(topic);
      if (fanoutPeers) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
        fanoutPeers.forEach((id) => {
          if (!this.direct.has(id) && this.score.score(id) >= 0 && (!backoff || !backoff.has(id))) {
            toAdd.add(id);
          }
        });
        this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
      }
      if (toAdd.size < this.opts.D) {
        const fanoutCount = toAdd.size;
        const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && (!backoff || !backoff.has(id)));
        newPeers.forEach((peer) => {
          toAdd.add(peer);
        });
        this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
      }
      this.mesh.set(topic, toAdd);
      toAdd.forEach((id) => {
        this.log("JOIN: Add mesh link to %s in %s", id, topic);
        this.sendGraft(id, topic);
      });
    }
    leave(topic) {
      if (this.status.code !== GossipStatusCode.started) {
        throw new Error("Gossipsub has not started");
      }
      this.log("LEAVE %s", topic);
      this.metrics?.onLeave(topic);
      const meshPeers = this.mesh.get(topic);
      if (meshPeers) {
        Promise.all(Array.from(meshPeers).map(async (id) => {
          this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
          return await this.sendPrune(id, topic);
        })).catch((err) => {
          this.log("Error sending prunes to mesh peers", err);
        });
        this.mesh.delete(topic);
      }
    }
    selectPeersToForward(topic, propagationSource, excludePeers) {
      const tosend = new Set;
      const peersInTopic = this.topics.get(topic);
      if (peersInTopic) {
        this.direct.forEach((peer) => {
          if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {
            tosend.add(peer);
          }
        });
        this.floodsubPeers.forEach((peer) => {
          if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(peer);
          }
        });
      }
      const meshPeers = this.mesh.get(topic);
      if (meshPeers && meshPeers.size > 0) {
        meshPeers.forEach((peer) => {
          if (propagationSource !== peer && !excludePeers?.has(peer)) {
            tosend.add(peer);
          }
        });
      }
      return tosend;
    }
    selectPeersToPublish(topic) {
      const tosend = new Set;
      const tosendCount = {
        direct: 0,
        floodsub: 0,
        mesh: 0,
        fanout: 0
      };
      const peersInTopic = this.topics.get(topic);
      if (peersInTopic) {
        if (this.opts.floodPublish) {
          peersInTopic.forEach((id) => {
            if (this.direct.has(id)) {
              tosend.add(id);
              tosendCount.direct++;
            } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
              tosend.add(id);
              tosendCount.floodsub++;
            }
          });
        } else {
          this.direct.forEach((id) => {
            if (peersInTopic.has(id)) {
              tosend.add(id);
              tosendCount.direct++;
            }
          });
          this.floodsubPeers.forEach((id) => {
            if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
              tosend.add(id);
              tosendCount.floodsub++;
            }
          });
          const meshPeers = this.mesh.get(topic);
          if (meshPeers && meshPeers.size > 0) {
            meshPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.mesh++;
            });
          } else {
            const fanoutPeers = this.fanout.get(topic);
            if (fanoutPeers && fanoutPeers.size > 0) {
              fanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            } else {
              const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
                return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
              });
              if (newFanoutPeers.size > 0) {
                this.fanout.set(topic, newFanoutPeers);
                newFanoutPeers.forEach((peer) => {
                  tosend.add(peer);
                  tosendCount.fanout++;
                });
              }
            }
            this.fanoutLastpub.set(topic, Date.now());
          }
        }
      }
      return { tosend, tosendCount };
    }
    forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
      if (propagationSource) {
        this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
      }
      const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
      tosend.forEach((id) => {
        this.sendRpc(id, { messages: [rawMsg] });
      });
      this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);
    }
    async publish(topic, data, opts) {
      const startMs = Date.now();
      const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;
      if (this.publishConfig == null) {
        throw Error("PublishError.Uninitialized");
      }
      const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
      const msgId2 = await this.msgIdFn(msg);
      const msgIdStr = this.msgIdToStrFn(msgId2);
      const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError;
      if (this.seenCache.has(msgIdStr)) {
        if (ignoreDuplicatePublishError) {
          this.metrics?.onPublishDuplicateMsg(topic);
          return { recipients: [] };
        }
        throw Error("PublishError.Duplicate");
      }
      const { tosend, tosendCount } = this.selectPeersToPublish(topic);
      const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic);
      const allowPublishToZeroPeers = opts?.allowPublishToZeroPeers ?? this.opts.allowPublishToZeroPeers;
      if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {
        throw Error("PublishError.InsufficientPeers");
      }
      this.seenCache.put(msgIdStr);
      this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
      this.publishedMessageIds.put(msgIdStr);
      for (const id of tosend) {
        const sent = this.sendRpc(id, { messages: [rawMsg] });
        if (!sent) {
          tosend.delete(id);
        }
      }
      const durationMs = Date.now() - startMs;
      this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0, durationMs);
      if (willSendToSelf) {
        tosend.add(this.components.peerId.toString());
        super.dispatchEvent(new CustomEvent("gossipsub:message", {
          detail: {
            propagationSource: this.components.peerId,
            msgId: msgIdStr,
            msg
          }
        }));
        super.dispatchEvent(new CustomEvent("message", { detail: msg }));
      }
      return {
        recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))
      };
    }
    reportMessageValidationResult(msgId2, propagationSource, acceptance) {
      let cacheEntry;
      if (acceptance === TopicValidatorResult.Accept) {
        cacheEntry = this.mcache.validate(msgId2);
        if (cacheEntry != null) {
          const { message: rawMsg, originatingPeers } = cacheEntry;
          this.score.deliverMessage(propagationSource, msgId2, rawMsg.topic);
          this.forwardMessage(msgId2, cacheEntry.message, propagationSource, originatingPeers);
        }
      } else {
        cacheEntry = this.mcache.remove(msgId2);
        if (cacheEntry) {
          const rejectReason = rejectReasonFromAcceptance(acceptance);
          const { message: rawMsg, originatingPeers } = cacheEntry;
          this.score.rejectMessage(propagationSource, msgId2, rawMsg.topic, rejectReason);
          for (const peer of originatingPeers) {
            this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
          }
        }
      }
      const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId2);
      this.metrics?.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs);
    }
    sendGraft(id, topic) {
      const graft = [
        {
          topicID: topic
        }
      ];
      this.sendRpc(id, { control: { graft } });
    }
    async sendPrune(id, topic) {
      const onUnsubscribe = true;
      const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)];
      this.sendRpc(id, { control: { prune } });
    }
    sendRpc(id, rpc2) {
      const outboundStream = this.streamsOutbound.get(id);
      if (!outboundStream) {
        this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
        return false;
      }
      const ctrl = this.control.get(id);
      if (ctrl) {
        this.piggybackControl(id, rpc2, ctrl);
        this.control.delete(id);
      }
      const ihave = this.gossip.get(id);
      if (ihave) {
        this.piggybackGossip(id, rpc2, ihave);
        this.gossip.delete(id);
      }
      const rpcBytes = RPC.encode(rpc2).finish();
      try {
        outboundStream.push(rpcBytes);
      } catch (e) {
        this.log.error(`Cannot send rpc to ${id}`, e);
        if (ctrl) {
          this.control.set(id, ctrl);
        }
        if (ihave) {
          this.gossip.set(id, ihave);
        }
        return false;
      }
      this.metrics?.onRpcSent(rpc2, rpcBytes.length);
      return true;
    }
    piggybackControl(id, outRpc, ctrl) {
      if (ctrl.graft) {
        if (!outRpc.control)
          outRpc.control = {};
        if (!outRpc.control.graft)
          outRpc.control.graft = [];
        for (const graft of ctrl.graft) {
          if (graft.topicID && this.mesh.get(graft.topicID)?.has(id)) {
            outRpc.control.graft.push(graft);
          }
        }
      }
      if (ctrl.prune) {
        if (!outRpc.control)
          outRpc.control = {};
        if (!outRpc.control.prune)
          outRpc.control.prune = [];
        for (const prune of ctrl.prune) {
          if (prune.topicID && !this.mesh.get(prune.topicID)?.has(id)) {
            outRpc.control.prune.push(prune);
          }
        }
      }
    }
    piggybackGossip(id, outRpc, ihave) {
      if (!outRpc.control)
        outRpc.control = {};
      outRpc.control.ihave = ihave;
    }
    async sendGraftPrune(tograft, toprune, noPX) {
      const doPX = this.opts.doPX;
      const onUnsubscribe = false;
      for (const [id, topics] of tograft) {
        const graft = topics.map((topicID) => ({ topicID }));
        let prune = [];
        const pruning = toprune.get(id);
        if (pruning) {
          prune = await Promise.all(pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
          toprune.delete(id);
        }
        this.sendRpc(id, { control: { graft, prune } });
      }
      for (const [id, topics] of toprune) {
        const prune = await Promise.all(topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
        this.sendRpc(id, { control: { prune } });
      }
    }
    emitGossip(peersToGossipByTopic) {
      const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
      for (const [topic, peersToGossip] of peersToGossipByTopic) {
        this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
      }
    }
    doEmitGossip(topic, candidateToGossip, messageIDs) {
      if (!messageIDs.length) {
        return;
      }
      shuffle(messageIDs);
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
      }
      if (!candidateToGossip.size)
        return;
      let target = this.opts.Dlazy;
      const factor = GossipsubGossipFactor * candidateToGossip.size;
      let peersToGossip = candidateToGossip;
      if (factor > target) {
        target = factor;
      }
      if (target > peersToGossip.size) {
        target = peersToGossip.size;
      } else {
        peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
      }
      peersToGossip.forEach((id) => {
        let peerMessageIDs = messageIDs;
        if (messageIDs.length > GossipsubMaxIHaveLength) {
          peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
        }
        this.pushGossip(id, {
          topicID: topic,
          messageIDs: peerMessageIDs
        });
      });
    }
    flush() {
      for (const [peer, ihave] of this.gossip.entries()) {
        this.gossip.delete(peer);
        this.sendRpc(peer, { control: { ihave } });
      }
      for (const [peer, control] of this.control.entries()) {
        this.control.delete(peer);
        this.sendRpc(peer, { control: { graft: control.graft, prune: control.prune } });
      }
    }
    pushGossip(id, controlIHaveMsgs) {
      this.log("Add gossip to %s", id);
      const gossip = this.gossip.get(id) || [];
      this.gossip.set(id, gossip.concat(controlIHaveMsgs));
    }
    async makePrune(id, topic, doPX, onUnsubscribe) {
      this.score.prune(id, topic);
      if (this.streamsOutbound.get(id).protocol === GossipsubIDv10) {
        return {
          topicID: topic,
          peers: []
        };
      }
      const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff;
      const backoff = backoffMs / 1000;
      this.doAddBackoff(id, topic, backoffMs);
      if (!doPX) {
        return {
          topicID: topic,
          peers: [],
          backoff
        };
      }
      const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
        return xid !== id && this.score.score(xid) >= 0;
      });
      const px = await Promise.all(Array.from(peers).map(async (peerId) => {
        const id2 = peerIdFromString(peerId);
        let peerInfo;
        try {
          peerInfo = await this.components.peerStore.get(id2);
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            throw err;
          }
        }
        return {
          peerID: id2.toBytes(),
          signedPeerRecord: peerInfo?.peerRecordEnvelope
        };
      }));
      return {
        topicID: topic,
        peers: px,
        backoff
      };
    }
    async heartbeat() {
      const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
      this.heartbeatTicks++;
      const scores = new Map;
      const getScore = (id) => {
        let s2 = scores.get(id);
        if (s2 === undefined) {
          s2 = this.score.score(id);
          scores.set(id, s2);
        }
        return s2;
      };
      const tograft = new Map;
      const toprune = new Map;
      const noPX = new Map;
      this.clearBackoff();
      this.peerhave.clear();
      this.metrics?.cacheSize.set({ cache: "iasked" }, this.iasked.size);
      this.iasked.clear();
      this.applyIwantPenalties();
      if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
        await this.directConnect();
      }
      this.fastMsgIdCache?.prune();
      this.seenCache.prune();
      this.gossipTracer.prune();
      this.publishedMessageIds.prune();
      const peersToGossipByTopic = new Map;
      this.mesh.forEach((peers, topic) => {
        const peersInTopic = this.topics.get(topic);
        const candidateMeshPeers = new Set;
        const peersToGossip = new Set;
        peersToGossipByTopic.set(topic, peersToGossip);
        if (peersInTopic) {
          const shuffledPeers = shuffle(Array.from(peersInTopic));
          const backoff = this.backoff.get(topic);
          for (const id of shuffledPeers) {
            const peerStreams = this.streamsOutbound.get(id);
            if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
              const score = getScore(id);
              if ((!backoff || !backoff.has(id)) && score >= 0)
                candidateMeshPeers.add(id);
              if (score >= this.opts.scoreThresholds.gossipThreshold)
                peersToGossip.add(id);
            }
          }
        }
        const prunePeer = (id, reason) => {
          this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
          this.addBackoff(id, topic);
          peers.delete(id);
          if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
            peersToGossip.add(id);
          this.metrics?.onRemoveFromMesh(topic, reason, 1);
          const topics = toprune.get(id);
          if (!topics) {
            toprune.set(id, [topic]);
          } else {
            topics.push(topic);
          }
        };
        const graftPeer = (id, reason) => {
          this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
          this.score.graft(id, topic);
          peers.add(id);
          peersToGossip.delete(id);
          this.metrics?.onAddToMesh(topic, reason, 1);
          const topics = tograft.get(id);
          if (!topics) {
            tograft.set(id, [topic]);
          } else {
            topics.push(topic);
          }
        };
        peers.forEach((id) => {
          const score = getScore(id);
          if (score < 0) {
            this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
            prunePeer(id, ChurnReason.BadScore);
            noPX.set(id, true);
          }
        });
        if (peers.size < Dlo) {
          const ineed = D - peers.size;
          const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
          newMeshPeers.forEach((p) => {
            graftPeer(p, InclusionReason.NotEnough);
          });
        }
        if (peers.size > Dhi) {
          let peersArray = Array.from(peers);
          peersArray.sort((a, b) => getScore(b) - getScore(a));
          peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
          let outbound = 0;
          peersArray.slice(0, D).forEach((p) => {
            if (this.outbound.get(p)) {
              outbound++;
            }
          });
          if (outbound < Dout) {
            const rotate = (i) => {
              const p = peersArray[i];
              for (let j = i;j > 0; j--) {
                peersArray[j] = peersArray[j - 1];
              }
              peersArray[0] = p;
            };
            if (outbound > 0) {
              let ihave = outbound;
              for (let i = 1;i < D && ihave > 0; i++) {
                if (this.outbound.get(peersArray[i])) {
                  rotate(i);
                  ihave--;
                }
              }
            }
            let ineed = D - outbound;
            for (let i = D;i < peersArray.length && ineed > 0; i++) {
              if (this.outbound.get(peersArray[i])) {
                rotate(i);
                ineed--;
              }
            }
          }
          peersArray.slice(D).forEach((p) => {
            prunePeer(p, ChurnReason.Excess);
          });
        }
        if (peers.size >= Dlo) {
          let outbound = 0;
          peers.forEach((p) => {
            if (this.outbound.get(p)) {
              outbound++;
            }
          });
          if (outbound < Dout) {
            const ineed = Dout - outbound;
            const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
            newMeshPeers.forEach((p) => {
              graftPeer(p, InclusionReason.Outbound);
            });
          }
        }
        if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
          const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
          const medianIndex = Math.floor(peers.size / 2);
          const medianScore = getScore(peersList[medianIndex]);
          if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
            const ineed = this.opts.opportunisticGraftPeers;
            const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
            for (const id of newMeshPeers) {
              this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
              graftPeer(id, InclusionReason.Opportunistic);
            }
          }
        }
      });
      const now = Date.now();
      this.fanoutLastpub.forEach((lastpb, topic) => {
        if (lastpb + fanoutTTL < now) {
          this.fanout.delete(topic);
          this.fanoutLastpub.delete(topic);
        }
      });
      this.fanout.forEach((fanoutPeers, topic) => {
        const topicPeers = this.topics.get(topic);
        fanoutPeers.forEach((id) => {
          if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
            fanoutPeers.delete(id);
          }
        });
        const peersInTopic = this.topics.get(topic);
        const candidateFanoutPeers = [];
        const peersToGossip = new Set;
        peersToGossipByTopic.set(topic, peersToGossip);
        if (peersInTopic) {
          const shuffledPeers = shuffle(Array.from(peersInTopic));
          for (const id of shuffledPeers) {
            const peerStreams = this.streamsOutbound.get(id);
            if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
              const score = getScore(id);
              if (score >= this.opts.scoreThresholds.publishThreshold)
                candidateFanoutPeers.push(id);
              if (score >= this.opts.scoreThresholds.gossipThreshold)
                peersToGossip.add(id);
            }
          }
        }
        if (fanoutPeers.size < D) {
          const ineed = D - fanoutPeers.size;
          candidateFanoutPeers.slice(0, ineed).forEach((id) => {
            fanoutPeers.add(id);
            peersToGossip?.delete(id);
          });
        }
      });
      this.emitGossip(peersToGossipByTopic);
      await this.sendGraftPrune(tograft, toprune, noPX);
      this.flush();
      this.mcache.shift();
      this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
    }
    getRandomGossipPeers(topic, count, filter2 = () => true) {
      const peersInTopic = this.topics.get(topic);
      if (!peersInTopic) {
        return new Set;
      }
      let peers = [];
      peersInTopic.forEach((id) => {
        const peerStreams = this.streamsOutbound.get(id);
        if (!peerStreams) {
          return;
        }
        if (this.multicodecs.includes(peerStreams.protocol) && filter2(id)) {
          peers.push(id);
        }
      });
      peers = shuffle(peers);
      if (count > 0 && peers.length > count) {
        peers = peers.slice(0, count);
      }
      return new Set(peers);
    }
    onScrapeMetrics(metrics) {
      metrics.mcacheSize.set(this.mcache.size);
      metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount);
      metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
      metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
      metrics.cacheSize.set({ cache: "fastMsgIdCache" }, this.fastMsgIdCache?.size ?? 0);
      metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
      metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
      metrics.cacheSize.set({ cache: "score" }, this.score.size);
      metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
      metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
      metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
      metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
      metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
      metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
      metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
      metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
      metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
      metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
      metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
      metrics.cacheSize.set({ cache: "control" }, this.control.size);
      metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
      metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
      let backoffSize = 0;
      const now = Date.now();
      metrics.connectedPeersBackoffSec.reset();
      for (const backoff of this.backoff.values()) {
        backoffSize += backoff.size;
        for (const [peer, expiredMs] of backoff.entries()) {
          if (this.peers.has(peer)) {
            metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1000);
          }
        }
      }
      metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
      for (const [topicStr, peers] of this.topics) {
        metrics.topicPeersCount.set({ topicStr }, peers.size);
      }
      for (const [topicStr, peers] of this.mesh) {
        metrics.meshPeerCounts.set({ topicStr }, peers.size);
      }
      const scores = [];
      const scoreByPeer = new Map;
      metrics.behaviourPenalty.reset();
      for (const peerIdStr of this.peers.keys()) {
        const score = this.score.score(peerIdStr);
        scores.push(score);
        scoreByPeer.set(peerIdStr, score);
        metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);
      }
      metrics.registerScores(scores, this.opts.scoreThresholds);
      metrics.registerScorePerMesh(this.mesh, scoreByPeer);
      const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
      metrics.registerScoreWeights(sw);
    }
  }
  GossipSub.multicodec = GossipsubIDv11;
  var RelayCodecs = ["/vac/waku/relay/2.0.0"];
  var log$n = debug("waku:relay");
  var log$m = debug("waku:message:topic-only");

  class TopicOnlyMessage {
    constructor(pubSubTopic, proto) {
      this.payload = new Uint8Array;
      this.pubSubTopic = pubSubTopic;
      this.proto = proto;
    }
    get contentTopic() {
      return this.proto.contentTopic;
    }
  }

  class TopicOnlyDecoder {
    constructor() {
      this.contentTopic = "";
    }
    fromWireToProtoObj(bytes2) {
      const protoMessage = TopicOnlyMessage$1.decode(bytes2);
      log$m("Message decoded", protoMessage);
      return Promise.resolve({
        contentTopic: protoMessage.contentTopic,
        payload: new Uint8Array,
        rateLimitProof: undefined,
        timestamp: undefined,
        meta: undefined,
        version: undefined,
        ephemeral: undefined
      });
    }
    async fromProtoObj(pubSubTopic, proto) {
      return new TopicOnlyMessage(pubSubTopic, proto);
    }
  }
  var log$l = debug("waku:relay");

  class Relay {
    constructor(libp2p, options) {
      if (!this.isRelayPubSub(libp2p.services.pubsub)) {
        throw Error(`Failed to initialize Relay. libp2p.pubsub does not support ${Relay.multicodec}`);
      }
      this.gossipSub = libp2p.services.pubsub;
      this.pubSubTopic = options?.pubSubTopic ?? DefaultPubSubTopic;
      if (this.gossipSub.isStarted()) {
        this.gossipSubSubscribe(this.pubSubTopic);
      }
      this.observers = new Map;
      this.defaultDecoder = new TopicOnlyDecoder;
    }
    async start() {
      if (this.gossipSub.isStarted()) {
        throw Error("GossipSub already started.");
      }
      await this.gossipSub.start();
      this.gossipSubSubscribe(this.pubSubTopic);
    }
    async send(encoder2, message2) {
      const recipients = [];
      if (!isSizeValid(message2.payload)) {
        log$l("Failed to send waku relay: message is bigger that 1MB");
        return {
          recipients,
          errors: [SendError.SIZE_TOO_BIG]
        };
      }
      const msg = await encoder2.toWire(message2);
      if (!msg) {
        log$l("Failed to encode message, aborting publish");
        return {
          recipients,
          errors: [SendError.ENCODE_FAILED]
        };
      }
      return this.gossipSub.publish(this.pubSubTopic, msg);
    }
    subscribe(decoders2, callback) {
      const contentTopicToObservers = Array.isArray(decoders2) ? toObservers(decoders2, callback) : toObservers([decoders2], callback);
      for (const contentTopic of contentTopicToObservers.keys()) {
        const currObservers = this.observers.get(contentTopic) || new Set;
        const newObservers = contentTopicToObservers.get(contentTopic) || new Set;
        this.observers.set(contentTopic, union(currObservers, newObservers));
      }
      return () => {
        for (const contentTopic of contentTopicToObservers.keys()) {
          const currentObservers = this.observers.get(contentTopic) || new Set;
          const observersToRemove = contentTopicToObservers.get(contentTopic) || new Set;
          const nextObservers = leftMinusJoin(currentObservers, observersToRemove);
          if (nextObservers.size) {
            this.observers.set(contentTopic, nextObservers);
          } else {
            this.observers.delete(contentTopic);
          }
        }
      };
    }
    toSubscriptionIterator(decoders2) {
      return toAsyncIterator(this, decoders2);
    }
    getActiveSubscriptions() {
      const map2 = new Map;
      map2.set(this.pubSubTopic, this.observers.keys());
      return map2;
    }
    getMeshPeers(topic) {
      return this.gossipSub.getMeshPeers(topic ?? this.pubSubTopic);
    }
    async processIncomingMessage(pubSubTopic, bytes2) {
      const topicOnlyMsg = await this.defaultDecoder.fromWireToProtoObj(bytes2);
      if (!topicOnlyMsg || !topicOnlyMsg.contentTopic) {
        log$l("Message does not have a content topic, skipping");
        return;
      }
      const observers = this.observers.get(topicOnlyMsg.contentTopic);
      if (!observers) {
        return;
      }
      await Promise.all(Array.from(observers).map(({ decoder, callback }) => {
        return (async () => {
          try {
            const protoMsg = await decoder.fromWireToProtoObj(bytes2);
            if (!protoMsg) {
              log$l("Internal error: message previously decoded failed on 2nd pass.");
              return;
            }
            const msg = await decoder.fromProtoObj(pubSubTopic, protoMsg);
            if (msg) {
              await callback(msg);
            } else {
              log$l("Failed to decode messages on", topicOnlyMsg.contentTopic);
            }
          } catch (error) {
            log$l("Error while decoding message:", error);
          }
        })();
      }));
    }
    gossipSubSubscribe(pubSubTopic) {
      this.gossipSub.addEventListener("gossipsub:message", (event) => {
        if (event.detail.msg.topic !== pubSubTopic)
          return;
        log$l(`Message received on ${pubSubTopic}`);
        this.processIncomingMessage(event.detail.msg.topic, event.detail.msg.data).catch((e) => log$l("Failed to process incoming message", e));
      });
      this.gossipSub.topicValidators.set(pubSubTopic, messageValidator);
      this.gossipSub.subscribe(pubSubTopic);
    }
    isRelayPubSub(pubsub) {
      return pubsub?.multicodecs?.includes(Relay.multicodec) || false;
    }
  }
  Relay.multicodec = RelayCodecs[0];
  var index = Object.freeze({
    __proto__: null,
    wakuGossipSub,
    wakuRelay
  });
  exports.relay = index;
  var events$1 = { exports: {} };
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
  };
  events$1.exports = EventEmitter$1;
  events$1.exports.once = once;
  EventEmitter$1.EventEmitter = EventEmitter$1;
  EventEmitter$1.prototype._events = undefined;
  EventEmitter$1.prototype._eventsCount = 0;
  EventEmitter$1.prototype._maxListeners = undefined;
  var defaultMaxListeners = 10;
  Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter$1.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
  };
  EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter$1.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1;i < arguments.length; i++)
      args.push(arguments[i]);
    var doError = type === "error";
    var events2 = this._events;
    if (events2 !== undefined)
      doError = doError && events2.error === undefined;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type];
    if (handler === undefined)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0;i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }
    return true;
  };
  EventEmitter$1.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
  EventEmitter$1.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };
  EventEmitter$1.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter$1.prototype.removeListener = function removeListener(type, listener) {
    var list, events2, position, i, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === undefined)
      return this;
    list = events2[type];
    if (list === undefined)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = Object.create(null);
      else {
        delete events2[type];
        if (events2.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length - 1;i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type] = list[0];
      if (events2.removeListener !== undefined)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
  EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events2, i;
    events2 = this._events;
    if (events2 === undefined)
      return this;
    if (events2.removeListener === undefined) {
      if (arguments.length === 0) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type] !== undefined) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else
          delete events2[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key;
      for (i = 0;i < keys.length; ++i) {
        key = keys[i];
        if (key === "removeListener")
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type];
    if (typeof listeners === "function") {
      this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
      for (i = listeners.length - 1;i >= 0; i--) {
        this.removeListener(type, listeners[i]);
      }
    }
    return this;
  };
  EventEmitter$1.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  EventEmitter$1.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  EventEmitter$1.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  EventEmitter$1.prototype.listenerCount = listenerCount;
  EventEmitter$1.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  var eventsExports = events$1.exports;
  var src$5 = base$5;
  var _brrp__multiformats_scope_baseX$5 = src$5;
  var coerce$5 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$5 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$5 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$5(this, decoder);
    }
  };
  var ComposedDecoder$5 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$5(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$5 = (left2, right2) => new ComposedDecoder$5({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$5 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$5(name2, prefix, baseEncode);
      this.decoder = new Decoder$5(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$9 = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$5(name2, prefix, encode3, decode3);
  var baseX$5 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$5(alphabet2, name2);
    return from$9({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$5(decode3(text))
    });
  };
  var decode$9 = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$e = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$5 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$9({
      prefix,
      name: name2,
      encode(input) {
        return encode$e(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$9(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base58btc$5 = baseX$5({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$5({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var encode_1$3 = encode$d;
  var MSB$4 = 128;
  var REST$4 = 127;
  var MSBALL$3 = ~REST$4;
  var INT$3 = Math.pow(2, 31);
  var decode$8 = read$4;
  var MSB$1$3 = 128;
  var REST$1$3 = 127;
  var N1$3 = Math.pow(2, 7);
  var N2$3 = Math.pow(2, 14);
  var N3$3 = Math.pow(2, 21);
  var N4$3 = Math.pow(2, 28);
  var N5$3 = Math.pow(2, 35);
  var N6$3 = Math.pow(2, 42);
  var N7$3 = Math.pow(2, 49);
  var N8$3 = Math.pow(2, 56);
  var N9$3 = Math.pow(2, 63);
  var length$3 = function(value) {
    return value < N1$3 ? 1 : value < N2$3 ? 2 : value < N3$3 ? 3 : value < N4$3 ? 4 : value < N5$3 ? 5 : value < N6$3 ? 6 : value < N7$3 ? 7 : value < N8$3 ? 8 : value < N9$3 ? 9 : 10;
  };
  var varint$3 = {
    encode: encode_1$3,
    decode: decode$8,
    encodingLength: length$3
  };
  var _brrp_varint$3 = varint$3;
  var encodeTo$3 = (int, target, offset = 0) => {
    _brrp_varint$3.encode(int, target, offset);
    return target;
  };
  var encodingLength$3 = (int) => {
    return _brrp_varint$3.encodingLength(int);
  };
  var create$7 = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength$3(code2);
    const digestOffset = sizeOffset + encodingLength$3(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo$3(code2, bytes2, 0);
    encodeTo$3(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest$3(code2, size, digest2, bytes2);
  };
  var Digest$3 = class Digest2 {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  };
  var code$3 = 0;
  var name$3 = "identity";
  var encode$c = coerce$5;
  var digest$3 = (input) => create$7(code$3, encode$c(input));
  var identity$3 = { code: code$3, name: name$3, encode: encode$c, digest: digest$3 };
  var from$8 = ({ name: name2, code: code2, encode: encode3 }) => new Hasher$3(name2, code2, encode3);
  var Hasher$3 = class Hasher2 {
    constructor(name2, code2, encode3) {
      this.name = name2;
      this.code = code2;
      this.encode = encode3;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create$7(this.code, result) : result.then((digest2) => create$7(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var sha$3 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
  var sha256$4 = from$8({
    name: "sha2-256",
    code: 18,
    encode: sha$3("SHA-256")
  });
  var PUBLIC_KEY_BYTE_LENGTH$3 = 32;
  var PRIVATE_KEY_BYTE_LENGTH$3 = 64;
  var KEYS_BYTE_LENGTH$3 = 32;
  var base64$5 = rfc4648$5({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$5({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$5({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$5({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var webcrypto$3 = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto == null || nativeCrypto.subtle == null) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    }
  };
  var derivedEmptyPasswordKey$3 = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
  var KeyType$3;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["Secp256k1"] = "Secp256k1";
  })(KeyType$3 || (KeyType$3 = {}));
  var __KeyTypeValues$3;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
  })(__KeyTypeValues$3 || (__KeyTypeValues$3 = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues$3);
    };
  })(KeyType$3 || (KeyType$3 = {}));
  var PublicKey$3;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$3.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$3.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf) => {
      return decodeMessage$1(buf, PublicKey2.codec());
    };
  })(PublicKey$3 || (PublicKey$3 = {}));
  var PrivateKey$3;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$3.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$3.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf) => {
      return decodeMessage$1(buf, PrivateKey2.codec());
    };
  })(PrivateKey$3 || (PrivateKey$3 = {}));
  var Ed25519PublicKey$3 = class Ed25519PublicKey2 {
    constructor(key) {
      this._key = ensureKey$3(key, PUBLIC_KEY_BYTE_LENGTH$3);
    }
    async verify(data, sig) {
      return hashAndVerify$b(this._key, sig, data);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PublicKey$3.encode({
        Type: KeyType$3.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$4.digest(this.bytes);
      return bytes2;
    }
  };
  var Ed25519PrivateKey$3 = class Ed25519PrivateKey2 {
    constructor(key, publicKey) {
      this._key = ensureKey$3(key, PRIVATE_KEY_BYTE_LENGTH$3);
      this._publicKey = ensureKey$3(publicKey, PUBLIC_KEY_BYTE_LENGTH$3);
    }
    async sign(message2) {
      return hashAndSign$b(this._key, message2);
    }
    get public() {
      return new Ed25519PublicKey$3(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$3.encode({
        Type: KeyType$3.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$4.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const encoding = identity$3.digest(this.public.bytes);
      return base58btc$5.encode(encoding.bytes).substring(1);
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$3(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Ed25519$3 = Object.freeze({
    __proto__: null,
    Ed25519PrivateKey: Ed25519PrivateKey$3,
    Ed25519PublicKey: Ed25519PublicKey$3,
    generateKeyPair: generateKeyPair$d,
    generateKeyPairFromSeed: generateKeyPairFromSeed$3,
    unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey$3,
    unmarshalEd25519PublicKey: unmarshalEd25519PublicKey$3
  });
  var bits$3 = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  var curveTypes$3 = Object.keys(bits$3);
  curveTypes$3.join(" / ");
  var MAX_KEY_SIZE$3 = 8192;
  var RsaPublicKey$3 = class RsaPublicKey2 {
    constructor(key) {
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$a(this._key, sig, data);
    }
    marshal() {
      return jwkToPkix$3(this._key);
    }
    get bytes() {
      return PublicKey$3.encode({
        Type: KeyType$3.RSA,
        Data: this.marshal()
      }).subarray();
    }
    encrypt(bytes2) {
      return encrypt$3(this._key, bytes2);
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$4.digest(this.bytes);
      return bytes2;
    }
  };
  var RsaPrivateKey$3 = class RsaPrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey;
    }
    genSecret() {
      return randomBytes$3(16);
    }
    async sign(message2) {
      return hashAndSign$a(this._key, message2);
    }
    get public() {
      if (this._publicKey == null) {
        throw new CodeError$3("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
      }
      return new RsaPublicKey$3(this._publicKey);
    }
    decrypt(bytes2) {
      return decrypt$3(this._key, bytes2);
    }
    marshal() {
      return jwkToPkcs1$3(this._key);
    }
    get bytes() {
      return PrivateKey$3.encode({
        Type: KeyType$3.RSA,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$4.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "pkcs-8") {
      if (format4 === "pkcs-8") {
        const buffer = new forge$n.util.ByteBuffer(this.marshal());
        const asn12 = forge$n.asn1.fromDer(buffer);
        const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
        const options = {
          algorithm: "aes256",
          count: 1e4,
          saltSize: 128 / 8,
          prfAlgorithm: "sha512"
        };
        return forge$n.pki.encryptRsaPrivateKey(privateKey, password, options);
      } else if (format4 === "libp2p-key") {
        return exporter$3(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var RSA$3 = Object.freeze({
    __proto__: null,
    MAX_KEY_SIZE: MAX_KEY_SIZE$3,
    RsaPrivateKey: RsaPrivateKey$3,
    RsaPublicKey: RsaPublicKey$3,
    fromJwk: fromJwk$3,
    generateKeyPair: generateKeyPair$c,
    unmarshalRsaPrivateKey: unmarshalRsaPrivateKey$3,
    unmarshalRsaPublicKey: unmarshalRsaPublicKey$3
  });
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = new Uint32Array(64);

  class SHA256 extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }

  class SHA224 extends SHA256 {
    constructor() {
      super();
      this.A = 3238371032 | 0;
      this.B = 914150663 | 0;
      this.C = 812702999 | 0;
      this.D = 4144912697 | 0;
      this.E = 4290775857 | 0;
      this.F = 1750603025 | 0;
      this.G = 1694076839 | 0;
      this.H = 3204075428 | 0;
      this.outputLen = 28;
    }
  }
  var sha256$3 = wrapConstructor(() => new SHA256);
  wrapConstructor(() => new SHA224);
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
  var DER = {
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(data) {
      const { Err: E } = DER;
      if (data.length < 2 || data[0] !== 2)
        throw new E("Invalid signature integer tag");
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data.subarray(len + 2) };
    },
    toSig(hex) {
      const { Err: E } = DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      if (!(data instanceof Uint8Array))
        throw new Error("ui8a expected");
      let l = data.length;
      if (l < 2 || data[0] != 48)
        throw new E("Invalid signature tag");
      if (data[1] !== l - 2)
        throw new E("Invalid signature: incorrect length");
      const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
      const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r, s: s2 };
    },
    hexFromSig(sig) {
      const slice = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
      const h = (num) => {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      };
      const s2 = slice(h(sig.s));
      const r = slice(h(sig.r));
      const shl = s2.length / 2;
      const rhl = r.length / 2;
      const sl = h(shl);
      const rl = h(rhl);
      return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s2}`;
    }
  };
  var _0n = BigInt(0);
  var _1n$1 = BigInt(1);
  BigInt(2);
  var _3n = BigInt(3);
  BigInt(4);

  class HMAC extends Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      assert.hash(hash2);
      const key = toBytes$1(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0;i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i = 0;i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      assert.exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      assert.exists(this);
      assert.bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }
  var hmac = (hash2, key, message2) => new HMAC(hash2, key).update(message2).digest();
  hmac.create = (hash2, key) => new HMAC(hash2, key);
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var divNearest = (a, b) => (a + b / _2n) / b;
  var Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
  var secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod$2(k - c1 * a1 - c2 * a2, n);
        let k2 = mod$2(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256$3);
  BigInt(0);
  secp256k1.ProjectivePoint;
  var Secp256k1PublicKey$3 = class Secp256k1PublicKey2 {
    constructor(key) {
      validatePublicKey$3(key);
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$9(this._key, sig, data);
    }
    marshal() {
      return compressPublicKey$3(this._key);
    }
    get bytes() {
      return PublicKey$3.encode({
        Type: KeyType$3.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$4.digest(this.bytes);
      return bytes2;
    }
  };
  var Secp256k1PrivateKey$3 = class Secp256k1PrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey ?? computePublicKey$3(key);
      validatePrivateKey$3(this._key);
      validatePublicKey$3(this._publicKey);
    }
    async sign(message2) {
      return hashAndSign$9(this._key, message2);
    }
    get public() {
      return new Secp256k1PublicKey$3(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$3.encode({
        Type: KeyType$3.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$4.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$3(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Secp256k1$3 = Object.freeze({
    __proto__: null,
    Secp256k1PrivateKey: Secp256k1PrivateKey$3,
    Secp256k1PublicKey: Secp256k1PublicKey$3,
    generateKeyPair: generateKeyPair$b,
    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey$3,
    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey$3
  });
  var supportedKeys$3 = {
    rsa: RSA$3,
    ed25519: Ed25519$3,
    secp256k1: Secp256k1$3
  };
  var contentRouting = Symbol.for("@libp2p/content-routing");
  var peerRouting = Symbol.for("@libp2p/peer-routing");
  var webcrypto$2 = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto == null || nativeCrypto.subtle == null) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    }
  };
  var src$4 = base$4;
  var _brrp__multiformats_scope_baseX$4 = src$4;
  var coerce$4 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$4 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$4 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$4(this, decoder);
    }
  };
  var ComposedDecoder$4 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$4(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$4 = (left2, right2) => new ComposedDecoder$4({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$4 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$4(name2, prefix, baseEncode);
      this.decoder = new Decoder$4(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$7 = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$4(name2, prefix, encode3, decode3);
  var baseX$4 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$4(alphabet2, name2);
    return from$7({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$4(decode3(text))
    });
  };
  var decode$7 = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$b = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$4 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$7({
      prefix,
      name: name2,
      encode(input) {
        return encode$b(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$7(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base58btc$4 = baseX$4({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$4({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var encode_1$2 = encode$a;
  var MSB$3 = 128;
  var REST$3 = 127;
  var MSBALL$2 = ~REST$3;
  var INT$2 = Math.pow(2, 31);
  var decode$6 = read$3;
  var MSB$1$2 = 128;
  var REST$1$2 = 127;
  var N1$2 = Math.pow(2, 7);
  var N2$2 = Math.pow(2, 14);
  var N3$2 = Math.pow(2, 21);
  var N4$2 = Math.pow(2, 28);
  var N5$2 = Math.pow(2, 35);
  var N6$2 = Math.pow(2, 42);
  var N7$2 = Math.pow(2, 49);
  var N8$2 = Math.pow(2, 56);
  var N9$2 = Math.pow(2, 63);
  var length$2 = function(value) {
    return value < N1$2 ? 1 : value < N2$2 ? 2 : value < N3$2 ? 3 : value < N4$2 ? 4 : value < N5$2 ? 5 : value < N6$2 ? 6 : value < N7$2 ? 7 : value < N8$2 ? 8 : value < N9$2 ? 9 : 10;
  };
  var varint$2 = {
    encode: encode_1$2,
    decode: decode$6,
    encodingLength: length$2
  };
  var _brrp_varint$2 = varint$2;
  var encodeTo$2 = (int, target, offset = 0) => {
    _brrp_varint$2.encode(int, target, offset);
    return target;
  };
  var encodingLength$2 = (int) => {
    return _brrp_varint$2.encodingLength(int);
  };
  var create$5 = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength$2(code2);
    const digestOffset = sizeOffset + encodingLength$2(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo$2(code2, bytes2, 0);
    encodeTo$2(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest$2(code2, size, digest2, bytes2);
  };
  var Digest$2 = class Digest2 {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  };
  var code$2 = 0;
  var name$2 = "identity";
  var encode$9 = coerce$4;
  var digest$2 = (input) => create$5(code$2, encode$9(input));
  var identity$2 = { code: code$2, name: name$2, encode: encode$9, digest: digest$2 };
  var from$6 = ({ name: name2, code: code2, encode: encode3 }) => new Hasher$2(name2, code2, encode3);
  var Hasher$2 = class Hasher2 {
    constructor(name2, code2, encode3) {
      this.name = name2;
      this.code = code2;
      this.encode = encode3;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create$5(this.code, result) : result.then((digest2) => create$5(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var sha$2 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
  var sha256$2 = from$6({
    name: "sha2-256",
    code: 18,
    encode: sha$2("SHA-256")
  });
  var PUBLIC_KEY_BYTE_LENGTH$2 = 32;
  var PRIVATE_KEY_BYTE_LENGTH$2 = 64;
  var KEYS_BYTE_LENGTH$2 = 32;
  var base64$4 = rfc4648$4({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$4({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$4({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$4({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var derivedEmptyPasswordKey$2 = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
  var KeyType$2;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["Secp256k1"] = "Secp256k1";
  })(KeyType$2 || (KeyType$2 = {}));
  var __KeyTypeValues$2;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
  })(__KeyTypeValues$2 || (__KeyTypeValues$2 = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues$2);
    };
  })(KeyType$2 || (KeyType$2 = {}));
  var PublicKey$2;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$2.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$2.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf) => {
      return decodeMessage$1(buf, PublicKey2.codec());
    };
  })(PublicKey$2 || (PublicKey$2 = {}));
  var PrivateKey$2;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$2.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$2.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf) => {
      return decodeMessage$1(buf, PrivateKey2.codec());
    };
  })(PrivateKey$2 || (PrivateKey$2 = {}));
  var Ed25519PublicKey$2 = class Ed25519PublicKey2 {
    constructor(key) {
      this._key = ensureKey$2(key, PUBLIC_KEY_BYTE_LENGTH$2);
    }
    async verify(data, sig) {
      return hashAndVerify$8(this._key, sig, data);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PublicKey$2.encode({
        Type: KeyType$2.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$2.digest(this.bytes);
      return bytes2;
    }
  };
  var Ed25519PrivateKey$2 = class Ed25519PrivateKey2 {
    constructor(key, publicKey) {
      this._key = ensureKey$2(key, PRIVATE_KEY_BYTE_LENGTH$2);
      this._publicKey = ensureKey$2(publicKey, PUBLIC_KEY_BYTE_LENGTH$2);
    }
    async sign(message2) {
      return hashAndSign$8(this._key, message2);
    }
    get public() {
      return new Ed25519PublicKey$2(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$2.encode({
        Type: KeyType$2.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$2.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const encoding = identity$2.digest(this.public.bytes);
      return base58btc$4.encode(encoding.bytes).substring(1);
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$2(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Ed25519$2 = Object.freeze({
    __proto__: null,
    Ed25519PrivateKey: Ed25519PrivateKey$2,
    Ed25519PublicKey: Ed25519PublicKey$2,
    generateKeyPair: generateKeyPair$a,
    generateKeyPairFromSeed: generateKeyPairFromSeed$2,
    unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey$2,
    unmarshalEd25519PublicKey: unmarshalEd25519PublicKey$2
  });
  var bits$2 = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  var curveTypes$2 = Object.keys(bits$2);
  curveTypes$2.join(" / ");
  var MAX_KEY_SIZE$2 = 8192;
  var RsaPublicKey$2 = class RsaPublicKey2 {
    constructor(key) {
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$7(this._key, sig, data);
    }
    marshal() {
      return jwkToPkix$2(this._key);
    }
    get bytes() {
      return PublicKey$2.encode({
        Type: KeyType$2.RSA,
        Data: this.marshal()
      }).subarray();
    }
    encrypt(bytes2) {
      return encrypt$2(this._key, bytes2);
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$2.digest(this.bytes);
      return bytes2;
    }
  };
  var RsaPrivateKey$2 = class RsaPrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey;
    }
    genSecret() {
      return randomBytes$2(16);
    }
    async sign(message2) {
      return hashAndSign$7(this._key, message2);
    }
    get public() {
      if (this._publicKey == null) {
        throw new CodeError$3("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
      }
      return new RsaPublicKey$2(this._publicKey);
    }
    decrypt(bytes2) {
      return decrypt$2(this._key, bytes2);
    }
    marshal() {
      return jwkToPkcs1$2(this._key);
    }
    get bytes() {
      return PrivateKey$2.encode({
        Type: KeyType$2.RSA,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$2.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "pkcs-8") {
      if (format4 === "pkcs-8") {
        const buffer = new forge$n.util.ByteBuffer(this.marshal());
        const asn12 = forge$n.asn1.fromDer(buffer);
        const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
        const options = {
          algorithm: "aes256",
          count: 1e4,
          saltSize: 128 / 8,
          prfAlgorithm: "sha512"
        };
        return forge$n.pki.encryptRsaPrivateKey(privateKey, password, options);
      } else if (format4 === "libp2p-key") {
        return exporter$2(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var RSA$2 = Object.freeze({
    __proto__: null,
    MAX_KEY_SIZE: MAX_KEY_SIZE$2,
    RsaPrivateKey: RsaPrivateKey$2,
    RsaPublicKey: RsaPublicKey$2,
    fromJwk: fromJwk$2,
    generateKeyPair: generateKeyPair$9,
    unmarshalRsaPrivateKey: unmarshalRsaPrivateKey$2,
    unmarshalRsaPublicKey: unmarshalRsaPublicKey$2
  });
  var Secp256k1PublicKey$2 = class Secp256k1PublicKey2 {
    constructor(key) {
      validatePublicKey$2(key);
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$6(this._key, sig, data);
    }
    marshal() {
      return compressPublicKey$2(this._key);
    }
    get bytes() {
      return PublicKey$2.encode({
        Type: KeyType$2.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$2.digest(this.bytes);
      return bytes2;
    }
  };
  var Secp256k1PrivateKey$2 = class Secp256k1PrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey ?? computePublicKey$2(key);
      validatePrivateKey$2(this._key);
      validatePublicKey$2(this._publicKey);
    }
    async sign(message2) {
      return hashAndSign$6(this._key, message2);
    }
    get public() {
      return new Secp256k1PublicKey$2(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$2.encode({
        Type: KeyType$2.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$2.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$2(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Secp256k1$2 = Object.freeze({
    __proto__: null,
    Secp256k1PrivateKey: Secp256k1PrivateKey$2,
    Secp256k1PublicKey: Secp256k1PublicKey$2,
    generateKeyPair: generateKeyPair$8,
    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey$2,
    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey$2
  });
  var supportedKeys$2 = {
    rsa: RSA$2,
    ed25519: Ed25519$2,
    secp256k1: Secp256k1$2
  };
  var hashName = {
    sha1: "sha1",
    "sha2-256": "sha256",
    "sha2-512": "sha512"
  };
  var base32$3 = rfc4648$4({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  rfc4648$4({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  rfc4648$4({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  rfc4648$4({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  rfc4648$4({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  rfc4648$4({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  rfc4648$4({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  rfc4648$4({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  rfc4648$4({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  debug.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc$4.baseEncode(v);
  };
  debug.formatters.t = (v) => {
    return v == null ? "undefined" : base32$3.baseEncode(v);
  };
  debug.formatters.m = (v) => {
    return v == null ? "undefined" : base64$4.baseEncode(v);
  };
  debug.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  var nanoid$1 = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63;
    if (byte < 36) {
      id += byte.toString(36);
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte > 62) {
      id += "-";
    } else {
      id += "_";
    }
    return id;
  }, "");
  var pathSepS = "/";
  var pathSepB = new TextEncoder().encode(pathSepS);
  var pathSep = pathSepB[0];

  class Key {
    constructor(s2, clean) {
      if (typeof s2 === "string") {
        this._buf = fromString$3(s2);
      } else if (s2 instanceof Uint8Array) {
        this._buf = s2;
      } else {
        throw new Error("Invalid key, should be String of Uint8Array");
      }
      if (clean == null) {
        clean = true;
      }
      if (clean) {
        this.clean();
      }
      if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
        throw new Error("Invalid key");
      }
    }
    toString(encoding = "utf8") {
      return toString$9(this._buf, encoding);
    }
    uint8Array() {
      return this._buf;
    }
    get [Symbol.toStringTag]() {
      return `Key(${this.toString()})`;
    }
    static withNamespaces(list) {
      return new Key(list.join(pathSepS));
    }
    static random() {
      return new Key(nanoid$1().replace(/-/g, ""));
    }
    static asKey(other) {
      if (other instanceof Uint8Array || typeof other === "string") {
        return new Key(other);
      }
      if (typeof other.uint8Array === "function") {
        return new Key(other.uint8Array());
      }
      return null;
    }
    clean() {
      if (this._buf == null || this._buf.byteLength === 0) {
        this._buf = pathSepB;
      }
      if (this._buf[0] !== pathSep) {
        const bytes2 = new Uint8Array(this._buf.byteLength + 1);
        bytes2.fill(pathSep, 0, 1);
        bytes2.set(this._buf, 1);
        this._buf = bytes2;
      }
      while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
        this._buf = this._buf.subarray(0, -1);
      }
    }
    less(key) {
      const list1 = this.list();
      const list2 = key.list();
      for (let i = 0;i < list1.length; i++) {
        if (list2.length < i + 1) {
          return false;
        }
        const c1 = list1[i];
        const c2 = list2[i];
        if (c1 < c2) {
          return true;
        } else if (c1 > c2) {
          return false;
        }
      }
      return list1.length < list2.length;
    }
    reverse() {
      return Key.withNamespaces(this.list().slice().reverse());
    }
    namespaces() {
      return this.list();
    }
    baseNamespace() {
      const ns = this.namespaces();
      return ns[ns.length - 1];
    }
    list() {
      return this.toString().split(pathSepS).slice(1);
    }
    type() {
      return namespaceType(this.baseNamespace());
    }
    name() {
      return namespaceValue(this.baseNamespace());
    }
    instance(s2) {
      return new Key(this.toString() + ":" + s2);
    }
    path() {
      let p = this.parent().toString();
      if (!p.endsWith(pathSepS)) {
        p += pathSepS;
      }
      p += this.type();
      return new Key(p);
    }
    parent() {
      const list = this.list();
      if (list.length === 1) {
        return new Key(pathSepS);
      }
      return new Key(list.slice(0, -1).join(pathSepS));
    }
    child(key) {
      if (this.toString() === pathSepS) {
        return key;
      } else if (key.toString() === pathSepS) {
        return this;
      }
      return new Key(this.toString() + key.toString(), false);
    }
    isAncestorOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return other.toString().startsWith(this.toString());
    }
    isDecendantOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return this.toString().startsWith(other.toString());
    }
    isTopLevel() {
      return this.list().length === 1;
    }
    concat(...keys) {
      return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
    }
  }
  var isPlainObj = (value) => {
    if (Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
  };
  var isOptionObject = isPlainObj;
  var { hasOwnProperty } = Object.prototype;
  var { propertyIsEnumerable } = Object;
  var defineProperty = (object, name2, value) => Object.defineProperty(object, name2, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
  var globalThis$1 = commonjsGlobal;
  var defaultMergeOptions = {
    concatArrays: false,
    ignoreUndefined: false
  };
  var getEnumerableOwnPropertyKeys = (value) => {
    const keys = [];
    for (const key in value) {
      if (hasOwnProperty.call(value, key)) {
        keys.push(key);
      }
    }
    if (Object.getOwnPropertySymbols) {
      const symbols = Object.getOwnPropertySymbols(value);
      for (const symbol2 of symbols) {
        if (propertyIsEnumerable.call(value, symbol2)) {
          keys.push(symbol2);
        }
      }
    }
    return keys;
  };
  var mergeKeys = (merged, source2, keys, config) => {
    keys.forEach((key) => {
      if (typeof source2[key] === "undefined" && config.ignoreUndefined) {
        return;
      }
      if ((key in merged) && merged[key] !== Object.getPrototypeOf(merged)) {
        defineProperty(merged, key, merge(merged[key], source2[key], config));
      } else {
        defineProperty(merged, key, clone(source2[key]));
      }
    });
    return merged;
  };
  var concatArrays = (merged, source2, config) => {
    let result = merged.slice(0, 0);
    let resultIndex = 0;
    [merged, source2].forEach((array) => {
      const indices = [];
      for (let k = 0;k < array.length; k++) {
        if (!hasOwnProperty.call(array, k)) {
          continue;
        }
        indices.push(String(k));
        if (array === merged) {
          defineProperty(result, resultIndex++, array[k]);
        } else {
          defineProperty(result, resultIndex++, clone(array[k]));
        }
      }
      result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
    });
    return result;
  };
  var mergeOptions = function(...options) {
    const config = merge(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
    let merged = { _: {} };
    for (const option of options) {
      if (option === undefined) {
        continue;
      }
      if (!isOptionObject(option)) {
        throw new TypeError("`" + option + "` is not an Option Object");
      }
      merged = merge(merged, { _: option }, config);
    }
    return merged._;
  };
  var mergeOptions$1 = getDefaultExportFromCjs(mergeOptions);
  var truncate$2 = function truncate(getLength2, string2, byteLength) {
    if (typeof string2 !== "string") {
      throw new Error("Input must be string");
    }
    var charLength = string2.length;
    var curByteLength = 0;
    var codePoint;
    var segment;
    for (var i = 0;i < charLength; i += 1) {
      codePoint = string2.charCodeAt(i);
      segment = string2[i];
      if (isHighSurrogate$1(codePoint) && isLowSurrogate$1(string2.charCodeAt(i + 1))) {
        i += 1;
        segment += string2[i];
      }
      curByteLength += getLength2(segment);
      if (curByteLength === byteLength) {
        return string2.slice(0, i + 1);
      } else if (curByteLength > byteLength) {
        return string2.slice(0, i - segment.length + 1);
      }
    }
    return string2;
  };
  var browser$1 = function getByteLength(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Input must be string");
    }
    var charLength = string2.length;
    var byteLength = 0;
    var codePoint = null;
    var prevCodePoint = null;
    for (var i = 0;i < charLength; i++) {
      codePoint = string2.charCodeAt(i);
      if (isLowSurrogate(codePoint)) {
        if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
          byteLength += 1;
        } else {
          byteLength += 3;
        }
      } else if (codePoint <= 127) {
        byteLength += 1;
      } else if (codePoint >= 128 && codePoint <= 2047) {
        byteLength += 2;
      } else if (codePoint >= 2048 && codePoint <= 65535) {
        byteLength += 3;
      }
      prevCodePoint = codePoint;
    }
    return byteLength;
  };
  var truncate$1 = truncate$2;
  var getLength = browser$1;
  var browser = truncate$1.bind(null, getLength);
  var truncate = browser;
  var illegalRe = /[\/\?<>\\:\*\|"]/g;
  var controlRe = /[\x00-\x1f\x80-\x9f]/g;
  var reservedRe = /^\.+$/;
  var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
  var windowsTrailingRe = /[\. ]+$/;
  var sanitizeFilename = function(input, options) {
    var replacement = options && options.replacement || "";
    var output2 = sanitize(input, replacement);
    if (replacement === "") {
      return output2;
    }
    return sanitize(output2, "");
  };
  var sanitize$1 = getDefaultExportFromCjs(sanitizeFilename);
  var codes$3;
  (function(codes2) {
    codes2["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
    codes2["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
    codes2["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
    codes2["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
    codes2["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
    codes2["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
    codes2["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
    codes2["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
    codes2["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
    codes2["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
    codes2["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
    codes2["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
    codes2["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
    codes2["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
    codes2["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  })(codes$3 || (codes$3 = {}));
  var log$k = logger$3("libp2p:keychain");
  var keyPrefix = "/pkcs8/";
  var infoPrefix = "/info/";
  var privates = new WeakMap;
  var NIST = {
    minKeyLength: 112 / 8,
    minSaltLength: 128 / 8,
    minIterationCount: 1000
  };
  var defaultOptions$6 = {
    dek: {
      keyLength: 512 / 8,
      iterationCount: 1e4,
      salt: "you should override this value with a crypto secure random number",
      hash: "sha2-512"
    }
  };

  class DefaultKeyChain {
    constructor(components, init2) {
      this.components = components;
      this.init = mergeOptions$1(defaultOptions$6, init2);
      if (this.init.pass != null && this.init.pass?.length < 20) {
        throw new Error("pass must be least 20 characters");
      }
      if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
        throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
      }
      if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
        throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
      }
      if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
        throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
      }
      const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
      privates.set(this, { dek });
    }
    static generateOptions() {
      const options = Object.assign({}, defaultOptions$6);
      const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
      options.dek.salt = toString$9(randomBytes$2(saltLength), "base64");
      return options;
    }
    static get options() {
      return defaultOptions$6;
    }
    async createKey(name2, type, size = 2048) {
      if (!validateKeyName(name2) || name2 === "self") {
        await randomDelay();
        throw new CodeError$3("Invalid key name", codes$3.ERR_INVALID_KEY_NAME);
      }
      if (typeof type !== "string") {
        await randomDelay();
        throw new CodeError$3("Invalid key type", codes$3.ERR_INVALID_KEY_TYPE);
      }
      const dsname = DsName(name2);
      const exists2 = await this.components.datastore.has(dsname);
      if (exists2) {
        await randomDelay();
        throw new CodeError$3("Key name already exists", codes$3.ERR_KEY_ALREADY_EXISTS);
      }
      switch (type.toLowerCase()) {
        case "rsa":
          if (!Number.isSafeInteger(size) || size < 2048) {
            await randomDelay();
            throw new CodeError$3("Invalid RSA key size", codes$3.ERR_INVALID_KEY_SIZE);
          }
          break;
      }
      let keyInfo;
      try {
        const keypair = await generateKeyPair$7(type, size);
        const kid = await keypair.id();
        const cached = privates.get(this);
        if (cached == null) {
          throw new CodeError$3("dek missing", codes$3.ERR_INVALID_PARAMETERS);
        }
        const dek = cached.dek;
        const pem2 = await keypair.export(dek);
        keyInfo = {
          name: name2,
          id: kid
        };
        const batch = this.components.datastore.batch();
        batch.put(dsname, fromString$3(pem2));
        batch.put(DsInfoName(name2), fromString$3(JSON.stringify(keyInfo)));
        await batch.commit();
      } catch (err) {
        await randomDelay();
        throw err;
      }
      return keyInfo;
    }
    async listKeys() {
      const query2 = {
        prefix: infoPrefix
      };
      const info = [];
      for await (const value of this.components.datastore.query(query2)) {
        info.push(JSON.parse(toString$9(value.value)));
      }
      return info;
    }
    async findKeyById(id) {
      try {
        const keys = await this.listKeys();
        const key = keys.find((k) => k.id === id);
        if (key == null) {
          throw new CodeError$3(`Key with id '${id}' does not exist.`, codes$3.ERR_KEY_NOT_FOUND);
        }
        return key;
      } catch (err) {
        await randomDelay();
        throw err;
      }
    }
    async findKeyByName(name2) {
      if (!validateKeyName(name2)) {
        await randomDelay();
        throw new CodeError$3(`Invalid key name '${name2}'`, codes$3.ERR_INVALID_KEY_NAME);
      }
      const dsname = DsInfoName(name2);
      try {
        const res = await this.components.datastore.get(dsname);
        return JSON.parse(toString$9(res));
      } catch (err) {
        await randomDelay();
        log$k.error(err);
        throw new CodeError$3(`Key '${name2}' does not exist.`, codes$3.ERR_KEY_NOT_FOUND);
      }
    }
    async removeKey(name2) {
      if (!validateKeyName(name2) || name2 === "self") {
        await randomDelay();
        throw new CodeError$3(`Invalid key name '${name2}'`, codes$3.ERR_INVALID_KEY_NAME);
      }
      const dsname = DsName(name2);
      const keyInfo = await this.findKeyByName(name2);
      const batch = this.components.datastore.batch();
      batch.delete(dsname);
      batch.delete(DsInfoName(name2));
      await batch.commit();
      return keyInfo;
    }
    async renameKey(oldName, newName) {
      if (!validateKeyName(oldName) || oldName === "self") {
        await randomDelay();
        throw new CodeError$3(`Invalid old key name '${oldName}'`, codes$3.ERR_OLD_KEY_NAME_INVALID);
      }
      if (!validateKeyName(newName) || newName === "self") {
        await randomDelay();
        throw new CodeError$3(`Invalid new key name '${newName}'`, codes$3.ERR_NEW_KEY_NAME_INVALID);
      }
      const oldDsname = DsName(oldName);
      const newDsname = DsName(newName);
      const oldInfoName = DsInfoName(oldName);
      const newInfoName = DsInfoName(newName);
      const exists2 = await this.components.datastore.has(newDsname);
      if (exists2) {
        await randomDelay();
        throw new CodeError$3(`Key '${newName}' already exists`, codes$3.ERR_KEY_ALREADY_EXISTS);
      }
      try {
        const pem2 = await this.components.datastore.get(oldDsname);
        const res = await this.components.datastore.get(oldInfoName);
        const keyInfo = JSON.parse(toString$9(res));
        keyInfo.name = newName;
        const batch = this.components.datastore.batch();
        batch.put(newDsname, pem2);
        batch.put(newInfoName, fromString$3(JSON.stringify(keyInfo)));
        batch.delete(oldDsname);
        batch.delete(oldInfoName);
        await batch.commit();
        return keyInfo;
      } catch (err) {
        await randomDelay();
        throw err;
      }
    }
    async exportKey(name2, password) {
      if (!validateKeyName(name2)) {
        await randomDelay();
        throw new CodeError$3(`Invalid key name '${name2}'`, codes$3.ERR_INVALID_KEY_NAME);
      }
      if (password == null) {
        await randomDelay();
        throw new CodeError$3("Password is required", codes$3.ERR_PASSWORD_REQUIRED);
      }
      const dsname = DsName(name2);
      try {
        const res = await this.components.datastore.get(dsname);
        const pem2 = toString$9(res);
        const cached = privates.get(this);
        if (cached == null) {
          throw new CodeError$3("dek missing", codes$3.ERR_INVALID_PARAMETERS);
        }
        const dek = cached.dek;
        const privateKey = await importKey(pem2, dek);
        const keyString = await privateKey.export(password);
        return keyString;
      } catch (err) {
        await randomDelay();
        throw err;
      }
    }
    async exportPeerId(name2) {
      const password = "temporary-password";
      const pem2 = await this.exportKey(name2, password);
      const privateKey = await importKey(pem2, password);
      return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
    }
    async importKey(name2, pem2, password) {
      if (!validateKeyName(name2) || name2 === "self") {
        await randomDelay();
        throw new CodeError$3(`Invalid key name '${name2}'`, codes$3.ERR_INVALID_KEY_NAME);
      }
      if (pem2 == null) {
        await randomDelay();
        throw new CodeError$3("PEM encoded key is required", codes$3.ERR_PEM_REQUIRED);
      }
      const dsname = DsName(name2);
      const exists2 = await this.components.datastore.has(dsname);
      if (exists2) {
        await randomDelay();
        throw new CodeError$3(`Key '${name2}' already exists`, codes$3.ERR_KEY_ALREADY_EXISTS);
      }
      let privateKey;
      try {
        privateKey = await importKey(pem2, password);
      } catch (err) {
        await randomDelay();
        throw new CodeError$3("Cannot read the key, most likely the password is wrong", codes$3.ERR_CANNOT_READ_KEY);
      }
      let kid;
      try {
        kid = await privateKey.id();
        const cached = privates.get(this);
        if (cached == null) {
          throw new CodeError$3("dek missing", codes$3.ERR_INVALID_PARAMETERS);
        }
        const dek = cached.dek;
        pem2 = await privateKey.export(dek);
      } catch (err) {
        await randomDelay();
        throw err;
      }
      const keyInfo = {
        name: name2,
        id: kid
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString$3(pem2));
      batch.put(DsInfoName(name2), fromString$3(JSON.stringify(keyInfo)));
      await batch.commit();
      return keyInfo;
    }
    async importPeer(name2, peer) {
      try {
        if (!validateKeyName(name2)) {
          throw new CodeError$3(`Invalid key name '${name2}'`, codes$3.ERR_INVALID_KEY_NAME);
        }
        if (peer == null) {
          throw new CodeError$3("PeerId is required", codes$3.ERR_MISSING_PRIVATE_KEY);
        }
        if (peer.privateKey == null) {
          throw new CodeError$3("PeerId.privKey is required", codes$3.ERR_MISSING_PRIVATE_KEY);
        }
        const privateKey = await unmarshalPrivateKey$3(peer.privateKey);
        const dsname = DsName(name2);
        const exists2 = await this.components.datastore.has(dsname);
        if (exists2) {
          await randomDelay();
          throw new CodeError$3(`Key '${name2}' already exists`, codes$3.ERR_KEY_ALREADY_EXISTS);
        }
        const cached = privates.get(this);
        if (cached == null) {
          throw new CodeError$3("dek missing", codes$3.ERR_INVALID_PARAMETERS);
        }
        const dek = cached.dek;
        const pem2 = await privateKey.export(dek);
        const keyInfo = {
          name: name2,
          id: peer.toString()
        };
        const batch = this.components.datastore.batch();
        batch.put(dsname, fromString$3(pem2));
        batch.put(DsInfoName(name2), fromString$3(JSON.stringify(keyInfo)));
        await batch.commit();
        return keyInfo;
      } catch (err) {
        await randomDelay();
        throw err;
      }
    }
    async getPrivateKey(name2) {
      if (!validateKeyName(name2)) {
        await randomDelay();
        throw new CodeError$3(`Invalid key name '${name2}'`, codes$3.ERR_INVALID_KEY_NAME);
      }
      try {
        const dsname = DsName(name2);
        const res = await this.components.datastore.get(dsname);
        return toString$9(res);
      } catch (err) {
        await randomDelay();
        log$k.error(err);
        throw new CodeError$3(`Key '${name2}' does not exist.`, codes$3.ERR_KEY_NOT_FOUND);
      }
    }
    async rotateKeychainPass(oldPass, newPass) {
      if (typeof oldPass !== "string") {
        await randomDelay();
        throw new CodeError$3(`Invalid old pass type '${typeof oldPass}'`, codes$3.ERR_INVALID_OLD_PASS_TYPE);
      }
      if (typeof newPass !== "string") {
        await randomDelay();
        throw new CodeError$3(`Invalid new pass type '${typeof newPass}'`, codes$3.ERR_INVALID_NEW_PASS_TYPE);
      }
      if (newPass.length < 20) {
        await randomDelay();
        throw new CodeError$3(`Invalid pass length ${newPass.length}`, codes$3.ERR_INVALID_PASS_LENGTH);
      }
      log$k("recreating keychain");
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError$3("dek missing", codes$3.ERR_INVALID_PARAMETERS);
      }
      const oldDek = cached.dek;
      this.init.pass = newPass;
      const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
      privates.set(this, { dek: newDek });
      const keys = await this.listKeys();
      for (const key of keys) {
        const res = await this.components.datastore.get(DsName(key.name));
        const pem2 = toString$9(res);
        const privateKey = await importKey(pem2, oldDek);
        const password = newDek.toString();
        const keyAsPEM = await privateKey.export(password);
        const batch = this.components.datastore.batch();
        const keyInfo = {
          name: key.name,
          id: key.id
        };
        batch.put(DsName(key.name), fromString$3(keyAsPEM));
        batch.put(DsInfoName(key.name), fromString$3(JSON.stringify(keyInfo)));
        await batch.commit();
      }
      log$k("keychain reconstructed");
    }
  }
  var base32$2 = rfc4648$5({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  rfc4648$5({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  rfc4648$5({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  rfc4648$5({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  rfc4648$5({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  rfc4648$5({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  rfc4648$5({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  rfc4648$5({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  rfc4648$5({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  debug.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc$5.baseEncode(v);
  };
  debug.formatters.t = (v) => {
    return v == null ? "undefined" : base32$2.baseEncode(v);
  };
  debug.formatters.m = (v) => {
    return v == null ? "undefined" : base64$5.baseEncode(v);
  };
  debug.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };

  class PeerMap {
    constructor(map2) {
      this.map = new Map;
      if (map2 != null) {
        for (const [key, value] of map2.entries()) {
          this.map.set(key.toString(), value);
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    clear() {
      this.map.clear();
    }
    delete(peer) {
      this.map.delete(peer.toString());
    }
    entries() {
      return mapIterable(this.map.entries(), (val) => {
        return [peerIdFromString(val[0]), val[1]];
      });
    }
    forEach(fn) {
      this.map.forEach((value, key) => {
        fn(value, peerIdFromString(key), this);
      });
    }
    get(peer) {
      return this.map.get(peer.toString());
    }
    has(peer) {
      return this.map.has(peer.toString());
    }
    set(peer, value) {
      this.map.set(peer.toString(), value);
    }
    keys() {
      return mapIterable(this.map.keys(), (val) => {
        return peerIdFromString(val);
      });
    }
    values() {
      return this.map.values();
    }
    get size() {
      return this.map.size;
    }
  }

  class PeerSet {
    constructor(set) {
      this.set = new Set;
      if (set != null) {
        for (const key of set) {
          this.set.add(key.toString());
        }
      }
    }
    get size() {
      return this.set.size;
    }
    [Symbol.iterator]() {
      return this.values();
    }
    add(peer) {
      this.set.add(peer.toString());
    }
    clear() {
      this.set.clear();
    }
    delete(peer) {
      this.set.delete(peer.toString());
    }
    entries() {
      return mapIterable(this.set.entries(), (val) => {
        const peerId = peerIdFromString(val[0]);
        return [peerId, peerId];
      });
    }
    forEach(predicate) {
      this.set.forEach((str) => {
        const id = peerIdFromString(str);
        predicate(id, id, this);
      });
    }
    has(peer) {
      return this.set.has(peer.toString());
    }
    values() {
      return mapIterable(this.set.values(), (val) => {
        return peerIdFromString(val);
      });
    }
    intersection(other) {
      const output2 = new PeerSet;
      for (const peerId of other) {
        if (this.has(peerId)) {
          output2.add(peerId);
        }
      }
      return output2;
    }
    difference(other) {
      const output2 = new PeerSet;
      for (const peerId of this) {
        if (!other.has(peerId)) {
          output2.add(peerId);
        }
      }
      return output2;
    }
    union(other) {
      const output2 = new PeerSet;
      for (const peerId of other) {
        output2.add(peerId);
      }
      for (const peerId of this) {
        output2.add(peerId);
      }
      return output2;
    }
  }
  var src$3 = base$3;
  var _brrp__multiformats_scope_baseX$3 = src$3;
  var coerce$3 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$3 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$3 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$3(this, decoder);
    }
  };
  var ComposedDecoder$3 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$3(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$3 = (left2, right2) => new ComposedDecoder$3({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$3 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$3(name2, prefix, baseEncode);
      this.decoder = new Decoder$3(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$5 = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$3(name2, prefix, encode3, decode3);
  var baseX$3 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$3(alphabet2, name2);
    return from$5({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$3(decode3(text))
    });
  };
  var decode$5 = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$8 = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$3 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$5({
      prefix,
      name: name2,
      encode(input) {
        return encode$8(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$5(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base58btc$3 = baseX$3({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$3({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var encode_1$1 = encode$7;
  var MSB$2 = 128;
  var REST$2 = 127;
  var MSBALL$1 = ~REST$2;
  var INT$1 = Math.pow(2, 31);
  var decode$4 = read$2;
  var MSB$1$1 = 128;
  var REST$1$1 = 127;
  var N1$1 = Math.pow(2, 7);
  var N2$1 = Math.pow(2, 14);
  var N3$1 = Math.pow(2, 21);
  var N4$1 = Math.pow(2, 28);
  var N5$1 = Math.pow(2, 35);
  var N6$1 = Math.pow(2, 42);
  var N7$1 = Math.pow(2, 49);
  var N8$1 = Math.pow(2, 56);
  var N9$1 = Math.pow(2, 63);
  var length$1 = function(value) {
    return value < N1$1 ? 1 : value < N2$1 ? 2 : value < N3$1 ? 3 : value < N4$1 ? 4 : value < N5$1 ? 5 : value < N6$1 ? 6 : value < N7$1 ? 7 : value < N8$1 ? 8 : value < N9$1 ? 9 : 10;
  };
  var varint$1 = {
    encode: encode_1$1,
    decode: decode$4,
    encodingLength: length$1
  };
  var _brrp_varint$1 = varint$1;
  var encodeTo$1 = (int, target, offset = 0) => {
    _brrp_varint$1.encode(int, target, offset);
    return target;
  };
  var encodingLength$1 = (int) => {
    return _brrp_varint$1.encodingLength(int);
  };
  var create$3 = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength$1(code2);
    const digestOffset = sizeOffset + encodingLength$1(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo$1(code2, bytes2, 0);
    encodeTo$1(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest$1(code2, size, digest2, bytes2);
  };
  var Digest$1 = class Digest2 {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  };
  var code$1 = 0;
  var name$1 = "identity";
  var encode$6 = coerce$3;
  var digest$1 = (input) => create$3(code$1, encode$6(input));
  var identity$1 = { code: code$1, name: name$1, encode: encode$6, digest: digest$1 };
  var from$4 = ({ name: name2, code: code2, encode: encode3 }) => new Hasher$1(name2, code2, encode3);
  var Hasher$1 = class Hasher2 {
    constructor(name2, code2, encode3) {
      this.name = name2;
      this.code = code2;
      this.encode = encode3;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create$3(this.code, result) : result.then((digest2) => create$3(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var sha$1 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
  var sha256$1 = from$4({
    name: "sha2-256",
    code: 18,
    encode: sha$1("SHA-256")
  });
  var PUBLIC_KEY_BYTE_LENGTH$1 = 32;
  var PRIVATE_KEY_BYTE_LENGTH$1 = 64;
  var KEYS_BYTE_LENGTH$1 = 32;
  var base64$3 = rfc4648$3({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$3({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$3({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$3({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var webcrypto$1 = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto == null || nativeCrypto.subtle == null) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    }
  };
  var derivedEmptyPasswordKey$1 = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
  var KeyType$1;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["Secp256k1"] = "Secp256k1";
  })(KeyType$1 || (KeyType$1 = {}));
  var __KeyTypeValues$1;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
  })(__KeyTypeValues$1 || (__KeyTypeValues$1 = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues$1);
    };
  })(KeyType$1 || (KeyType$1 = {}));
  var PublicKey$1;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$1.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$1.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf) => {
      return decodeMessage$1(buf, PublicKey2.codec());
    };
  })(PublicKey$1 || (PublicKey$1 = {}));
  var PrivateKey$1;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType$1.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType$1.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf) => {
      return decodeMessage$1(buf, PrivateKey2.codec());
    };
  })(PrivateKey$1 || (PrivateKey$1 = {}));
  var Ed25519PublicKey$1 = class Ed25519PublicKey2 {
    constructor(key) {
      this._key = ensureKey$1(key, PUBLIC_KEY_BYTE_LENGTH$1);
    }
    async verify(data, sig) {
      return hashAndVerify$5(this._key, sig, data);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PublicKey$1.encode({
        Type: KeyType$1.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$1.digest(this.bytes);
      return bytes2;
    }
  };
  var Ed25519PrivateKey$1 = class Ed25519PrivateKey2 {
    constructor(key, publicKey) {
      this._key = ensureKey$1(key, PRIVATE_KEY_BYTE_LENGTH$1);
      this._publicKey = ensureKey$1(publicKey, PUBLIC_KEY_BYTE_LENGTH$1);
    }
    async sign(message2) {
      return hashAndSign$5(this._key, message2);
    }
    get public() {
      return new Ed25519PublicKey$1(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$1.encode({
        Type: KeyType$1.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$1.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const encoding = identity$1.digest(this.public.bytes);
      return base58btc$3.encode(encoding.bytes).substring(1);
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$1(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Ed25519$1 = Object.freeze({
    __proto__: null,
    Ed25519PrivateKey: Ed25519PrivateKey$1,
    Ed25519PublicKey: Ed25519PublicKey$1,
    generateKeyPair: generateKeyPair$6,
    generateKeyPairFromSeed: generateKeyPairFromSeed$1,
    unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey$1,
    unmarshalEd25519PublicKey: unmarshalEd25519PublicKey$1
  });
  var bits$1 = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  var curveTypes$1 = Object.keys(bits$1);
  curveTypes$1.join(" / ");
  var MAX_KEY_SIZE$1 = 8192;
  var RsaPublicKey$1 = class RsaPublicKey2 {
    constructor(key) {
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$4(this._key, sig, data);
    }
    marshal() {
      return jwkToPkix$1(this._key);
    }
    get bytes() {
      return PublicKey$1.encode({
        Type: KeyType$1.RSA,
        Data: this.marshal()
      }).subarray();
    }
    encrypt(bytes2) {
      return encrypt$1(this._key, bytes2);
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$1.digest(this.bytes);
      return bytes2;
    }
  };
  var RsaPrivateKey$1 = class RsaPrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey;
    }
    genSecret() {
      return randomBytes$1(16);
    }
    async sign(message2) {
      return hashAndSign$4(this._key, message2);
    }
    get public() {
      if (this._publicKey == null) {
        throw new CodeError$3("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
      }
      return new RsaPublicKey$1(this._publicKey);
    }
    decrypt(bytes2) {
      return decrypt$1(this._key, bytes2);
    }
    marshal() {
      return jwkToPkcs1$1(this._key);
    }
    get bytes() {
      return PrivateKey$1.encode({
        Type: KeyType$1.RSA,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$1.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "pkcs-8") {
      if (format4 === "pkcs-8") {
        const buffer = new forge$n.util.ByteBuffer(this.marshal());
        const asn12 = forge$n.asn1.fromDer(buffer);
        const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
        const options = {
          algorithm: "aes256",
          count: 1e4,
          saltSize: 128 / 8,
          prfAlgorithm: "sha512"
        };
        return forge$n.pki.encryptRsaPrivateKey(privateKey, password, options);
      } else if (format4 === "libp2p-key") {
        return exporter$1(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var RSA$1 = Object.freeze({
    __proto__: null,
    MAX_KEY_SIZE: MAX_KEY_SIZE$1,
    RsaPrivateKey: RsaPrivateKey$1,
    RsaPublicKey: RsaPublicKey$1,
    fromJwk: fromJwk$1,
    generateKeyPair: generateKeyPair$5,
    unmarshalRsaPrivateKey: unmarshalRsaPrivateKey$1,
    unmarshalRsaPublicKey: unmarshalRsaPublicKey$1
  });
  var Secp256k1PublicKey$1 = class Secp256k1PublicKey2 {
    constructor(key) {
      validatePublicKey$1(key);
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$3(this._key, sig, data);
    }
    marshal() {
      return compressPublicKey$1(this._key);
    }
    get bytes() {
      return PublicKey$1.encode({
        Type: KeyType$1.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$1.digest(this.bytes);
      return bytes2;
    }
  };
  var Secp256k1PrivateKey$1 = class Secp256k1PrivateKey2 {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey ?? computePublicKey$1(key);
      validatePrivateKey$1(this._key);
      validatePublicKey$1(this._publicKey);
    }
    async sign(message2) {
      return hashAndSign$3(this._key, message2);
    }
    get public() {
      return new Secp256k1PublicKey$1(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey$1.encode({
        Type: KeyType$1.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256$1.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter$1(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  var Secp256k1$1 = Object.freeze({
    __proto__: null,
    Secp256k1PrivateKey: Secp256k1PrivateKey$1,
    Secp256k1PublicKey: Secp256k1PublicKey$1,
    generateKeyPair: generateKeyPair$4,
    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey$1,
    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey$1
  });
  var supportedKeys$1 = {
    rsa: RSA$1,
    ed25519: Ed25519$1,
    secp256k1: Secp256k1$1
  };
  var PeerIdProto;
  (function(PeerIdProto2) {
    let _codec;
    PeerIdProto2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.id != null) {
            w.uint32(10);
            w.bytes(obj.id);
          }
          if (obj.pubKey != null) {
            w.uint32(18);
            w.bytes(obj.pubKey);
          }
          if (obj.privKey != null) {
            w.uint32(26);
            w.bytes(obj.privKey);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader2.bytes();
                break;
              case 2:
                obj.pubKey = reader2.bytes();
                break;
              case 3:
                obj.privKey = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerIdProto2.encode = (obj) => {
      return encodeMessage(obj, PeerIdProto2.codec());
    };
    PeerIdProto2.decode = (buf) => {
      return decodeMessage$1(buf, PeerIdProto2.codec());
    };
  })(PeerIdProto || (PeerIdProto = {}));
  var createEd25519PeerId = async () => {
    const key = await generateKeyPair$3("Ed25519");
    const id = await createFromPrivKey(key);
    if (id.type === "Ed25519") {
      return id;
    }
    throw new Error(`Generated unexpected PeerId type "${id.type}"`);
  };
  var src$2 = base$2;
  var _brrp__multiformats_scope_baseX$2 = src$2;
  var coerce$2 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$2 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$2 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$2(this, decoder);
    }
  };
  var ComposedDecoder$2 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$2(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$2 = (left2, right2) => new ComposedDecoder$2({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$2 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$2(name2, prefix, baseEncode);
      this.decoder = new Decoder$2(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$3 = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$2(name2, prefix, encode3, decode3);
  var baseX$2 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$2(alphabet2, name2);
    return from$3({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$2(decode3(text))
    });
  };
  var decode$3 = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$5 = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$2 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$3({
      prefix,
      name: name2,
      encode(input) {
        return encode$5(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$3(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base32$1 = rfc4648$2({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  rfc4648$2({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  rfc4648$2({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  rfc4648$2({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  rfc4648$2({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  rfc4648$2({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  rfc4648$2({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  rfc4648$2({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  rfc4648$2({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base58btc$2 = baseX$2({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$2({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base64$2 = rfc4648$2({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$2({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$2({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$2({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  debug.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc$2.baseEncode(v);
  };
  debug.formatters.t = (v) => {
    return v == null ? "undefined" : base32$1.baseEncode(v);
  };
  debug.formatters.m = (v) => {
    return v == null ? "undefined" : base64$2.baseEncode(v);
  };
  debug.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  var src$1 = base$1;
  var _brrp__multiformats_scope_baseX$1 = src$1;
  var coerce$1 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var Encoder$1 = class Encoder2 {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder$1 = class Decoder2 {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or$1(this, decoder);
    }
  };
  var ComposedDecoder$1 = class ComposedDecoder2 {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or$1(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or$1 = (left2, right2) => new ComposedDecoder$1({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });
  var Codec$1 = class Codec2 {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder$1(name2, prefix, baseEncode);
      this.decoder = new Decoder$1(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from$2 = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec$1(name2, prefix, encode3, decode3);
  var baseX$1 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX$1(alphabet2, name2);
    return from$2({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce$1(decode3(text))
    });
  };
  var decode$2 = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$4 = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$1 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from$2({
      prefix,
      name: name2,
      encode(input) {
        return encode$4(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$2(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base58btc$1 = baseX$1({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX$1({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var encode_1 = encode$3;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  var decode$1 = read$1;
  var MSB$1 = 128;
  var REST$1 = 127;
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode$1,
    encodingLength: length
  };
  var _brrp_varint = varint;
  var encodeTo = (int, target, offset = 0) => {
    _brrp_varint.encode(int, target, offset);
    return target;
  };
  var encodingLength = (int) => {
    return _brrp_varint.encodingLength(int);
  };
  var create$1 = (code2, digest2) => {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength(code2);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes2 = new Uint8Array(digestOffset + size);
    encodeTo(code2, bytes2, 0);
    encodeTo(size, bytes2, sizeOffset);
    bytes2.set(digest2, digestOffset);
    return new Digest(code2, size, digest2, bytes2);
  };

  class Digest {
    constructor(code2, size, digest2, bytes2) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes2;
    }
  }
  var code = 0;
  var name = "identity";
  var encode$2 = coerce$1;
  var digest = (input) => create$1(code, encode$2(input));
  var identity = { code, name, encode: encode$2, digest };
  var from$1 = ({ name: name2, code: code2, encode: encode3 }) => new Hasher(name2, code2, encode3);

  class Hasher {
    constructor(name2, code2, encode3) {
      this.name = name2;
      this.code = code2;
      this.encode = encode3;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create$1(this.code, result) : result.then((digest2) => create$1(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  }
  var sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
  var sha256 = from$1({
    name: "sha2-256",
    code: 18,
    encode: sha("SHA-256")
  });
  var PUBLIC_KEY_BYTE_LENGTH = 32;
  var PRIVATE_KEY_BYTE_LENGTH = 64;
  var KEYS_BYTE_LENGTH = 32;
  var base64$1 = rfc4648$1({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648$1({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648$1({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648$1({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var webcrypto = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto == null || nativeCrypto.subtle == null) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    }
  };
  var derivedEmptyPasswordKey = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
  var KeyType;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["Secp256k1"] = "Secp256k1";
  })(KeyType || (KeyType = {}));
  var __KeyTypeValues;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
  })(__KeyTypeValues || (__KeyTypeValues = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues);
    };
  })(KeyType || (KeyType = {}));
  var PublicKey;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf) => {
      return decodeMessage$1(buf, PublicKey2.codec());
    };
  })(PublicKey || (PublicKey = {}));
  var PrivateKey;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {};
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = KeyType.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf) => {
      return decodeMessage$1(buf, PrivateKey2.codec());
    };
  })(PrivateKey || (PrivateKey = {}));

  class Ed25519PublicKey {
    constructor(key) {
      this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
    }
    async verify(data, sig) {
      return hashAndVerify$2(this._key, sig, data);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PublicKey.encode({
        Type: KeyType.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256.digest(this.bytes);
      return bytes2;
    }
  }

  class Ed25519PrivateKey {
    constructor(key, publicKey) {
      this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
      this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
    }
    async sign(message2) {
      return hashAndSign$2(this._key, message2);
    }
    get public() {
      return new Ed25519PublicKey(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey.encode({
        Type: KeyType.Ed25519,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const encoding = identity.digest(this.public.bytes);
      return base58btc$1.encode(encoding.bytes).substring(1);
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  }
  var Ed25519 = Object.freeze({
    __proto__: null,
    Ed25519PrivateKey,
    Ed25519PublicKey,
    generateKeyPair: generateKeyPair$2,
    generateKeyPairFromSeed,
    unmarshalEd25519PrivateKey,
    unmarshalEd25519PublicKey
  });
  var bits = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  var curveTypes = Object.keys(bits);
  curveTypes.join(" / ");
  var MAX_KEY_SIZE = 8192;

  class RsaPublicKey {
    constructor(key) {
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify$1(this._key, sig, data);
    }
    marshal() {
      return jwkToPkix(this._key);
    }
    get bytes() {
      return PublicKey.encode({
        Type: KeyType.RSA,
        Data: this.marshal()
      }).subarray();
    }
    encrypt(bytes2) {
      return encrypt(this._key, bytes2);
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256.digest(this.bytes);
      return bytes2;
    }
  }

  class RsaPrivateKey {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey;
    }
    genSecret() {
      return randomBytes(16);
    }
    async sign(message2) {
      return hashAndSign$1(this._key, message2);
    }
    get public() {
      if (this._publicKey == null) {
        throw new CodeError$3("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
      }
      return new RsaPublicKey(this._publicKey);
    }
    decrypt(bytes2) {
      return decrypt(this._key, bytes2);
    }
    marshal() {
      return jwkToPkcs1(this._key);
    }
    get bytes() {
      return PrivateKey.encode({
        Type: KeyType.RSA,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "pkcs-8") {
      if (format4 === "pkcs-8") {
        const buffer = new forge$n.util.ByteBuffer(this.marshal());
        const asn12 = forge$n.asn1.fromDer(buffer);
        const privateKey = forge$n.pki.privateKeyFromAsn1(asn12);
        const options = {
          algorithm: "aes256",
          count: 1e4,
          saltSize: 128 / 8,
          prfAlgorithm: "sha512"
        };
        return forge$n.pki.encryptRsaPrivateKey(privateKey, password, options);
      } else if (format4 === "libp2p-key") {
        return exporter(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  }
  var RSA = Object.freeze({
    __proto__: null,
    MAX_KEY_SIZE,
    RsaPrivateKey,
    RsaPublicKey,
    fromJwk,
    generateKeyPair: generateKeyPair$1,
    unmarshalRsaPrivateKey,
    unmarshalRsaPublicKey
  });

  class Secp256k1PublicKey {
    constructor(key) {
      validatePublicKey(key);
      this._key = key;
    }
    async verify(data, sig) {
      return hashAndVerify(this._key, sig, data);
    }
    marshal() {
      return compressPublicKey(this._key);
    }
    get bytes() {
      return PublicKey.encode({
        Type: KeyType.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256.digest(this.bytes);
      return bytes2;
    }
  }

  class Secp256k1PrivateKey {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey ?? computePublicKey(key);
      validatePrivateKey(this._key);
      validatePublicKey(this._publicKey);
    }
    async sign(message2) {
      return hashAndSign(this._key, message2);
    }
    get public() {
      return new Secp256k1PublicKey(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return PrivateKey.encode({
        Type: KeyType.Secp256k1,
        Data: this.marshal()
      }).subarray();
    }
    equals(key) {
      return equals$4(this.bytes, key.bytes);
    }
    async hash() {
      const { bytes: bytes2 } = await sha256.digest(this.bytes);
      return bytes2;
    }
    async id() {
      const hash2 = await this.public.hash();
      return toString$9(hash2, "base58btc");
    }
    async export(password, format4 = "libp2p-key") {
      if (format4 === "libp2p-key") {
        return exporter(this.bytes, password);
      } else {
        throw new CodeError$3(`export format '${format4}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  }
  var Secp256k1 = Object.freeze({
    __proto__: null,
    Secp256k1PrivateKey,
    Secp256k1PublicKey,
    generateKeyPair,
    unmarshalSecp256k1PrivateKey,
    unmarshalSecp256k1PublicKey
  });
  var supportedKeys = {
    rsa: RSA,
    ed25519: Ed25519,
    secp256k1: Secp256k1
  };
  var codes$2 = {
    ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
  };
  var Envelope;
  (function(Envelope2) {
    let _codec;
    Envelope2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.publicKey);
          }
          if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.payloadType);
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w.uint32(26);
            w.bytes(obj.payload);
          }
          if (obj.signature != null && obj.signature.byteLength > 0) {
            w.uint32(42);
            w.bytes(obj.signature);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            publicKey: new Uint8Array(0),
            payloadType: new Uint8Array(0),
            payload: new Uint8Array(0),
            signature: new Uint8Array(0)
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.publicKey = reader2.bytes();
                break;
              case 2:
                obj.payloadType = reader2.bytes();
                break;
              case 3:
                obj.payload = reader2.bytes();
                break;
              case 5:
                obj.signature = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Envelope2.encode = (obj) => {
      return encodeMessage(obj, Envelope2.codec());
    };
    Envelope2.decode = (buf) => {
      return decodeMessage$1(buf, Envelope2.codec());
    };
  })(Envelope || (Envelope = {}));

  class RecordEnvelope {
    constructor(init2) {
      const { peerId, payloadType, payload, signature } = init2;
      this.peerId = peerId;
      this.payloadType = payloadType;
      this.payload = payload;
      this.signature = signature;
    }
    marshal() {
      if (this.peerId.publicKey == null) {
        throw new Error("Missing public key");
      }
      if (this.marshaled == null) {
        this.marshaled = Envelope.encode({
          publicKey: this.peerId.publicKey,
          payloadType: this.payloadType,
          payload: this.payload.subarray(),
          signature: this.signature
        });
      }
      return this.marshaled;
    }
    equals(other) {
      return equals$4(this.marshal(), other.marshal());
    }
    async validate(domain) {
      const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
      if (this.peerId.publicKey == null) {
        throw new Error("Missing public key");
      }
      const key = unmarshalPublicKey(this.peerId.publicKey);
      return key.verify(signData.subarray(), this.signature);
    }
  }
  _q = RecordEnvelope;
  RecordEnvelope.createFromProtobuf = async (data) => {
    const envelopeData = Envelope.decode(data);
    const peerId = await peerIdFromKeys(envelopeData.publicKey);
    return new _q({
      peerId,
      payloadType: envelopeData.payloadType,
      payload: envelopeData.payload,
      signature: envelopeData.signature
    });
  };
  RecordEnvelope.seal = async (record, peerId) => {
    if (peerId.privateKey == null) {
      throw new Error("Missing private key");
    }
    const domain = record.domain;
    const payloadType = record.codec;
    const payload = record.marshal();
    const signData = formatSignaturePayload(domain, payloadType, payload);
    const key = await unmarshalPrivateKey(peerId.privateKey);
    const signature = await key.sign(signData.subarray());
    return new _q({
      peerId,
      payloadType,
      payload,
      signature
    });
  };
  RecordEnvelope.openAndCertify = async (data, domain) => {
    const envelope = await _q.createFromProtobuf(data);
    const valid = await envelope.validate(domain);
    if (!valid) {
      throw new CodeError$3("envelope signature is not valid for the given domain", codes$2.ERR_SIGNATURE_NOT_VALID);
    }
    return envelope;
  };
  var formatSignaturePayload = (domain, payloadType, payload) => {
    const domainUint8Array = fromString$3(domain);
    const domainLength = unsigned.encode(domainUint8Array.byteLength);
    const payloadTypeLength = unsigned.encode(payloadType.length);
    const payloadLength = unsigned.encode(payload.length);
    return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
  };
  var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
  var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);
  var PeerRecord$1;
  (function(PeerRecord2) {
    (function(AddressInfo) {
      let _codec2;
      AddressInfo.codec = () => {
        if (_codec2 == null) {
          _codec2 = message$1((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
              w.uint32(10);
              w.bytes(obj.multiaddr);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              multiaddr: new Uint8Array(0)
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.multiaddr = reader2.bytes();
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      AddressInfo.encode = (obj) => {
        return encodeMessage(obj, AddressInfo.codec());
      };
      AddressInfo.decode = (buf) => {
        return decodeMessage$1(buf, AddressInfo.codec());
      };
    })(PeerRecord2.AddressInfo || (PeerRecord2.AddressInfo = {}));
    let _codec;
    PeerRecord2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.peerId != null && obj.peerId.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.peerId);
          }
          if (obj.seq != null && obj.seq !== 0n) {
            w.uint32(16);
            w.uint64(obj.seq);
          }
          if (obj.addresses != null) {
            for (const value of obj.addresses) {
              w.uint32(26);
              PeerRecord2.AddressInfo.codec().encode(value, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            peerId: new Uint8Array(0),
            seq: 0n,
            addresses: []
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.peerId = reader2.bytes();
                break;
              case 2:
                obj.seq = reader2.uint64();
                break;
              case 3:
                obj.addresses.push(PeerRecord2.AddressInfo.codec().decode(reader2, reader2.uint32()));
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerRecord2.encode = (obj) => {
      return encodeMessage(obj, PeerRecord2.codec());
    };
    PeerRecord2.decode = (buf) => {
      return decodeMessage$1(buf, PeerRecord2.codec());
    };
  })(PeerRecord$1 || (PeerRecord$1 = {}));

  class PeerRecord {
    constructor(init2) {
      this.domain = PeerRecord.DOMAIN;
      this.codec = PeerRecord.CODEC;
      const { peerId, multiaddrs, seqNumber } = init2;
      this.peerId = peerId;
      this.multiaddrs = multiaddrs ?? [];
      this.seqNumber = seqNumber ?? BigInt(Date.now());
    }
    marshal() {
      if (this.marshaled == null) {
        this.marshaled = PeerRecord$1.encode({
          peerId: this.peerId.toBytes(),
          seq: BigInt(this.seqNumber),
          addresses: this.multiaddrs.map((m) => ({
            multiaddr: m.bytes
          }))
        });
      }
      return this.marshaled;
    }
    equals(other) {
      if (!(other instanceof PeerRecord)) {
        return false;
      }
      if (!this.peerId.equals(other.peerId)) {
        return false;
      }
      if (this.seqNumber !== other.seqNumber) {
        return false;
      }
      if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
        return false;
      }
      return true;
    }
  }
  PeerRecord.createFromProtobuf = (buf) => {
    const peerRecord = PeerRecord$1.decode(buf);
    const peerId = peerIdFromBytes(peerRecord.peerId);
    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr$1(a.multiaddr));
    const seqNumber = peerRecord.seq;
    return new PeerRecord({ peerId, multiaddrs, seqNumber });
  };
  PeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
  PeerRecord.CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
  var eventemitter3 = { exports: {} };
  (function(module2) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once2) {
      this.fn = fn;
      this.context = context;
      this.once = once2 || false;
    }
    function addListener(emitter, event, fn, context, once2) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events;
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events;
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names2 = [], events2, name2;
      if (this._eventsCount === 0)
        return names2;
      for (name2 in events2 = this._events) {
        if (has.call(events2, name2))
          names2.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events2));
      }
      return names2;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, undefined, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1);i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j;
        for (i = 0;i < length2; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, undefined, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1);j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once2) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length2 = listeners.length;i < length2; i++) {
          if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events;
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module2.exports = EventEmitter2;
    }
  })(eventemitter3);
  var eventemitter3Exports = eventemitter3.exports;
  var EventEmitter = getDefaultExportFromCjs(eventemitter3Exports);
  var TimeoutError$1 = class TimeoutError2 extends Error {
    constructor(message2) {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var AbortError$2 = class AbortError2 extends Error {
    constructor(message2) {
      super();
      this.name = "AbortError";
      this.message = message2;
    }
  };
  var getDOMException$1 = (errorMessage) => globalThis.DOMException === undefined ? new AbortError$2(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason$1 = (signal) => {
    const reason = signal.reason === undefined ? getDOMException$1("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException$1(reason);
  };
  var __classPrivateFieldGet$1 = function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _PriorityQueue_queue;

  class PriorityQueue {
    constructor() {
      _PriorityQueue_queue.set(this, []);
    }
    enqueue(run, options) {
      options = {
        priority: 0,
        ...options
      };
      const element = {
        priority: options.priority,
        run
      };
      if (this.size && __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
        __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").push(element);
        return;
      }
      const index2 = lowerBound$1(__classPrivateFieldGet$1(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
      __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").splice(index2, 0, element);
    }
    dequeue() {
      const item = __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").shift();
      return item === null || item === undefined ? undefined : item.run;
    }
    filter(options) {
      return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").length;
    }
  }
  _PriorityQueue_queue = new WeakMap;
  var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _PQueue_instances;
  var _PQueue_carryoverConcurrencyCount;
  var _PQueue_isIntervalIgnored;
  var _PQueue_intervalCount;
  var _PQueue_intervalCap;
  var _PQueue_interval;
  var _PQueue_intervalEnd;
  var _PQueue_intervalId;
  var _PQueue_timeoutId;
  var _PQueue_queue;
  var _PQueue_queueClass;
  var _PQueue_pending;
  var _PQueue_concurrency;
  var _PQueue_isPaused;
  var _PQueue_throwOnTimeout;
  var _PQueue_doesIntervalAllowAnother_get;
  var _PQueue_doesConcurrentAllowAnother_get;
  var _PQueue_next;
  var _PQueue_onResumeInterval;
  var _PQueue_isIntervalPaused_get;
  var _PQueue_tryToStartAnother;
  var _PQueue_initializeIntervalIfNeeded;
  var _PQueue_onInterval;
  var _PQueue_processQueue;
  var _PQueue_throwOnAbort;
  var _PQueue_onEvent;
  var AbortError$1 = class AbortError2 extends Error {
  };

  class PQueue extends EventEmitter {
    constructor(options) {
      var _a3, _b2, _c2, _d;
      super();
      _PQueue_instances.add(this);
      _PQueue_carryoverConcurrencyCount.set(this, undefined);
      _PQueue_isIntervalIgnored.set(this, undefined);
      _PQueue_intervalCount.set(this, 0);
      _PQueue_intervalCap.set(this, undefined);
      _PQueue_interval.set(this, undefined);
      _PQueue_intervalEnd.set(this, 0);
      _PQueue_intervalId.set(this, undefined);
      _PQueue_timeoutId.set(this, undefined);
      _PQueue_queue.set(this, undefined);
      _PQueue_queueClass.set(this, undefined);
      _PQueue_pending.set(this, 0);
      _PQueue_concurrency.set(this, undefined);
      _PQueue_isPaused.set(this, undefined);
      _PQueue_throwOnTimeout.set(this, undefined);
      Object.defineProperty(this, "timeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      options = {
        carryoverConcurrencyCount: false,
        intervalCap: Number.POSITIVE_INFINITY,
        interval: 0,
        concurrency: Number.POSITIVE_INFINITY,
        autoStart: true,
        queueClass: PriorityQueue,
        ...options
      };
      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b2 = (_a3 = options.intervalCap) === null || _a3 === undefined ? undefined : _a3.toString()) !== null && _b2 !== undefined ? _b2 : ""}\` (${typeof options.intervalCap})`);
      }
      if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c2 = options.interval) === null || _c2 === undefined ? undefined : _c2.toString()) !== null && _d !== undefined ? _d : ""}\` (${typeof options.interval})`);
      }
      __classPrivateFieldSet2(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
      __classPrivateFieldSet2(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
      __classPrivateFieldSet2(this, _PQueue_intervalCap, options.intervalCap, "f");
      __classPrivateFieldSet2(this, _PQueue_interval, options.interval, "f");
      __classPrivateFieldSet2(this, _PQueue_queue, new options.queueClass, "f");
      __classPrivateFieldSet2(this, _PQueue_queueClass, options.queueClass, "f");
      this.concurrency = options.concurrency;
      this.timeout = options.timeout;
      __classPrivateFieldSet2(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
      __classPrivateFieldSet2(this, _PQueue_isPaused, options.autoStart === false, "f");
    }
    get concurrency() {
      return __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      __classPrivateFieldSet2(this, _PQueue_concurrency, newConcurrency, "f");
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    }
    async add(function_, options = {}) {
      options = {
        timeout: this.timeout,
        throwOnTimeout: __classPrivateFieldGet2(this, _PQueue_throwOnTimeout, "f"),
        ...options
      };
      return new Promise((resolve5, reject) => {
        __classPrivateFieldGet2(this, _PQueue_queue, "f").enqueue(async () => {
          var _a3;
          var _b2, _c2;
          __classPrivateFieldSet2(this, _PQueue_pending, (_b2 = __classPrivateFieldGet2(this, _PQueue_pending, "f"), _b2++, _b2), "f");
          __classPrivateFieldSet2(this, _PQueue_intervalCount, (_c2 = __classPrivateFieldGet2(this, _PQueue_intervalCount, "f"), _c2++, _c2), "f");
          try {
            if ((_a3 = options.signal) === null || _a3 === undefined ? undefined : _a3.aborted) {
              throw new AbortError$1("The task was aborted.");
            }
            let operation = function_({ signal: options.signal });
            if (options.timeout) {
              operation = pTimeout$1(Promise.resolve(operation), options.timeout);
            }
            if (options.signal) {
              operation = Promise.race([operation, __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, options.signal)]);
            }
            const result = await operation;
            resolve5(result);
            this.emit("completed", result);
          } catch (error) {
            if (error instanceof TimeoutError$1 && !options.throwOnTimeout) {
              resolve5();
              return;
            }
            reject(error);
            this.emit("error", error);
          } finally {
            __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_next).call(this);
          }
        }, options);
        this.emit("add");
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
      });
    }
    async addAll(functions, options) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    start() {
      if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
        return this;
      }
      __classPrivateFieldSet2(this, _PQueue_isPaused, false, "f");
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
      return this;
    }
    pause() {
      __classPrivateFieldSet2(this, _PQueue_isPaused, true, "f");
    }
    clear() {
      __classPrivateFieldSet2(this, _PQueue_queue, new (__classPrivateFieldGet2(this, _PQueue_queueClass, "f")), "f");
    }
    async onEmpty() {
      if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
        return;
      }
      await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
    }
    async onSizeLessThan(limit) {
      if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit) {
        return;
      }
      await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit);
    }
    async onIdle() {
      if (__classPrivateFieldGet2(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
        return;
      }
      await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
    }
    get size() {
      return __classPrivateFieldGet2(this, _PQueue_queue, "f").size;
    }
    sizeBy(options) {
      return __classPrivateFieldGet2(this, _PQueue_queue, "f").filter(options).length;
    }
    get pending() {
      return __classPrivateFieldGet2(this, _PQueue_pending, "f");
    }
    get isPaused() {
      return __classPrivateFieldGet2(this, _PQueue_isPaused, "f");
    }
  }
  _PQueue_carryoverConcurrencyCount = new WeakMap, _PQueue_isIntervalIgnored = new WeakMap, _PQueue_intervalCount = new WeakMap, _PQueue_intervalCap = new WeakMap, _PQueue_interval = new WeakMap, _PQueue_intervalEnd = new WeakMap, _PQueue_intervalId = new WeakMap, _PQueue_timeoutId = new WeakMap, _PQueue_queue = new WeakMap, _PQueue_queueClass = new WeakMap, _PQueue_pending = new WeakMap, _PQueue_concurrency = new WeakMap, _PQueue_isPaused = new WeakMap, _PQueue_throwOnTimeout = new WeakMap, _PQueue_instances = new WeakSet, _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {
    return __classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet2(this, _PQueue_intervalCap, "f");
  }, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {
    return __classPrivateFieldGet2(this, _PQueue_pending, "f") < __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
  }, _PQueue_next = function _PQueue_next() {
    var _a3;
    __classPrivateFieldSet2(this, _PQueue_pending, (_a3 = __classPrivateFieldGet2(this, _PQueue_pending, "f"), _a3--, _a3), "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    this.emit("next");
  }, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
    __classPrivateFieldSet2(this, _PQueue_timeoutId, undefined, "f");
  }, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {
    const now = Date.now();
    if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f") === undefined) {
      const delay = __classPrivateFieldGet2(this, _PQueue_intervalEnd, "f") - now;
      if (delay < 0) {
        __classPrivateFieldSet2(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pending, "f") : 0, "f");
      } else {
        if (__classPrivateFieldGet2(this, _PQueue_timeoutId, "f") === undefined) {
          __classPrivateFieldSet2(this, _PQueue_timeoutId, setTimeout(() => {
            __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
          }, delay), "f");
        }
        return true;
      }
    }
    return false;
  }, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
        clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
      }
      __classPrivateFieldSet2(this, _PQueue_intervalId, undefined, "f");
      this.emit("empty");
      if (__classPrivateFieldGet2(this, _PQueue_pending, "f") === 0) {
        this.emit("idle");
      }
      return false;
    }
    if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
      const canInitializeInterval = !__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
      if (__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
        const job = __classPrivateFieldGet2(this, _PQueue_queue, "f").dequeue();
        if (!job) {
          return false;
        }
        this.emit("active");
        job();
        if (canInitializeInterval) {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
        }
        return true;
      }
    }
    return false;
  }, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {
    if (__classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalId, "f") !== undefined) {
      return;
    }
    __classPrivateFieldSet2(this, _PQueue_intervalId, setInterval(() => {
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
    }, __classPrivateFieldGet2(this, _PQueue_interval, "f")), "f");
    __classPrivateFieldSet2(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet2(this, _PQueue_interval, "f"), "f");
  }, _PQueue_onInterval = function _PQueue_onInterval() {
    if (__classPrivateFieldGet2(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
      __classPrivateFieldSet2(this, _PQueue_intervalId, undefined, "f");
    }
    __classPrivateFieldSet2(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pending, "f") : 0, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }, _PQueue_processQueue = function _PQueue_processQueue() {
    while (__classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
    }
  }, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(new AbortError$1("The task was aborted."));
      }, { once: true });
    });
  }, _PQueue_onEvent = async function _PQueue_onEvent(event, filter2) {
    return new Promise((resolve5) => {
      const listener = () => {
        if (filter2 && !filter2()) {
          return;
        }
        this.off(event, listener);
        resolve5();
      };
      this.on(event, listener);
    });
  };

  class TimeoutError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "TimeoutError";
    }
  }

  class AbortError extends Error {
    constructor(message2) {
      super();
      this.name = "AbortError";
      this.message = message2;
    }
  }
  var getDOMException = (errorMessage) => globalThis.DOMException === undefined ? new AbortError(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason = (signal) => {
    const reason = signal.reason === undefined ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
  };
  var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63;
    if (byte < 36) {
      id += byte.toString(36);
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte > 62) {
      id += "-";
    } else {
      id += "_";
    }
    return id;
  }, "");
  var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
  var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
  var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
  var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
  var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
  var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
  var events = {};
  var observable = (worker) => {
    worker.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
    if (worker.port != null) {
      worker.port.addEventListener("message", (event) => {
        observable.dispatchEvent("message", worker, event);
      });
    }
  };
  observable.addEventListener = (type, fn) => {
    if (events[type] == null) {
      events[type] = [];
    }
    events[type].push(fn);
  };
  observable.removeEventListener = (type, fn) => {
    if (events[type] == null) {
      return;
    }
    events[type] = events[type].filter((listener) => listener === fn);
  };
  observable.dispatchEvent = function(type, worker, event) {
    if (events[type] == null) {
      return;
    }
    events[type].forEach((fn) => fn(worker, event));
  };
  var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
    return (worker, event) => {
      if (event.data.type !== requestType) {
        return;
      }
      const requestEvent = {
        type: event.data.type,
        name: event.data.name,
        identifier: event.data.identifier
      };
      emitter.dispatchEvent(new MessageEvent(masterEvent, {
        data: {
          name: requestEvent.name,
          handler: async () => {
            worker.postMessage({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            return await new Promise((resolve5) => {
              const releaseEventListener = (event2) => {
                if (event2 == null || event2.data == null) {
                  return;
                }
                const releaseEvent = {
                  type: event2.data.type,
                  name: event2.data.name,
                  identifier: event2.data.identifier
                };
                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  worker.removeEventListener("message", releaseEventListener);
                  resolve5();
                }
              };
              worker.addEventListener("message", releaseEventListener);
            });
          }
        }
      }));
    };
  };
  var makeWorkerLockRequest = (name2, requestType, grantType, releaseType) => {
    return async () => {
      const id = nanoid();
      globalThis.postMessage({
        type: requestType,
        identifier: id,
        name: name2
      });
      return await new Promise((resolve5) => {
        const listener = (event) => {
          if (event == null || event.data == null) {
            return;
          }
          const responseEvent = {
            type: event.data.type,
            identifier: event.data.identifier
          };
          if (responseEvent.type === grantType && responseEvent.identifier === id) {
            globalThis.removeEventListener("message", listener);
            resolve5(() => {
              globalThis.postMessage({
                type: releaseType,
                identifier: id,
                name: name2
              });
            });
          }
        };
        globalThis.addEventListener("message", listener);
      });
    };
  };
  var defaultOptions$5 = {
    singleProcess: false
  };
  var impl = (options) => {
    options = Object.assign({}, defaultOptions$5, options);
    const isPrimary = Boolean(globalThis.document) || options.singleProcess;
    if (isPrimary) {
      const emitter = new EventTarget;
      observable.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
      observable.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
      return emitter;
    }
    return {
      isWorker: true,
      readLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
      writeLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
    };
  };
  var mutexes = {};
  var implementation;
  var createMutex = (name2, options) => {
    if (implementation.isWorker === true) {
      return {
        readLock: implementation.readLock(name2, options),
        writeLock: implementation.writeLock(name2, options)
      };
    }
    const masterQueue = new PQueue({ concurrency: 1 });
    let readQueue;
    return {
      async readLock() {
        if (readQueue != null) {
          return await createReleaseable(readQueue, options);
        }
        readQueue = new PQueue({
          concurrency: options.concurrency,
          autoStart: false
        });
        const localReadQueue = readQueue;
        const readPromise = createReleaseable(readQueue, options);
        masterQueue.add(async () => {
          localReadQueue.start();
          return await localReadQueue.onIdle().then(() => {
            if (readQueue === localReadQueue) {
              readQueue = null;
            }
          });
        });
        return await readPromise;
      },
      async writeLock() {
        readQueue = null;
        return await createReleaseable(masterQueue, options);
      }
    };
  };
  var defaultOptions$4 = {
    name: "lock",
    concurrency: Infinity,
    timeout: 84600000,
    singleProcess: false
  };
  var codes$1 = {
    ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS"
  };
  var Peer;
  (function(Peer2) {
    (function(Peer$metadataEntry) {
      let _codec2;
      Peer$metadataEntry.codec = () => {
        if (_codec2 == null) {
          _codec2 = message$1((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.key != null && obj.key !== "") {
              w.uint32(10);
              w.string(obj.key);
            }
            if (obj.value != null && obj.value.byteLength > 0) {
              w.uint32(18);
              w.bytes(obj.value);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              key: "",
              value: new Uint8Array(0)
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.key = reader2.string();
                  break;
                case 2:
                  obj.value = reader2.bytes();
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Peer$metadataEntry.encode = (obj) => {
        return encodeMessage(obj, Peer$metadataEntry.codec());
      };
      Peer$metadataEntry.decode = (buf) => {
        return decodeMessage$1(buf, Peer$metadataEntry.codec());
      };
    })(Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
    (function(Peer$tagsEntry) {
      let _codec2;
      Peer$tagsEntry.codec = () => {
        if (_codec2 == null) {
          _codec2 = message$1((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.key != null && obj.key !== "") {
              w.uint32(10);
              w.string(obj.key);
            }
            if (obj.value != null) {
              w.uint32(18);
              Tag.codec().encode(obj.value, w);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length2) => {
            const obj = {
              key: ""
            };
            const end = length2 == null ? reader2.len : reader2.pos + length2;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1:
                  obj.key = reader2.string();
                  break;
                case 2:
                  obj.value = Tag.codec().decode(reader2, reader2.uint32());
                  break;
                default:
                  reader2.skipType(tag & 7);
                  break;
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Peer$tagsEntry.encode = (obj) => {
        return encodeMessage(obj, Peer$tagsEntry.codec());
      };
      Peer$tagsEntry.decode = (buf) => {
        return decodeMessage$1(buf, Peer$tagsEntry.codec());
      };
    })(Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
    let _codec;
    Peer2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.addresses != null) {
            for (const value of obj.addresses) {
              w.uint32(10);
              Address.codec().encode(value, w);
            }
          }
          if (obj.protocols != null) {
            for (const value of obj.protocols) {
              w.uint32(18);
              w.string(value);
            }
          }
          if (obj.publicKey != null) {
            w.uint32(34);
            w.bytes(obj.publicKey);
          }
          if (obj.peerRecordEnvelope != null) {
            w.uint32(42);
            w.bytes(obj.peerRecordEnvelope);
          }
          if (obj.metadata != null && obj.metadata.size !== 0) {
            for (const [key, value] of obj.metadata.entries()) {
              w.uint32(50);
              Peer2.Peer$metadataEntry.codec().encode({ key, value }, w);
            }
          }
          if (obj.tags != null && obj.tags.size !== 0) {
            for (const [key, value] of obj.tags.entries()) {
              w.uint32(58);
              Peer2.Peer$tagsEntry.codec().encode({ key, value }, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            addresses: [],
            protocols: [],
            metadata: new Map,
            tags: new Map
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.addresses.push(Address.codec().decode(reader2, reader2.uint32()));
                break;
              case 2:
                obj.protocols.push(reader2.string());
                break;
              case 4:
                obj.publicKey = reader2.bytes();
                break;
              case 5:
                obj.peerRecordEnvelope = reader2.bytes();
                break;
              case 6: {
                const entry = Peer2.Peer$metadataEntry.codec().decode(reader2, reader2.uint32());
                obj.metadata.set(entry.key, entry.value);
                break;
              }
              case 7: {
                const entry = Peer2.Peer$tagsEntry.codec().decode(reader2, reader2.uint32());
                obj.tags.set(entry.key, entry.value);
                break;
              }
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Peer2.encode = (obj) => {
      return encodeMessage(obj, Peer2.codec());
    };
    Peer2.decode = (buf) => {
      return decodeMessage$1(buf, Peer2.codec());
    };
  })(Peer || (Peer = {}));
  var Address;
  (function(Address2) {
    let _codec;
    Address2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (obj.isCertified != null) {
            w.uint32(16);
            w.bool(obj.isCertified);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            multiaddr: new Uint8Array(0)
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.multiaddr = reader2.bytes();
                break;
              case 2:
                obj.isCertified = reader2.bool();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Address2.encode = (obj) => {
      return encodeMessage(obj, Address2.codec());
    };
    Address2.decode = (buf) => {
      return decodeMessage$1(buf, Address2.codec());
    };
  })(Address || (Address = {}));
  var Tag;
  (function(Tag2) {
    let _codec;
    Tag2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.value != null && obj.value !== 0) {
            w.uint32(8);
            w.uint32(obj.value);
          }
          if (obj.expiry != null) {
            w.uint32(16);
            w.uint64(obj.expiry);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            value: 0
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.value = reader2.uint32();
                break;
              case 2:
                obj.expiry = reader2.uint64();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Tag2.encode = (obj) => {
      return encodeMessage(obj, Tag2.codec());
    };
    Tag2.decode = (buf) => {
      return decodeMessage$1(buf, Tag2.codec());
    };
  })(Tag || (Tag = {}));
  var NAMESPACE_COMMON = "/peers/";

  class PersistentStore {
    constructor(components, init2 = {}) {
      _PersistentStore_instances.add(this);
      this.peerId = components.peerId;
      this.datastore = components.datastore;
      this.addressFilter = init2.addressFilter;
      this.lock = createMortice({
        name: "peer-store",
        singleProcess: true
      });
    }
    async has(peerId) {
      return this.datastore.has(peerIdToDatastoreKey(peerId));
    }
    async delete(peerId) {
      if (this.peerId.equals(peerId)) {
        throw new CodeError$3("Cannot delete self peer", codes$1.ERR_INVALID_PARAMETERS);
      }
      await this.datastore.delete(peerIdToDatastoreKey(peerId));
    }
    async load(peerId) {
      const buf = await this.datastore.get(peerIdToDatastoreKey(peerId));
      return bytesToPeer(peerId, buf);
    }
    async save(peerId, data) {
      const { existingBuf, existingPeer } = await __classPrivateFieldGet2(this, _PersistentStore_instances, "m", _PersistentStore_findExistingPeer).call(this, peerId);
      const peerPb = await toPeerPB(peerId, data, "patch", {
        addressFilter: this.addressFilter
      });
      return __classPrivateFieldGet2(this, _PersistentStore_instances, "m", _PersistentStore_saveIfDifferent).call(this, peerId, peerPb, existingBuf, existingPeer);
    }
    async patch(peerId, data) {
      const { existingBuf, existingPeer } = await __classPrivateFieldGet2(this, _PersistentStore_instances, "m", _PersistentStore_findExistingPeer).call(this, peerId);
      const peerPb = await toPeerPB(peerId, data, "patch", {
        addressFilter: this.addressFilter,
        existingPeer
      });
      return __classPrivateFieldGet2(this, _PersistentStore_instances, "m", _PersistentStore_saveIfDifferent).call(this, peerId, peerPb, existingBuf, existingPeer);
    }
    async merge(peerId, data) {
      const { existingBuf, existingPeer } = await __classPrivateFieldGet2(this, _PersistentStore_instances, "m", _PersistentStore_findExistingPeer).call(this, peerId);
      const peerPb = await toPeerPB(peerId, data, "merge", {
        addressFilter: this.addressFilter,
        existingPeer
      });
      return __classPrivateFieldGet2(this, _PersistentStore_instances, "m", _PersistentStore_saveIfDifferent).call(this, peerId, peerPb, existingBuf, existingPeer);
    }
    async* all(query2) {
      const peerCache = new PeerMap;
      for await (const { key, value } of this.datastore.query(mapQuery(query2 ?? {}, peerCache))) {
        const peer = decodePeer(key, value, peerCache);
        if (peer.id.equals(this.peerId)) {
          continue;
        }
        yield peer;
      }
    }
  }
  _PersistentStore_instances = new WeakSet, _PersistentStore_findExistingPeer = async function _PersistentStore_findExistingPeer(peerId) {
    try {
      const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId));
      const existingPeer = bytesToPeer(peerId, existingBuf);
      return {
        existingBuf,
        existingPeer
      };
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    return {};
  }, _PersistentStore_saveIfDifferent = async function _PersistentStore_saveIfDifferent(peerId, peer, existingBuf, existingPeer) {
    const buf = Peer.encode(peer);
    if (existingBuf != null && equals$4(buf, existingBuf)) {
      return {
        peer: bytesToPeer(peerId, buf),
        previous: existingPeer,
        updated: false
      };
    }
    await this.datastore.put(peerIdToDatastoreKey(peerId), buf);
    return {
      peer: bytesToPeer(peerId, buf),
      previous: existingPeer,
      updated: true
    };
  };
  var log$j = logger$1("libp2p:peer-store");

  class PersistentPeerStore {
    constructor(components, init2 = {}) {
      _PersistentPeerStore_instances.add(this);
      this.events = components.events;
      this.peerId = components.peerId;
      this.store = new PersistentStore(components, init2);
    }
    async forEach(fn, query2) {
      log$j.trace("forEach await read lock");
      const release = await this.store.lock.readLock();
      log$j.trace("forEach got read lock");
      try {
        for await (const peer of this.store.all(query2)) {
          fn(peer);
        }
      } finally {
        log$j.trace("forEach release read lock");
        release();
      }
    }
    async all(query2) {
      log$j.trace("all await read lock");
      const release = await this.store.lock.readLock();
      log$j.trace("all got read lock");
      try {
        return await all$1(this.store.all(query2));
      } finally {
        log$j.trace("all release read lock");
        release();
      }
    }
    async delete(peerId) {
      log$j.trace("delete await write lock");
      const release = await this.store.lock.writeLock();
      log$j.trace("delete got write lock");
      try {
        await this.store.delete(peerId);
      } finally {
        log$j.trace("delete release write lock");
        release();
      }
    }
    async has(peerId) {
      log$j.trace("has await read lock");
      const release = await this.store.lock.readLock();
      log$j.trace("has got read lock");
      try {
        return await this.store.has(peerId);
      } finally {
        log$j.trace("has release read lock");
        release();
      }
    }
    async get(peerId) {
      log$j.trace("get await read lock");
      const release = await this.store.lock.readLock();
      log$j.trace("get got read lock");
      try {
        return await this.store.load(peerId);
      } finally {
        log$j.trace("get release read lock");
        release();
      }
    }
    async save(id, data) {
      log$j.trace("save await write lock");
      const release = await this.store.lock.writeLock();
      log$j.trace("save got write lock");
      try {
        const result = await this.store.save(id, data);
        __classPrivateFieldGet2(this, _PersistentPeerStore_instances, "m", _PersistentPeerStore_emitIfUpdated).call(this, id, result);
        return result.peer;
      } finally {
        log$j.trace("save release write lock");
        release();
      }
    }
    async patch(id, data) {
      log$j.trace("patch await write lock");
      const release = await this.store.lock.writeLock();
      log$j.trace("patch got write lock");
      try {
        const result = await this.store.patch(id, data);
        __classPrivateFieldGet2(this, _PersistentPeerStore_instances, "m", _PersistentPeerStore_emitIfUpdated).call(this, id, result);
        return result.peer;
      } finally {
        log$j.trace("patch release write lock");
        release();
      }
    }
    async merge(id, data) {
      log$j.trace("merge await write lock");
      const release = await this.store.lock.writeLock();
      log$j.trace("merge got write lock");
      try {
        const result = await this.store.merge(id, data);
        __classPrivateFieldGet2(this, _PersistentPeerStore_instances, "m", _PersistentPeerStore_emitIfUpdated).call(this, id, result);
        return result.peer;
      } finally {
        log$j.trace("merge release write lock");
        release();
      }
    }
    async consumePeerRecord(buf, expectedPeer) {
      const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN);
      if (expectedPeer?.equals(envelope.peerId) === false) {
        log$j("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, envelope.peerId);
        return false;
      }
      const peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
      let peer;
      try {
        peer = await this.get(envelope.peerId);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      if (peer?.peerRecordEnvelope != null) {
        const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
        const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log$j("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          return false;
        }
      }
      await this.patch(peerRecord.peerId, {
        peerRecordEnvelope: buf,
        addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
          isCertified: true,
          multiaddr: multiaddr2
        }))
      });
      return true;
    }
  }
  _PersistentPeerStore_instances = new WeakSet, _PersistentPeerStore_emitIfUpdated = function _PersistentPeerStore_emitIfUpdated(id, result) {
    if (!result.updated) {
      return;
    }
    if (this.peerId.equals(id)) {
      this.events.safeDispatchEvent("self:peer:update", { detail: result });
    } else {
      this.events.safeDispatchEvent("peer:update", { detail: result });
    }
  };

  class BaseDatastore {
    put(key, val, options) {
      return Promise.reject(new Error(".put is not implemented"));
    }
    get(key, options) {
      return Promise.reject(new Error(".get is not implemented"));
    }
    has(key, options) {
      return Promise.reject(new Error(".has is not implemented"));
    }
    delete(key, options) {
      return Promise.reject(new Error(".delete is not implemented"));
    }
    async* putMany(source2, options = {}) {
      for await (const { key, value } of source2) {
        await this.put(key, value, options);
        yield key;
      }
    }
    async* getMany(source2, options = {}) {
      for await (const key of source2) {
        yield {
          key,
          value: await this.get(key, options)
        };
      }
    }
    async* deleteMany(source2, options = {}) {
      for await (const key of source2) {
        await this.delete(key, options);
        yield key;
      }
    }
    batch() {
      let puts = [];
      let dels = [];
      return {
        put(key, value) {
          puts.push({ key, value });
        },
        delete(key) {
          dels.push(key);
        },
        commit: async (options) => {
          await drain(this.putMany(puts, options));
          puts = [];
          await drain(this.deleteMany(dels, options));
          dels = [];
        }
      };
    }
    async* _all(q, options) {
      throw new Error("._all is not implemented");
    }
    async* _allKeys(q, options) {
      throw new Error("._allKeys is not implemented");
    }
    query(q, options) {
      let it = this._all(q, options);
      if (q.prefix != null) {
        const prefix = q.prefix;
        it = filter$1(it, (e) => e.key.toString().startsWith(prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => filter$1(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => sort(it2, f), it);
      }
      if (q.offset != null) {
        let i = 0;
        const offset = q.offset;
        it = filter$1(it, () => i++ >= offset);
      }
      if (q.limit != null) {
        it = take(it, q.limit);
      }
      return it;
    }
    queryKeys(q, options) {
      let it = this._allKeys(q, options);
      if (q.prefix != null) {
        const prefix = q.prefix;
        it = filter$1(it, (key) => key.toString().startsWith(prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => filter$1(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => sort(it2, f), it);
      }
      if (q.offset != null) {
        const offset = q.offset;
        let i = 0;
        it = filter$1(it, () => i++ >= offset);
      }
      if (q.limit != null) {
        it = take(it, q.limit);
      }
      return it;
    }
  }

  class MemoryDatastore extends BaseDatastore {
    constructor() {
      super();
      this.data = new Map;
    }
    put(key, val) {
      this.data.set(key.toString(), val);
      return key;
    }
    get(key) {
      const result = this.data.get(key.toString());
      if (result == null) {
        throw notFoundError();
      }
      return result;
    }
    has(key) {
      return this.data.has(key.toString());
    }
    delete(key) {
      this.data.delete(key.toString());
    }
    *_all() {
      for (const [key, value] of this.data.entries()) {
        yield { key: new Key(key), value };
      }
    }
    *_allKeys() {
      for (const key of this.data.keys()) {
        yield new Key(key);
      }
    }
  }
  var log$i = logger$2("libp2p:address-manager");
  var defaultAddressFilter = (addrs) => addrs;

  class DefaultAddressManager {
    constructor(components, init2 = {}) {
      const { listen = [], announce = [] } = init2;
      this.components = components;
      this.listen = listen.map((ma) => ma.toString());
      this.announce = new Set(announce.map((ma) => ma.toString()));
      this.observed = new Map;
      this.announceFilter = init2.announceFilter ?? defaultAddressFilter;
      this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1000);
      components.events.addEventListener("transport:listening", () => {
        this._updatePeerStoreAddresses();
      });
      components.events.addEventListener("transport:close", () => {
        this._updatePeerStoreAddresses();
      });
    }
    _updatePeerStoreAddresses() {
      const addrs = this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([_, metadata]) => metadata.confident).map(([str]) => multiaddr$1(str))).map((ma) => {
        if (ma.getPeerId() === this.components.peerId.toString()) {
          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
        }
        return ma;
      });
      this.components.peerStore.patch(this.components.peerId, {
        multiaddrs: addrs
      }).catch((err) => {
        log$i.error("error updating addresses", err);
      });
    }
    getListenAddrs() {
      return Array.from(this.listen).map((a) => multiaddr$1(a));
    }
    getAnnounceAddrs() {
      return Array.from(this.announce).map((a) => multiaddr$1(a));
    }
    getObservedAddrs() {
      return Array.from(this.observed).map(([a]) => multiaddr$1(a));
    }
    addObservedAddr(addr) {
      addr = stripPeerId(addr, this.components.peerId);
      const addrString = addr.toString();
      if (this.observed.has(addrString)) {
        return;
      }
      this.observed.set(addrString, {
        confident: false
      });
    }
    confirmObservedAddr(addr) {
      addr = stripPeerId(addr, this.components.peerId);
      const addrString = addr.toString();
      const metadata = this.observed.get(addrString) ?? {
        confident: false
      };
      const startingConfidence = metadata.confident;
      this.observed.set(addrString, {
        confident: true
      });
      if (!startingConfidence) {
        this._updatePeerStoreAddresses();
      }
    }
    removeObservedAddr(addr) {
      addr = stripPeerId(addr, this.components.peerId);
      const addrString = addr.toString();
      this.observed.delete(addrString);
    }
    getAddresses() {
      let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
      if (addrs.length === 0) {
        addrs = this.components.transportManager.getAddrs().map((ma) => ma.toString());
      }
      addrs = addrs.concat(Array.from(this.observed).filter(([ma, metadata]) => metadata.confident).map(([ma]) => ma));
      const addrSet = new Set(addrs);
      return this.announceFilter(Array.from(addrSet).map((str) => multiaddr$1(str))).map((ma) => {
        if (ma.protos().pop()?.path === true) {
          return ma;
        }
        if (ma.getPeerId() === this.components.peerId.toString()) {
          return ma;
        }
        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
      });
    }
  }

  class DefaultComponents {
    constructor(init2 = {}) {
      this.components = {};
      this._started = false;
      this.components = {};
      for (const [key, value] of Object.entries(init2)) {
        this.components[key] = value;
      }
    }
    isStarted() {
      return this._started;
    }
    async _invokeStartableMethod(methodName) {
      await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
        await startable[methodName]?.();
      }));
    }
    async beforeStart() {
      await this._invokeStartableMethod("beforeStart");
    }
    async start() {
      await this._invokeStartableMethod("start");
      this._started = true;
    }
    async afterStart() {
      await this._invokeStartableMethod("afterStart");
    }
    async beforeStop() {
      await this._invokeStartableMethod("beforeStop");
    }
    async stop() {
      await this._invokeStartableMethod("stop");
      this._started = false;
    }
    async afterStop() {
      await this._invokeStartableMethod("afterStop");
    }
  }
  var OPTIONAL_SERVICES = [
    "metrics",
    "connectionProtector"
  ];
  var NON_SERVICE_PROPERTIES = [
    "components",
    "isStarted",
    "beforeStart",
    "start",
    "afterStart",
    "beforeStop",
    "stop",
    "afterStop",
    "then",
    "_invokeStartableMethod"
  ];
  var Netmask_1;
  (function() {
    var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
    long2ip = function(long) {
      var a, b, c, d;
      a = (long & 255 << 24) >>> 24;
      b = (long & 255 << 16) >>> 16;
      c = (long & 255 << 8) >>> 8;
      d = long & 255;
      return [a, b, c, d].join(".");
    };
    ip2long = function(ip) {
      var b, c, i, j, n, ref;
      b = [];
      for (i = j = 0;j <= 3; i = ++j) {
        if (ip.length === 0) {
          break;
        }
        if (i > 0) {
          if (ip[0] !== ".") {
            throw new Error("Invalid IP");
          }
          ip = ip.substring(1);
        }
        ref = atob(ip), n = ref[0], c = ref[1];
        ip = ip.substring(c);
        b.push(n);
      }
      if (ip.length !== 0) {
        throw new Error("Invalid IP");
      }
      switch (b.length) {
        case 1:
          if (b[0] > 4294967295) {
            throw new Error("Invalid IP");
          }
          return b[0] >>> 0;
        case 2:
          if (b[0] > 255 || b[1] > 16777215) {
            throw new Error("Invalid IP");
          }
          return (b[0] << 24 | b[1]) >>> 0;
        case 3:
          if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
            throw new Error("Invalid IP");
          }
          return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
        case 4:
          if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
            throw new Error("Invalid IP");
          }
          return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
        default:
          throw new Error("Invalid IP");
      }
    };
    chr = function(b) {
      return b.charCodeAt(0);
    };
    chr0 = chr("0");
    chra = chr("a");
    chrA = chr("A");
    atob = function(s2) {
      var base3, dmax, i, n, start;
      n = 0;
      base3 = 10;
      dmax = "9";
      i = 0;
      if (s2.length > 1 && s2[i] === "0") {
        if (s2[i + 1] === "x" || s2[i + 1] === "X") {
          i += 2;
          base3 = 16;
        } else if ("0" <= s2[i + 1] && s2[i + 1] <= "9") {
          i++;
          base3 = 8;
          dmax = "7";
        }
      }
      start = i;
      while (i < s2.length) {
        if ("0" <= s2[i] && s2[i] <= dmax) {
          n = n * base3 + (chr(s2[i]) - chr0) >>> 0;
        } else if (base3 === 16) {
          if ("a" <= s2[i] && s2[i] <= "f") {
            n = n * base3 + (10 + chr(s2[i]) - chra) >>> 0;
          } else if ("A" <= s2[i] && s2[i] <= "F") {
            n = n * base3 + (10 + chr(s2[i]) - chrA) >>> 0;
          } else {
            break;
          }
        } else {
          break;
        }
        if (n > 4294967295) {
          throw new Error("too large");
        }
        i++;
      }
      if (i === start) {
        throw new Error("empty octet");
      }
      return [n, i];
    };
    Netmask = function() {
      function Netmask2(net, mask) {
        var i, j, ref;
        if (typeof net !== "string") {
          throw new Error("Missing `net' parameter");
        }
        if (!mask) {
          ref = net.split("/", 2), net = ref[0], mask = ref[1];
        }
        if (!mask) {
          mask = 32;
        }
        if (typeof mask === "string" && mask.indexOf(".") > -1) {
          try {
            this.maskLong = ip2long(mask);
          } catch (error1) {
            throw new Error("Invalid mask: " + mask);
          }
          for (i = j = 32;j >= 0; i = --j) {
            if (this.maskLong === 4294967295 << 32 - i >>> 0) {
              this.bitmask = i;
              break;
            }
          }
        } else if (mask || mask === 0) {
          this.bitmask = parseInt(mask, 10);
          this.maskLong = 0;
          if (this.bitmask > 0) {
            this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
          }
        } else {
          throw new Error("Invalid mask: empty");
        }
        try {
          this.netLong = (ip2long(net) & this.maskLong) >>> 0;
        } catch (error1) {
          throw new Error("Invalid net address: " + net);
        }
        if (!(this.bitmask <= 32)) {
          throw new Error("Invalid mask for ip4: " + mask);
        }
        this.size = Math.pow(2, 32 - this.bitmask);
        this.base = long2ip(this.netLong);
        this.mask = long2ip(this.maskLong);
        this.hostmask = long2ip(~this.maskLong);
        this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
        this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
        this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : undefined;
      }
      Netmask2.prototype.contains = function(ip) {
        if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
          ip = new Netmask2(ip);
        }
        if (ip instanceof Netmask2) {
          return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
        } else {
          return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
        }
      };
      Netmask2.prototype.next = function(count) {
        if (count == null) {
          count = 1;
        }
        return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
      };
      Netmask2.prototype.forEach = function(fn) {
        var index2, lastLong, long;
        long = ip2long(this.first);
        lastLong = ip2long(this.last);
        index2 = 0;
        while (long <= lastLong) {
          fn(long2ip(long), long, index2);
          index2++;
          long++;
        }
      };
      Netmask2.prototype.toString = function() {
        return this.base + "/" + this.bitmask;
      };
      return Netmask2;
    }();
    Netmask_1 = Netmask;
  }).call(commonjsGlobal);
  var word = "[a-fA-F\\d:]";
  var boundry = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|\$))` : "";
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6segment = "[a-fA-F\\d]{1,4}";
  var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp(`(?:^${v4}\$)|(?:^${v6}\$)`);
  var v4exact = new RegExp(`^${v4}\$`);
  var v6exact = new RegExp(`^${v6}\$`);
  var ipRegex = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, "g");
  ipRegex.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, "g");
  ipRegex.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, "g");
  var ipaddr$1 = { exports: {} };
  (function(module2) {
    (function(root) {
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\$`, "i"),
        longValue: new RegExp(`^${ipv4Part}\$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+\$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+\$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        native: new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?\$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)\$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?\$`, "i")
      };
      function expandIPv6(string2, parts) {
        if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string2.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string2 = string2.replace(/%.+$/, "");
        }
        while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string2.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string2.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string2 = string2.replace("::", replacement);
        if (string2[0] === ":") {
          string2 = string2.slice(1);
        }
        if (string2[string2.length - 1] === ":") {
          string2 = string2.slice(0, -1);
        }
        parts = function() {
          const ref = string2.split(":");
          const results = [];
          for (let i = 0;i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first2, second2, partSize, cidrBits) {
        if (first2.length !== second2.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first2[part] >> shift !== second2[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string2) {
        if (hexRegex.test(string2)) {
          return parseInt(string2, 16);
        }
        if (string2[0] === "0" && !isNaN(parseInt(string2[1], 10))) {
          if (octalRegex.test(string2)) {
            return parseInt(string2, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string2} as octal`);
        }
        return parseInt(string2, 10);
      }
      function padPart(part, length2) {
        while (part.length < length2) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr2 = {};
      ipaddr2.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0;i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          private: [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === undefined) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3;i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string2) {
        try {
          const cidr = this.parseCIDR(string2);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.isIPv4 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv4.isValid = function(string2) {
        try {
          new this(this.parser(string2));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string2) {
        if (ipaddr2.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string2) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.parse = function(string2) {
        const parts = this.parser(string2);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr2.IPv4.parseCIDR = function(string2) {
        let match;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.parser = function(string2) {
        let match, part, value;
        if (match = string2.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0;i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string2.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0;shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string2.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string2.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0;i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0;i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === undefined) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7;i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes2 = [];
          const ref = this.parts;
          for (let i = 0;i < ref.length; i++) {
            part = ref[i];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0;i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0;i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string2 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string2)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string2;
          }
          return `${string2.substring(0, bestMatchIndex)}::${string2.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        return IPv6;
      }();
      ipaddr2.IPv6.broadcastAddressFromCIDR = function(string2) {
        try {
          const cidr = this.parseCIDR(string2);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.isIPv6 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv6.isValid = function(string2) {
        if (typeof string2 === "string" && string2.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string2);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv6.networkAddressFromCIDR = function(string2) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.parse = function(string2) {
        const addr = this.parser(string2);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv6.parseCIDR = function(string2) {
        let maskLength, match, parsed;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.IPv6.parser = function(string2) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string2.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string2)) {
          return expandIPv6(string2, 8);
        }
        if (match = string2.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0;i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.fromByteArray = function(bytes2) {
        const length2 = bytes2.length;
        if (length2 === 4) {
          return new ipaddr2.IPv4(bytes2);
        } else if (length2 === 16) {
          return new ipaddr2.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.isValid = function(string2) {
        return ipaddr2.IPv6.isValid(string2) || ipaddr2.IPv4.isValid(string2);
      };
      ipaddr2.parse = function(string2) {
        if (ipaddr2.IPv6.isValid(string2)) {
          return ipaddr2.IPv6.parse(string2);
        } else if (ipaddr2.IPv4.isValid(string2)) {
          return ipaddr2.IPv4.parse(string2);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string2) {
        try {
          return ipaddr2.IPv6.parseCIDR(string2);
        } catch (e) {
          try {
            return ipaddr2.IPv4.parseCIDR(string2);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.process = function(string2) {
        const addr = this.parse(string2);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === undefined || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0;i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (module2.exports) {
        module2.exports = ipaddr2;
      } else {
        root.ipaddr = ipaddr2;
      }
    })(commonjsGlobal);
  })(ipaddr$1);
  var ipaddrExports = ipaddr$1.exports;
  var ipaddr = getDefaultExportFromCjs(ipaddrExports);
  var { isValid: is_valid, parse } = ipaddr;
  var PRIVATE_IP_RANGES = [
    "0.0.0.0/8",
    "10.0.0.0/8",
    "100.64.0.0/10",
    "127.0.0.0/8",
    "169.254.0.0/16",
    "172.16.0.0/12",
    "192.0.0.0/24",
    "192.0.0.0/29",
    "192.0.0.8/32",
    "192.0.0.9/32",
    "192.0.0.10/32",
    "192.0.0.170/32",
    "192.0.0.171/32",
    "192.0.2.0/24",
    "192.31.196.0/24",
    "192.52.193.0/24",
    "192.88.99.0/24",
    "192.168.0.0/16",
    "192.175.48.0/24",
    "198.18.0.0/15",
    "198.51.100.0/24",
    "203.0.113.0/24",
    "240.0.0.0/4",
    "255.255.255.255/32"
  ];
  var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new Netmask_1(ip_range));
  var is_ip_private = (ip) => {
    if (is_valid(ip)) {
      const parsed = parse(ip);
      if (parsed.kind() === "ipv4")
        return ipv4_check(parsed.toNormalizedString());
      else if (parsed.kind() === "ipv6")
        return ipv6_check(ip);
    } else if (isIP(ip) && ipRegex.v6().test(ip))
      return ipv6_check(ip);
    return;
  };
  var receptacle = Receptacle;
  var toMS = requireMs();
  var cache = Receptacle.prototype;
  var counter = new Date % 1e9;
  cache.has = function(key) {
    return key in this._lookup;
  };
  cache.get = function(key) {
    if (!this.has(key))
      return null;
    var record = this._lookup[key];
    if (record.refresh)
      this.expire(key, record.refresh);
    this.items.splice(this.items.indexOf(record), 1);
    this.items.push(record);
    return record.value;
  };
  cache.meta = function(key) {
    if (!this.has(key))
      return null;
    var record = this._lookup[key];
    if (!("meta" in record))
      return null;
    return record.meta;
  };
  cache.set = function(key, value, options) {
    var oldRecord = this._lookup[key];
    var record = this._lookup[key] = { key, value };
    this.lastModified = new Date;
    if (oldRecord) {
      clearTimeout(oldRecord.timeout);
      this.items.splice(this.items.indexOf(oldRecord), 1, record);
    } else {
      if (this.size >= this.max)
        this.delete(this.items[0].key);
      this.items.push(record);
      this.size++;
    }
    if (options) {
      if ("ttl" in options)
        this.expire(key, options.ttl);
      if ("meta" in options)
        record.meta = options.meta;
      if (options.refresh)
        record.refresh = options.ttl;
    }
    return this;
  };
  cache.delete = function(key) {
    var record = this._lookup[key];
    if (!record)
      return false;
    this.lastModified = new Date;
    this.items.splice(this.items.indexOf(record), 1);
    clearTimeout(record.timeout);
    delete this._lookup[key];
    this.size--;
    return this;
  };
  cache.expire = function(key, ttl) {
    var ms2 = ttl || 0;
    var record = this._lookup[key];
    if (!record)
      return this;
    if (typeof ms2 === "string")
      ms2 = toMS(ttl);
    if (typeof ms2 !== "number")
      throw new TypeError("Expiration time must be a string or number.");
    clearTimeout(record.timeout);
    record.timeout = setTimeout(this.delete.bind(this, record.key), ms2);
    record.expires = Number(new Date) + ms2;
    return this;
  };
  cache.clear = function() {
    for (var i = this.items.length;i--; )
      this.delete(this.items[i].key);
    return this;
  };
  cache.toJSON = function() {
    var items = new Array(this.items.length);
    var item;
    for (var i = items.length;i--; ) {
      item = this.items[i];
      items[i] = {
        key: item.key,
        meta: item.meta,
        value: item.value,
        expires: item.expires,
        refresh: item.refresh
      };
    }
    return {
      id: this.id,
      max: isFinite(this.max) ? this.max : undefined,
      lastModified: this.lastModified,
      items
    };
  };
  var Receptacle$1 = getDefaultExportFromCjs(receptacle);
  var globalFetch = globalThis.fetch;
  var globalHeaders = globalThis.Headers;
  var log$h = Object.assign(debug("dns-over-http-resolver"), {
    error: debug("dns-over-http-resolver:error")
  });

  class Resolver {
    constructor(options = {}) {
      this._cache = new Receptacle$1({ max: options?.maxCache ?? 100 });
      this._TXTcache = new Receptacle$1({ max: options?.maxCache ?? 100 });
      this._servers = [
        "https://cloudflare-dns.com/dns-query",
        "https://dns.google/resolve"
      ];
      this._request = options.request ?? request;
      this._abortControllers = [];
    }
    cancel() {
      this._abortControllers.forEach((controller) => controller.abort());
    }
    getServers() {
      return this._servers;
    }
    _getShuffledServers() {
      const newServers = [...this._servers];
      for (let i = newServers.length - 1;i > 0; i--) {
        const j = Math.floor(Math.random() * i);
        const temp = newServers[i];
        newServers[i] = newServers[j];
        newServers[j] = temp;
      }
      return newServers;
    }
    setServers(servers) {
      this._servers = servers;
    }
    async resolve(hostname, rrType = "A") {
      switch (rrType) {
        case "A":
          return await this.resolve4(hostname);
        case "AAAA":
          return await this.resolve6(hostname);
        case "TXT":
          return await this.resolveTxt(hostname);
        default:
          throw new Error(`${rrType} is not supported`);
      }
    }
    async resolve4(hostname) {
      const recordType = "A";
      const cached = this._cache.get(getCacheKey(hostname, recordType));
      if (cached != null) {
        return cached;
      }
      let aborted = false;
      for (const server of this._getShuffledServers()) {
        const controller = new AbortController;
        this._abortControllers.push(controller);
        try {
          const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
          const data = response.Answer.map((a) => a.data);
          const ttl = Math.min(...response.Answer.map((a) => a.TTL));
          this._cache.set(getCacheKey(hostname, recordType), data, { ttl });
          return data;
        } catch (err) {
          if (controller.signal.aborted) {
            aborted = true;
          }
          log$h.error(`${server} could not resolve ${hostname} record ${recordType}`);
        } finally {
          this._abortControllers = this._abortControllers.filter((c) => c !== controller);
        }
      }
      if (aborted) {
        throw Object.assign(new Error("queryA ECANCELLED"), {
          code: "ECANCELLED"
        });
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    async resolve6(hostname) {
      const recordType = "AAAA";
      const cached = this._cache.get(getCacheKey(hostname, recordType));
      if (cached != null) {
        return cached;
      }
      let aborted = false;
      for (const server of this._getShuffledServers()) {
        const controller = new AbortController;
        this._abortControllers.push(controller);
        try {
          const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
          const data = response.Answer.map((a) => a.data);
          const ttl = Math.min(...response.Answer.map((a) => a.TTL));
          this._cache.set(getCacheKey(hostname, recordType), data, { ttl });
          return data;
        } catch (err) {
          if (controller.signal.aborted) {
            aborted = true;
          }
          log$h.error(`${server} could not resolve ${hostname} record ${recordType}`);
        } finally {
          this._abortControllers = this._abortControllers.filter((c) => c !== controller);
        }
      }
      if (aborted) {
        throw Object.assign(new Error("queryAaaa ECANCELLED"), {
          code: "ECANCELLED"
        });
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    async resolveTxt(hostname) {
      const recordType = "TXT";
      const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
      if (cached != null) {
        return cached;
      }
      let aborted = false;
      for (const server of this._getShuffledServers()) {
        const controller = new AbortController;
        this._abortControllers.push(controller);
        try {
          const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
          const data = response.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
          const ttl = Math.min(...response.Answer.map((a) => a.TTL));
          this._TXTcache.set(getCacheKey(hostname, recordType), data, { ttl });
          return data;
        } catch (err) {
          if (controller.signal.aborted) {
            aborted = true;
          }
          log$h.error(`${server} could not resolve ${hostname} record ${recordType}`);
        } finally {
          this._abortControllers = this._abortControllers.filter((c) => c !== controller);
        }
      }
      if (aborted) {
        throw Object.assign(new Error("queryTxt ECANCELLED"), {
          code: "ECANCELLED"
        });
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    clearCache() {
      this._cache.clear();
      this._TXTcache.clear();
    }
  }
  var { code: dnsaddrCode } = getProtocol$1("dnsaddr");
  var messages;
  (function(messages2) {
    messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
    messages2["DHT_DISABLED"] = "DHT is not available";
    messages2["PUBSUB_DISABLED"] = "PubSub is not available";
    messages2["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
    messages2["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
    messages2["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
    messages2["NOT_FOUND"] = "Not found";
  })(messages || (messages = {}));
  var codes;
  (function(codes2) {
    codes2["DHT_DISABLED"] = "ERR_DHT_DISABLED";
    codes2["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
    codes2["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
    codes2["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
    codes2["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
    codes2["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
    codes2["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
    codes2["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
    codes2["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
    codes2["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
    codes2["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
    codes2["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
    codes2["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
    codes2["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
    codes2["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
    codes2["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
    codes2["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
    codes2["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
    codes2["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
    codes2["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
    codes2["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
    codes2["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
    codes2["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
    codes2["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
    codes2["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
    codes2["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
    codes2["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
    codes2["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
    codes2["ERR_TIMEOUT"] = "ERR_TIMEOUT";
    codes2["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
    codes2["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
    codes2["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
    codes2["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
    codes2["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
    codes2["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
    codes2["ERR_FIND_SELF"] = "ERR_FIND_SELF";
    codes2["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
    codes2["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
    codes2["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
    codes2["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
    codes2["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
    codes2["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
    codes2["ERR_NO_KEY"] = "ERR_NO_KEY";
    codes2["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
    codes2["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
    codes2["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
    codes2["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
    codes2["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
    codes2["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
    codes2["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
    codes2["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
    codes2["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
    codes2["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
    codes2["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
    codes2["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
    codes2["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
    codes2["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
    codes2["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
    codes2["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
    codes2["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
    codes2["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
    codes2["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
    codes2["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
    codes2["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
    codes2["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
    codes2["ERR_CONNECTION_DENIED"] = "ERR_CONNECTION_DENIED";
    codes2["ERR_TRANSFER_LIMIT_EXCEEDED"] = "ERR_TRANSFER_LIMIT_EXCEEDED";
  })(codes || (codes = {}));
  var DefaultConfig = {
    addresses: {
      listen: [],
      announce: [],
      noAnnounce: [],
      announceFilter: (multiaddrs) => multiaddrs
    },
    connectionManager: {
      resolvers: {
        dnsaddr: dnsaddrResolver
      },
      addressSorter: publicAddressesFirst
    },
    transportManager: {
      faultTolerance: FaultTolerance.FATAL_ALL
    }
  };
  var KEEP_ALIVE = "keep-alive";
  var RateLimiterAbstract_1 = class RateLimiterAbstract2 {
    constructor(opts = {}) {
      this.points = opts.points;
      this.duration = opts.duration;
      this.blockDuration = opts.blockDuration;
      this.execEvenly = opts.execEvenly;
      this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;
      this.keyPrefix = opts.keyPrefix;
    }
    get points() {
      return this._points;
    }
    set points(value) {
      this._points = value >= 0 ? value : 4;
    }
    get duration() {
      return this._duration;
    }
    set duration(value) {
      this._duration = typeof value === "undefined" ? 1 : value;
    }
    get msDuration() {
      return this.duration * 1000;
    }
    get blockDuration() {
      return this._blockDuration;
    }
    set blockDuration(value) {
      this._blockDuration = typeof value === "undefined" ? 0 : value;
    }
    get msBlockDuration() {
      return this.blockDuration * 1000;
    }
    get execEvenly() {
      return this._execEvenly;
    }
    set execEvenly(value) {
      this._execEvenly = typeof value === "undefined" ? false : Boolean(value);
    }
    get execEvenlyMinDelayMs() {
      return this._execEvenlyMinDelayMs;
    }
    set execEvenlyMinDelayMs(value) {
      this._execEvenlyMinDelayMs = typeof value === "undefined" ? Math.ceil(this.msDuration / this.points) : value;
    }
    get keyPrefix() {
      return this._keyPrefix;
    }
    set keyPrefix(value) {
      if (typeof value === "undefined") {
        value = "rlflx";
      }
      if (typeof value !== "string") {
        throw new Error("keyPrefix must be string");
      }
      this._keyPrefix = value;
    }
    _getKeySecDuration(options = {}) {
      return options && options.customDuration >= 0 ? options.customDuration : this.duration;
    }
    getKey(key) {
      return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
    }
    parseKey(rlKey) {
      return rlKey.substring(this.keyPrefix.length);
    }
    consume() {
      throw new Error("You have to implement the method 'consume'!");
    }
    penalty() {
      throw new Error("You have to implement the method 'penalty'!");
    }
    reward() {
      throw new Error("You have to implement the method 'reward'!");
    }
    get() {
      throw new Error("You have to implement the method 'get'!");
    }
    set() {
      throw new Error("You have to implement the method 'set'!");
    }
    block() {
      throw new Error("You have to implement the method 'block'!");
    }
    delete() {
      throw new Error("You have to implement the method 'delete'!");
    }
  };
  var BlockedKeys_1$1 = class BlockedKeys2 {
    constructor() {
      this._keys = {};
      this._addedKeysAmount = 0;
    }
    collectExpired() {
      const now = Date.now();
      Object.keys(this._keys).forEach((key) => {
        if (this._keys[key] <= now) {
          delete this._keys[key];
        }
      });
      this._addedKeysAmount = Object.keys(this._keys).length;
    }
    add(key, sec) {
      this.addMs(key, sec * 1000);
    }
    addMs(key, ms2) {
      this._keys[key] = Date.now() + ms2;
      this._addedKeysAmount++;
      if (this._addedKeysAmount > 999) {
        this.collectExpired();
      }
    }
    msBeforeExpire(key) {
      const expire = this._keys[key];
      if (expire && expire >= Date.now()) {
        this.collectExpired();
        const now = Date.now();
        return expire >= now ? expire - now : 0;
      }
      return 0;
    }
    delete(key) {
      if (key) {
        delete this._keys[key];
      } else {
        Object.keys(this._keys).forEach((key2) => {
          delete this._keys[key2];
        });
      }
    }
  };
  var BlockedKeys$1 = BlockedKeys_1$1;
  var BlockedKeys_1 = BlockedKeys$1;
  var RateLimiterRes_1 = class RateLimiterRes2 {
    constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {
      this.remainingPoints = typeof remainingPoints === "undefined" ? 0 : remainingPoints;
      this.msBeforeNext = typeof msBeforeNext === "undefined" ? 0 : msBeforeNext;
      this.consumedPoints = typeof consumedPoints === "undefined" ? 0 : consumedPoints;
      this.isFirstInDuration = typeof isFirstInDuration === "undefined" ? false : isFirstInDuration;
    }
    get msBeforeNext() {
      return this._msBeforeNext;
    }
    set msBeforeNext(ms2) {
      this._msBeforeNext = ms2;
      return this;
    }
    get remainingPoints() {
      return this._remainingPoints;
    }
    set remainingPoints(p) {
      this._remainingPoints = p;
      return this;
    }
    get consumedPoints() {
      return this._consumedPoints;
    }
    set consumedPoints(p) {
      this._consumedPoints = p;
      return this;
    }
    get isFirstInDuration() {
      return this._isFirstInDuration;
    }
    set isFirstInDuration(value) {
      this._isFirstInDuration = Boolean(value);
    }
    _getDecoratedProperties() {
      return {
        remainingPoints: this.remainingPoints,
        msBeforeNext: this.msBeforeNext,
        consumedPoints: this.consumedPoints,
        isFirstInDuration: this.isFirstInDuration
      };
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this._getDecoratedProperties();
    }
    toString() {
      return JSON.stringify(this._getDecoratedProperties());
    }
    toJSON() {
      return this._getDecoratedProperties();
    }
  };
  var RateLimiterAbstract$3 = RateLimiterAbstract_1;
  var BlockedKeys = BlockedKeys_1;
  var RateLimiterRes$b = RateLimiterRes_1;
  var RateLimiterStoreAbstract_1 = class RateLimiterStoreAbstract2 extends RateLimiterAbstract$3 {
    constructor(opts = {}) {
      super(opts);
      this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed;
      this.inMemoryBlockDuration = opts.inMemoryBlockDuration;
      this.insuranceLimiter = opts.insuranceLimiter;
      this._inMemoryBlockedKeys = new BlockedKeys;
    }
    get client() {
      return this._client;
    }
    set client(value) {
      if (typeof value === "undefined") {
        throw new Error("storeClient is not set");
      }
      this._client = value;
    }
    _afterConsume(resolve5, reject, rlKey, changedPoints, storeResult, options = {}) {
      const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);
      if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
        this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);
        if (res.consumedPoints > this.points) {
          return reject(res);
        } else {
          return resolve5(res);
        }
      } else if (res.consumedPoints > this.points) {
        let blockPromise = Promise.resolve();
        if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {
          res.msBeforeNext = this.msBlockDuration;
          blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);
        }
        if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
          this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);
          res.msBeforeNext = this.msInMemoryBlockDuration;
        }
        blockPromise.then(() => {
          reject(res);
        }).catch((err) => {
          reject(err);
        });
      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
        let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
        if (delay < this.execEvenlyMinDelayMs) {
          delay = res.consumedPoints * this.execEvenlyMinDelayMs;
        }
        setTimeout(resolve5, delay, res);
      } else {
        resolve5(res);
      }
    }
    _handleError(err, funcName, resolve5, reject, key, data = false, options = {}) {
      if (!(this.insuranceLimiter instanceof RateLimiterAbstract$3)) {
        reject(err);
      } else {
        this.insuranceLimiter[funcName](key, data, options).then((res) => {
          resolve5(res);
        }).catch((res) => {
          reject(res);
        });
      }
    }
    getInMemoryBlockMsBeforeExpire(rlKey) {
      if (this.inMemoryBlockOnConsumed > 0) {
        return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);
      }
      return 0;
    }
    get inMemoryBlockOnConsumed() {
      return this._inMemoryBlockOnConsumed;
    }
    set inMemoryBlockOnConsumed(value) {
      this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;
      if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {
        throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
      }
    }
    get inMemoryBlockDuration() {
      return this._inMemoryBlockDuration;
    }
    set inMemoryBlockDuration(value) {
      this._inMemoryBlockDuration = value ? parseInt(value) : 0;
      if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {
        throw new Error("inMemoryBlockOnConsumed option must be set up");
      }
    }
    get msInMemoryBlockDuration() {
      return this._inMemoryBlockDuration * 1000;
    }
    get insuranceLimiter() {
      return this._insuranceLimiter;
    }
    set insuranceLimiter(value) {
      if (typeof value !== "undefined" && !(value instanceof RateLimiterAbstract$3)) {
        throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
      }
      this._insuranceLimiter = value;
      if (this._insuranceLimiter) {
        this._insuranceLimiter.blockDuration = this.blockDuration;
        this._insuranceLimiter.execEvenly = this.execEvenly;
      }
    }
    block(key, secDuration, options = {}) {
      const msDuration = secDuration * 1000;
      return this._block(this.getKey(key), this.points + 1, msDuration, options);
    }
    set(key, points, secDuration, options = {}) {
      const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;
      return this._block(this.getKey(key), points, msDuration, options);
    }
    consume(key, pointsToConsume = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const rlKey = this.getKey(key);
        const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);
        if (inMemoryBlockMsBeforeExpire > 0) {
          return reject(new RateLimiterRes$b(0, inMemoryBlockMsBeforeExpire));
        }
        this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options).then((res) => {
          this._afterConsume(resolve5, reject, rlKey, pointsToConsume, res);
        }).catch((err) => {
          this._handleError(err, "consume", resolve5, reject, key, pointsToConsume, options);
        });
      });
    }
    penalty(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5, reject) => {
        this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options).then((res) => {
          resolve5(this._getRateLimiterRes(rlKey, points, res));
        }).catch((err) => {
          this._handleError(err, "penalty", resolve5, reject, key, points, options);
        });
      });
    }
    reward(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5, reject) => {
        this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options).then((res) => {
          resolve5(this._getRateLimiterRes(rlKey, -points, res));
        }).catch((err) => {
          this._handleError(err, "reward", resolve5, reject, key, points, options);
        });
      });
    }
    get(key, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5, reject) => {
        this._get(rlKey, options).then((res) => {
          if (res === null || typeof res === "undefined") {
            resolve5(null);
          } else {
            resolve5(this._getRateLimiterRes(rlKey, 0, res));
          }
        }).catch((err) => {
          this._handleError(err, "get", resolve5, reject, key, options);
        });
      });
    }
    delete(key, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5, reject) => {
        this._delete(rlKey, options).then((res) => {
          this._inMemoryBlockedKeys.delete(rlKey);
          resolve5(res);
        }).catch((err) => {
          this._handleError(err, "delete", resolve5, reject, key, options);
        });
      });
    }
    deleteInMemoryBlockedAll() {
      this._inMemoryBlockedKeys.delete();
    }
    _getRateLimiterRes(rlKey, changedPoints, storeResult) {
      throw new Error("You have to implement the method '_getRateLimiterRes'!");
    }
    _block(rlKey, initPoints, msDuration, options = {}) {
      return new Promise((resolve5, reject) => {
        this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {
          resolve5(new RateLimiterRes$b(0, msDuration > 0 ? msDuration : -1, initPoints));
        }).catch((err) => {
          this._handleError(err, "block", resolve5, reject, this.parseKey(rlKey), msDuration / 1000, options);
        });
      });
    }
    _get(rlKey, options = {}) {
      throw new Error("You have to implement the method '_get'!");
    }
    _delete(rlKey, options = {}) {
      throw new Error("You have to implement the method '_delete'!");
    }
    _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
      throw new Error("You have to implement the method '_upsert'!");
    }
  };
  var RateLimiterStoreAbstract$4 = RateLimiterStoreAbstract_1;
  var RateLimiterRes$a = RateLimiterRes_1;
  var incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} `;
  var RateLimiterRedis$1 = class RateLimiterRedis2 extends RateLimiterStoreAbstract$4 {
    constructor(opts) {
      super(opts);
      this.client = opts.storeClient;
      this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;
      this.useRedisPackage = opts.useRedisPackage;
      this.useRedis3AndLowerPackage = opts.useRedis3AndLowerPackage;
      if (typeof this.client.defineCommand === "function") {
        this.client.defineCommand("rlflxIncr", {
          numberOfKeys: 1,
          lua: incrTtlLuaScript
        });
      }
    }
    _isRedisReady() {
      if (!this._rejectIfRedisNotReady) {
        return true;
      }
      if (this.client.status && this.client.status !== "ready") {
        return false;
      }
      if (typeof this.client.isReady === "function" && !this.client.isReady()) {
        return false;
      }
      return true;
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      let [consumed, resTtlMs] = result;
      if (Array.isArray(consumed)) {
        [, consumed] = consumed;
        [, resTtlMs] = resTtlMs;
      }
      const res = new RateLimiterRes$a;
      res.consumedPoints = parseInt(consumed);
      res.isFirstInDuration = res.consumedPoints === changedPoints;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = resTtlMs;
      return res;
    }
    async _upsert(rlKey, points, msDuration, forceExpire = false) {
      if (!this._isRedisReady()) {
        throw new Error("Redis connection is not ready");
      }
      const secDuration = Math.floor(msDuration / 1000);
      const multi = this.client.multi();
      if (forceExpire) {
        if (secDuration > 0) {
          if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
            multi.set(rlKey, points, "EX", secDuration);
          } else {
            multi.set(rlKey, points, { EX: secDuration });
          }
        } else {
          multi.set(rlKey, points);
        }
        if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
          return multi.pttl(rlKey).exec(true);
        }
        return multi.pTTL(rlKey).exec(true);
      }
      if (secDuration > 0) {
        if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
          return this.client.rlflxIncr([rlKey].concat([String(points), String(secDuration)]));
        }
        if (this.useRedis3AndLowerPackage) {
          return new Promise((resolve5, reject) => {
            const incrCallback = function(err, result) {
              if (err) {
                return reject(err);
              }
              return resolve5(result);
            };
            if (typeof this.client.rlflxIncr === "function") {
              this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);
            } else {
              this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);
            }
          });
        } else {
          return this.client.eval(incrTtlLuaScript, {
            keys: [rlKey],
            arguments: [String(points), String(secDuration)]
          });
        }
      } else {
        if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
          return multi.incrby(rlKey, points).pttl(rlKey).exec(true);
        }
        return multi.incrBy(rlKey, points).pTTL(rlKey).exec(true);
      }
    }
    async _get(rlKey) {
      if (!this._isRedisReady()) {
        throw new Error("Redis connection is not ready");
      }
      if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
        return this.client.multi().get(rlKey).pttl(rlKey).exec().then((result) => {
          const [[, points]] = result;
          if (points === null)
            return null;
          return result;
        });
      }
      return this.client.multi().get(rlKey).pTTL(rlKey).exec(true).then((result) => {
        const [points] = result;
        if (points === null)
          return null;
        return result;
      });
    }
    _delete(rlKey) {
      return this.client.del(rlKey).then((result) => result > 0);
    }
  };
  var RateLimiterRedis_1 = RateLimiterRedis$1;
  var RateLimiterStoreAbstract$3 = RateLimiterStoreAbstract_1;
  var RateLimiterRes$9 = RateLimiterRes_1;
  var RateLimiterMongo$1 = class RateLimiterMongo2 extends RateLimiterStoreAbstract$3 {
    constructor(opts) {
      super(opts);
      this.dbName = opts.dbName;
      this.tableName = opts.tableName;
      this.indexKeyPrefix = opts.indexKeyPrefix;
      if (opts.mongo) {
        this.client = opts.mongo;
      } else {
        this.client = opts.storeClient;
      }
      if (typeof this.client.then === "function") {
        this.client.then((conn) => {
          this.client = conn;
          this._initCollection();
          this._driverVersion = getDriverVersion(this.client);
        });
      } else {
        this._initCollection();
        this._driverVersion = getDriverVersion(this.client);
      }
    }
    get dbName() {
      return this._dbName;
    }
    set dbName(value) {
      this._dbName = typeof value === "undefined" ? RateLimiterMongo2.getDbName() : value;
    }
    static getDbName() {
      return "node-rate-limiter-flexible";
    }
    get tableName() {
      return this._tableName;
    }
    set tableName(value) {
      this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
    }
    get client() {
      return this._client;
    }
    set client(value) {
      if (typeof value === "undefined") {
        throw new Error("mongo is not set");
      }
      this._client = value;
    }
    get indexKeyPrefix() {
      return this._indexKeyPrefix;
    }
    set indexKeyPrefix(obj) {
      this._indexKeyPrefix = obj || {};
    }
    _initCollection() {
      const db = typeof this.client.db === "function" ? this.client.db(this.dbName) : this.client;
      const collection = db.collection(this.tableName);
      collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });
      collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });
      this._collection = collection;
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      const res = new RateLimiterRes$9;
      let doc;
      if (typeof result.value === "undefined") {
        doc = result;
      } else {
        doc = result.value;
      }
      res.isFirstInDuration = doc.points === changedPoints;
      res.consumedPoints = doc.points;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;
      return res;
    }
    _upsert(key, points, msDuration, forceExpire = false, options = {}) {
      if (!this._collection) {
        return Promise.reject(Error("Mongo connection is not established"));
      }
      const docAttrs = options.attrs || {};
      let where;
      let upsertData;
      if (forceExpire) {
        where = { key };
        where = Object.assign(where, docAttrs);
        upsertData = {
          $set: {
            key,
            points,
            expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
          }
        };
        upsertData.$set = Object.assign(upsertData.$set, docAttrs);
      } else {
        where = {
          $or: [
            { expire: { $gt: new Date } },
            { expire: { $eq: null } }
          ],
          key
        };
        where = Object.assign(where, docAttrs);
        upsertData = {
          $setOnInsert: {
            key,
            expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
          },
          $inc: { points }
        };
        upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);
      }
      const upsertOptions = {
        upsert: true
      };
      if (this._driverVersion.major >= 4 || (this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7)) {
        upsertOptions.returnDocument = "after";
      } else {
        upsertOptions.returnOriginal = false;
      }
      return new Promise((resolve5, reject) => {
        this._collection.findOneAndUpdate(where, upsertData, upsertOptions).then((res) => {
          resolve5(res);
        }).catch((errUpsert) => {
          if (errUpsert && errUpsert.code === 11000) {
            const replaceWhere = Object.assign({
              $or: [
                { expire: { $lte: new Date } },
                { expire: { $eq: null } }
              ],
              key
            }, docAttrs);
            const replaceTo = {
              $set: Object.assign({
                key,
                points,
                expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
              }, docAttrs)
            };
            this._collection.findOneAndUpdate(replaceWhere, replaceTo, upsertOptions).then((res) => {
              resolve5(res);
            }).catch((errReplace) => {
              if (errReplace && errReplace.code === 11000) {
                this._upsert(key, points, msDuration, forceExpire).then((res) => resolve5(res)).catch((err) => reject(err));
              } else {
                reject(errReplace);
              }
            });
          } else {
            reject(errUpsert);
          }
        });
      });
    }
    _get(rlKey, options = {}) {
      if (!this._collection) {
        return Promise.reject(Error("Mongo connection is not established"));
      }
      const docAttrs = options.attrs || {};
      const where = Object.assign({
        key: rlKey,
        $or: [
          { expire: { $gt: new Date } },
          { expire: { $eq: null } }
        ]
      }, docAttrs);
      return this._collection.findOne(where);
    }
    _delete(rlKey, options = {}) {
      if (!this._collection) {
        return Promise.reject(Error("Mongo connection is not established"));
      }
      const docAttrs = options.attrs || {};
      const where = Object.assign({ key: rlKey }, docAttrs);
      return this._collection.deleteOne(where).then((res) => res.deletedCount > 0);
    }
  };
  var RateLimiterMongo_1 = RateLimiterMongo$1;
  var RateLimiterStoreAbstract$2 = RateLimiterStoreAbstract_1;
  var RateLimiterRes$8 = RateLimiterRes_1;
  var RateLimiterMySQL$1 = class RateLimiterMySQL2 extends RateLimiterStoreAbstract$2 {
    constructor(opts, cb = null) {
      super(opts);
      this.client = opts.storeClient;
      this.clientType = opts.storeType;
      this.dbName = opts.dbName;
      this.tableName = opts.tableName;
      this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
      this.tableCreated = opts.tableCreated;
      if (!this.tableCreated) {
        this._createDbAndTable().then(() => {
          this.tableCreated = true;
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }).catch((err) => {
          if (typeof cb === "function") {
            cb(err);
          } else {
            throw err;
          }
        });
      } else {
        if (this.clearExpiredByTimeout) {
          this._clearExpiredHourAgo();
        }
        if (typeof cb === "function") {
          cb();
        }
      }
    }
    clearExpired(expire) {
      return new Promise((resolve5) => {
        this._getConnection().then((conn) => {
          conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {
            this._releaseConnection(conn);
            resolve5();
          });
        }).catch(() => {
          resolve5();
        });
      });
    }
    _clearExpiredHourAgo() {
      if (this._clearExpiredTimeoutId) {
        clearTimeout(this._clearExpiredTimeoutId);
      }
      this._clearExpiredTimeoutId = setTimeout(() => {
        this.clearExpired(Date.now() - 3600000).then(() => {
          this._clearExpiredHourAgo();
        });
      }, 300000);
      this._clearExpiredTimeoutId.unref();
    }
    _getConnection() {
      switch (this.clientType) {
        case "pool":
          return new Promise((resolve5, reject) => {
            this.client.getConnection((errConn, conn) => {
              if (errConn) {
                return reject(errConn);
              }
              resolve5(conn);
            });
          });
        case "sequelize":
          return this.client.connectionManager.getConnection();
        case "knex":
          return this.client.client.acquireConnection();
        default:
          return Promise.resolve(this.client);
      }
    }
    _releaseConnection(conn) {
      switch (this.clientType) {
        case "pool":
          return conn.release();
        case "sequelize":
          return this.client.connectionManager.releaseConnection(conn);
        case "knex":
          return this.client.client.releaseConnection(conn);
        default:
          return true;
      }
    }
    _createDbAndTable() {
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          conn.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (errDb) => {
            if (errDb) {
              this._releaseConnection(conn);
              return reject(errDb);
            }
            conn.query(this._getCreateTableStmt(), (err) => {
              if (err) {
                this._releaseConnection(conn);
                return reject(err);
              }
              this._releaseConnection(conn);
              resolve5();
            });
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _getCreateTableStmt() {
      return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (` + "`key` VARCHAR(255) CHARACTER SET utf8 NOT NULL,`points` INT(9) NOT NULL default 0,`expire` BIGINT UNSIGNED,PRIMARY KEY (`key`)) ENGINE = INNODB;";
    }
    get clientType() {
      return this._clientType;
    }
    set clientType(value) {
      if (typeof value === "undefined") {
        if (this.client.constructor.name === "Connection") {
          value = "connection";
        } else if (this.client.constructor.name === "Pool") {
          value = "pool";
        } else if (this.client.constructor.name === "Sequelize") {
          value = "sequelize";
        } else {
          throw new Error("storeType is not defined");
        }
      }
      this._clientType = value.toLowerCase();
    }
    get dbName() {
      return this._dbName;
    }
    set dbName(value) {
      this._dbName = typeof value === "undefined" ? "rtlmtrflx" : value;
    }
    get tableName() {
      return this._tableName;
    }
    set tableName(value) {
      this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
    }
    get tableCreated() {
      return this._tableCreated;
    }
    set tableCreated(value) {
      this._tableCreated = typeof value === "undefined" ? false : !!value;
    }
    get clearExpiredByTimeout() {
      return this._clearExpiredByTimeout;
    }
    set clearExpiredByTimeout(value) {
      this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      const res = new RateLimiterRes$8;
      const [row] = result;
      res.isFirstInDuration = changedPoints === row.points;
      res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
      return res;
    }
    _upsertTransaction(conn, key, points, msDuration, forceExpire) {
      return new Promise((resolve5, reject) => {
        conn.query("BEGIN", (errBegin) => {
          if (errBegin) {
            conn.rollback();
            return reject(errBegin);
          }
          const dateNow = Date.now();
          const newExpire = msDuration > 0 ? dateNow + msDuration : null;
          let q;
          let values;
          if (forceExpire) {
            q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`;
            values = [
              this.dbName,
              this.tableName,
              key,
              points,
              newExpire,
              points,
              newExpire
            ];
          } else {
            q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`;
            values = [
              this.dbName,
              this.tableName,
              key,
              points,
              newExpire,
              dateNow,
              points,
              points,
              dateNow,
              newExpire
            ];
          }
          conn.query(q, values, (errUpsert) => {
            if (errUpsert) {
              conn.rollback();
              return reject(errUpsert);
            }
            conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, key], (errSelect, res) => {
              if (errSelect) {
                conn.rollback();
                return reject(errSelect);
              }
              conn.query("COMMIT", (err) => {
                if (err) {
                  conn.rollback();
                  return reject(err);
                }
                resolve5(res);
              });
            });
          });
        });
      });
    }
    _upsert(key, points, msDuration, forceExpire = false) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          this._upsertTransaction(conn, key, points, msDuration, forceExpire).then((res) => {
            resolve5(res);
            this._releaseConnection(conn);
          }).catch((err) => {
            reject(err);
            this._releaseConnection(conn);
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _get(rlKey) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)", [this.dbName, this.tableName, rlKey, Date.now()], (err, res) => {
            if (err) {
              reject(err);
            } else if (res.length === 0) {
              resolve5(null);
            } else {
              resolve5(res);
            }
            this._releaseConnection(conn);
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _delete(rlKey) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          conn.query("DELETE FROM ??.?? WHERE `key` = ?", [this.dbName, this.tableName, rlKey], (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve5(res.affectedRows > 0);
            }
            this._releaseConnection(conn);
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
  };
  var RateLimiterMySQL_1 = RateLimiterMySQL$1;
  var RateLimiterStoreAbstract$1 = RateLimiterStoreAbstract_1;
  var RateLimiterRes$7 = RateLimiterRes_1;
  var RateLimiterPostgres$1 = class RateLimiterPostgres2 extends RateLimiterStoreAbstract$1 {
    constructor(opts, cb = null) {
      super(opts);
      this.client = opts.storeClient;
      this.clientType = opts.storeType;
      this.tableName = opts.tableName;
      this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
      this.tableCreated = opts.tableCreated;
      if (!this.tableCreated) {
        this._createTable().then(() => {
          this.tableCreated = true;
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }).catch((err) => {
          if (typeof cb === "function") {
            cb(err);
          } else {
            throw err;
          }
        });
      } else {
        if (typeof cb === "function") {
          cb();
        }
      }
    }
    clearExpired(expire) {
      return new Promise((resolve5) => {
        const q = {
          name: "rlflx-clear-expired",
          text: `DELETE FROM ${this.tableName} WHERE expire < \$1`,
          values: [expire]
        };
        this._query(q).then(() => {
          resolve5();
        }).catch(() => {
          resolve5();
        });
      });
    }
    _clearExpiredHourAgo() {
      if (this._clearExpiredTimeoutId) {
        clearTimeout(this._clearExpiredTimeoutId);
      }
      this._clearExpiredTimeoutId = setTimeout(() => {
        this.clearExpired(Date.now() - 3600000).then(() => {
          this._clearExpiredHourAgo();
        });
      }, 300000);
      this._clearExpiredTimeoutId.unref();
    }
    _getConnection() {
      switch (this.clientType) {
        case "pool":
          return Promise.resolve(this.client);
        case "sequelize":
          return this.client.connectionManager.getConnection();
        case "knex":
          return this.client.client.acquireConnection();
        case "typeorm":
          return Promise.resolve(this.client.driver.master);
        default:
          return Promise.resolve(this.client);
      }
    }
    _releaseConnection(conn) {
      switch (this.clientType) {
        case "pool":
          return true;
        case "sequelize":
          return this.client.connectionManager.releaseConnection(conn);
        case "knex":
          return this.client.client.releaseConnection(conn);
        case "typeorm":
          return true;
        default:
          return true;
      }
    }
    _createTable() {
      return new Promise((resolve5, reject) => {
        this._query({
          text: this._getCreateTableStmt()
        }).then(() => {
          resolve5();
        }).catch((err) => {
          if (err.code === "23505") {
            resolve5();
          } else {
            reject(err);
          }
        });
      });
    }
    _getCreateTableStmt() {
      return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
    }
    get clientType() {
      return this._clientType;
    }
    set clientType(value) {
      const constructorName = this.client.constructor.name;
      if (typeof value === "undefined") {
        if (constructorName === "Client") {
          value = "client";
        } else if (constructorName === "Pool" || constructorName === "BoundPool") {
          value = "pool";
        } else if (constructorName === "Sequelize") {
          value = "sequelize";
        } else {
          throw new Error("storeType is not defined");
        }
      }
      this._clientType = value.toLowerCase();
    }
    get tableName() {
      return this._tableName;
    }
    set tableName(value) {
      this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
    }
    get tableCreated() {
      return this._tableCreated;
    }
    set tableCreated(value) {
      this._tableCreated = typeof value === "undefined" ? false : !!value;
    }
    get clearExpiredByTimeout() {
      return this._clearExpiredByTimeout;
    }
    set clearExpiredByTimeout(value) {
      this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      const res = new RateLimiterRes$7;
      const row = result.rows[0];
      res.isFirstInDuration = changedPoints === row.points;
      res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
      return res;
    }
    _query(q) {
      const prefix = this.tableName.toLowerCase();
      const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };
      return new Promise((resolve5, reject) => {
        this._getConnection().then((conn) => {
          conn.query(queryObj).then((res) => {
            resolve5(res);
            this._releaseConnection(conn);
          }).catch((err) => {
            reject(err);
            this._releaseConnection(conn);
          });
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _upsert(key, points, msDuration, forceExpire = false) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      const newExpire = msDuration > 0 ? Date.now() + msDuration : null;
      const expireQ = forceExpire ? " $3 " : ` CASE
             WHEN ${this.tableName}.expire <= \$4 THEN \$3
             ELSE ${this.tableName}.expire
            END `;
      return this._query({
        name: forceExpire ? "rlflx-upsert-force" : "rlflx-upsert",
        text: `
            INSERT INTO ${this.tableName} VALUES (\$1, \$2, \$3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= \$4 OR 1=${forceExpire ? 1 : 0}) THEN \$2
                          ELSE ${this.tableName}.points + (\$2)
                         END,
                expire = ${expireQ}
            RETURNING points, expire;`,
        values: [key, points, newExpire, Date.now()]
      });
    }
    _get(rlKey) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return new Promise((resolve5, reject) => {
        this._query({
          name: "rlflx-get",
          text: `
            SELECT points, expire FROM ${this.tableName} WHERE key = \$1 AND (expire > \$2 OR expire IS NULL);`,
          values: [rlKey, Date.now()]
        }).then((res) => {
          if (res.rowCount === 0) {
            res = null;
          }
          resolve5(res);
        }).catch((err) => {
          reject(err);
        });
      });
    }
    _delete(rlKey) {
      if (!this.tableCreated) {
        return Promise.reject(Error("Table is not created yet"));
      }
      return this._query({
        name: "rlflx-delete",
        text: `DELETE FROM ${this.tableName} WHERE key = \$1`,
        values: [rlKey]
      }).then((res) => res.rowCount > 0);
    }
  };
  var RateLimiterPostgres_1 = RateLimiterPostgres$1;
  var Record_1 = class Record2 {
    constructor(value, expiresAt, timeoutId = null) {
      this.value = value;
      this.expiresAt = expiresAt;
      this.timeoutId = timeoutId;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      this._value = parseInt(value);
    }
    get expiresAt() {
      return this._expiresAt;
    }
    set expiresAt(value) {
      if (!(value instanceof Date) && Number.isInteger(value)) {
        value = new Date(value);
      }
      this._expiresAt = value;
    }
    get timeoutId() {
      return this._timeoutId;
    }
    set timeoutId(value) {
      this._timeoutId = value;
    }
  };
  var Record = Record_1;
  var RateLimiterRes$6 = RateLimiterRes_1;
  var MemoryStorage_1 = class MemoryStorage2 {
    constructor() {
      this._storage = {};
    }
    incrby(key, value, durationSec) {
      if (this._storage[key]) {
        const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
        if (msBeforeExpires !== 0) {
          this._storage[key].value = this._storage[key].value + value;
          return new RateLimiterRes$6(0, msBeforeExpires, this._storage[key].value, false);
        }
        return this.set(key, value, durationSec);
      }
      return this.set(key, value, durationSec);
    }
    set(key, value, durationSec) {
      const durationMs = durationSec * 1000;
      if (this._storage[key] && this._storage[key].timeoutId) {
        clearTimeout(this._storage[key].timeoutId);
      }
      this._storage[key] = new Record(value, durationMs > 0 ? new Date(Date.now() + durationMs) : null);
      if (durationMs > 0) {
        this._storage[key].timeoutId = setTimeout(() => {
          delete this._storage[key];
        }, durationMs);
        if (this._storage[key].timeoutId.unref) {
          this._storage[key].timeoutId.unref();
        }
      }
      return new RateLimiterRes$6(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);
    }
    get(key) {
      if (this._storage[key]) {
        const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
        return new RateLimiterRes$6(0, msBeforeExpires, this._storage[key].value, false);
      }
      return null;
    }
    delete(key) {
      if (this._storage[key]) {
        if (this._storage[key].timeoutId) {
          clearTimeout(this._storage[key].timeoutId);
        }
        delete this._storage[key];
        return true;
      }
      return false;
    }
  };
  var RateLimiterAbstract$2 = RateLimiterAbstract_1;
  var MemoryStorage = MemoryStorage_1;
  var RateLimiterRes$5 = RateLimiterRes_1;
  var RateLimiterMemory$2 = class RateLimiterMemory2 extends RateLimiterAbstract$2 {
    constructor(opts = {}) {
      super(opts);
      this._memoryStorage = new MemoryStorage;
    }
    consume(key, pointsToConsume = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const rlKey = this.getKey(key);
        const secDuration = this._getKeySecDuration(options);
        let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        if (res.consumedPoints > this.points) {
          if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
            res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
          }
          reject(res);
        } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
          let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
          if (delay < this.execEvenlyMinDelayMs) {
            delay = res.consumedPoints * this.execEvenlyMinDelayMs;
          }
          setTimeout(resolve5, delay, res);
        } else {
          resolve5(res);
        }
      });
    }
    penalty(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5) => {
        const secDuration = this._getKeySecDuration(options);
        const res = this._memoryStorage.incrby(rlKey, points, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        resolve5(res);
      });
    }
    reward(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      return new Promise((resolve5) => {
        const secDuration = this._getKeySecDuration(options);
        const res = this._memoryStorage.incrby(rlKey, -points, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        resolve5(res);
      });
    }
    block(key, secDuration) {
      const msDuration = secDuration * 1000;
      const initPoints = this.points + 1;
      this._memoryStorage.set(this.getKey(key), initPoints, secDuration);
      return Promise.resolve(new RateLimiterRes$5(0, msDuration === 0 ? -1 : msDuration, initPoints));
    }
    set(key, points, secDuration) {
      const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;
      this._memoryStorage.set(this.getKey(key), points, secDuration);
      return Promise.resolve(new RateLimiterRes$5(0, msDuration === 0 ? -1 : msDuration, points));
    }
    get(key) {
      const res = this._memoryStorage.get(this.getKey(key));
      if (res !== null) {
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      }
      return Promise.resolve(res);
    }
    delete(key) {
      return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));
    }
  };
  var RateLimiterMemory_1 = RateLimiterMemory$2;
  var cluster = require$$1;
  var crypto$1 = require$$1;
  var RateLimiterAbstract$1 = RateLimiterAbstract_1;
  var RateLimiterMemory$1 = RateLimiterMemory_1;
  var RateLimiterRes$4 = RateLimiterRes_1;
  var channel = "rate_limiter_flexible";
  var masterInstance = null;
  var masterSendToWorker = function(worker, msg, type, res) {
    let data;
    if (res === null || res === true || res === false) {
      data = res;
    } else {
      data = {
        remainingPoints: res.remainingPoints,
        msBeforeNext: res.msBeforeNext,
        consumedPoints: res.consumedPoints,
        isFirstInDuration: res.isFirstInDuration
      };
    }
    worker.send({
      channel,
      keyPrefix: msg.keyPrefix,
      promiseId: msg.promiseId,
      type,
      data
    });
  };
  var workerWaitInit = function(payload) {
    setTimeout(() => {
      if (this._initiated) {
        process.send(payload);
      } else if (typeof this._promises[payload.promiseId] !== "undefined") {
        workerWaitInit.call(this, payload);
      }
    }, 30);
  };
  var workerSendToMaster = function(func, promiseId, key, arg, opts) {
    const payload = {
      channel,
      keyPrefix: this.keyPrefix,
      func,
      promiseId,
      data: {
        key,
        arg,
        opts
      }
    };
    if (!this._initiated) {
      workerWaitInit.call(this, payload);
    } else {
      process.send(payload);
    }
  };
  var masterProcessMsg = function(worker, msg) {
    if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === "undefined") {
      return false;
    }
    let promise;
    switch (msg.func) {
      case "consume":
        promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);
        break;
      case "penalty":
        promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);
        break;
      case "reward":
        promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);
        break;
      case "block":
        promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);
        break;
      case "get":
        promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);
        break;
      case "delete":
        promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);
        break;
      default:
        return false;
    }
    if (promise) {
      promise.then((res) => {
        masterSendToWorker(worker, msg, "resolve", res);
      }).catch((rejRes) => {
        masterSendToWorker(worker, msg, "reject", rejRes);
      });
    }
  };
  var workerProcessMsg = function(msg) {
    if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {
      return false;
    }
    if (this._promises[msg.promiseId]) {
      clearTimeout(this._promises[msg.promiseId].timeoutId);
      let res;
      if (msg.data === null || msg.data === true || msg.data === false) {
        res = msg.data;
      } else {
        res = new RateLimiterRes$4(msg.data.remainingPoints, msg.data.msBeforeNext, msg.data.consumedPoints, msg.data.isFirstInDuration);
      }
      switch (msg.type) {
        case "resolve":
          this._promises[msg.promiseId].resolve(res);
          break;
        case "reject":
          this._promises[msg.promiseId].reject(res);
          break;
        default:
          throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);
      }
      delete this._promises[msg.promiseId];
    }
  };
  var getOpts = function() {
    return {
      points: this.points,
      duration: this.duration,
      blockDuration: this.blockDuration,
      execEvenly: this.execEvenly,
      execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
      keyPrefix: this.keyPrefix
    };
  };
  var savePromise = function(resolve5, reject) {
    const hrtime = process.hrtime();
    let promiseId = hrtime[0].toString() + hrtime[1].toString();
    if (typeof this._promises[promiseId] !== "undefined") {
      promiseId += crypto$1.randomBytes(12).toString("base64");
    }
    this._promises[promiseId] = {
      resolve: resolve5,
      reject,
      timeoutId: setTimeout(() => {
        delete this._promises[promiseId];
        reject(new Error("RateLimiterCluster timeout: no answer from master in time"));
      }, this.timeoutMs)
    };
    return promiseId;
  };
  var RateLimiterClusterMaster$1 = class RateLimiterClusterMaster2 {
    constructor() {
      if (masterInstance) {
        return masterInstance;
      }
      this._rateLimiters = {};
      cluster.setMaxListeners(0);
      cluster.on("message", (worker, msg) => {
        if (msg && msg.channel === channel && msg.type === "init") {
          if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory$1(msg.opts);
          }
          worker.send({
            channel,
            type: "init",
            keyPrefix: msg.opts.keyPrefix
          });
        } else {
          masterProcessMsg.call(this, worker, msg);
        }
      });
      masterInstance = this;
    }
  };
  var RateLimiterClusterMasterPM2$1 = class RateLimiterClusterMasterPM22 {
    constructor(pm2) {
      if (masterInstance) {
        return masterInstance;
      }
      this._rateLimiters = {};
      pm2.launchBus((err, pm2Bus) => {
        pm2Bus.on("process:msg", (packet2) => {
          const msg = packet2.raw;
          if (msg && msg.channel === channel && msg.type === "init") {
            if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
              this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory$1(msg.opts);
            }
            pm2.sendDataToProcessId(packet2.process.pm_id, {
              data: {},
              topic: channel,
              channel,
              type: "init",
              keyPrefix: msg.opts.keyPrefix
            }, (sendErr, res) => {
              if (sendErr) {
                console.log(sendErr, res);
              }
            });
          } else {
            const worker = {
              send: (msgData) => {
                const pm2Message = msgData;
                pm2Message.topic = channel;
                if (typeof pm2Message.data === "undefined") {
                  pm2Message.data = {};
                }
                pm2.sendDataToProcessId(packet2.process.pm_id, pm2Message, (sendErr, res) => {
                  if (sendErr) {
                    console.log(sendErr, res);
                  }
                });
              }
            };
            masterProcessMsg.call(this, worker, msg);
          }
        });
      });
      masterInstance = this;
    }
  };

  class RateLimiterClusterWorker extends RateLimiterAbstract$1 {
    get timeoutMs() {
      return this._timeoutMs;
    }
    set timeoutMs(value) {
      this._timeoutMs = typeof value === "undefined" ? 5000 : Math.abs(parseInt(value));
    }
    constructor(opts = {}) {
      super(opts);
      process.setMaxListeners(0);
      this.timeoutMs = opts.timeoutMs;
      this._initiated = false;
      process.on("message", (msg) => {
        if (msg && msg.channel === channel && msg.type === "init" && msg.keyPrefix === this.keyPrefix) {
          this._initiated = true;
        } else {
          workerProcessMsg.call(this, msg);
        }
      });
      process.send({
        channel,
        type: "init",
        opts: getOpts.call(this)
      });
      this._promises = {};
    }
    consume(key, pointsToConsume = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise.call(this, resolve5, reject);
        workerSendToMaster.call(this, "consume", promiseId, key, pointsToConsume, options);
      });
    }
    penalty(key, points = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise.call(this, resolve5, reject);
        workerSendToMaster.call(this, "penalty", promiseId, key, points, options);
      });
    }
    reward(key, points = 1, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise.call(this, resolve5, reject);
        workerSendToMaster.call(this, "reward", promiseId, key, points, options);
      });
    }
    block(key, secDuration, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise.call(this, resolve5, reject);
        workerSendToMaster.call(this, "block", promiseId, key, secDuration, options);
      });
    }
    get(key, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise.call(this, resolve5, reject);
        workerSendToMaster.call(this, "get", promiseId, key, options);
      });
    }
    delete(key, options = {}) {
      return new Promise((resolve5, reject) => {
        const promiseId = savePromise.call(this, resolve5, reject);
        workerSendToMaster.call(this, "delete", promiseId, key, options);
      });
    }
  }
  var RateLimiterCluster$1 = {
    RateLimiterClusterMaster: RateLimiterClusterMaster$1,
    RateLimiterClusterMasterPM2: RateLimiterClusterMasterPM2$1,
    RateLimiterCluster: RateLimiterClusterWorker
  };
  var RateLimiterStoreAbstract = RateLimiterStoreAbstract_1;
  var RateLimiterRes$3 = RateLimiterRes_1;
  var RateLimiterMemcache$1 = class RateLimiterMemcache2 extends RateLimiterStoreAbstract {
    constructor(opts) {
      super(opts);
      this.client = opts.storeClient;
    }
    _getRateLimiterRes(rlKey, changedPoints, result) {
      const res = new RateLimiterRes$3;
      res.consumedPoints = parseInt(result.consumedPoints);
      res.isFirstInDuration = result.consumedPoints === changedPoints;
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      res.msBeforeNext = result.msBeforeNext;
      return res;
    }
    _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
      return new Promise((resolve5, reject) => {
        const nowMs = Date.now();
        const secDuration = Math.floor(msDuration / 1000);
        if (forceExpire) {
          this.client.set(rlKey, points, secDuration, (err) => {
            if (!err) {
              this.client.set(`${rlKey}_expire`, secDuration > 0 ? nowMs + secDuration * 1000 : -1, secDuration, () => {
                const res = {
                  consumedPoints: points,
                  msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1
                };
                resolve5(res);
              });
            } else {
              reject(err);
            }
          });
        } else {
          this.client.incr(rlKey, points, (err, consumedPoints) => {
            if (err || consumedPoints === false) {
              this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {
                if (errAddKey || !createdNew) {
                  if (typeof options.attemptNumber === "undefined" || options.attemptNumber < 3) {
                    const nextOptions = Object.assign({}, options);
                    nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;
                    this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then((resUpsert) => resolve5(resUpsert)).catch((errUpsert) => reject(errUpsert));
                  } else {
                    reject(new Error("Can not add key"));
                  }
                } else {
                  this.client.add(`${rlKey}_expire`, secDuration > 0 ? nowMs + secDuration * 1000 : -1, secDuration, () => {
                    const res = {
                      consumedPoints: points,
                      msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1
                    };
                    resolve5(res);
                  });
                }
              });
            } else {
              this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                if (errGetExpire) {
                  reject(errGetExpire);
                } else {
                  const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                  const res = {
                    consumedPoints,
                    msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                  };
                  resolve5(res);
                }
              });
            }
          });
        }
      });
    }
    _get(rlKey) {
      return new Promise((resolve5, reject) => {
        const nowMs = Date.now();
        this.client.get(rlKey, (err, consumedPoints) => {
          if (!consumedPoints) {
            resolve5(null);
          } else {
            this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
              if (errGetExpire) {
                reject(errGetExpire);
              } else {
                const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                const res = {
                  consumedPoints,
                  msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                };
                resolve5(res);
              }
            });
          }
        });
      });
    }
    _delete(rlKey) {
      return new Promise((resolve5, reject) => {
        this.client.del(rlKey, (err, res) => {
          if (err) {
            reject(err);
          } else if (res === false) {
            resolve5(res);
          } else {
            this.client.del(`${rlKey}_expire`, (errDelExpire) => {
              if (errDelExpire) {
                reject(errDelExpire);
              } else {
                resolve5(res);
              }
            });
          }
        });
      });
    }
  };
  var RateLimiterMemcache_1 = RateLimiterMemcache$1;
  var RateLimiterRes$2 = RateLimiterRes_1;
  var RLWrapperBlackAndWhite_1 = class RLWrapperBlackAndWhite2 {
    constructor(opts = {}) {
      this.limiter = opts.limiter;
      this.blackList = opts.blackList;
      this.whiteList = opts.whiteList;
      this.isBlackListed = opts.isBlackListed;
      this.isWhiteListed = opts.isWhiteListed;
      this.runActionAnyway = opts.runActionAnyway;
    }
    get limiter() {
      return this._limiter;
    }
    set limiter(value) {
      if (typeof value === "undefined") {
        throw new Error("limiter is not set");
      }
      this._limiter = value;
    }
    get runActionAnyway() {
      return this._runActionAnyway;
    }
    set runActionAnyway(value) {
      this._runActionAnyway = typeof value === "undefined" ? false : value;
    }
    get blackList() {
      return this._blackList;
    }
    set blackList(value) {
      this._blackList = Array.isArray(value) ? value : [];
    }
    get isBlackListed() {
      return this._isBlackListed;
    }
    set isBlackListed(func) {
      if (typeof func === "undefined") {
        func = () => false;
      }
      if (typeof func !== "function") {
        throw new Error("isBlackListed must be function");
      }
      this._isBlackListed = func;
    }
    get whiteList() {
      return this._whiteList;
    }
    set whiteList(value) {
      this._whiteList = Array.isArray(value) ? value : [];
    }
    get isWhiteListed() {
      return this._isWhiteListed;
    }
    set isWhiteListed(func) {
      if (typeof func === "undefined") {
        func = () => false;
      }
      if (typeof func !== "function") {
        throw new Error("isWhiteListed must be function");
      }
      this._isWhiteListed = func;
    }
    isBlackListedSomewhere(key) {
      return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);
    }
    isWhiteListedSomewhere(key) {
      return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);
    }
    getBlackRes() {
      return new RateLimiterRes$2(0, Number.MAX_SAFE_INTEGER, 0, false);
    }
    getWhiteRes() {
      return new RateLimiterRes$2(Number.MAX_SAFE_INTEGER, 0, 0, false);
    }
    rejectBlack() {
      return Promise.reject(this.getBlackRes());
    }
    resolveBlack() {
      return Promise.resolve(this.getBlackRes());
    }
    resolveWhite() {
      return Promise.resolve(this.getWhiteRes());
    }
    consume(key, pointsToConsume = 1) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.rejectBlack();
      }
      if (typeof res === "undefined") {
        return this.limiter.consume(key, pointsToConsume);
      }
      if (this.runActionAnyway) {
        this.limiter.consume(key, pointsToConsume).catch(() => {
        });
      }
      return res;
    }
    block(key, secDuration) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.resolveBlack();
      }
      if (typeof res === "undefined") {
        return this.limiter.block(key, secDuration);
      }
      if (this.runActionAnyway) {
        this.limiter.block(key, secDuration).catch(() => {
        });
      }
      return res;
    }
    penalty(key, points) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.resolveBlack();
      }
      if (typeof res === "undefined") {
        return this.limiter.penalty(key, points);
      }
      if (this.runActionAnyway) {
        this.limiter.penalty(key, points).catch(() => {
        });
      }
      return res;
    }
    reward(key, points) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.resolveBlack();
      }
      if (typeof res === "undefined") {
        return this.limiter.reward(key, points);
      }
      if (this.runActionAnyway) {
        this.limiter.reward(key, points).catch(() => {
        });
      }
      return res;
    }
    get(key) {
      let res;
      if (this.isWhiteListedSomewhere(key)) {
        res = this.resolveWhite();
      } else if (this.isBlackListedSomewhere(key)) {
        res = this.resolveBlack();
      }
      if (typeof res === "undefined" || this.runActionAnyway) {
        return this.limiter.get(key);
      }
      return res;
    }
    delete(key) {
      return this.limiter.delete(key);
    }
  };
  var RateLimiterAbstract = RateLimiterAbstract_1;
  var RateLimiterUnion_1 = class RateLimiterUnion2 {
    constructor(...limiters) {
      if (limiters.length < 1) {
        throw new Error("RateLimiterUnion: at least one limiter have to be passed");
      }
      limiters.forEach((limiter) => {
        if (!(limiter instanceof RateLimiterAbstract)) {
          throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
        }
      });
      this._limiters = limiters;
    }
    consume(key, points = 1) {
      return new Promise((resolve5, reject) => {
        const promises = [];
        this._limiters.forEach((limiter) => {
          promises.push(limiter.consume(key, points).catch((rej) => ({ rejected: true, rej })));
        });
        Promise.all(promises).then((res) => {
          const resObj = {};
          let rejected = false;
          res.forEach((item) => {
            if (item.rejected === true) {
              rejected = true;
            }
          });
          for (let i = 0;i < res.length; i++) {
            if (rejected && res[i].rejected === true) {
              resObj[this._limiters[i].keyPrefix] = res[i].rej;
            } else if (!rejected) {
              resObj[this._limiters[i].keyPrefix] = res[i];
            }
          }
          if (rejected) {
            reject(resObj);
          } else {
            resolve5(resObj);
          }
        });
      });
    }
  };
  var RateLimiterQueueError_1 = class RateLimiterQueueError2 extends Error {
    constructor(message2, extra) {
      super();
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "CustomError";
      this.message = message2;
      if (extra) {
        this.extra = extra;
      }
    }
  };
  var RateLimiterQueueError = RateLimiterQueueError_1;
  var MAX_QUEUE_SIZE = 4294967295;
  var KEY_DEFAULT = "limiter";
  var RateLimiterQueue_1 = class RateLimiterQueue2 {
    constructor(limiterFlexible, opts = {
      maxQueueSize: MAX_QUEUE_SIZE
    }) {
      this._queueLimiters = {
        KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)
      };
      this._limiterFlexible = limiterFlexible;
      this._maxQueueSize = opts.maxQueueSize;
    }
    getTokensRemaining(key = KEY_DEFAULT) {
      if (this._queueLimiters[key]) {
        return this._queueLimiters[key].getTokensRemaining();
      } else {
        return Promise.resolve(this._limiterFlexible.points);
      }
    }
    removeTokens(tokens, key = KEY_DEFAULT) {
      if (!this._queueLimiters[key]) {
        this._queueLimiters[key] = new RateLimiterQueueInternal(this._limiterFlexible, {
          key,
          maxQueueSize: this._maxQueueSize
        });
      }
      return this._queueLimiters[key].removeTokens(tokens);
    }
  };

  class RateLimiterQueueInternal {
    constructor(limiterFlexible, opts = {
      maxQueueSize: MAX_QUEUE_SIZE,
      key: KEY_DEFAULT
    }) {
      this._key = opts.key;
      this._waitTimeout = null;
      this._queue = [];
      this._limiterFlexible = limiterFlexible;
      this._maxQueueSize = opts.maxQueueSize;
    }
    getTokensRemaining() {
      return this._limiterFlexible.get(this._key).then((rlRes) => {
        return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;
      });
    }
    removeTokens(tokens) {
      const _this = this;
      return new Promise((resolve5, reject) => {
        if (tokens > _this._limiterFlexible.points) {
          reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));
          return;
        }
        if (_this._queue.length > 0) {
          _this._queueRequest.call(_this, resolve5, reject, tokens);
        } else {
          _this._limiterFlexible.consume(_this._key, tokens).then((res) => {
            resolve5(res.remainingPoints);
          }).catch((rej) => {
            if (rej instanceof Error) {
              reject(rej);
            } else {
              _this._queueRequest.call(_this, resolve5, reject, tokens);
              if (_this._waitTimeout === null) {
                _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
              }
            }
          });
        }
      });
    }
    _queueRequest(resolve5, reject, tokens) {
      const _this = this;
      if (_this._queue.length < _this._maxQueueSize) {
        _this._queue.push({ resolve: resolve5, reject, tokens });
      } else {
        reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`));
      }
    }
    _processFIFO() {
      const _this = this;
      if (_this._waitTimeout !== null) {
        clearTimeout(_this._waitTimeout);
        _this._waitTimeout = null;
      }
      if (_this._queue.length === 0) {
        return;
      }
      const item = _this._queue.shift();
      _this._limiterFlexible.consume(_this._key, item.tokens).then((res) => {
        item.resolve(res.remainingPoints);
        _this._processFIFO.call(_this);
      }).catch((rej) => {
        if (rej instanceof Error) {
          item.reject(rej);
          _this._processFIFO.call(_this);
        } else {
          _this._queue.unshift(item);
          if (_this._waitTimeout === null) {
            _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
          }
        }
      });
    }
  }
  var RateLimiterRes$1 = RateLimiterRes_1;
  var BurstyRateLimiter_1 = class BurstyRateLimiter2 {
    constructor(rateLimiter, burstLimiter) {
      this._rateLimiter = rateLimiter;
      this._burstLimiter = burstLimiter;
    }
    _combineRes(rlRes, blRes) {
      if (!rlRes) {
        return null;
      }
      return new RateLimiterRes$1(rlRes.remainingPoints, Math.min(rlRes.msBeforeNext, blRes ? blRes.msBeforeNext : 0), rlRes.consumedPoints, rlRes.isFirstInDuration);
    }
    consume(key, pointsToConsume = 1, options = {}) {
      return this._rateLimiter.consume(key, pointsToConsume, options).catch((rlRej) => {
        if (rlRej instanceof RateLimiterRes$1) {
          return this._burstLimiter.consume(key, pointsToConsume, options).then((blRes) => {
            return Promise.resolve(this._combineRes(rlRej, blRes));
          }).catch((blRej) => {
            if (blRej instanceof RateLimiterRes$1) {
              return Promise.reject(this._combineRes(rlRej, blRej));
            } else {
              return Promise.reject(blRej);
            }
          });
        } else {
          return Promise.reject(rlRej);
        }
      });
    }
    get(key) {
      return Promise.all([
        this._rateLimiter.get(key),
        this._burstLimiter.get(key)
      ]).then(([rlRes, blRes]) => {
        return this._combineRes(rlRes, blRes);
      });
    }
    get points() {
      return this._rateLimiter.points;
    }
  };
  var RateLimiterRedis = RateLimiterRedis_1;
  var RateLimiterMongo = RateLimiterMongo_1;
  var RateLimiterMySQL = RateLimiterMySQL_1;
  var RateLimiterPostgres = RateLimiterPostgres_1;
  var { RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster } = RateLimiterCluster$1;
  var RateLimiterMemory = RateLimiterMemory_1;
  var RateLimiterMemcache = RateLimiterMemcache_1;
  var RLWrapperBlackAndWhite = RLWrapperBlackAndWhite_1;
  var RateLimiterUnion = RateLimiterUnion_1;
  var RateLimiterQueue = RateLimiterQueue_1;
  var BurstyRateLimiter = BurstyRateLimiter_1;
  var RateLimiterRes = RateLimiterRes_1;
  var rateLimiterFlexible = {
    RateLimiterRedis,
    RateLimiterMongo,
    RateLimiterMySQL,
    RateLimiterPostgres,
    RateLimiterMemory,
    RateLimiterMemcache,
    RateLimiterClusterMaster,
    RateLimiterClusterMasterPM2,
    RateLimiterCluster,
    RLWrapperBlackAndWhite,
    RateLimiterUnion,
    RateLimiterQueue,
    BurstyRateLimiter,
    RateLimiterRes
  };
  var log$g = logger$2("libp2p:get-peer");

  class PeerPriorityQueue {
    constructor() {
      _PeerPriorityQueue_queue.set(this, []);
    }
    enqueue(run, options) {
      const peerId = options?.peerId;
      const priority = options?.priority ?? 0;
      if (peerId == null) {
        throw new CodeError$3("missing peer id", codes.ERR_INVALID_PARAMETERS);
      }
      const element = {
        priority,
        peerId,
        run
      };
      if (this.size > 0 && __classPrivateFieldGet2(this, _PeerPriorityQueue_queue, "f")[this.size - 1].priority >= priority) {
        __classPrivateFieldGet2(this, _PeerPriorityQueue_queue, "f").push(element);
        return;
      }
      const index2 = lowerBound(__classPrivateFieldGet2(this, _PeerPriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
      __classPrivateFieldGet2(this, _PeerPriorityQueue_queue, "f").splice(index2, 0, element);
    }
    dequeue() {
      const item = __classPrivateFieldGet2(this, _PeerPriorityQueue_queue, "f").shift();
      return item?.run;
    }
    filter(options) {
      if (options.peerId != null) {
        const peerId = options.peerId;
        return __classPrivateFieldGet2(this, _PeerPriorityQueue_queue, "f").filter((element) => peerId.equals(element.peerId)).map((element) => element.run);
      }
      return __classPrivateFieldGet2(this, _PeerPriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return __classPrivateFieldGet2(this, _PeerPriorityQueue_queue, "f").length;
    }
  }
  _PeerPriorityQueue_queue = new WeakMap;

  class PeerJobQueue extends PQueue {
    constructor(options = {}) {
      super({
        ...options,
        queueClass: PeerPriorityQueue
      });
    }
    hasJob(peerId) {
      return this.sizeBy({
        peerId
      }) > 0;
    }
  }
  var DIAL_TIMEOUT = 30000;
  var INBOUND_UPGRADE_TIMEOUT = 30000;
  var MAX_PEER_ADDRS_TO_DIAL = 25;
  var MAX_PARALLEL_DIALS_PER_PEER = 10;
  var AUTO_DIAL_INTERVAL = 5000;
  var AUTO_DIAL_PRIORITY = 0;
  var AUTO_DIAL_MAX_QUEUE_LENGTH = 100;
  var AUTO_DIAL_PEER_RETRY_THRESHOLD = 1000 * 60;
  var AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10;
  var INBOUND_CONNECTION_THRESHOLD = 5;
  var MAX_INCOMING_PENDING_CONNECTIONS = 10;
  var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
  var MAX_PARALLEL_DIALS = 10;
  var MIN_CONNECTIONS = 5;
  var MAX_CONNECTIONS = 100;
  var AUTO_DIAL_CONCURRENCY = 10;
  var log$f = logger$2("libp2p:connection-manager:auto-dial");
  var defaultOptions$3 = {
    minConnections: MIN_CONNECTIONS,
    maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,
    autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
    autoDialPriority: AUTO_DIAL_PRIORITY,
    autoDialInterval: AUTO_DIAL_INTERVAL,
    autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,
    autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE
  };

  class AutoDial {
    constructor(components, init2) {
      this.connectionManager = components.connectionManager;
      this.peerStore = components.peerStore;
      this.minConnections = init2.minConnections ?? defaultOptions$3.minConnections;
      this.autoDialPriority = init2.autoDialPriority ?? defaultOptions$3.autoDialPriority;
      this.autoDialIntervalMs = init2.autoDialInterval ?? defaultOptions$3.autoDialInterval;
      this.autoDialMaxQueueLength = init2.maxQueueLength ?? defaultOptions$3.maxQueueLength;
      this.autoDialPeerRetryThresholdMs = init2.autoDialPeerRetryThreshold ?? defaultOptions$3.autoDialPeerRetryThreshold;
      this.autoDialDiscoveredPeersDebounce = init2.autoDialDiscoveredPeersDebounce ?? defaultOptions$3.autoDialDiscoveredPeersDebounce;
      this.started = false;
      this.running = false;
      this.queue = new PeerJobQueue({
        concurrency: init2.autoDialConcurrency ?? defaultOptions$3.autoDialConcurrency
      });
      this.queue.addListener("error", (err) => {
        log$f.error("error during auto-dial", err);
      });
      components.events.addEventListener("connection:close", () => {
        this.autoDial().catch((err) => {
          log$f.error(err);
        });
      });
      let debounce2;
      components.events.addEventListener("peer:discovery", () => {
        clearTimeout(debounce2);
        debounce2 = setTimeout(() => {
          this.autoDial().catch((err) => {
            log$f.error(err);
          });
        }, this.autoDialDiscoveredPeersDebounce);
      });
    }
    isStarted() {
      return this.started;
    }
    start() {
      this.autoDialInterval = setTimeout(() => {
        this.autoDial().catch((err) => {
          log$f.error("error while autodialing", err);
        });
      }, this.autoDialIntervalMs);
      this.started = true;
    }
    afterStart() {
      this.autoDial().catch((err) => {
        log$f.error("error while autodialing", err);
      });
    }
    stop() {
      this.queue.clear();
      clearTimeout(this.autoDialInterval);
      this.started = false;
      this.running = false;
    }
    async autoDial() {
      if (!this.started) {
        return;
      }
      const connections = this.connectionManager.getConnectionsMap();
      const numConnections = connections.size;
      if (numConnections >= this.minConnections) {
        if (this.minConnections > 0) {
          log$f.trace("have enough connections %d/%d", numConnections, this.minConnections);
        }
        return;
      }
      if (this.queue.size > this.autoDialMaxQueueLength) {
        log$f("not enough connections %d/%d but auto dial queue is full", numConnections, this.minConnections);
        return;
      }
      if (this.running) {
        log$f("not enough connections %d/%d - but skipping autodial as it is already running", numConnections, this.minConnections);
        return;
      }
      this.running = true;
      log$f("not enough connections %d/%d - will dial peers to increase the number of connections", numConnections, this.minConnections);
      const dialQueue = new PeerSet(this.connectionManager.getDialQueue().map((queue) => queue.peerId).filter(Boolean));
      const peers = await this.peerStore.all({
        filters: [
          (peer) => {
            if (peer.addresses.length === 0) {
              log$f.trace("not autodialing %p because they have no addresses");
              return false;
            }
            if (connections.has(peer.id)) {
              log$f.trace("not autodialing %p because they are already connected");
              return false;
            }
            if (dialQueue.has(peer.id)) {
              log$f.trace("not autodialing %p because they are already being dialed");
              return false;
            }
            if (this.queue.hasJob(peer.id)) {
              log$f.trace("not autodialing %p because they are already being autodialed");
              return false;
            }
            return true;
          }
        ]
      });
      const shuffledPeers = peers.sort(() => Math.random() > 0.5 ? 1 : -1);
      const peerValues = new PeerMap;
      for (const peer of shuffledPeers) {
        if (peerValues.has(peer.id)) {
          continue;
        }
        peerValues.set(peer.id, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      }
      const sortedPeers = shuffledPeers.sort((a, b) => {
        const peerAValue = peerValues.get(a.id) ?? 0;
        const peerBValue = peerValues.get(b.id) ?? 0;
        if (peerAValue > peerBValue) {
          return -1;
        }
        if (peerAValue < peerBValue) {
          return 1;
        }
        return 0;
      });
      const peersThatHaveNotFailed = sortedPeers.filter((peer) => {
        const lastDialFailure = peer.metadata.get(LAST_DIAL_FAILURE_KEY);
        if (lastDialFailure == null) {
          return true;
        }
        const lastDialFailureTimestamp = parseInt(toString$9(lastDialFailure));
        if (isNaN(lastDialFailureTimestamp)) {
          return true;
        }
        return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs;
      });
      log$f("selected %d/%d peers to dial", peersThatHaveNotFailed.length, peers.length);
      for (const peer of peersThatHaveNotFailed) {
        this.queue.add(async () => {
          const numConnections2 = this.connectionManager.getConnectionsMap().size;
          if (numConnections2 >= this.minConnections) {
            log$f("got enough connections now %d/%d", numConnections2, this.minConnections);
            this.queue.clear();
            return;
          }
          log$f("connecting to a peerStore stored peer %p", peer.id);
          await this.connectionManager.openConnection(peer.id, {
            priority: this.autoDialPriority
          });
        }, {
          peerId: peer.id
        }).catch((err) => {
          log$f.error("could not connect to peerStore stored peer", err);
        });
      }
      this.running = false;
      if (this.started) {
        this.autoDialInterval = setTimeout(() => {
          this.autoDial().catch((err) => {
            log$f.error("error while autodialing", err);
          });
        }, this.autoDialIntervalMs);
      }
    }
  }
  var log$e = logger$2("libp2p:connection-manager:connection-pruner");
  var defaultOptions$2 = {
    maxConnections: MAX_CONNECTIONS,
    allow: []
  };

  class ConnectionPruner {
    constructor(components, init2 = {}) {
      this.maxConnections = init2.maxConnections ?? defaultOptions$2.maxConnections;
      this.allow = init2.allow ?? defaultOptions$2.allow;
      this.connectionManager = components.connectionManager;
      this.peerStore = components.peerStore;
      this.events = components.events;
      components.events.addEventListener("connection:open", () => {
        this.maybePruneConnections().catch((err) => {
          log$e.error(err);
        });
      });
    }
    async maybePruneConnections() {
      const connections = this.connectionManager.getConnections();
      const numConnections = connections.length;
      const toPrune = Math.max(numConnections - this.maxConnections, 0);
      log$e("checking max connections limit %d/%d", numConnections, this.maxConnections);
      if (numConnections <= this.maxConnections) {
        return;
      }
      log$e("max connections limit exceeded %d/%d, pruning %d connection(s)", numConnections, this.maxConnections, toPrune);
      const peerValues = new PeerMap;
      for (const connection of connections) {
        const remotePeer = connection.remotePeer;
        if (peerValues.has(remotePeer)) {
          continue;
        }
        peerValues.set(remotePeer, 0);
        try {
          const peer = await this.peerStore.get(remotePeer);
          peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
            return acc + curr.value;
          }, 0));
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            log$e.error("error loading peer tags", err);
          }
        }
      }
      const sortedConnections = connections.sort((a, b) => {
        const peerAValue = peerValues.get(a.remotePeer) ?? 0;
        const peerBValue = peerValues.get(b.remotePeer) ?? 0;
        if (peerAValue > peerBValue) {
          return 1;
        }
        if (peerAValue < peerBValue) {
          return -1;
        }
        const connectionALifespan = a.timeline.open;
        const connectionBLifespan = b.timeline.open;
        if (connectionALifespan < connectionBLifespan) {
          return 1;
        }
        if (connectionALifespan > connectionBLifespan) {
          return -1;
        }
        return 0;
      });
      const toClose = [];
      for (const connection of sortedConnections) {
        log$e("too many connections open - closing a connection to %p", connection.remotePeer);
        const connectionInAllowList = this.allow.some((ma) => {
          return connection.remoteAddr.toString().startsWith(ma.toString());
        });
        if (!connectionInAllowList) {
          toClose.push(connection);
        }
        if (toClose.length === toPrune) {
          break;
        }
      }
      await Promise.all(toClose.map(async (connection) => {
        try {
          await connection.close();
        } catch (err) {
          log$e.error(err);
        }
      }));
      this.events.safeDispatchEvent("connection:prune", { detail: toClose });
    }
  }
  var log$d = logger$2("libp2p:connection-manager:utils");
  var log$c = logger$2("libp2p:connection-manager:dial-queue");
  var defaultOptions$1 = {
    addressSorter: publicAddressesFirst,
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
    maxParallelDialsPerPeer: MAX_PARALLEL_DIALS_PER_PEER,
    dialTimeout: DIAL_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    }
  };

  class DialQueue {
    constructor(components, init2 = {}) {
      this.addressSorter = init2.addressSorter ?? defaultOptions$1.addressSorter;
      this.maxPeerAddrsToDial = init2.maxPeerAddrsToDial ?? defaultOptions$1.maxPeerAddrsToDial;
      this.maxParallelDialsPerPeer = init2.maxParallelDialsPerPeer ?? defaultOptions$1.maxParallelDialsPerPeer;
      this.dialTimeout = init2.dialTimeout ?? defaultOptions$1.dialTimeout;
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.connectionGater = components.connectionGater;
      this.transportManager = components.transportManager;
      this.shutDownController = new AbortController;
      try {
        eventsExports.setMaxListeners?.(Infinity, this.shutDownController.signal);
      } catch {
      }
      this.pendingDialCount = components.metrics?.registerMetric("libp2p_dialler_pending_dials");
      this.inProgressDialCount = components.metrics?.registerMetric("libp2p_dialler_in_progress_dials");
      this.pendingDials = [];
      for (const [key, value] of Object.entries(init2.resolvers ?? {})) {
        resolvers$2.set(key, value);
      }
      this.queue = new PQueue({
        concurrency: init2.maxParallelDials ?? defaultOptions$1.maxParallelDials
      });
      this.queue.on("add", () => {
        this.pendingDialCount?.update(this.queue.size);
        this.inProgressDialCount?.update(this.queue.pending);
      });
      this.queue.on("active", () => {
        this.pendingDialCount?.update(this.queue.size);
        this.inProgressDialCount?.update(this.queue.pending);
      });
      this.queue.on("completed", () => {
        this.pendingDialCount?.update(this.queue.size);
        this.inProgressDialCount?.update(this.queue.pending);
      });
      this.queue.on("error", (err) => {
        log$c.error("error in dial queue", err);
        this.pendingDialCount?.update(this.queue.size);
        this.inProgressDialCount?.update(this.queue.pending);
      });
      this.queue.on("empty", () => {
        this.pendingDialCount?.update(this.queue.size);
        this.inProgressDialCount?.update(this.queue.pending);
      });
      this.queue.on("idle", () => {
        this.pendingDialCount?.update(this.queue.size);
        this.inProgressDialCount?.update(this.queue.pending);
      });
    }
    stop() {
      this.shutDownController.abort();
    }
    async dial(peerIdOrMultiaddr, options = {}) {
      const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
      const addrs = multiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
      const signal = this.createDialAbortControllers(options.signal);
      let addrsToDial;
      try {
        addrsToDial = await this.calculateMultiaddrs(peerId, addrs, {
          ...options,
          signal
        });
      } catch (err) {
        signal.clear();
        throw err;
      }
      const existingDial = this.pendingDials.find((dial) => {
        if (dial.peerId != null && peerId != null && dial.peerId.equals(peerId)) {
          return true;
        }
        if (addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()).join() === dial.multiaddrs.map((multiaddr2) => multiaddr2.toString()).join()) {
          return true;
        }
        return false;
      });
      if (existingDial != null) {
        log$c("joining existing dial target for %p", peerId);
        signal.clear();
        return existingDial.promise;
      }
      log$c("creating dial target for", addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      const pendingDial = {
        id: randomId(),
        status: "queued",
        peerId,
        multiaddrs: addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      };
      pendingDial.promise = this.performDial(pendingDial, {
        ...options,
        signal
      }).finally(() => {
        this.pendingDials = this.pendingDials.filter((p) => p.id !== pendingDial.id);
        signal.clear();
      }).catch(async (err) => {
        log$c.error("dial failed to %s", pendingDial.multiaddrs.map((ma) => ma.toString()).join(", "), err);
        if (peerId != null) {
          try {
            await this.peerStore.patch(peerId, {
              metadata: {
                [LAST_DIAL_FAILURE_KEY]: fromString$3(Date.now().toString())
              }
            });
          } catch (err2) {
            log$c.error("could not update last dial failure key for %p", peerId, err2);
          }
        }
        if (signal.aborted) {
          const error = new CodeError$3(err.message, codes.ERR_TIMEOUT);
          throw error;
        }
        throw err;
      });
      this.pendingDials.push(pendingDial);
      return pendingDial.promise;
    }
    createDialAbortControllers(userSignal) {
      const signal = anySignal([
        AbortSignal.timeout(this.dialTimeout),
        this.shutDownController.signal,
        userSignal
      ]);
      try {
        eventsExports.setMaxListeners?.(Infinity, signal);
      } catch {
      }
      return signal;
    }
    async calculateMultiaddrs(peerId, addrs = [], options = {}) {
      if (peerId != null) {
        if (this.peerId.equals(peerId)) {
          throw new CodeError$3("Tried to dial self", codes.ERR_DIALED_SELF);
        }
        if (await this.connectionGater.denyDialPeer?.(peerId) === true) {
          throw new CodeError$3("The dial request is blocked by gater.allowDialPeer", codes.ERR_PEER_DIAL_INTERCEPTED);
        }
        if (addrs.length === 0) {
          log$c("loading multiaddrs for %p", peerId);
          try {
            const peer = await this.peerStore.get(peerId);
            addrs.push(...peer.addresses);
            log$c("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          } catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
              throw err;
            }
          }
        }
      }
      const resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
        const result = await resolveMultiaddrs(addr.multiaddr, options);
        if (result.length === 1 && result[0].equals(addr.multiaddr)) {
          return addr;
        }
        return result.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          isCertified: false
        }));
      }))).flat();
      const filteredAddrs = resolvedAddresses.filter((addr) => {
        if (this.transportManager.transportForMultiaddr(addr.multiaddr) == null) {
          return false;
        }
        const addrPeerId = addr.multiaddr.getPeerId();
        if (peerId != null && addrPeerId != null) {
          return peerId.equals(addrPeerId);
        }
        return true;
      });
      const dedupedAddrs = new Map;
      for (const addr of filteredAddrs) {
        const maStr = addr.multiaddr.toString();
        const existing = dedupedAddrs.get(maStr);
        if (existing != null) {
          existing.isCertified = existing.isCertified || addr.isCertified || false;
          continue;
        }
        dedupedAddrs.set(maStr, addr);
      }
      let dedupedMultiaddrs = [...dedupedAddrs.values()];
      if (dedupedMultiaddrs.length === 0 || dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {
        log$c("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        log$c("addresses for %p after filtering", peerId ?? "unknown peer", dedupedMultiaddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      }
      if (dedupedMultiaddrs.length === 0) {
        throw new CodeError$3("The dial request has no valid addresses", codes.ERR_NO_VALID_ADDRESSES);
      }
      if (dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {
        throw new CodeError$3("dial with more addresses than allowed", codes.ERR_TOO_MANY_ADDRESSES);
      }
      if (peerId != null) {
        const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
        dedupedMultiaddrs = dedupedMultiaddrs.map((addr) => {
          const addressPeerId = addr.multiaddr.getPeerId();
          const lastProto = addr.multiaddr.protos().pop();
          if (lastProto?.path === true) {
            return addr;
          }
          if (addressPeerId !== peerId.toString()) {
            return {
              multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
              isCertified: addr.isCertified
            };
          }
          return addr;
        });
      }
      const gatedAdrs = [];
      for (const addr of dedupedMultiaddrs) {
        if (this.connectionGater.denyDialMultiaddr != null && await this.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
          continue;
        }
        gatedAdrs.push(addr);
      }
      const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter);
      if (sortedGatedAddrs.length === 0) {
        throw new CodeError$3("The connection gater denied all addresses in the dial request", codes.ERR_NO_VALID_ADDRESSES);
      }
      return sortedGatedAddrs;
    }
    async performDial(pendingDial, options = {}) {
      const dialAbortControllers = pendingDial.multiaddrs.map(() => new AbortController);
      try {
        const peerDialQueue = new PQueue({
          concurrency: this.maxParallelDialsPerPeer
        });
        peerDialQueue.on("error", (err) => {
          log$c.error("error dialling", err);
        });
        const conn = await Promise.any(pendingDial.multiaddrs.map(async (addr, i) => {
          const controller = dialAbortControllers[i];
          if (controller == null) {
            throw new CodeError$3("dialAction did not come with an AbortController", codes.ERR_INVALID_PARAMETERS);
          }
          const signal = combineSignals(controller.signal, options.signal);
          signal.addEventListener("abort", () => {
            log$c("dial to %a aborted", addr);
          });
          const deferred = pDefer();
          await peerDialQueue.add(async () => {
            if (signal.aborted) {
              log$c("dial to %a was aborted before reaching the head of the peer dial queue", addr);
              deferred.reject(new AbortError$8);
              return;
            }
            await this.queue.add(async () => {
              try {
                if (signal.aborted) {
                  log$c("dial to %a was aborted before reaching the head of the dial queue", addr);
                  deferred.reject(new AbortError$8);
                  return;
                }
                pendingDial.status = "active";
                const conn2 = await this.transportManager.dial(addr, {
                  ...options,
                  signal
                });
                if (controller.signal.aborted) {
                  log$c("multiple dials succeeded, closing superfluous connection");
                  conn2.close().catch((err) => {
                    log$c.error("error closing superfluous connection", err);
                  });
                  deferred.reject(new AbortError$8);
                  return;
                }
                dialAbortControllers[i] = undefined;
                dialAbortControllers.forEach((c) => {
                  if (c !== undefined) {
                    c.abort();
                  }
                });
                log$c("dial to %a succeeded", addr);
                deferred.resolve(conn2);
              } catch (err) {
                log$c.error("error during dial of %a", addr, err);
                deferred.reject(err);
              }
            }, {
              ...options,
              signal
            }).catch((err) => {
              deferred.reject(err);
            });
          }, {
            signal
          }).catch((err) => {
            deferred.reject(err);
          }).finally(() => {
            signal.clear();
          });
          return deferred.promise;
        }));
        if (conn == null) {
          throw new CodeError$3("successful dial led to empty object returned from peer dial queue", codes.ERR_TRANSPORT_DIAL_FAILED);
        }
        pendingDial.status = "success";
        return conn;
      } catch (err) {
        pendingDial.status = "error";
        if (pendingDial.multiaddrs.length === 1 && err.name === "AggregateError") {
          throw err.errors[0];
        }
        throw err;
      }
    }
  }
  var log$b = logger$2("libp2p:connection-manager");
  var DEFAULT_DIAL_PRIORITY = 50;
  var defaultOptions = {
    minConnections: MIN_CONNECTIONS,
    maxConnections: MAX_CONNECTIONS,
    inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
    maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,
    autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
    autoDialPriority: AUTO_DIAL_PRIORITY,
    autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH
  };

  class DefaultConnectionManager {
    constructor(components, init2 = {}) {
      this.maxConnections = init2.maxConnections ?? defaultOptions.maxConnections;
      const minConnections = init2.minConnections ?? defaultOptions.minConnections;
      if (this.maxConnections < minConnections) {
        throw new CodeError$3("Connection Manager maxConnections must be greater than minConnections", codes.ERR_INVALID_PARAMETERS);
      }
      this.connections = new PeerMap;
      this.started = false;
      this.peerStore = components.peerStore;
      this.metrics = components.metrics;
      this.events = components.events;
      this.onConnect = this.onConnect.bind(this);
      this.onDisconnect = this.onDisconnect.bind(this);
      this.events.addEventListener("connection:open", this.onConnect);
      this.events.addEventListener("connection:close", this.onDisconnect);
      this.allow = (init2.allow ?? []).map((ma) => multiaddr$1(ma));
      this.deny = (init2.deny ?? []).map((ma) => multiaddr$1(ma));
      this.incomingPendingConnections = 0;
      this.maxIncomingPendingConnections = init2.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections;
      this.inboundConnectionRateLimiter = new rateLimiterFlexible.RateLimiterMemory({
        points: init2.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,
        duration: 1
      });
      this.autoDial = new AutoDial({
        connectionManager: this,
        peerStore: components.peerStore,
        events: components.events
      }, {
        minConnections,
        autoDialConcurrency: init2.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,
        autoDialPriority: init2.autoDialPriority ?? defaultOptions.autoDialPriority,
        maxQueueLength: init2.autoDialMaxQueueLength ?? defaultOptions.autoDialMaxQueueLength
      });
      this.connectionPruner = new ConnectionPruner({
        connectionManager: this,
        peerStore: components.peerStore,
        events: components.events
      }, {
        maxConnections: this.maxConnections,
        allow: this.allow
      });
      this.dialQueue = new DialQueue({
        peerId: components.peerId,
        metrics: components.metrics,
        peerStore: components.peerStore,
        transportManager: components.transportManager,
        connectionGater: components.connectionGater
      }, {
        addressSorter: init2.addressSorter ?? publicAddressesFirst,
        maxParallelDials: init2.maxParallelDials ?? MAX_PARALLEL_DIALS,
        maxPeerAddrsToDial: init2.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
        dialTimeout: init2.dialTimeout ?? DIAL_TIMEOUT,
        resolvers: init2.resolvers ?? {
          dnsaddr: dnsaddrResolver
        }
      });
    }
    isStarted() {
      return this.started;
    }
    async start() {
      this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
        calculate: () => {
          const metric = {
            inbound: 0,
            outbound: 0
          };
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              if (conn.direction === "inbound") {
                metric.inbound++;
              } else {
                metric.outbound++;
              }
            }
          }
          return metric;
        }
      });
      this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
        label: "protocol",
        calculate: () => {
          const metric = {};
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              for (const stream of conn.streams) {
                const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                metric[key] = (metric[key] ?? 0) + 1;
              }
            }
          }
          return metric;
        }
      });
      this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
        label: "protocol",
        calculate: () => {
          const allStreams = {};
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              const streams = {};
              for (const stream of conn.streams) {
                const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                streams[key] = (streams[key] ?? 0) + 1;
              }
              for (const [protocol, count] of Object.entries(streams)) {
                allStreams[protocol] = allStreams[protocol] ?? [];
                allStreams[protocol].push(count);
              }
            }
          }
          const metric = {};
          for (let [protocol, counts] of Object.entries(allStreams)) {
            counts = counts.sort((a, b) => a - b);
            const index2 = Math.floor(counts.length * 0.9);
            metric[protocol] = counts[index2];
          }
          return metric;
        }
      });
      this.autoDial.start();
      this.started = true;
      log$b("started");
    }
    async afterStart() {
      Promise.resolve().then(async () => {
        const keepAlivePeers = await this.peerStore.all({
          filters: [(peer) => {
            return peer.tags.has(KEEP_ALIVE);
          }]
        });
        await Promise.all(keepAlivePeers.map(async (peer) => {
          await this.openConnection(peer.id).catch((err) => {
            log$b.error(err);
          });
        }));
      }).catch((err) => {
        log$b.error(err);
      });
      this.autoDial.afterStart();
    }
    async stop() {
      this.dialQueue.stop();
      this.autoDial.stop();
      const tasks = [];
      for (const connectionList of this.connections.values()) {
        for (const connection of connectionList) {
          tasks.push((async () => {
            try {
              await connection.close();
            } catch (err) {
              log$b.error(err);
            }
          })());
        }
      }
      log$b("closing %d connections", tasks.length);
      await Promise.all(tasks);
      this.connections.clear();
      log$b("stopped");
    }
    onConnect(evt) {
      this._onConnect(evt).catch((err) => {
        log$b.error(err);
      });
    }
    async _onConnect(evt) {
      const { detail: connection } = evt;
      if (!this.started) {
        await connection.close();
        return;
      }
      const peerId = connection.remotePeer;
      const storedConns = this.connections.get(peerId);
      let isNewPeer2 = false;
      if (storedConns != null) {
        storedConns.push(connection);
      } else {
        isNewPeer2 = true;
        this.connections.set(peerId, [connection]);
      }
      if (peerId.publicKey != null && peerId.type === "RSA") {
        await this.peerStore.patch(peerId, {
          publicKey: peerId.publicKey
        });
      }
      if (isNewPeer2) {
        this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
      }
    }
    onDisconnect(evt) {
      const { detail: connection } = evt;
      if (!this.started) {
        return;
      }
      const peerId = connection.remotePeer;
      let storedConn = this.connections.get(peerId);
      if (storedConn != null && storedConn.length > 1) {
        storedConn = storedConn.filter((conn) => conn.id !== connection.id);
        this.connections.set(peerId, storedConn);
      } else if (storedConn != null) {
        this.connections.delete(peerId);
        this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
      }
    }
    getConnections(peerId) {
      if (peerId != null) {
        return this.connections.get(peerId) ?? [];
      }
      let conns = [];
      for (const c of this.connections.values()) {
        conns = conns.concat(c);
      }
      return conns;
    }
    getConnectionsMap() {
      return this.connections;
    }
    async openConnection(peerIdOrMultiaddr, options = {}) {
      if (!this.isStarted()) {
        throw new CodeError$3("Not started", codes.ERR_NODE_NOT_STARTED);
      }
      options.signal?.throwIfAborted();
      const { peerId } = getPeerAddress(peerIdOrMultiaddr);
      if (peerId != null && options.force !== true) {
        log$b("dial %p", peerId);
        const existingConnections = this.getConnections(peerId);
        if (existingConnections.length > 0) {
          log$b("had an existing connection to %p", peerId);
          return existingConnections[0];
        }
      }
      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
        ...options,
        priority: options.priority ?? DEFAULT_DIAL_PRIORITY
      });
      let peerConnections = this.connections.get(connection.remotePeer);
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer, peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    }
    async closeConnections(peerId, options = {}) {
      const connections = this.connections.get(peerId) ?? [];
      await Promise.all(connections.map(async (connection) => {
        try {
          await connection.close(options);
        } catch (err) {
          connection.abort(err);
        }
      }));
    }
    async acceptIncomingConnection(maConn) {
      const denyConnection = this.deny.some((ma) => {
        return maConn.remoteAddr.toString().startsWith(ma.toString());
      });
      if (denyConnection) {
        log$b("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
        return false;
      }
      const allowConnection = this.allow.some((ma) => {
        return maConn.remoteAddr.toString().startsWith(ma.toString());
      });
      if (allowConnection) {
        this.incomingPendingConnections++;
        return true;
      }
      if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
        log$b("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
        return false;
      }
      if (maConn.remoteAddr.isThinWaistAddress()) {
        const host = maConn.remoteAddr.nodeAddress().address;
        try {
          await this.inboundConnectionRateLimiter.consume(host, 1);
        } catch {
          log$b("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
          return false;
        }
      }
      if (this.getConnections().length < this.maxConnections) {
        this.incomingPendingConnections++;
        return true;
      }
      log$b("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
      return false;
    }
    afterUpgradeInbound() {
      this.incomingPendingConnections--;
    }
    getDialQueue() {
      return this.dialQueue.pendingDials;
    }
  }

  class CompoundContentRouting {
    constructor(components, init2) {
      this.routers = init2.routers ?? [];
      this.started = false;
      this.components = components;
    }
    isStarted() {
      return this.started;
    }
    async start() {
      this.started = true;
    }
    async stop() {
      this.started = false;
    }
    async* findProviders(key, options = {}) {
      if (this.routers.length === 0) {
        throw new CodeError$3("No content routers available", codes.ERR_NO_ROUTERS_AVAILABLE);
      }
      yield* pipe(merge$1(...this.routers.map((router) => router.findProviders(key, options))), (source2) => storeAddresses(source2, this.components.peerStore), (source2) => uniquePeers(source2), (source2) => requirePeers(source2));
    }
    async provide(key, options = {}) {
      if (this.routers.length === 0) {
        throw new CodeError$3("No content routers available", codes.ERR_NO_ROUTERS_AVAILABLE);
      }
      await Promise.all(this.routers.map(async (router) => {
        await router.provide(key, options);
      }));
    }
    async put(key, value, options) {
      if (!this.isStarted()) {
        throw new CodeError$3(messages.NOT_STARTED_YET, codes.DHT_NOT_STARTED);
      }
      await Promise.all(this.routers.map(async (router) => {
        await router.put(key, value, options);
      }));
    }
    async get(key, options) {
      if (!this.isStarted()) {
        throw new CodeError$3(messages.NOT_STARTED_YET, codes.DHT_NOT_STARTED);
      }
      return Promise.any(this.routers.map(async (router) => {
        return router.get(key, options);
      }));
    }
  }
  var log$a = logger$2("libp2p:peer-routing");

  class DefaultPeerRouting {
    constructor(components, init2) {
      this.components = components;
      this.routers = init2.routers ?? [];
    }
    async findPeer(id, options) {
      if (this.routers.length === 0) {
        throw new CodeError$3("No peer routers available", codes.ERR_NO_ROUTERS_AVAILABLE);
      }
      if (id.toString() === this.components.peerId.toString()) {
        throw new CodeError$3("Should not try to find self", codes.ERR_FIND_SELF);
      }
      const output2 = await pipe(merge$1(...this.routers.map((router) => async function* () {
        try {
          yield await router.findPeer(id, options);
        } catch (err) {
          log$a.error(err);
        }
      }())), (source2) => filter(source2, Boolean), (source2) => storeAddresses(source2, this.components.peerStore), async (source2) => first(source2));
      if (output2 != null) {
        return output2;
      }
      throw new CodeError$3(messages.NOT_FOUND, codes.ERR_NOT_FOUND);
    }
    async* getClosestPeers(key, options) {
      if (this.routers.length === 0) {
        throw new CodeError$3("No peer routers available", codes.ERR_NO_ROUTERS_AVAILABLE);
      }
      yield* pipe(merge$1(...this.routers.map((router) => router.getClosestPeers(key, options))), (source2) => storeAddresses(source2, this.components.peerStore), (source2) => uniquePeers(source2), (source2) => requirePeers(source2));
    }
  }
  var log$9 = logger$2("libp2p:registrar");
  var DEFAULT_MAX_INBOUND_STREAMS = 32;
  var DEFAULT_MAX_OUTBOUND_STREAMS = 64;

  class DefaultRegistrar {
    constructor(components) {
      this.topologies = new Map;
      this.handlers = new Map;
      this.components = components;
      this._onDisconnect = this._onDisconnect.bind(this);
      this._onPeerUpdate = this._onPeerUpdate.bind(this);
      this._onConnect = this._onConnect.bind(this);
      this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
      this.components.events.addEventListener("peer:connect", this._onConnect);
      this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    }
    getProtocols() {
      return Array.from(new Set([
        ...this.handlers.keys()
      ])).sort();
    }
    getHandler(protocol) {
      const handler = this.handlers.get(protocol);
      if (handler == null) {
        throw new CodeError$3(`No handler registered for protocol ${protocol}`, codes.ERR_NO_HANDLER_FOR_PROTOCOL);
      }
      return handler;
    }
    getTopologies(protocol) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        return [];
      }
      return [
        ...topologies.values()
      ];
    }
    async handle(protocol, handler, opts) {
      if (this.handlers.has(protocol)) {
        throw new CodeError$3(`Handler already registered for protocol ${protocol}`, codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
      }
      const options = mergeOptions$1.bind({ ignoreUndefined: true })({
        maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
        maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
      }, opts);
      this.handlers.set(protocol, {
        handler,
        options
      });
      await this.components.peerStore.merge(this.components.peerId, {
        protocols: [protocol]
      });
    }
    async unhandle(protocols) {
      const protocolList = Array.isArray(protocols) ? protocols : [protocols];
      protocolList.forEach((protocol) => {
        this.handlers.delete(protocol);
      });
      await this.components.peerStore.patch(this.components.peerId, {
        protocols: this.getProtocols()
      });
    }
    async register(protocol, topology) {
      if (topology == null) {
        throw new CodeError$3("invalid topology", codes.ERR_INVALID_PARAMETERS);
      }
      const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
      let topologies = this.topologies.get(protocol);
      if (topologies == null) {
        topologies = new Map;
        this.topologies.set(protocol, topologies);
      }
      topologies.set(id, topology);
      return id;
    }
    unregister(id) {
      for (const [protocol, topologies] of this.topologies.entries()) {
        if (topologies.has(id)) {
          topologies.delete(id);
          if (topologies.size === 0) {
            this.topologies.delete(protocol);
          }
        }
      }
    }
    _onDisconnect(evt) {
      const remotePeer = evt.detail;
      this.components.peerStore.get(remotePeer).then((peer) => {
        for (const protocol of peer.protocols) {
          const topologies = this.topologies.get(protocol);
          if (topologies == null) {
            continue;
          }
          for (const topology of topologies.values()) {
            topology.onDisconnect?.(remotePeer);
          }
        }
      }).catch((err) => {
        if (err.code === codes.ERR_NOT_FOUND) {
          return;
        }
        log$9.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
      });
    }
    _onConnect(evt) {
      const remotePeer = evt.detail;
      this.components.peerStore.get(remotePeer).then((peer) => {
        const connection = this.components.connectionManager.getConnections(peer.id)[0];
        if (connection == null) {
          log$9("peer %p connected but the connection manager did not have a connection", peer);
          return;
        }
        for (const protocol of peer.protocols) {
          const topologies = this.topologies.get(protocol);
          if (topologies == null) {
            continue;
          }
          for (const topology of topologies.values()) {
            topology.onConnect?.(remotePeer, connection);
          }
        }
      }).catch((err) => {
        if (err.code === codes.ERR_NOT_FOUND) {
          return;
        }
        log$9.error("could not inform topologies of connecting peer %p", remotePeer, err);
      });
    }
    _onPeerUpdate(evt) {
      const { peer, previous } = evt.detail;
      const removed = (previous?.protocols ?? []).filter((protocol) => !peer.protocols.includes(protocol));
      const added = peer.protocols.filter((protocol) => !(previous?.protocols ?? []).includes(protocol));
      for (const protocol of removed) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onDisconnect?.(peer.id);
        }
      }
      for (const protocol of added) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          const connection = this.components.connectionManager.getConnections(peer.id)[0];
          if (connection == null) {
            continue;
          }
          topology.onConnect?.(peer.id, connection);
        }
      }
    }
  }

  class TrackedMap extends Map {
    constructor(init2) {
      super();
      const { name: name2, metrics } = init2;
      this.metric = metrics.registerMetric(name2);
      this.updateComponentMetric();
    }
    set(key, value) {
      super.set(key, value);
      this.updateComponentMetric();
      return this;
    }
    delete(key) {
      const deleted = super.delete(key);
      this.updateComponentMetric();
      return deleted;
    }
    clear() {
      super.clear();
      this.updateComponentMetric();
    }
    updateComponentMetric() {
      this.metric.update(this.size);
    }
  }
  var log$8 = logger$2("libp2p:transports");

  class DefaultTransportManager {
    constructor(components, init2 = {}) {
      this.components = components;
      this.started = false;
      this.transports = new Map;
      this.listeners = trackedMap({
        name: "libp2p_transport_manager_listeners",
        metrics: this.components.metrics
      });
      this.faultTolerance = init2.faultTolerance ?? FaultTolerance.FATAL_ALL;
    }
    add(transport) {
      const tag = transport[Symbol.toStringTag];
      if (tag == null) {
        throw new CodeError$3("Transport must have a valid tag", codes.ERR_INVALID_KEY);
      }
      if (this.transports.has(tag)) {
        throw new CodeError$3(`There is already a transport with the tag ${tag}`, codes.ERR_DUPLICATE_TRANSPORT);
      }
      log$8("adding transport %s", tag);
      this.transports.set(tag, transport);
      if (!this.listeners.has(tag)) {
        this.listeners.set(tag, []);
      }
    }
    isStarted() {
      return this.started;
    }
    start() {
      this.started = true;
    }
    async afterStart() {
      const addrs = this.components.addressManager.getListenAddrs();
      await this.listen(addrs);
    }
    async stop() {
      const tasks = [];
      for (const [key, listeners] of this.listeners) {
        log$8("closing listeners for %s", key);
        while (listeners.length > 0) {
          const listener = listeners.pop();
          if (listener == null) {
            continue;
          }
          tasks.push(listener.close());
        }
      }
      await Promise.all(tasks);
      log$8("all listeners closed");
      for (const key of this.listeners.keys()) {
        this.listeners.set(key, []);
      }
      this.started = false;
    }
    async dial(ma, options) {
      const transport = this.transportForMultiaddr(ma);
      if (transport == null) {
        throw new CodeError$3(`No transport available for address ${String(ma)}`, codes.ERR_TRANSPORT_UNAVAILABLE);
      }
      try {
        return await transport.dial(ma, {
          ...options,
          upgrader: this.components.upgrader
        });
      } catch (err) {
        if (err.code == null) {
          err.code = codes.ERR_TRANSPORT_DIAL_FAILED;
        }
        throw err;
      }
    }
    getAddrs() {
      let addrs = [];
      for (const listeners of this.listeners.values()) {
        for (const listener of listeners) {
          addrs = [...addrs, ...listener.getAddrs()];
        }
      }
      return addrs;
    }
    getTransports() {
      return Array.of(...this.transports.values());
    }
    getListeners() {
      return Array.of(...this.listeners.values()).flat();
    }
    transportForMultiaddr(ma) {
      for (const transport of this.transports.values()) {
        const addrs = transport.filter([ma]);
        if (addrs.length > 0) {
          return transport;
        }
      }
    }
    async listen(addrs) {
      if (!this.isStarted()) {
        throw new CodeError$3("Not started", codes.ERR_NODE_NOT_STARTED);
      }
      if (addrs == null || addrs.length === 0) {
        log$8("no addresses were provided for listening, this node is dial only");
        return;
      }
      const couldNotListen = [];
      for (const [key, transport] of this.transports.entries()) {
        const supportedAddrs = transport.filter(addrs);
        const tasks = [];
        for (const addr of supportedAddrs) {
          log$8("creating listener for %s on %a", key, addr);
          const listener = transport.createListener({
            upgrader: this.components.upgrader
          });
          let listeners = this.listeners.get(key) ?? [];
          if (listeners == null) {
            listeners = [];
            this.listeners.set(key, listeners);
          }
          listeners.push(listener);
          listener.addEventListener("listening", () => {
            this.components.events.safeDispatchEvent("transport:listening", {
              detail: listener
            });
          });
          listener.addEventListener("close", () => {
            const index2 = listeners.findIndex((l) => l === listener);
            listeners.splice(index2, 1);
            this.components.events.safeDispatchEvent("transport:close", {
              detail: listener
            });
          });
          tasks.push(listener.listen(addr));
        }
        if (tasks.length === 0) {
          couldNotListen.push(key);
          continue;
        }
        const results = await Promise.allSettled(tasks);
        const isListening = results.find((r) => r.status === "fulfilled");
        if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
          throw new CodeError$3(`Transport (${key}) could not listen on any available address`, codes.ERR_NO_VALID_ADDRESSES);
        }
      }
      if (couldNotListen.length === this.transports.size) {
        const message2 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
        if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
          throw new CodeError$3(message2, codes.ERR_NO_VALID_ADDRESSES);
        }
        log$8(`libp2p in dial mode only: ${message2}`);
      }
    }
    async remove(key) {
      log$8("removing %s", key);
      for (const listener of this.listeners.get(key) ?? []) {
        await listener.close();
      }
      this.transports.delete(key);
      this.listeners.delete(key);
    }
    async removeAll() {
      const tasks = [];
      for (const key of this.transports.keys()) {
        tasks.push(this.remove(key));
      }
      await Promise.all(tasks);
    }
  }
  var PROTOCOL_ID = "/multistream/1.0.0";
  var MAX_PROTOCOL_LENGTH = 1024;
  var src = base;
  var _brrp__multiformats_scope_baseX = src;
  var coerce = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };

  class Encoder {
    constructor(name2, prefix, baseEncode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  }

  class Decoder {
    constructor(name2, prefix, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === undefined) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or(this, decoder);
    }
  }

  class ComposedDecoder {
    constructor(decoders2) {
      this.decoders = decoders2;
    }
    or(decoder) {
      return or(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  }
  var or = (left2, right2) => new ComposedDecoder({
    ...left2.decoders || { [left2.prefix]: left2 },
    ...right2.decoders || { [right2.prefix]: right2 }
  });

  class Codec {
    constructor(name2, prefix, baseEncode, baseDecode) {
      this.name = name2;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name2, prefix, baseEncode);
      this.decoder = new Decoder(name2, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  }
  var from = ({ name: name2, prefix, encode: encode3, decode: decode3 }) => new Codec(name2, prefix, encode3, decode3);
  var baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
    const { encode: encode3, decode: decode3 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
    return from({
      prefix,
      name: name2,
      encode: encode3,
      decode: (text) => coerce(decode3(text))
    });
  };
  var decode = (string2, alphabet2, bitsPerChar, name2) => {
    const codes2 = {};
    for (let i = 0;i < alphabet2.length; ++i) {
      codes2[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0;i < end; ++i) {
      const value = codes2[string2[i]];
      if (value === undefined) {
        throw new SyntaxError(`Non-${name2} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$1 = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i = 0;i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet2[mask & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from({
      prefix,
      name: name2,
      encode(input) {
        return encode$1(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode(input, alphabet2, bitsPerChar, name2);
      }
    });
  };
  var base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base64 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  debug.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc.baseEncode(v);
  };
  debug.formatters.t = (v) => {
    return v == null ? "undefined" : base32.baseEncode(v);
  };
  debug.formatters.m = (v) => {
    return v == null ? "undefined" : base64.baseEncode(v);
  };
  debug.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  debug.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  var log$7 = logger("libp2p:mss");
  var NewLine = fromString$3("\n");
  var log$6 = logger("libp2p:mss:select");
  var log$5 = logger("libp2p:mss:handle");
  var symbol = Symbol.for("@libp2p/connection");
  var log$4 = logger$2("libp2p:connection");
  var CLOSE_TIMEOUT = 500;

  class ConnectionImpl {
    constructor(init2) {
      this[_r] = "Connection";
      this[_t] = true;
      const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init2;
      this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
      this.remoteAddr = remoteAddr;
      this.remotePeer = remotePeer;
      this.direction = init2.direction;
      this.status = "open";
      this.timeline = init2.timeline;
      this.multiplexer = init2.multiplexer;
      this.encryption = init2.encryption;
      this.transient = init2.transient ?? false;
      this._newStream = newStream;
      this._close = close;
      this._abort = abort;
      this._getStreams = getStreams;
      this.tags = [];
    }
    get streams() {
      return this._getStreams();
    }
    async newStream(protocols, options) {
      if (this.status === "closing") {
        throw new CodeError$3("the connection is being closed", "ERR_CONNECTION_BEING_CLOSED");
      }
      if (this.status === "closed") {
        throw new CodeError$3("the connection is closed", "ERR_CONNECTION_CLOSED");
      }
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      if (this.transient && options?.runOnTransientConnection !== true) {
        throw new CodeError$3("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
      }
      const stream = await this._newStream(protocols, options);
      stream.direction = "outbound";
      return stream;
    }
    async close(options = {}) {
      if (this.status === "closed" || this.status === "closing") {
        return;
      }
      log$4("closing connection to %a", this.remoteAddr);
      this.status = "closing";
      options.signal = options?.signal ?? AbortSignal.timeout(CLOSE_TIMEOUT);
      try {
        eventsExports.setMaxListeners?.(Infinity, options.signal);
      } catch {
      }
      try {
        await Promise.all(this.streams.map(async (s2) => s2.close(options)));
        await this._close(options);
        this.timeline.close = Date.now();
        this.status = "closed";
      } catch (err) {
        log$4.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
        this.abort(err);
      }
    }
    abort(err) {
      log$4.error("aborting connection to %a due to error", this.remoteAddr, err);
      this.status = "closing";
      this.streams.forEach((s2) => {
        s2.abort(err);
      });
      log$4.error("all streams aborted", this.streams.length);
      this._abort(err);
      this.timeline.close = Date.now();
      this.status = "closed";
    }
  }
  _r = Symbol.toStringTag, _t = symbol;
  var log$3 = logger$2("libp2p:upgrader");

  class DefaultUpgrader {
    constructor(components, init2) {
      this.components = components;
      this.connectionEncryption = new Map;
      init2.connectionEncryption.forEach((encrypter) => {
        this.connectionEncryption.set(encrypter.protocol, encrypter);
      });
      this.muxers = new Map;
      init2.muxers.forEach((muxer) => {
        this.muxers.set(muxer.protocol, muxer);
      });
      this.inboundUpgradeTimeout = init2.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
      this.events = components.events;
    }
    async shouldBlockConnection(remotePeer, maConn, connectionType) {
      const connectionGater2 = this.components.connectionGater[connectionType];
      if (connectionGater2 !== undefined) {
        if (await connectionGater2(remotePeer, maConn)) {
          throw new CodeError$3(`The multiaddr connection is blocked by gater.${connectionType}`, codes.ERR_CONNECTION_INTERCEPTED);
        }
      }
    }
    async upgradeInbound(maConn, opts) {
      const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);
      if (!accept) {
        throw new CodeError$3("connection denied", codes.ERR_CONNECTION_DENIED);
      }
      let encryptedConn;
      let remotePeer;
      let upgradedConn;
      let muxerFactory;
      let cryptoProtocol;
      const signal = AbortSignal.timeout(this.inboundUpgradeTimeout);
      const onAbort = () => {
        maConn.abort(new CodeError$3("inbound upgrade timeout", codes.ERR_TIMEOUT));
      };
      signal.addEventListener("abort", onAbort, { once: true });
      try {
        eventsExports.setMaxListeners?.(Infinity, signal);
      } catch {
      }
      try {
        if (await this.components.connectionGater.denyInboundConnection?.(maConn) === true) {
          throw new CodeError$3("The multiaddr connection is blocked by gater.acceptConnection", codes.ERR_CONNECTION_INTERCEPTED);
        }
        this.components.metrics?.trackMultiaddrConnection(maConn);
        log$3("starting the inbound connection upgrade");
        let protectedConn = maConn;
        if (opts?.skipProtection !== true) {
          const protector = this.components.connectionProtector;
          if (protector != null) {
            log$3("protecting the inbound connection");
            protectedConn = await protector.protect(maConn);
          }
        }
        try {
          encryptedConn = protectedConn;
          if (opts?.skipEncryption !== true) {
            ({
              conn: encryptedConn,
              remotePeer,
              protocol: cryptoProtocol
            } = await this._encryptInbound(protectedConn));
            const maConn2 = {
              ...protectedConn,
              ...encryptedConn
            };
            await this.shouldBlockConnection(remotePeer, maConn2, "denyInboundEncryptedConnection");
          } else {
            const idStr = maConn.remoteAddr.getPeerId();
            if (idStr == null) {
              throw new CodeError$3("inbound connection that skipped encryption must have a peer id", codes.ERR_INVALID_MULTIADDR);
            }
            const remotePeerId = peerIdFromString(idStr);
            cryptoProtocol = "native";
            remotePeer = remotePeerId;
          }
          upgradedConn = encryptedConn;
          if (opts?.muxerFactory != null) {
            muxerFactory = opts.muxerFactory;
          } else if (this.muxers.size > 0) {
            const multiplexed = await this._multiplexInbound({
              ...protectedConn,
              ...encryptedConn
            }, this.muxers);
            muxerFactory = multiplexed.muxerFactory;
            upgradedConn = multiplexed.stream;
          }
        } catch (err) {
          log$3.error("Failed to upgrade inbound connection", err);
          throw err;
        }
        await this.shouldBlockConnection(remotePeer, maConn, "denyInboundUpgradedConnection");
        log$3("Successfully upgraded inbound connection");
        return this._createConnection({
          cryptoProtocol,
          direction: "inbound",
          maConn,
          upgradedConn,
          muxerFactory,
          remotePeer,
          transient: opts?.transient
        });
      } finally {
        signal.removeEventListener("abort", onAbort);
        this.components.connectionManager.afterUpgradeInbound();
      }
    }
    async upgradeOutbound(maConn, opts) {
      const idStr = maConn.remoteAddr.getPeerId();
      let remotePeerId;
      if (idStr != null) {
        remotePeerId = peerIdFromString(idStr);
        await this.shouldBlockConnection(remotePeerId, maConn, "denyOutboundConnection");
      }
      let encryptedConn;
      let remotePeer;
      let upgradedConn;
      let cryptoProtocol;
      let muxerFactory;
      this.components.metrics?.trackMultiaddrConnection(maConn);
      log$3("Starting the outbound connection upgrade");
      let protectedConn = maConn;
      if (opts?.skipProtection !== true) {
        const protector = this.components.connectionProtector;
        if (protector != null) {
          protectedConn = await protector.protect(maConn);
        }
      }
      try {
        encryptedConn = protectedConn;
        if (opts?.skipEncryption !== true) {
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptOutbound(protectedConn, remotePeerId));
          const maConn2 = {
            ...protectedConn,
            ...encryptedConn
          };
          await this.shouldBlockConnection(remotePeer, maConn2, "denyOutboundEncryptedConnection");
        } else {
          if (remotePeerId == null) {
            throw new CodeError$3("Encryption was skipped but no peer id was passed", codes.ERR_INVALID_PEER);
          }
          cryptoProtocol = "native";
          remotePeer = remotePeerId;
        }
        upgradedConn = encryptedConn;
        if (opts?.muxerFactory != null) {
          muxerFactory = opts.muxerFactory;
        } else if (this.muxers.size > 0) {
          const multiplexed = await this._multiplexOutbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        }
      } catch (err) {
        log$3.error("Failed to upgrade outbound connection", err);
        await maConn.close(err);
        throw err;
      }
      await this.shouldBlockConnection(remotePeer, maConn, "denyOutboundUpgradedConnection");
      log$3("Successfully upgraded outbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "outbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer,
        transient: opts?.transient
      });
    }
    _createConnection(opts) {
      const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, transient } = opts;
      let muxer;
      let newStream;
      let connection;
      if (muxerFactory != null) {
        muxer = muxerFactory.createStreamMuxer({
          direction,
          onIncomingStream: (muxedStream) => {
            if (connection == null) {
              return;
            }
            Promise.resolve().then(async () => {
              const protocols = this.components.registrar.getProtocols();
              const { stream, protocol } = await handle(muxedStream, protocols);
              log$3("%s: incoming stream opened on %s", direction, protocol);
              if (connection == null) {
                return;
              }
              const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
              const streamCount = countStreams(protocol, "inbound", connection);
              if (streamCount === incomingLimit) {
                const err = new CodeError$3(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`, codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);
                muxedStream.abort(err);
                throw err;
              }
              muxedStream.source = stream.source;
              muxedStream.sink = stream.sink;
              muxedStream.protocol = protocol;
              await this.components.peerStore.merge(remotePeer, {
                protocols: [protocol]
              });
              this.components.metrics?.trackProtocolStream(muxedStream, connection);
              this._onStream({ connection, stream: muxedStream, protocol });
            }).catch(async (err) => {
              log$3.error(err);
              if (muxedStream.timeline.close == null) {
                await muxedStream.close();
              }
            });
          }
        });
        newStream = async (protocols, options = {}) => {
          if (muxer == null) {
            throw new CodeError$3("Stream is not multiplexed", codes.ERR_MUXER_UNAVAILABLE);
          }
          log$3("%s: starting new stream on %s", direction, protocols);
          const muxedStream = await muxer.newStream();
          try {
            if (options.signal == null) {
              log$3("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
              options.signal = AbortSignal.timeout(30000);
              try {
                eventsExports.setMaxListeners?.(Infinity, options.signal);
              } catch {
              }
            }
            const { stream, protocol } = await select(muxedStream, protocols, options);
            const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
            const streamCount = countStreams(protocol, "outbound", connection);
            if (streamCount >= outgoingLimit) {
              const err = new CodeError$3(`Too many outbound protocol streams for protocol "${protocol}" - limit ${outgoingLimit}`, codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
              muxedStream.abort(err);
              throw err;
            }
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            });
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            this.components.metrics?.trackProtocolStream(muxedStream, connection);
            return muxedStream;
          } catch (err) {
            log$3.error("could not create new stream", err);
            if (muxedStream.timeline.close == null) {
              muxedStream.abort(err);
            }
            if (err.code != null) {
              throw err;
            }
            throw new CodeError$3(String(err), codes.ERR_UNSUPPORTED_PROTOCOL);
          }
        };
        Promise.all([
          muxer.sink(upgradedConn.source),
          upgradedConn.sink(muxer.source)
        ]).catch((err) => {
          log$3.error(err);
        });
      }
      const _timeline = maConn.timeline;
      maConn.timeline = new Proxy(_timeline, {
        set: (...args) => {
          if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
            (async () => {
              try {
                if (connection.status === "open") {
                  await connection.close();
                }
              } catch (err) {
                log$3.error(err);
              } finally {
                this.events.safeDispatchEvent("connection:close", {
                  detail: connection
                });
              }
            })().catch((err) => {
              log$3.error(err);
            });
          }
          return Reflect.set(...args);
        }
      });
      maConn.timeline.upgraded = Date.now();
      const errConnectionNotMultiplexed = () => {
        throw new CodeError$3("connection is not multiplexed", codes.ERR_CONNECTION_NOT_MULTIPLEXED);
      };
      connection = createConnection({
        remoteAddr: maConn.remoteAddr,
        remotePeer,
        status: "open",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer?.protocol,
        encryption: cryptoProtocol,
        transient,
        newStream: newStream ?? errConnectionNotMultiplexed,
        getStreams: () => {
          if (muxer != null) {
            return muxer.streams;
          } else {
            return [];
          }
        },
        close: async (options) => {
          await maConn.close(options);
          if (muxer != null) {
            await muxer.close(options);
          }
        },
        abort: (err) => {
          maConn.abort(err);
          if (muxer != null) {
            muxer.abort(err);
          }
        }
      });
      this.events.safeDispatchEvent("connection:open", {
        detail: connection
      });
      return connection;
    }
    _onStream(opts) {
      const { connection, stream, protocol } = opts;
      const { handler, options } = this.components.registrar.getHandler(protocol);
      if (connection.transient && options.runOnTransientConnection !== true) {
        throw new CodeError$3("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
      }
      handler({ connection, stream });
    }
    async _encryptInbound(connection) {
      const protocols = Array.from(this.connectionEncryption.keys());
      log$3("handling inbound crypto protocol selection", protocols);
      try {
        const { stream, protocol } = await handle(connection, protocols, {
          writeBytes: true
        });
        const encrypter = this.connectionEncryption.get(protocol);
        if (encrypter == null) {
          throw new Error(`no crypto module found for ${protocol}`);
        }
        log$3("encrypting inbound connection...");
        return {
          ...await encrypter.secureInbound(this.components.peerId, stream),
          protocol
        };
      } catch (err) {
        throw new CodeError$3(String(err), codes.ERR_ENCRYPTION_FAILED);
      }
    }
    async _encryptOutbound(connection, remotePeerId) {
      const protocols = Array.from(this.connectionEncryption.keys());
      log$3("selecting outbound crypto protocol", protocols);
      try {
        const { stream, protocol } = await select(connection, protocols, {
          writeBytes: true
        });
        const encrypter = this.connectionEncryption.get(protocol);
        if (encrypter == null) {
          throw new Error(`no crypto module found for ${protocol}`);
        }
        log$3("encrypting outbound connection to %p", remotePeerId);
        return {
          ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),
          protocol
        };
      } catch (err) {
        throw new CodeError$3(String(err), codes.ERR_ENCRYPTION_FAILED);
      }
    }
    async _multiplexOutbound(connection, muxers) {
      const protocols = Array.from(muxers.keys());
      log$3("outbound selecting muxer %s", protocols);
      try {
        const { stream, protocol } = await select(connection, protocols, {
          writeBytes: true
        });
        log$3("%s selected as muxer protocol", protocol);
        const muxerFactory = muxers.get(protocol);
        return { stream, muxerFactory };
      } catch (err) {
        log$3.error("error multiplexing outbound stream", err);
        throw new CodeError$3(String(err), codes.ERR_MUXER_UNAVAILABLE);
      }
    }
    async _multiplexInbound(connection, muxers) {
      const protocols = Array.from(muxers.keys());
      log$3("inbound handling muxers %s", protocols);
      try {
        const { stream, protocol } = await handle(connection, protocols, {
          writeBytes: true
        });
        const muxerFactory = muxers.get(protocol);
        return { stream, muxerFactory };
      } catch (err) {
        log$3.error("error multiplexing inbound stream", err);
        throw new CodeError$3(String(err), codes.ERR_MUXER_UNAVAILABLE);
      }
    }
  }
  var log$2 = logger$2("libp2p");

  class Libp2pNode extends EventEmitter$2 {
    constructor(init2) {
      super();
      _Libp2pNode_instances.add(this);
      _Libp2pNode_started.set(this, undefined);
      const events2 = new EventEmitter$2;
      const originalDispatch = events2.dispatchEvent.bind(events2);
      events2.dispatchEvent = (evt) => {
        const internalResult = originalDispatch(evt);
        const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
        return internalResult || externalResult;
      };
      try {
        eventsExports.setMaxListeners?.(Infinity, events2);
      } catch {
      }
      __classPrivateFieldSet2(this, _Libp2pNode_started, false, "f");
      this.peerId = init2.peerId;
      this.services = {};
      const components = this.components = defaultComponents({
        peerId: init2.peerId,
        events: events2,
        datastore: init2.datastore ?? new MemoryDatastore,
        connectionGater: connectionGater(init2.connectionGater)
      });
      this.peerStore = this.configureComponent("peerStore", new PersistentPeerStore(components, {
        addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
        ...init2.peerStore
      }));
      if (init2.metrics != null) {
        this.metrics = this.configureComponent("metrics", init2.metrics(this.components));
      }
      components.events.addEventListener("peer:update", (evt) => {
        if (evt.detail.previous == null) {
          const peerInfo = {
            id: evt.detail.peer.id,
            multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr),
            protocols: evt.detail.peer.protocols
          };
          components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
        }
      });
      if (init2.connectionProtector != null) {
        this.configureComponent("connectionProtector", init2.connectionProtector(components));
      }
      this.components.upgrader = new DefaultUpgrader(this.components, {
        connectionEncryption: (init2.connectionEncryption ?? []).map((fn, index2) => this.configureComponent(`connection-encryption-${index2}`, fn(this.components))),
        muxers: (init2.streamMuxers ?? []).map((fn, index2) => this.configureComponent(`stream-muxers-${index2}`, fn(this.components))),
        inboundUpgradeTimeout: init2.connectionManager.inboundUpgradeTimeout
      });
      this.configureComponent("transportManager", new DefaultTransportManager(this.components, init2.transportManager));
      this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init2.connectionManager));
      this.configureComponent("registrar", new DefaultRegistrar(this.components));
      this.configureComponent("addressManager", new DefaultAddressManager(this.components, init2.addresses));
      const keychainOpts = DefaultKeyChain.generateOptions();
      this.keychain = this.configureComponent("keyChain", new DefaultKeyChain(this.components, {
        ...keychainOpts,
        ...init2.keychain
      }));
      const peerRouters = (init2.peerRouters ?? []).map((fn, index2) => this.configureComponent(`peer-router-${index2}`, fn(this.components)));
      this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
        routers: peerRouters
      }));
      const contentRouters = (init2.contentRouters ?? []).map((fn, index2) => this.configureComponent(`content-router-${index2}`, fn(this.components)));
      this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
        routers: contentRouters
      }));
      (init2.peerDiscovery ?? []).forEach((fn, index2) => {
        const service2 = this.configureComponent(`peer-discovery-${index2}`, fn(this.components));
        service2.addEventListener("peer", (evt) => {
          __classPrivateFieldGet2(this, _Libp2pNode_instances, "m", _Libp2pNode_onDiscoveryPeer).call(this, evt);
        });
      });
      init2.transports.forEach((fn, index2) => {
        this.components.transportManager.add(this.configureComponent(`transport-${index2}`, fn(this.components)));
      });
      if (init2.services != null) {
        for (const name2 of Object.keys(init2.services)) {
          const createService = init2.services[name2];
          const service2 = createService(this.components);
          if (service2 == null) {
            log$2.error("service factory %s returned null or undefined instance", name2);
            continue;
          }
          this.services[name2] = service2;
          this.configureComponent(name2, service2);
          if (service2[contentRouting] != null) {
            log$2("registering service %s for content routing", name2);
            contentRouters.push(service2[contentRouting]);
          }
          if (service2[peerRouting] != null) {
            log$2("registering service %s for peer routing", name2);
            peerRouters.push(service2[peerRouting]);
          }
          if (service2[peerDiscovery] != null) {
            log$2("registering service %s for peer discovery", name2);
            service2[peerDiscovery].addEventListener("peer", (evt) => {
              __classPrivateFieldGet2(this, _Libp2pNode_instances, "m", _Libp2pNode_onDiscoveryPeer).call(this, evt);
            });
          }
        }
      }
    }
    configureComponent(name2, component) {
      if (component == null) {
        log$2.error("component %s was null or undefined", name2);
      }
      this.components[name2] = component;
      return component;
    }
    async start() {
      if (__classPrivateFieldGet2(this, _Libp2pNode_started, "f")) {
        return;
      }
      __classPrivateFieldSet2(this, _Libp2pNode_started, true, "f");
      log$2("libp2p is starting");
      const keys = await this.keychain.listKeys();
      if (keys.find((key) => key.name === "self") == null) {
        log$2("importing self key into keychain");
        await this.keychain.importPeer("self", this.components.peerId);
      }
      try {
        await this.components.beforeStart?.();
        await this.components.start();
        await this.components.afterStart?.();
        this.safeDispatchEvent("start", { detail: this });
        log$2("libp2p has started");
      } catch (err) {
        log$2.error("An error occurred starting libp2p", err);
        await this.stop();
        throw err;
      }
    }
    async stop() {
      if (!__classPrivateFieldGet2(this, _Libp2pNode_started, "f")) {
        return;
      }
      log$2("libp2p is stopping");
      __classPrivateFieldSet2(this, _Libp2pNode_started, false, "f");
      await this.components.beforeStop?.();
      await this.components.stop();
      await this.components.afterStop?.();
      this.safeDispatchEvent("stop", { detail: this });
      log$2("libp2p has stopped");
    }
    isStarted() {
      return __classPrivateFieldGet2(this, _Libp2pNode_started, "f");
    }
    getConnections(peerId) {
      return this.components.connectionManager.getConnections(peerId);
    }
    getDialQueue() {
      return this.components.connectionManager.getDialQueue();
    }
    getPeers() {
      const peerSet = new PeerSet;
      for (const conn of this.components.connectionManager.getConnections()) {
        peerSet.add(conn.remotePeer);
      }
      return Array.from(peerSet);
    }
    async dial(peer, options = {}) {
      return this.components.connectionManager.openConnection(peer, options);
    }
    async dialProtocol(peer, protocols, options = {}) {
      if (protocols == null) {
        throw new CodeError$3("no protocols were provided to open a stream", codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
      }
      protocols = Array.isArray(protocols) ? protocols : [protocols];
      if (protocols.length === 0) {
        throw new CodeError$3("no protocols were provided to open a stream", codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
      }
      const connection = await this.dial(peer, options);
      return connection.newStream(protocols, options);
    }
    getMultiaddrs() {
      return this.components.addressManager.getAddresses();
    }
    getProtocols() {
      return this.components.registrar.getProtocols();
    }
    async hangUp(peer, options = {}) {
      if (isMultiaddr$1(peer)) {
        peer = peerIdFromString(peer.getPeerId() ?? "");
      }
      await this.components.connectionManager.closeConnections(peer, options);
    }
    async getPublicKey(peer, options = {}) {
      log$2("getPublicKey %p", peer);
      if (peer.publicKey != null) {
        return peer.publicKey;
      }
      const peerInfo = await this.peerStore.get(peer);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
      const peerKey = concat$1([
        fromString$3("/pk/"),
        peer.multihash.digest
      ]);
      const bytes2 = await this.contentRouting.get(peerKey, options);
      unmarshalPublicKey$1(bytes2);
      await this.peerStore.patch(peer, {
        publicKey: bytes2
      });
      return bytes2;
    }
    async handle(protocols, handler, options) {
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      await Promise.all(protocols.map(async (protocol) => {
        await this.components.registrar.handle(protocol, handler, options);
      }));
    }
    async unhandle(protocols) {
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      await Promise.all(protocols.map(async (protocol) => {
        await this.components.registrar.unhandle(protocol);
      }));
    }
    async register(protocol, topology) {
      return this.components.registrar.register(protocol, topology);
    }
    unregister(id) {
      this.components.registrar.unregister(id);
    }
  }
  _Libp2pNode_started = new WeakMap, _Libp2pNode_instances = new WeakSet, _Libp2pNode_onDiscoveryPeer = function _Libp2pNode_onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      log$2.error(new Error(codes.ERR_DISCOVERED_SELF));
      return;
    }
    this.components.peerStore.merge(peer.id, {
      multiaddrs: peer.multiaddrs,
      protocols: peer.protocols
    }).catch((err) => {
      log$2.error(err);
    });
  };
  var version = "0.46.9";
  var AGENT_VERSION = `js-libp2p/${version}`;
  var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
  var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
  var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
  var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
  var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
  var Identify;
  (function(Identify2) {
    let _codec;
    Identify2.codec = () => {
      if (_codec == null) {
        _codec = message$1((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.protocolVersion != null) {
            w.uint32(42);
            w.string(obj.protocolVersion);
          }
          if (obj.agentVersion != null) {
            w.uint32(50);
            w.string(obj.agentVersion);
          }
          if (obj.publicKey != null) {
            w.uint32(10);
            w.bytes(obj.publicKey);
          }
          if (obj.listenAddrs != null) {
            for (const value of obj.listenAddrs) {
              w.uint32(18);
              w.bytes(value);
            }
          }
          if (obj.observedAddr != null) {
            w.uint32(34);
            w.bytes(obj.observedAddr);
          }
          if (obj.protocols != null) {
            for (const value of obj.protocols) {
              w.uint32(26);
              w.string(value);
            }
          }
          if (obj.signedPeerRecord != null) {
            w.uint32(66);
            w.bytes(obj.signedPeerRecord);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length2) => {
          const obj = {
            listenAddrs: [],
            protocols: []
          };
          const end = length2 == null ? reader2.len : reader2.pos + length2;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 5:
                obj.protocolVersion = reader2.string();
                break;
              case 6:
                obj.agentVersion = reader2.string();
                break;
              case 1:
                obj.publicKey = reader2.bytes();
                break;
              case 2:
                obj.listenAddrs.push(reader2.bytes());
                break;
              case 4:
                obj.observedAddr = reader2.bytes();
                break;
              case 3:
                obj.protocols.push(reader2.string());
                break;
              case 8:
                obj.signedPeerRecord = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Identify2.encode = (obj) => {
      return encodeMessage(obj, Identify2.codec());
    };
    Identify2.decode = (buf) => {
      return decodeMessage$1(buf, Identify2.codec());
    };
  })(Identify || (Identify = {}));
  var log$1 = logger$2("libp2p:identify");
  var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
  var defaultValues = {
    protocolPrefix: "ipfs",
    agentVersion: AGENT_VERSION,
    timeout: 60000,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxPushIncomingStreams: 1,
    maxPushOutgoingStreams: 1,
    maxObservedAddresses: 10,
    maxIdentifyMessageSize: 8192,
    runOnConnectionOpen: true,
    runOnTransientConnection: true
  };

  class DefaultIdentifyService {
    constructor(components, init2) {
      _DefaultIdentifyService_instances.add(this);
      this.started = false;
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.registrar = components.registrar;
      this.addressManager = components.addressManager;
      this.connectionManager = components.connectionManager;
      this.events = components.events;
      this.identifyProtocolStr = `/${init2.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
      this.identifyPushProtocolStr = `/${init2.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
      this.timeout = init2.timeout ?? defaultValues.timeout;
      this.maxInboundStreams = init2.maxInboundStreams ?? defaultValues.maxInboundStreams;
      this.maxOutboundStreams = init2.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
      this.maxPushIncomingStreams = init2.maxPushIncomingStreams ?? defaultValues.maxPushIncomingStreams;
      this.maxPushOutgoingStreams = init2.maxPushOutgoingStreams ?? defaultValues.maxPushOutgoingStreams;
      this.maxIdentifyMessageSize = init2.maxIdentifyMessageSize ?? defaultValues.maxIdentifyMessageSize;
      this.maxObservedAddresses = init2.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
      this.runOnTransientConnection = init2.runOnTransientConnection ?? defaultValues.runOnTransientConnection;
      this.host = {
        protocolVersion: `${init2.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
        agentVersion: init2.agentVersion ?? defaultValues.agentVersion
      };
      if (init2.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {
        components.events.addEventListener("connection:open", (evt) => {
          const connection = evt.detail;
          this.identify(connection).catch((err) => {
            log$1.error("error during identify trigged by connection:open", err);
          });
        });
      }
      components.events.addEventListener("self:peer:update", (evt) => {
        this.push().catch((err) => {
          log$1.error(err);
        });
      });
      if (this.host.agentVersion === AGENT_VERSION) {
        if (isNode || isElectronMain) {
          this.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
        } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
          this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
        }
      }
    }
    isStarted() {
      return this.started;
    }
    async start() {
      if (this.started) {
        return;
      }
      await this.peerStore.merge(this.peerId, {
        metadata: {
          AgentVersion: fromString$3(this.host.agentVersion),
          ProtocolVersion: fromString$3(this.host.protocolVersion)
        }
      });
      await this.registrar.handle(this.identifyProtocolStr, (data) => {
        this._handleIdentify(data).catch((err) => {
          log$1.error(err);
        });
      }, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnTransientConnection: this.runOnTransientConnection
      });
      await this.registrar.handle(this.identifyPushProtocolStr, (data) => {
        this._handlePush(data).catch((err) => {
          log$1.error(err);
        });
      }, {
        maxInboundStreams: this.maxPushIncomingStreams,
        maxOutboundStreams: this.maxPushOutgoingStreams,
        runOnTransientConnection: this.runOnTransientConnection
      });
      this.started = true;
    }
    async stop() {
      await this.registrar.unhandle(this.identifyProtocolStr);
      await this.registrar.unhandle(this.identifyPushProtocolStr);
      this.started = false;
    }
    async pushToConnections(connections) {
      const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol$1("p2p").code));
      const peerRecord = new PeerRecord({
        peerId: this.peerId,
        multiaddrs: listenAddresses
      });
      const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId);
      const supportedProtocols2 = this.registrar.getProtocols();
      const peer = await this.peerStore.get(this.peerId);
      const agentVersion = toString$9(peer.metadata.get("AgentVersion") ?? fromString$3(this.host.agentVersion));
      const protocolVersion = toString$9(peer.metadata.get("ProtocolVersion") ?? fromString$3(this.host.protocolVersion));
      const pushes = connections.map(async (connection) => {
        let stream;
        const signal = AbortSignal.timeout(this.timeout);
        try {
          eventsExports.setMaxListeners?.(Infinity, signal);
        } catch {
        }
        try {
          stream = await connection.newStream([this.identifyPushProtocolStr], {
            signal,
            runOnTransientConnection: this.runOnTransientConnection
          });
          const pb = pbStream(stream, {
            maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
          }).pb(Identify);
          await pb.write({
            listenAddrs: listenAddresses.map((ma) => ma.bytes),
            signedPeerRecord: signedPeerRecord.marshal(),
            protocols: supportedProtocols2,
            agentVersion,
            protocolVersion
          }, {
            signal
          });
          await stream.close({
            signal
          });
        } catch (err) {
          log$1.error("could not push identify update to peer", err);
          stream?.abort(err);
        }
      });
      await Promise.all(pushes);
    }
    async push() {
      if (!this.isStarted()) {
        return;
      }
      const connections = [];
      await Promise.all(this.connectionManager.getConnections().map(async (conn) => {
        try {
          const peer = await this.peerStore.get(conn.remotePeer);
          if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
            return;
          }
          connections.push(conn);
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        }
      }));
      await this.pushToConnections(connections);
    }
    async _identify(connection, options = {}) {
      let stream;
      options.signal = options.signal ?? AbortSignal.timeout(this.timeout);
      try {
        stream = await connection.newStream([this.identifyProtocolStr], {
          ...options,
          runOnTransientConnection: this.runOnTransientConnection
        });
        const pb = pbStream(stream, {
          maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
        }).pb(Identify);
        const message2 = await pb.read(options);
        await stream.close(options);
        return message2;
      } catch (err) {
        log$1.error("error while reading identify message", err);
        stream?.abort(err);
        throw err;
      }
    }
    async identify(connection, options = {}) {
      const message2 = await this._identify(connection, options);
      const { publicKey, protocols, observedAddr } = message2;
      if (publicKey == null) {
        throw new CodeError$3("public key was missing from identify message", codes.ERR_MISSING_PUBLIC_KEY);
      }
      const id = await peerIdFromKeys(publicKey);
      if (!connection.remotePeer.equals(id)) {
        throw new CodeError$3("identified peer does not match the expected peer", codes.ERR_INVALID_PEER);
      }
      if (this.peerId.equals(id)) {
        throw new CodeError$3("identified peer is our own peer id?", codes.ERR_INVALID_PEER);
      }
      const cleanObservedAddr = getCleanMultiaddr(observedAddr);
      log$1("identify completed for peer %p and protocols %o", id, protocols);
      log$1("our observed address is %a", cleanObservedAddr);
      if (cleanObservedAddr != null && this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {
        log$1("storing our observed address %a", cleanObservedAddr);
        this.addressManager.addObservedAddr(cleanObservedAddr);
      }
      const signedPeerRecord = await __classPrivateFieldGet2(this, _DefaultIdentifyService_instances, "m", _DefaultIdentifyService_consumeIdentifyMessage).call(this, connection.remotePeer, message2);
      const result = {
        peerId: id,
        protocolVersion: message2.protocolVersion,
        agentVersion: message2.agentVersion,
        publicKey: message2.publicKey,
        listenAddrs: message2.listenAddrs.map((buf) => multiaddr$1(buf)),
        observedAddr: message2.observedAddr == null ? undefined : multiaddr$1(message2.observedAddr),
        protocols: message2.protocols,
        signedPeerRecord
      };
      this.events.safeDispatchEvent("peer:identify", { detail: result });
      return result;
    }
    async _handleIdentify(data) {
      const { connection, stream } = data;
      const signal = AbortSignal.timeout(this.timeout);
      try {
        eventsExports.setMaxListeners?.(Infinity, signal);
      } catch {
      }
      try {
        const publicKey = this.peerId.publicKey ?? new Uint8Array(0);
        const peerData = await this.peerStore.get(this.peerId);
        const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol$1("p2p").code));
        let signedPeerRecord = peerData.peerRecordEnvelope;
        if (multiaddrs.length > 0 && signedPeerRecord == null) {
          const peerRecord = new PeerRecord({
            peerId: this.peerId,
            multiaddrs
          });
          const envelope = await RecordEnvelope.seal(peerRecord, this.peerId);
          signedPeerRecord = envelope.marshal().subarray();
        }
        const pb = pbStream(stream).pb(Identify);
        await pb.write({
          protocolVersion: this.host.protocolVersion,
          agentVersion: this.host.agentVersion,
          publicKey,
          listenAddrs: multiaddrs.map((addr) => addr.bytes),
          signedPeerRecord,
          observedAddr: connection.remoteAddr.bytes,
          protocols: peerData.protocols
        }, {
          signal
        });
        await stream.close({
          signal
        });
      } catch (err) {
        log$1.error("could not respond to identify request", err);
        stream.abort(err);
      }
    }
    async _handlePush(data) {
      const { connection, stream } = data;
      try {
        if (this.peerId.equals(connection.remotePeer)) {
          throw new Error("received push from ourselves?");
        }
        const options = {
          signal: AbortSignal.timeout(this.timeout)
        };
        const pb = pbStream(stream, {
          maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
        }).pb(Identify);
        const message2 = await pb.read(options);
        await stream.close(options);
        await __classPrivateFieldGet2(this, _DefaultIdentifyService_instances, "m", _DefaultIdentifyService_consumeIdentifyMessage).call(this, connection.remotePeer, message2);
      } catch (err) {
        log$1.error("received invalid message", err);
        stream.abort(err);
        return;
      }
      log$1("handled push from %p", connection.remotePeer);
    }
  }
  _DefaultIdentifyService_instances = new WeakSet, _DefaultIdentifyService_consumeIdentifyMessage = async function _DefaultIdentifyService_consumeIdentifyMessage(remotePeer, message2) {
    log$1("received identify from %p", remotePeer);
    if (message2 == null) {
      throw new Error("Message was null or undefined");
    }
    const peer = {
      addresses: message2.listenAddrs.map((buf) => ({
        isCertified: false,
        multiaddr: multiaddr$1(buf)
      })),
      protocols: message2.protocols,
      metadata: new Map,
      peerRecordEnvelope: message2.signedPeerRecord
    };
    let output2;
    if (message2.signedPeerRecord != null) {
      log$1("received signedPeerRecord in push from %p", remotePeer);
      let peerRecordEnvelope = message2.signedPeerRecord;
      const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN);
      let peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
      if (!peerRecord.peerId.equals(envelope.peerId)) {
        throw new Error("signing key does not match PeerId in the PeerRecord");
      }
      if (!remotePeer.equals(peerRecord.peerId)) {
        throw new Error("signing key does not match remote PeerId");
      }
      let existingPeer;
      try {
        existingPeer = await this.peerStore.get(peerRecord.peerId);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      if (existingPeer != null) {
        peer.metadata = existingPeer.metadata;
        if (existingPeer.peerRecordEnvelope != null) {
          const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log$1("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            peerRecord = storedRecord;
            peerRecordEnvelope = existingPeer.peerRecordEnvelope;
          }
        }
      }
      peer.peerRecordEnvelope = peerRecordEnvelope;
      peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }));
      output2 = {
        seq: peerRecord.seqNumber,
        addresses: peerRecord.multiaddrs
      };
    } else {
      log$1("%p did not send a signed peer record", remotePeer);
    }
    if (message2.agentVersion != null) {
      peer.metadata.set("AgentVersion", fromString$3(message2.agentVersion));
    }
    if (message2.protocolVersion != null) {
      peer.metadata.set("ProtocolVersion", fromString$3(message2.protocolVersion));
    }
    await this.peerStore.patch(remotePeer, peer);
    return output2;
  };
  var PING_LENGTH = 32;
  var PROTOCOL_VERSION = "1.0.0";
  var PROTOCOL_NAME = "ping";
  var PROTOCOL_PREFIX = "ipfs";
  var TIMEOUT = 1e4;
  var MAX_INBOUND_STREAMS = 2;
  var MAX_OUTBOUND_STREAMS = 1;
  var log = logger$2("libp2p:ping");

  class DefaultPingService {
    constructor(components, init2) {
      this.components = components;
      this.started = false;
      this.protocol = `/${init2.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
      this.timeout = init2.timeout ?? TIMEOUT;
      this.maxInboundStreams = init2.maxInboundStreams ?? MAX_INBOUND_STREAMS;
      this.maxOutboundStreams = init2.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
      this.runOnTransientConnection = init2.runOnTransientConnection ?? true;
    }
    async start() {
      await this.components.registrar.handle(this.protocol, this.handleMessage, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnTransientConnection: this.runOnTransientConnection
      });
      this.started = true;
    }
    async stop() {
      await this.components.registrar.unhandle(this.protocol);
      this.started = false;
    }
    isStarted() {
      return this.started;
    }
    handleMessage(data) {
      log("incoming ping from %p", data.connection.remotePeer);
      const { stream } = data;
      const start = Date.now();
      pipe(stream, stream).catch((err) => {
        log.error("incoming ping from %p failed with error", data.connection.remotePeer, err);
      }).finally(() => {
        const ms2 = Date.now() - start;
        log("incoming ping from %p complete in %dms", data.connection.remotePeer, ms2);
      });
    }
    async ping(peer, options = {}) {
      log("pinging %p", peer);
      const start = Date.now();
      const data = randomBytes$3(PING_LENGTH);
      const connection = await this.components.connectionManager.openConnection(peer, options);
      let stream;
      let onAbort = () => {
      };
      options.signal = options.signal ?? AbortSignal.timeout(this.timeout);
      try {
        stream = await connection.newStream(this.protocol, {
          ...options,
          runOnTransientConnection: this.runOnTransientConnection
        });
        onAbort = () => {
          stream?.abort(new CodeError$3("ping timeout", codes.ERR_TIMEOUT));
        };
        options.signal.addEventListener("abort", onAbort, { once: true });
        const result = await pipe([data], stream, async (source2) => first(source2));
        const ms2 = Date.now() - start;
        if (result == null) {
          throw new CodeError$3(`Did not receive a ping ack after ${ms2}ms`, codes.ERR_WRONG_PING_ACK);
        }
        if (!equals$4(data, result.subarray())) {
          throw new CodeError$3(`Received wrong ping ack after ${ms2}ms`, codes.ERR_WRONG_PING_ACK);
        }
        log("ping %p complete in %dms", connection.remotePeer, ms2);
        return ms2;
      } catch (err) {
        log.error("error while pinging %p", connection.remotePeer, err);
        stream?.abort(err);
        throw err;
      } finally {
        options.signal.removeEventListener("abort", onAbort);
        if (stream != null) {
          await stream.close();
        }
      }
    }
  }
  var DEFAULT_NODE_REQUIREMENTS = {
    lightPush: 1,
    filter: 1,
    store: 1
  };
  exports.createLightNode = createLightNode;
  exports.createRelayNode = createRelayNode;
  exports.createFullNode = createFullNode;
  exports.defaultPeerDiscoveries = defaultPeerDiscoveries;
  exports.defaultLibp2p = defaultLibp2p;
});

// node_modules/waku-tss/public/waku.js
var require_waku = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  require_multiaddr_min();
  var wakusdk_js_1 = require_wakusdk();
  console.log("Multiaddr: ", globalThis.MultiformatsMultiaddr);

  class Waku {
    constructor(remotePeerId) {
      this.contentTopic = "/js-waku-examples/1/chat/utf8";
      this.remotePeerId = remotePeerId || "/dns4/nwaku.silent.sg/tcp/8000/wss/p2p/16Uiu2HAmMbo2nB3ZfTHNZi9tgLARsowksWPh7mBGQFXGSMLnF51o";
    }
    async init() {
      this.decoder = (0, wakusdk_js_1.createDecoder)(this.contentTopic);
      console.log("content topic", this.contentTopic);
      this.encoder = (0, wakusdk_js_1.createEncoder)({
        contentTopic: this.contentTopic,
        ephemeral: null,
        metaSetter: null
      });
      this.node = await (0, wakusdk_js_1.createLightNode)();
      console.log("peerid???", this.node.libp2p.getConnections());
      await this.node.start();
      await this.dial();
      await this.subscribe();
      return this;
    }
    async dial() {
      const ma = this.remotePeerId;
      if (!ma) {
        console.log("no multiaddr");
        return;
      }
      console.log("dialing: ", ma);
      const multiaddr = globalThis.MultiformatsMultiaddr.multiaddr(ma);
      await this.node.dial(multiaddr, ["filter", "lightpush"]);
      await (0, wakusdk_js_1.waitForRemotePeer)(this.node, ["filter", "lightpush"], 30000);
      const peers = await this.node.libp2p.peerStore.all();
      console.log("[waku] peer dialed, peers: ", peers);
    }
    async subscribe() {
      console.log("[waku] subscribing... content topic", this.contentTopic);
      let callback = this.onMessageRecevied;
      await this.node.filter.subscribe([this.decoder], callback);
      console.log("[waku] subscribed]");
    }
    async receiveMessage() {
      return new Promise((resolve5, reject) => {
        (async () => {
          await this.node.filter.subscribe([this.decoder], (receivedMessage) => resolve5(receivedMessage));
        })();
      });
    }
    async sendMessage(message) {
      console.log("[waku] message waiting to send, time (before await): ", Date.now());
      await this.node.lightPush.send(this.encoder, {
        payload: (0, wakusdk_js_1.utf8ToBytes)(message)
      });
      console.log("[waku] message sent", message, "time (sent): ", Date.now());
    }
    async onMessageRecevied(wakuMessage) {
      console.log(wakuMessage);
      const text = (0, wakusdk_js_1.bytesToUtf8)(wakuMessage.payload);
      const timestamp = wakuMessage.timestamp;
      let messageObj = JSON.parse(text);
      let messageFromSelf = messageObj.authorAccount == window.location.port;
      if (messageFromSelf)
        return;
      console.log("[waku] RAW message recevied callback", text, " time: ", Date.now());
      console.log("[waku] time taken to receive = ", Date.now() - messageObj.timestamp);
      globalThis.tempReceivedMessage = messageObj;
    }
  }
  exports.default = Waku;
});

// node_modules/waku-tss/public/chatForWaku.js
var require_chatForWaku = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class ChatForWaku {
    constructor(self2, name) {
      this.selfAccount = self2;
      this.name = name;
    }
    async sendMessage(message) {
      let messageObj = {
        authorAccount: this.name,
        message,
        timestamp: Date.now(),
        topic: "tempTSS"
      };
      let messageString = JSON.stringify(messageObj);
      this.selfAccount.sendMessage(messageString);
    }
  }
  exports.default = ChatForWaku;
});

// node_modules/yargs/lib/platform-shims/esm.mjs
import {notStrictEqual, strictEqual} from "assert";

// node_modules/cliui/build/lib/index.js
var addBorder = function(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return "";
    }
    if (ts.trim().length !== 0) {
      return style;
    }
    return "  ";
  }
  return "";
};
var _minWidth = function(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
};
var getWindowWidth = function() {
  if (typeof process === "object" && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
};
var alignRight = function(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth < width) {
    return " ".repeat(width - strWidth) + str;
  }
  return str;
};
var alignCenter = function(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth >= width) {
    return str;
  }
  return " ".repeat(width - strWidth >> 1) + str;
};
function cliui(opts, _mixin) {
  mixin = _mixin;
  return new UI({
    width: (opts === null || opts === undefined ? undefined : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === undefined ? undefined : opts.wrap
  });
}
var align = {
  right: alignRight,
  center: alignCenter
};
var top = 0;
var right = 1;
var bottom = 2;
var left = 3;

class UI {
  constructor(opts) {
    var _a;
    this.width = opts.width;
    this.wrap = (_a = opts.wrap) !== null && _a !== undefined ? _a : true;
    this.rows = [];
  }
  span(...args) {
    const cols = this.div(...args);
    cols.span = true;
  }
  resetOutput() {
    this.rows = [];
  }
  div(...args) {
    if (args.length === 0) {
      this.div("");
    }
    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
      return this.applyLayoutDSL(args[0]);
    }
    const cols = args.map((arg) => {
      if (typeof arg === "string") {
        return this.colFromString(arg);
      }
      return arg;
    });
    this.rows.push(cols);
    return cols;
  }
  shouldApplyLayoutDSL(...args) {
    return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
  }
  applyLayoutDSL(str) {
    const rows = str.split("\n").map((row) => row.split("\t"));
    let leftColumnWidth = 0;
    rows.forEach((columns) => {
      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
      }
    });
    rows.forEach((columns) => {
      this.div(...columns.map((r, i) => {
        return {
          text: r.trim(),
          padding: this.measurePadding(r),
          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
        };
      }));
    });
    return this.rows[this.rows.length - 1];
  }
  colFromString(text) {
    return {
      text,
      padding: this.measurePadding(text)
    };
  }
  measurePadding(str) {
    const noAnsi = mixin.stripAnsi(str);
    return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
  }
  toString() {
    const lines = [];
    this.rows.forEach((row) => {
      this.rowToString(row, lines);
    });
    return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
  }
  rowToString(row, lines) {
    this.rasterize(row).forEach((rrow, r) => {
      let str = "";
      rrow.forEach((col, c) => {
        const { width } = row[c];
        const wrapWidth = this.negatePadding(row[c]);
        let ts = col;
        if (wrapWidth > mixin.stringWidth(col)) {
          ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
        }
        if (row[c].align && row[c].align !== "left" && this.wrap) {
          const fn = align[row[c].align];
          ts = fn(ts, wrapWidth);
          if (mixin.stringWidth(ts) < wrapWidth) {
            ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
          }
        }
        const padding = row[c].padding || [0, 0, 0, 0];
        if (padding[left]) {
          str += " ".repeat(padding[left]);
        }
        str += addBorder(row[c], ts, "| ");
        str += ts;
        str += addBorder(row[c], ts, " |");
        if (padding[right]) {
          str += " ".repeat(padding[right]);
        }
        if (r === 0 && lines.length > 0) {
          str = this.renderInline(str, lines[lines.length - 1]);
        }
      });
      lines.push({
        text: str.replace(/ +$/, ""),
        span: row.span
      });
    });
    return lines;
  }
  renderInline(source, previousLine) {
    const match = source.match(/^ */);
    const leadingWhitespace = match ? match[0].length : 0;
    const target = previousLine.text;
    const targetTextWidth = mixin.stringWidth(target.trimRight());
    if (!previousLine.span) {
      return source;
    }
    if (!this.wrap) {
      previousLine.hidden = true;
      return target + source;
    }
    if (leadingWhitespace < targetTextWidth) {
      return source;
    }
    previousLine.hidden = true;
    return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
  }
  rasterize(row) {
    const rrows = [];
    const widths = this.columnWidths(row);
    let wrapped;
    row.forEach((col, c) => {
      col.width = widths[c];
      if (this.wrap) {
        wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
      } else {
        wrapped = col.text.split("\n");
      }
      if (col.border) {
        wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
        wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
      }
      if (col.padding) {
        wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
        wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
      }
      wrapped.forEach((str, r) => {
        if (!rrows[r]) {
          rrows.push([]);
        }
        const rrow = rrows[r];
        for (let i = 0;i < c; i++) {
          if (rrow[i] === undefined) {
            rrow.push("");
          }
        }
        rrow.push(str);
      });
    });
    return rrows;
  }
  negatePadding(col) {
    let wrapWidth = col.width || 0;
    if (col.padding) {
      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
    }
    if (col.border) {
      wrapWidth -= 4;
    }
    return wrapWidth;
  }
  columnWidths(row) {
    if (!this.wrap) {
      return row.map((col) => {
        return col.width || mixin.stringWidth(col.text);
      });
    }
    let unset = row.length;
    let remainingWidth = this.width;
    const widths = row.map((col) => {
      if (col.width) {
        unset--;
        remainingWidth -= col.width;
        return col.width;
      }
      return;
    });
    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
    return widths.map((w, i) => {
      if (w === undefined) {
        return Math.max(unsetWidth, _minWidth(row[i]));
      }
      return w;
    });
  }
}
var mixin;

// node_modules/cliui/build/lib/string-utils.js
function stripAnsi(str) {
  return str.replace(ansi, "");
}
function wrap(str, width) {
  const [start, end] = str.match(ansi) || ["", ""];
  str = stripAnsi(str);
  let wrapped = "";
  for (let i = 0;i < str.length; i++) {
    if (i !== 0 && i % width === 0) {
      wrapped += "\n";
    }
    wrapped += str.charAt(i);
  }
  if (start && end) {
    wrapped = `${start}${wrapped}${end}`;
  }
  return wrapped;
}
var ansi = new RegExp("\x1B(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|" + "\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");

// node_modules/cliui/index.mjs
function ui(opts) {
  return cliui(opts, {
    stringWidth: (str) => {
      return [...str].length;
    },
    stripAnsi,
    wrap
  });
}

// node_modules/escalade/sync/index.mjs
import {dirname, resolve} from "path";
import {readdirSync, statSync} from "fs";
function sync_default(start, callback) {
  let dir = resolve(".", start);
  let tmp, stats = statSync(dir);
  if (!stats.isDirectory()) {
    dir = dirname(dir);
  }
  while (true) {
    tmp = callback(dir, readdirSync(dir));
    if (tmp)
      return resolve(dir, tmp);
    dir = dirname(tmp = dir);
    if (tmp === dir)
      break;
  }
}

// node_modules/yargs/lib/platform-shims/esm.mjs
import {inspect} from "util";
import {readFileSync as readFileSync3} from "fs";
import {fileURLToPath} from "url";

// node_modules/yargs-parser/build/lib/index.js
import {format} from "util";
import {normalize, resolve as resolve2} from "path";

// node_modules/yargs-parser/build/lib/string-utils.js
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i = leadingHyphens ? leadingHyphens[0].length : 0;i < str.length; i++) {
      let chr = str.charAt(i);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i = 0;i < str.length; i++) {
    const chrLower = lowercase.charAt(i);
    const chrString = str.charAt(i);
    if (chrLower !== chrString && i > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x) {
  if (x === null || x === undefined)
    return false;
  if (typeof x === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(x))
    return true;
  if (/^0[^.]/.test(x))
    return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

// node_modules/yargs-parser/build/lib/tokenize-arg-string.js
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e) => typeof e !== "string" ? e + "" : e);
  }
  argString = argString.trim();
  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args = [];
  for (let ii = 0;ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);
    if (c === " " && !opening) {
      if (!(prevC === " ")) {
        i++;
      }
      continue;
    }
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }
    if (!args[i])
      args[i] = "";
    args[i] += c;
  }
  return args;
}

// node_modules/yargs-parser/build/lib/yargs-parser-types.js
var DefaultValuesForTypeKey;
(function(DefaultValuesForTypeKey2) {
  DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
  DefaultValuesForTypeKey2["STRING"] = "string";
  DefaultValuesForTypeKey2["NUMBER"] = "number";
  DefaultValuesForTypeKey2["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

// node_modules/yargs-parser/build/lib/yargs-parser.js
var combineAliases = function(aliases) {
  const aliasArrays = [];
  const combined = Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i = 0;i < aliasArrays.length; i++) {
      for (let ii = i + 1;ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function(v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v, i, self2) {
      return self2.indexOf(v) === i;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== undefined && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
};
var increment = function(orig) {
  return orig !== undefined ? orig + 1 : 1;
};
var sanitizeKey = function(key) {
  if (key === "__proto__")
    return "___proto___";
  return key;
};
var stripQuotes = function(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
};
var mixin2;

class YargsParser {
  constructor(_mixin) {
    mixin2 = _mixin;
  }
  parse(argsInput, options) {
    const opts = Object.assign({
      alias: undefined,
      array: undefined,
      boolean: undefined,
      config: undefined,
      configObjects: undefined,
      configuration: undefined,
      coerce: undefined,
      count: undefined,
      default: undefined,
      envPrefix: undefined,
      narg: undefined,
      normalize: undefined,
      string: undefined,
      number: undefined,
      __: undefined,
      key: undefined
    }, options);
    const args = tokenizeArgString(argsInput);
    const inputIsString = typeof argsInput === "string";
    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
    const configuration = Object.assign({
      "boolean-negation": true,
      "camel-case-expansion": true,
      "combine-arrays": false,
      "dot-notation": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": true,
      "greedy-arrays": true,
      "halt-at-non-option": false,
      "nargs-eats-options": false,
      "negation-prefix": "no-",
      "parse-numbers": true,
      "parse-positional-numbers": true,
      "populate--": false,
      "set-placeholder-key": false,
      "short-option-groups": true,
      "strip-aliased": false,
      "strip-dashed": false,
      "unknown-options-as-args": false
    }, opts.configuration);
    const defaults = Object.assign(Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration["populate--"];
    const notFlagsArgv = notFlagsOption ? "--" : "_";
    const newAliases = Object.create(null);
    const defaulted = Object.create(null);
    const __ = opts.__ || mixin2.format;
    const flags = {
      aliases: Object.create(null),
      arrays: Object.create(null),
      bools: Object.create(null),
      strings: Object.create(null),
      numbers: Object.create(null),
      counts: Object.create(null),
      normalize: Object.create(null),
      configs: Object.create(null),
      nargs: Object.create(null),
      coercions: Object.create(null),
      keys: []
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
    [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
      const key = typeof opt === "object" ? opt.key : opt;
      const assignment = Object.keys(opt).map(function(key2) {
        const arrayFlagKeys = {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        };
        return arrayFlagKeys[key2];
      }).filter(Boolean).pop();
      if (assignment) {
        flags[assignment][key] = true;
      }
      flags.arrays[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
      flags.bools[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
      flags.numbers[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
      flags.counts[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
      flags.normalize[key] = true;
      flags.keys.push(key);
    });
    if (typeof opts.narg === "object") {
      Object.entries(opts.narg).forEach(([key, value]) => {
        if (typeof value === "number") {
          flags.nargs[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.coerce === "object") {
      Object.entries(opts.coerce).forEach(([key, value]) => {
        if (typeof value === "function") {
          flags.coercions[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.config !== "undefined") {
      if (Array.isArray(opts.config) || typeof opts.config === "string") {
        [].concat(opts.config).filter(Boolean).forEach(function(key) {
          flags.configs[key] = true;
        });
      } else if (typeof opts.config === "object") {
        Object.entries(opts.config).forEach(([key, value]) => {
          if (typeof value === "boolean" || typeof value === "function") {
            flags.configs[key] = value;
          }
        });
      }
    }
    extendAliases(opts.key, aliases, opts.default, flags.arrays);
    Object.keys(defaults).forEach(function(key) {
      (flags.aliases[key] || []).forEach(function(alias) {
        defaults[alias] = defaults[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(Object.create(null), { _: [] });
    const argvReturn = {};
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      const truncatedArg = arg.replace(/^-{3,}/, "---");
      let broken;
      let key;
      let letters;
      let m;
      let next;
      let value;
      if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
        pushPositional(arg);
      } else if (truncatedArg.match(/^---+(=|$)/)) {
        pushPositional(arg);
        continue;
      } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
        m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          if (checkAllAliases(m[1], flags.arrays)) {
            i = eatArray(i, m[1], args, m[2]);
          } else if (checkAllAliases(m[1], flags.nargs) !== false) {
            i = eatNargs(i, m[1], args, m[2]);
          } else {
            setArg(m[1], m[2], true);
          }
        }
      } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
        m = arg.match(negatedBoolean);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
        }
      } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
        m = arg.match(/^--?(.+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m = arg.match(/^-([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          setArg(m[1], m[2]);
        }
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args[i + 1];
        m = arg.match(/^-(.\..+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split("");
        broken = false;
        for (let j = 0;j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (letters[j + 1] && letters[j + 1] === "=") {
            value = arg.slice(j + 3);
            key = letters[j];
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args, value);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args, value);
            } else {
              setArg(key, value);
            }
            broken = true;
            break;
          }
          if (next === "-") {
            setArg(letters[j], next);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
            setArg(letters[j], next);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], next);
            broken = true;
            break;
          } else {
            setArg(letters[j], defaultValue(letters[j]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === "--") {
        notFlags = args.slice(i + 1);
        break;
      } else if (configuration["halt-at-non-option"]) {
        notFlags = args.slice(i);
        break;
      } else {
        pushPositional(arg);
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
    applyCoercions(argv);
    if (configuration["set-placeholder-key"])
      setPlaceholderKeys(argv);
    Object.keys(flags.counts).forEach(function(key) {
      if (!hasKey(argv, key.split(".")))
        setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length)
      argv[notFlagsArgv] = [];
    notFlags.forEach(function(key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
      Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
        delete argv[key];
      });
    }
    if (configuration["strip-aliased"]) {
      [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
        if (configuration["camel-case-expansion"] && alias.includes("-")) {
          delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
        }
        delete argv[alias];
      });
    }
    function pushPositional(arg) {
      const maybeCoercedNumber = maybeCoerceNumber("_", arg);
      if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
        argv._.push(maybeCoercedNumber);
      }
    }
    function eatNargs(i, key, args2, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags.nargs);
      toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__("Argument unexpected for: %s", key));
        }
        setArg(key, defaultValue(key));
        return i;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration["nargs-eats-options"]) {
        if (args2.length - (i + 1) + available < toEat) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        available = toEat;
      } else {
        for (ii = i + 1;ii < args2.length; ii++) {
          if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
            available++;
          else
            break;
        }
        if (available < toEat)
          error = Error(__("Not enough arguments following: %s", key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i + 1;ii < consumed + i + 1; ii++) {
        setArg(key, args2[ii]);
      }
      return i + consumed;
    }
    function eatArray(i, key, args2, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args2[i + 1];
      const nargsCount = checkAllAliases(key, flags.nargs);
      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
        if (defaults[key] !== undefined) {
          const defVal = defaults[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign, true));
        }
        for (let ii = i + 1;ii < args2.length; ii++) {
          if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
            break;
          next = args2[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
            break;
          i = ii;
          argsToSet.push(processValue(key, next, inputIsString));
        }
      }
      if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
        error = Error(__("Not enough arguments following: %s", key));
      }
      setArg(key, argsToSet);
      return i;
    }
    function setArg(key, val, shouldStripQuotes = inputIsString) {
      if (/-/.test(key) && configuration["camel-case-expansion"]) {
        const alias = key.split(".").map(function(prop) {
          return camelCase(prop);
        }).join(".");
        addNewAlias(key, alias);
      }
      const value = processValue(key, val, shouldStripQuotes);
      const splitKey = key.split(".");
      setKey(argv, splitKey, value);
      if (flags.aliases[key]) {
        flags.aliases[key].forEach(function(x) {
          const keyProperties = x.split(".");
          setKey(argv, keyProperties, value);
        });
      }
      if (splitKey.length > 1 && configuration["dot-notation"]) {
        (flags.aliases[splitKey[0]] || []).forEach(function(x) {
          let keyProperties = x.split(".");
          const a = [].concat(splitKey);
          a.shift();
          keyProperties = keyProperties.concat(a);
          if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
            setKey(argv, keyProperties, value);
          }
        });
      }
      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
        const keys = [key].concat(flags.aliases[key] || []);
        keys.forEach(function(key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value2) {
              val = typeof value2 === "string" ? mixin2.normalize(value2) : value2;
            }
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags.aliases[key] && flags.aliases[key].length)) {
        flags.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val, shouldStripQuotes) {
      if (shouldStripQuotes) {
        val = stripQuotes(val);
      }
      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
        if (typeof val === "string")
          val = val === "true";
      }
      let value = Array.isArray(val) ? val.map(function(v) {
        return maybeCoerceNumber(key, v);
      }) : maybeCoerceNumber(key, val);
      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
        value = increment();
      }
      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
        if (Array.isArray(val))
          value = val.map((val2) => {
            return mixin2.normalize(val2);
          });
        else
          value = mixin2.normalize(val);
      }
      return value;
    }
    function maybeCoerceNumber(key, value) {
      if (!configuration["parse-positional-numbers"] && key === "_")
        return value;
      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
        const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
          value = Number(value);
        }
      }
      return value;
    }
    function setConfig(argv2) {
      const configLookup = Object.create(null);
      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
      Object.keys(flags.configs).forEach(function(configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config = null;
            const resolvedConfigPath = mixin2.resolve(mixin2.cwd(), configPath);
            const resolveConfig = flags.configs[configKey];
            if (typeof resolveConfig === "function") {
              try {
                config = resolveConfig(resolvedConfigPath);
              } catch (e) {
                config = e;
              }
              if (config instanceof Error) {
                error = config;
                return;
              }
            } else {
              config = mixin2.require(resolvedConfigPath);
            }
            setConfigObject(config);
          } catch (ex) {
            if (ex.name === "PermissionDenied")
              error = ex;
            else if (argv2[configKey])
              error = Error(__("Invalid JSON config file: %s", configPath));
          }
        }
      });
    }
    function setConfigObject(config, prev) {
      Object.keys(config).forEach(function(key) {
        const value = config[key];
        const fullKey = prev ? prev + "." + key : key;
        if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
          setConfigObject(value, fullKey);
        } else {
          if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
            setArg(fullKey, value);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects !== "undefined") {
        configObjects.forEach(function(configObject) {
          setConfigObject(configObject);
        });
      }
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === "undefined")
        return;
      const prefix = typeof envPrefix === "string" ? envPrefix : "";
      const env = mixin2.env();
      Object.keys(env).forEach(function(envVar) {
        if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split("__").map(function(key, i) {
            if (i === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase(key);
          });
          if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
            setArg(keys.join("."), env[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce;
      const applied = new Set;
      Object.keys(argv2).forEach(function(key) {
        if (!applied.has(key)) {
          coerce = checkAllAliases(key, flags.coercions);
          if (typeof coerce === "function") {
            try {
              const value = maybeCoerceNumber(key, coerce(argv2[key]));
              [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value;
              });
            } catch (err) {
              error = err;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags.keys.forEach((key) => {
        if (~key.indexOf("."))
          return;
        if (typeof argv2[key] === "undefined")
          argv2[key] = undefined;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
      Object.keys(defaults2).forEach(function(key) {
        if (!hasKey(obj, key.split("."))) {
          setKey(obj, key.split("."), defaults2[key]);
          if (canLog)
            defaulted[key] = true;
          (aliases2[key] || []).forEach(function(x) {
            if (hasKey(obj, x.split(".")))
              return;
            setKey(obj, x.split("."), defaults2[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o !== "object")
        return false;
      else
        return key in o;
    }
    function setKey(obj, keys, value) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        key2 = sanitizeKey(key2);
        if (typeof o === "object" && o[key2] === undefined) {
          o[key2] = {};
        }
        if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
          if (Array.isArray(o[key2])) {
            o[key2].push({});
          } else {
            o[key2] = [o[key2], {}];
          }
          o = o[key2][o[key2].length - 1];
        } else {
          o = o[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
      const isValueArray = Array.isArray(value);
      let duplicate = configuration["duplicate-arguments-array"];
      if (!duplicate && checkAllAliases(key, flags.nargs)) {
        duplicate = true;
        if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
          o[key] = undefined;
        }
      }
      if (value === increment()) {
        o[key] = increment(o[key]);
      } else if (Array.isArray(o[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o[key] = value;
        } else {
          o[key] = o[key].concat([value]);
        }
      } else if (o[key] === undefined && isTypeArray) {
        o[key] = isValueArray ? value : [value];
      } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
        o[key] = [o[key], value];
      } else {
        o[key] = value;
      }
    }
    function extendAliases(...args2) {
      args2.forEach(function(obj) {
        Object.keys(obj || {}).forEach(function(key) {
          if (flags.aliases[key])
            return;
          flags.aliases[key] = [].concat(aliases[key] || []);
          flags.aliases[key].concat(key).forEach(function(x) {
            if (/-/.test(x) && configuration["camel-case-expansion"]) {
              const c = camelCase(x);
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].concat(key).forEach(function(x) {
            if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
              const c = decamelize(x, "-");
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].forEach(function(x) {
            flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
              return x !== y;
            }));
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const flagsKeys = Object.keys(flags);
      const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
      return toCheck.some(function(flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function(pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split("");
      for (let j = 0;j < letters.length; j++) {
        next = arg.slice(j + 2);
        if (!hasAnyFlag(letters[j])) {
          hasAllFlags = false;
          break;
        }
        if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration["unknown-options-as-args"] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      arg = arg.replace(/^-{3,}/, "--");
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    }
    function defaultValue(key) {
      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && (`${key}` in defaults)) {
        return defaults[key];
      } else {
        return defaultForType(guessType(key));
      }
    }
    function defaultForType(type) {
      const def = {
        [DefaultValuesForTypeKey.BOOLEAN]: true,
        [DefaultValuesForTypeKey.STRING]: "",
        [DefaultValuesForTypeKey.NUMBER]: undefined,
        [DefaultValuesForTypeKey.ARRAY]: []
      };
      return def[type];
    }
    function guessType(key) {
      let type = DefaultValuesForTypeKey.BOOLEAN;
      if (checkAllAliases(key, flags.strings))
        type = DefaultValuesForTypeKey.STRING;
      else if (checkAllAliases(key, flags.numbers))
        type = DefaultValuesForTypeKey.NUMBER;
      else if (checkAllAliases(key, flags.bools))
        type = DefaultValuesForTypeKey.BOOLEAN;
      else if (checkAllAliases(key, flags.arrays))
        type = DefaultValuesForTypeKey.ARRAY;
      return type;
    }
    function isUndefined(num) {
      return num === undefined;
    }
    function checkConfiguration() {
      Object.keys(flags.counts).find((key) => {
        if (checkAllAliases(key, flags.arrays)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
          return true;
        } else if (checkAllAliases(key, flags.nargs)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
          return true;
        }
        return false;
      });
    }
    return {
      aliases: Object.assign({}, flags.aliases),
      argv: Object.assign(argvReturn, argv),
      configuration,
      defaulted: Object.assign({}, defaulted),
      error,
      newAliases: Object.assign({}, newAliases)
    };
  }
}

// node_modules/yargs-parser/build/lib/index.js
import {readFileSync} from "fs";
var _a;
var _b;
var _c;
var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
var nodeVersion = (_b = (_a = process === null || process === undefined ? undefined : process.versions) === null || _a === undefined ? undefined : _a.node) !== null && _b !== undefined ? _b : (_c = process === null || process === undefined ? undefined : process.version) === null || _c === undefined ? undefined : _c.slice(1);
if (nodeVersion) {
  const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
  if (major < minNodeVersion) {
    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
  }
}
var env = process ? process.env : {};
var parser = new YargsParser({
  cwd: process.cwd,
  env: () => {
    return env;
  },
  format,
  normalize,
  resolve: resolve2,
  require: (path) => {
    if (typeof require !== "undefined") {
      return import.meta.require(path);
    } else if (path.match(/\.json$/)) {
      return JSON.parse(readFileSync(path, "utf8"));
    } else {
      throw Error("only .json config files are supported in ESM");
    }
  }
});
var yargsParser = function Parser(args, opts) {
  const result = parser.parse(args.slice(), opts);
  return result.argv;
};
yargsParser.detailed = function(args, opts) {
  return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
var lib_default = yargsParser;

// node_modules/yargs/lib/platform-shims/esm.mjs
import {basename, dirname as dirname2, extname, relative, resolve as resolve4} from "path";

// node_modules/yargs/build/lib/utils/process-argv.js
var getProcessArgvBinIndex = function() {
  if (isBundledElectronApp())
    return 0;
  return 1;
};
var isBundledElectronApp = function() {
  return isElectronApp() && !process.defaultApp;
};
var isElectronApp = function() {
  return !!process.versions.electron;
};
function hideBin(argv) {
  return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
  return process.argv[getProcessArgvBinIndex()];
}

// node_modules/yargs/build/lib/yerror.js
class YError extends Error {
  constructor(msg) {
    super(msg || "yargs error");
    this.name = "YError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, YError);
    }
  }
}

// node_modules/y18n/build/lib/platform-shims/node.js
import {readFileSync as readFileSync2, statSync as statSync2, writeFile} from "fs";
import {format as format2} from "util";
import {resolve as resolve3} from "path";
var node_default = {
  fs: {
    readFileSync: readFileSync2,
    writeFile
  },
  format: format2,
  resolve: resolve3,
  exists: (file) => {
    try {
      return statSync2(file).isFile();
    } catch (err) {
      return false;
    }
  }
};

// node_modules/y18n/build/lib/index.js
function y18n(opts, _shim) {
  shim = _shim;
  const y18n2 = new Y18N(opts);
  return {
    __: y18n2.__.bind(y18n2),
    __n: y18n2.__n.bind(y18n2),
    setLocale: y18n2.setLocale.bind(y18n2),
    getLocale: y18n2.getLocale.bind(y18n2),
    updateLocale: y18n2.updateLocale.bind(y18n2),
    locale: y18n2.locale
  };
}
var shim;

class Y18N {
  constructor(opts) {
    opts = opts || {};
    this.directory = opts.directory || "./locales";
    this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
    this.locale = opts.locale || "en";
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
    this.cache = Object.create(null);
    this.writeQueue = [];
  }
  __(...args) {
    if (typeof arguments[0] !== "string") {
      return this._taggedLiteral(arguments[0], ...arguments);
    }
    const str = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    cb = cb || function() {
    };
    if (!this.cache[this.locale])
      this._readLocaleFile();
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str;
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
  }
  __n() {
    const args = Array.prototype.slice.call(arguments);
    const singular = args.shift();
    const plural = args.shift();
    const quantity = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    if (!this.cache[this.locale])
      this._readLocaleFile();
    let str = quantity === 1 ? singular : plural;
    if (this.cache[this.locale][singular]) {
      const entry = this.cache[this.locale][singular];
      str = entry[quantity === 1 ? "one" : "other"];
    }
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural
      };
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    const values = [str];
    if (~str.indexOf("%d"))
      values.push(quantity);
    return shim.format.apply(shim.format, values.concat(args));
  }
  setLocale(locale) {
    this.locale = locale;
  }
  getLocale() {
    return this.locale;
  }
  updateLocale(obj) {
    if (!this.cache[this.locale])
      this._readLocaleFile();
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        this.cache[this.locale][key] = obj[key];
      }
    }
  }
  _taggedLiteral(parts, ...args) {
    let str = "";
    parts.forEach(function(part, i) {
      const arg = args[i + 1];
      str += part;
      if (typeof arg !== "undefined") {
        str += "%s";
      }
    });
    return this.__.apply(this, [str].concat([].slice.call(args, 1)));
  }
  _enqueueWrite(work) {
    this.writeQueue.push(work);
    if (this.writeQueue.length === 1)
      this._processWriteQueue();
  }
  _processWriteQueue() {
    const _this = this;
    const work = this.writeQueue[0];
    const directory = work.directory;
    const locale = work.locale;
    const cb = work.cb;
    const languageFile = this._resolveLocaleFile(directory, locale);
    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
    shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
      _this.writeQueue.shift();
      if (_this.writeQueue.length > 0)
        _this._processWriteQueue();
      cb(err);
    });
  }
  _readLocaleFile() {
    let localeLookup = {};
    const languageFile = this._resolveLocaleFile(this.directory, this.locale);
    try {
      if (shim.fs.readFileSync) {
        localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
      }
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = "syntax error in " + languageFile;
      }
      if (err.code === "ENOENT")
        localeLookup = {};
      else
        throw err;
    }
    this.cache[this.locale] = localeLookup;
  }
  _resolveLocaleFile(directory, locale) {
    let file = shim.resolve(directory, "./", locale + ".json");
    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
      const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
      if (this._fileExistsSync(languageFile))
        file = languageFile;
    }
    return file;
  }
  _fileExistsSync(file) {
    return shim.exists(file);
  }
}

// node_modules/y18n/index.mjs
var y18n2 = (opts) => {
  return y18n(opts, node_default);
};
var y18n_default = y18n2;

// node_modules/yargs/lib/platform-shims/esm.mjs
var REQUIRE_ERROR = "require is not supported by ESM";
var REQUIRE_DIRECTORY_ERROR = "loading a directory of commands is not supported yet for ESM";
var __dirname2;
try {
  __dirname2 = fileURLToPath(import.meta.url);
} catch (e) {
  __dirname2 = process.cwd();
}
var mainFilename = __dirname2.substring(0, __dirname2.lastIndexOf("node_modules"));
var esm_default = {
  assert: {
    notStrictEqual,
    strictEqual
  },
  cliui: ui,
  findUp: sync_default,
  getEnv: (key) => {
    return process.env[key];
  },
  inspect,
  getCallerFile: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: lib_default,
  path: {
    basename,
    dirname: dirname2,
    extname,
    relative,
    resolve: resolve4
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
  },
  readFileSync: readFileSync3,
  require: () => {
    throw new YError(REQUIRE_ERROR);
  },
  requireDirectory: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  stringWidth: (str) => {
    return [...str].length;
  },
  y18n: y18n_default({
    directory: resolve4(__dirname2, "../../../locales"),
    updateFiles: false
  })
};

// node_modules/yargs/build/lib/typings/common-types.js
function assertNotStrictEqual(actual, expected, shim2, message) {
  shim2.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim2) {
  shim2.assert.strictEqual(typeof actual, "string");
}
function objectKeys(object) {
  return Object.keys(object);
}

// node_modules/yargs/build/lib/utils/is-promise.js
function isPromise(maybePromise) {
  return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
}

// node_modules/yargs/build/lib/parse-command.js
function parseCommand(cmd) {
  const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
  const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
  const bregex = /\.*[\][<>]/g;
  const firstCommand = splitCommand.shift();
  if (!firstCommand)
    throw new Error(`No command found in: ${cmd}`);
  const parsedCommand = {
    cmd: firstCommand.replace(bregex, ""),
    demanded: [],
    optional: []
  };
  splitCommand.forEach((cmd2, i) => {
    let variadic = false;
    cmd2 = cmd2.replace(/\s/g, "");
    if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1)
      variadic = true;
    if (/^\[/.test(cmd2)) {
      parsedCommand.optional.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    } else {
      parsedCommand.demanded.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    }
  });
  return parsedCommand;
}

// node_modules/yargs/build/lib/argsert.js
function argsert(arg1, arg2, arg3) {
  function parseArgs() {
    return typeof arg1 === "object" ? [{ demanded: [], optional: [] }, arg1, arg2] : [
      parseCommand(`cmd ${arg1}`),
      arg2,
      arg3
    ];
  }
  try {
    let position = 0;
    const [parsed, callerArguments, _length] = parseArgs();
    const args = [].slice.call(callerArguments);
    while (args.length && args[args.length - 1] === undefined)
      args.pop();
    const length = _length || args.length;
    if (length < parsed.demanded.length) {
      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
    }
    const totalCommands = parsed.demanded.length + parsed.optional.length;
    if (length > totalCommands) {
      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
    }
    parsed.demanded.forEach((demanded) => {
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0)
        argumentTypeError(observedType, demanded.cmd, position);
      position += 1;
    });
    parsed.optional.forEach((optional) => {
      if (args.length === 0)
        return;
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0)
        argumentTypeError(observedType, optional.cmd, position);
      position += 1;
    });
  } catch (err) {
    console.warn(err.stack);
  }
}
var guessType = function(arg) {
  if (Array.isArray(arg)) {
    return "array";
  } else if (arg === null) {
    return "null";
  }
  return typeof arg;
};
var argumentTypeError = function(observedType, allowedTypes, position) {
  throw new YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
};
var positionName = ["first", "second", "third", "fourth", "fifth", "sixth"];

// node_modules/yargs/build/lib/middleware.js
function commandMiddlewareFactory(commandMiddleware) {
  if (!commandMiddleware)
    return [];
  return commandMiddleware.map((middleware) => {
    middleware.applyBeforeValidation = false;
    return middleware;
  });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
  return middlewares.reduce((acc, middleware) => {
    if (middleware.applyBeforeValidation !== beforeValidation) {
      return acc;
    }
    if (middleware.mutates) {
      if (middleware.applied)
        return acc;
      middleware.applied = true;
    }
    if (isPromise(acc)) {
      return acc.then((initialObj) => Promise.all([initialObj, middleware(initialObj, yargs)])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
    } else {
      const result = middleware(acc, yargs);
      return isPromise(result) ? result.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
    }
  }, argv);
}

class GlobalMiddleware {
  constructor(yargs) {
    this.globalMiddleware = [];
    this.frozens = [];
    this.yargs = yargs;
  }
  addMiddleware(callback, applyBeforeValidation, global2 = true, mutates = false) {
    argsert("<array|function> [boolean] [boolean] [boolean]", [callback, applyBeforeValidation, global2], arguments.length);
    if (Array.isArray(callback)) {
      for (let i = 0;i < callback.length; i++) {
        if (typeof callback[i] !== "function") {
          throw Error("middleware must be a function");
        }
        const m = callback[i];
        m.applyBeforeValidation = applyBeforeValidation;
        m.global = global2;
      }
      Array.prototype.push.apply(this.globalMiddleware, callback);
    } else if (typeof callback === "function") {
      const m = callback;
      m.applyBeforeValidation = applyBeforeValidation;
      m.global = global2;
      m.mutates = mutates;
      this.globalMiddleware.push(callback);
    }
    return this.yargs;
  }
  addCoerceMiddleware(callback, option) {
    const aliases = this.yargs.getAliases();
    this.globalMiddleware = this.globalMiddleware.filter((m) => {
      const toCheck = [...aliases[option] || [], option];
      if (!m.option)
        return true;
      else
        return !toCheck.includes(m.option);
    });
    callback.option = option;
    return this.addMiddleware(callback, true, true, true);
  }
  getMiddleware() {
    return this.globalMiddleware;
  }
  freeze() {
    this.frozens.push([...this.globalMiddleware]);
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    if (frozen !== undefined)
      this.globalMiddleware = frozen;
  }
  reset() {
    this.globalMiddleware = this.globalMiddleware.filter((m) => m.global);
  }
}

// node_modules/yargs/build/lib/utils/maybe-async-result.js
function maybeAsyncResult(getResult, resultHandler, errorHandler = (err) => {
  throw err;
}) {
  try {
    const result = isFunction(getResult) ? getResult() : getResult;
    return isPromise(result) ? result.then((result2) => resultHandler(result2)) : resultHandler(result);
  } catch (err) {
    return errorHandler(err);
  }
}
var isFunction = function(arg) {
  return typeof arg === "function";
};

// node_modules/yargs/build/lib/utils/which-module.js
function whichModule(exported) {
  if (typeof require === "undefined")
    return null;
  for (let i = 0, files = Object.keys(require.cache), mod;i < files.length; i++) {
    mod = require.cache[files[i]];
    if (mod.exports === exported)
      return mod;
  }
  return null;
}

// node_modules/yargs/build/lib/command.js
function command(usage, validation, globalMiddleware, shim2) {
  return new CommandInstance(usage, validation, globalMiddleware, shim2);
}
function isCommandBuilderDefinition(builder) {
  return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
}
var isCommandAndAliases = function(cmd) {
  return cmd.every((c) => typeof c === "string");
};
function isCommandBuilderCallback(builder) {
  return typeof builder === "function";
}
var isCommandBuilderOptionDefinitions = function(builder) {
  return typeof builder === "object";
};
function isCommandHandlerDefinition(cmd) {
  return typeof cmd === "object" && !Array.isArray(cmd);
}
var DEFAULT_MARKER = /(^\*)|(^\$0)/;

class CommandInstance {
  constructor(usage, validation, globalMiddleware, shim2) {
    this.requireCache = new Set;
    this.handlers = {};
    this.aliasMap = {};
    this.frozens = [];
    this.shim = shim2;
    this.usage = usage;
    this.globalMiddleware = globalMiddleware;
    this.validation = validation;
  }
  addDirectory(dir, req, callerFile, opts) {
    opts = opts || {};
    if (typeof opts.recurse !== "boolean")
      opts.recurse = false;
    if (!Array.isArray(opts.extensions))
      opts.extensions = ["js"];
    const parentVisit = typeof opts.visit === "function" ? opts.visit : (o) => o;
    opts.visit = (obj, joined, filename) => {
      const visited = parentVisit(obj, joined, filename);
      if (visited) {
        if (this.requireCache.has(joined))
          return visited;
        else
          this.requireCache.add(joined);
        this.addHandler(visited);
      }
      return visited;
    };
    this.shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);
  }
  addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
    let aliases = [];
    const middlewares = commandMiddlewareFactory(commandMiddleware);
    handler = handler || (() => {
    });
    if (Array.isArray(cmd)) {
      if (isCommandAndAliases(cmd)) {
        [cmd, ...aliases] = cmd;
      } else {
        for (const command2 of cmd) {
          this.addHandler(command2);
        }
      }
    } else if (isCommandHandlerDefinition(cmd)) {
      let command2 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : this.moduleName(cmd);
      if (cmd.aliases)
        command2 = [].concat(command2).concat(cmd.aliases);
      this.addHandler(command2, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
      return;
    } else if (isCommandBuilderDefinition(builder)) {
      this.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
      return;
    }
    if (typeof cmd === "string") {
      const parsedCommand = parseCommand(cmd);
      aliases = aliases.map((alias) => parseCommand(alias).cmd);
      let isDefault = false;
      const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
        if (DEFAULT_MARKER.test(c)) {
          isDefault = true;
          return false;
        }
        return true;
      });
      if (parsedAliases.length === 0 && isDefault)
        parsedAliases.push("$0");
      if (isDefault) {
        parsedCommand.cmd = parsedAliases[0];
        aliases = parsedAliases.slice(1);
        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
      }
      aliases.forEach((alias) => {
        this.aliasMap[alias] = parsedCommand.cmd;
      });
      if (description !== false) {
        this.usage.command(cmd, description, isDefault, aliases, deprecated);
      }
      this.handlers[parsedCommand.cmd] = {
        original: cmd,
        description,
        handler,
        builder: builder || {},
        middlewares,
        deprecated,
        demanded: parsedCommand.demanded,
        optional: parsedCommand.optional
      };
      if (isDefault)
        this.defaultCommand = this.handlers[parsedCommand.cmd];
    }
  }
  getCommandHandlers() {
    return this.handlers;
  }
  getCommands() {
    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
  }
  hasDefaultCommand() {
    return !!this.defaultCommand;
  }
  runCommand(command2, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
    const commandHandler = this.handlers[command2] || this.handlers[this.aliasMap[command2]] || this.defaultCommand;
    const currentContext = yargs.getInternalMethods().getContext();
    const parentCommands = currentContext.commands.slice();
    const isDefaultCommand = !command2;
    if (command2) {
      currentContext.commands.push(command2);
      currentContext.fullCommands.push(commandHandler.original);
    }
    const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
    return isPromise(builderResult) ? builderResult.then((result) => this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs)) : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
  }
  applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
    const builder = commandHandler.builder;
    let innerYargs = yargs;
    if (isCommandBuilderCallback(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
      if (isPromise(builderOutput)) {
        return builderOutput.then((output) => {
          innerYargs = isYargsInstance(output) ? output : yargs;
          return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
        });
      }
    } else if (isCommandBuilderOptionDefinitions(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      innerYargs = yargs.getInternalMethods().reset(aliases);
      Object.keys(commandHandler.builder).forEach((key) => {
        innerYargs.option(key, builder[key]);
      });
    }
    return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
  }
  parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
    if (isDefaultCommand)
      innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
    if (this.shouldUpdateUsage(innerYargs)) {
      innerYargs.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
    }
    const innerArgv = innerYargs.getInternalMethods().runYargsParserAndExecuteCommands(null, undefined, true, commandIndex, helpOnly);
    return isPromise(innerArgv) ? innerArgv.then((argv) => ({
      aliases: innerYargs.parsed.aliases,
      innerArgv: argv
    })) : {
      aliases: innerYargs.parsed.aliases,
      innerArgv
    };
  }
  shouldUpdateUsage(yargs) {
    return !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() && yargs.getInternalMethods().getUsageInstance().getUsage().length === 0;
  }
  usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
    const pc = parentCommands.filter((c2) => {
      return !DEFAULT_MARKER.test(c2);
    });
    pc.push(c);
    return `\$0 ${pc.join(" ")}`;
  }
  handleValidationAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, aliases, yargs, middlewares, positionalMap) {
    if (!yargs.getInternalMethods().getHasOutput()) {
      const validation = yargs.getInternalMethods().runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        validation(result);
        return result;
      });
    }
    if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
      yargs.getInternalMethods().setHasOutput();
      const populateDoubleDash = !!yargs.getOptions().configuration["populate--"];
      yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        const handlerResult = commandHandler.handler(result);
        return isPromise(handlerResult) ? handlerResult.then(() => result) : result;
      });
      if (!isDefaultCommand) {
        yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
      }
      if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) {
        innerArgv.catch((error) => {
          try {
            yargs.getInternalMethods().getUsageInstance().fail(null, error);
          } catch (_err) {
          }
        });
      }
    }
    if (!isDefaultCommand) {
      currentContext.commands.pop();
      currentContext.fullCommands.pop();
    }
    return innerArgv;
  }
  applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
    let positionalMap = {};
    if (helpOnly)
      return innerArgv;
    if (!yargs.getInternalMethods().getHasOutput()) {
      positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
    }
    const middlewares = this.globalMiddleware.getMiddleware().slice(0).concat(commandHandler.middlewares);
    const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
    return isPromise(maybePromiseArgv) ? maybePromiseArgv.then((resolvedInnerArgv) => this.handleValidationAndGetResult(isDefaultCommand, commandHandler, resolvedInnerArgv, currentContext, aliases, yargs, middlewares, positionalMap)) : this.handleValidationAndGetResult(isDefaultCommand, commandHandler, maybePromiseArgv, currentContext, aliases, yargs, middlewares, positionalMap);
  }
  populatePositionals(commandHandler, argv, context, yargs) {
    argv._ = argv._.slice(context.commands.length);
    const demanded = commandHandler.demanded.slice(0);
    const optional = commandHandler.optional.slice(0);
    const positionalMap = {};
    this.validation.positionalCount(demanded.length, argv._.length);
    while (demanded.length) {
      const demand = demanded.shift();
      this.populatePositional(demand, argv, positionalMap);
    }
    while (optional.length) {
      const maybe = optional.shift();
      this.populatePositional(maybe, argv, positionalMap);
    }
    argv._ = context.commands.concat(argv._.map((a) => "" + a));
    this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
    return positionalMap;
  }
  populatePositional(positional, argv, positionalMap) {
    const cmd = positional.cmd[0];
    if (positional.variadic) {
      positionalMap[cmd] = argv._.splice(0).map(String);
    } else {
      if (argv._.length)
        positionalMap[cmd] = [String(argv._.shift())];
    }
  }
  cmdToParseOptions(cmdString) {
    const parseOptions = {
      array: [],
      default: {},
      alias: {},
      demand: {}
    };
    const parsed = parseCommand(cmdString);
    parsed.demanded.forEach((d) => {
      const [cmd, ...aliases] = d.cmd;
      if (d.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
      parseOptions.demand[cmd] = true;
    });
    parsed.optional.forEach((o) => {
      const [cmd, ...aliases] = o.cmd;
      if (o.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
    });
    return parseOptions;
  }
  postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
    const options = Object.assign({}, yargs.getOptions());
    options.default = Object.assign(parseOptions.default, options.default);
    for (const key of Object.keys(parseOptions.alias)) {
      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
    }
    options.array = options.array.concat(parseOptions.array);
    options.config = {};
    const unparsed = [];
    Object.keys(positionalMap).forEach((key) => {
      positionalMap[key].map((value) => {
        if (options.configuration["unknown-options-as-args"])
          options.key[key] = true;
        unparsed.push(`--${key}`);
        unparsed.push(value);
      });
    });
    if (!unparsed.length)
      return;
    const config = Object.assign({}, options.configuration, {
      "populate--": false
    });
    const parsed = this.shim.Parser.detailed(unparsed, Object.assign({}, options, {
      configuration: config
    }));
    if (parsed.error) {
      yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
    } else {
      const positionalKeys = Object.keys(positionalMap);
      Object.keys(positionalMap).forEach((key) => {
        positionalKeys.push(...parsed.aliases[key]);
      });
      Object.keys(parsed.argv).forEach((key) => {
        if (positionalKeys.includes(key)) {
          if (!positionalMap[key])
            positionalMap[key] = parsed.argv[key];
          if (!this.isInConfigs(yargs, key) && !this.isDefaulted(yargs, key) && Object.prototype.hasOwnProperty.call(argv, key) && Object.prototype.hasOwnProperty.call(parsed.argv, key) && (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) {
            argv[key] = [].concat(argv[key], parsed.argv[key]);
          } else {
            argv[key] = parsed.argv[key];
          }
        }
      });
    }
  }
  isDefaulted(yargs, key) {
    const { default: defaults } = yargs.getOptions();
    return Object.prototype.hasOwnProperty.call(defaults, key) || Object.prototype.hasOwnProperty.call(defaults, this.shim.Parser.camelCase(key));
  }
  isInConfigs(yargs, key) {
    const { configObjects } = yargs.getOptions();
    return configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, key)) || configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, this.shim.Parser.camelCase(key)));
  }
  runDefaultBuilderOn(yargs) {
    if (!this.defaultCommand)
      return;
    if (this.shouldUpdateUsage(yargs)) {
      const commandString = DEFAULT_MARKER.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
      yargs.getInternalMethods().getUsageInstance().usage(commandString, this.defaultCommand.description);
    }
    const builder = this.defaultCommand.builder;
    if (isCommandBuilderCallback(builder)) {
      return builder(yargs, true);
    } else if (!isCommandBuilderDefinition(builder)) {
      Object.keys(builder).forEach((key) => {
        yargs.option(key, builder[key]);
      });
    }
    return;
  }
  moduleName(obj) {
    const mod = whichModule(obj);
    if (!mod)
      throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
    return this.commandFromFilename(mod.filename);
  }
  commandFromFilename(filename) {
    return this.shim.path.basename(filename, this.shim.path.extname(filename));
  }
  extractDesc({ describe, description, desc }) {
    for (const test of [describe, description, desc]) {
      if (typeof test === "string" || test === false)
        return test;
      assertNotStrictEqual(test, true, this.shim);
    }
    return false;
  }
  freeze() {
    this.frozens.push({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    });
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    assertNotStrictEqual(frozen, undefined, this.shim);
    ({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand
    } = frozen);
  }
  reset() {
    this.handlers = {};
    this.aliasMap = {};
    this.defaultCommand = undefined;
    this.requireCache = new Set;
    return this;
  }
}

// node_modules/yargs/build/lib/utils/obj-filter.js
function objFilter(original = {}, filter = () => true) {
  const obj = {};
  objectKeys(original).forEach((key) => {
    if (filter(key, original[key])) {
      obj[key] = original[key];
    }
  });
  return obj;
}

// node_modules/yargs/build/lib/utils/set-blocking.js
function setBlocking(blocking) {
  if (typeof process === "undefined")
    return;
  [process.stdout, process.stderr].forEach((_stream) => {
    const stream = _stream;
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
      stream._handle.setBlocking(blocking);
    }
  });
}

// node_modules/yargs/build/lib/usage.js
var isBoolean = function(fail) {
  return typeof fail === "boolean";
};
function usage(yargs, shim2) {
  const __ = shim2.y18n.__;
  const self2 = {};
  const fails = [];
  self2.failFn = function failFn(f) {
    fails.push(f);
  };
  let failMessage = null;
  let globalFailMessage = null;
  let showHelpOnFail = true;
  self2.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
    const [enabled, message] = typeof arg1 === "string" ? [true, arg1] : [arg1, arg2];
    if (yargs.getInternalMethods().isGlobalContext()) {
      globalFailMessage = message;
    }
    failMessage = message;
    showHelpOnFail = enabled;
    return self2;
  };
  let failureOutput = false;
  self2.fail = function fail(msg, err) {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (fails.length) {
      for (let i = fails.length - 1;i >= 0; --i) {
        const fail = fails[i];
        if (isBoolean(fail)) {
          if (err)
            throw err;
          else if (msg)
            throw Error(msg);
        } else {
          fail(msg, err, self2);
        }
      }
    } else {
      if (yargs.getExitProcess())
        setBlocking(true);
      if (!failureOutput) {
        failureOutput = true;
        if (showHelpOnFail) {
          yargs.showHelp("error");
          logger.error();
        }
        if (msg || err)
          logger.error(msg || err);
        const globalOrCommandFailMessage = failMessage || globalFailMessage;
        if (globalOrCommandFailMessage) {
          if (msg || err)
            logger.error("");
          logger.error(globalOrCommandFailMessage);
        }
      }
      err = err || new YError(msg);
      if (yargs.getExitProcess()) {
        return yargs.exit(1);
      } else if (yargs.getInternalMethods().hasParseCallback()) {
        return yargs.exit(1, err);
      } else {
        throw err;
      }
    }
  };
  let usages = [];
  let usageDisabled = false;
  self2.usage = (msg, description) => {
    if (msg === null) {
      usageDisabled = true;
      usages = [];
      return self2;
    }
    usageDisabled = false;
    usages.push([msg, description || ""]);
    return self2;
  };
  self2.getUsage = () => {
    return usages;
  };
  self2.getUsageDisabled = () => {
    return usageDisabled;
  };
  self2.getPositionalGroupName = () => {
    return __("Positionals:");
  };
  let examples = [];
  self2.example = (cmd, description) => {
    examples.push([cmd, description || ""]);
  };
  let commands = [];
  self2.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
    if (isDefault) {
      commands = commands.map((cmdArray) => {
        cmdArray[2] = false;
        return cmdArray;
      });
    }
    commands.push([cmd, description || "", isDefault, aliases, deprecated]);
  };
  self2.getCommands = () => commands;
  let descriptions = {};
  self2.describe = function describe(keyOrKeys, desc) {
    if (Array.isArray(keyOrKeys)) {
      keyOrKeys.forEach((k) => {
        self2.describe(k, desc);
      });
    } else if (typeof keyOrKeys === "object") {
      Object.keys(keyOrKeys).forEach((k) => {
        self2.describe(k, keyOrKeys[k]);
      });
    } else {
      descriptions[keyOrKeys] = desc;
    }
  };
  self2.getDescriptions = () => descriptions;
  let epilogs = [];
  self2.epilog = (msg) => {
    epilogs.push(msg);
  };
  let wrapSet = false;
  let wrap2;
  self2.wrap = (cols) => {
    wrapSet = true;
    wrap2 = cols;
  };
  self2.getWrap = () => {
    if (shim2.getEnv("YARGS_DISABLE_WRAP")) {
      return null;
    }
    if (!wrapSet) {
      wrap2 = windowWidth();
      wrapSet = true;
    }
    return wrap2;
  };
  const deferY18nLookupPrefix = "__yargsString__:";
  self2.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
  self2.help = function help() {
    if (cachedHelpMessage)
      return cachedHelpMessage;
    normalizeAliases();
    const base$0 = yargs.customScriptName ? yargs.$0 : shim2.path.basename(yargs.$0);
    const demandedOptions = yargs.getDemandedOptions();
    const demandedCommands = yargs.getDemandedCommands();
    const deprecatedOptions = yargs.getDeprecatedOptions();
    const groups = yargs.getGroups();
    const options = yargs.getOptions();
    let keys = [];
    keys = keys.concat(Object.keys(descriptions));
    keys = keys.concat(Object.keys(demandedOptions));
    keys = keys.concat(Object.keys(demandedCommands));
    keys = keys.concat(Object.keys(options.default));
    keys = keys.filter(filterHiddenOptions);
    keys = Object.keys(keys.reduce((acc, key) => {
      if (key !== "_")
        acc[key] = true;
      return acc;
    }, {}));
    const theWrap = self2.getWrap();
    const ui2 = shim2.cliui({
      width: theWrap,
      wrap: !!theWrap
    });
    if (!usageDisabled) {
      if (usages.length) {
        usages.forEach((usage2) => {
          ui2.div({ text: `${usage2[0].replace(/\$0/g, base$0)}` });
          if (usage2[1]) {
            ui2.div({ text: `${usage2[1]}`, padding: [1, 0, 0, 0] });
          }
        });
        ui2.div();
      } else if (commands.length) {
        let u = null;
        if (demandedCommands._) {
          u = `${base$0} <${__("command")}>\n`;
        } else {
          u = `${base$0} [${__("command")}]\n`;
        }
        ui2.div(`${u}`);
      }
    }
    if (commands.length > 1 || commands.length === 1 && !commands[0][2]) {
      ui2.div(__("Commands:"));
      const context = yargs.getInternalMethods().getContext();
      const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
      if (yargs.getInternalMethods().getParserConfiguration()["sort-commands"] === true) {
        commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
      }
      const prefix = base$0 ? `${base$0} ` : "";
      commands.forEach((command2) => {
        const commandString = `${prefix}${parentCommands}${command2[0].replace(/^\$0 ?/, "")}`;
        ui2.span({
          text: commandString,
          padding: [0, 2, 0, 2],
          width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
        }, { text: command2[1] });
        const hints = [];
        if (command2[2])
          hints.push(`[${__("default")}]`);
        if (command2[3] && command2[3].length) {
          hints.push(`[${__("aliases:")} ${command2[3].join(", ")}]`);
        }
        if (command2[4]) {
          if (typeof command2[4] === "string") {
            hints.push(`[${__("deprecated: %s", command2[4])}]`);
          } else {
            hints.push(`[${__("deprecated")}]`);
          }
        }
        if (hints.length) {
          ui2.div({
            text: hints.join(" "),
            padding: [0, 0, 0, 2],
            align: "right"
          });
        } else {
          ui2.div();
        }
      });
      ui2.div();
    }
    const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
    keys = keys.filter((key) => !yargs.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
    const defaultGroup = __("Options:");
    if (!groups[defaultGroup])
      groups[defaultGroup] = [];
    addUngroupedKeys(keys, options.alias, groups, defaultGroup);
    const isLongSwitch = (sw) => /^--/.test(getText(sw));
    const displayedGroups = Object.keys(groups).filter((groupName) => groups[groupName].length > 0).map((groupName) => {
      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
        if (aliasKeys.includes(key))
          return key;
        for (let i = 0, aliasKey;(aliasKey = aliasKeys[i]) !== undefined; i++) {
          if ((options.alias[aliasKey] || []).includes(key))
            return aliasKey;
        }
        return key;
      });
      return { groupName, normalizedKeys };
    }).filter(({ normalizedKeys }) => normalizedKeys.length > 0).map(({ groupName, normalizedKeys }) => {
      const switches = normalizedKeys.reduce((acc, key) => {
        acc[key] = [key].concat(options.alias[key] || []).map((sw) => {
          if (groupName === self2.getPositionalGroupName())
            return sw;
          else {
            return (/^[0-9]$/.test(sw) ? options.boolean.includes(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw;
          }
        }).sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(", ");
        return acc;
      }, {});
      return { groupName, normalizedKeys, switches };
    });
    const shortSwitchesUsed = displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).some(({ normalizedKeys, switches }) => !normalizedKeys.every((key) => isLongSwitch(switches[key])));
    if (shortSwitchesUsed) {
      displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).forEach(({ normalizedKeys, switches }) => {
        normalizedKeys.forEach((key) => {
          if (isLongSwitch(switches[key])) {
            switches[key] = addIndentation(switches[key], "-x, ".length);
          }
        });
      });
    }
    displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
      ui2.div(groupName);
      normalizedKeys.forEach((key) => {
        const kswitch = switches[key];
        let desc = descriptions[key] || "";
        let type = null;
        if (desc.includes(deferY18nLookupPrefix))
          desc = __(desc.substring(deferY18nLookupPrefix.length));
        if (options.boolean.includes(key))
          type = `[${__("boolean")}]`;
        if (options.count.includes(key))
          type = `[${__("count")}]`;
        if (options.string.includes(key))
          type = `[${__("string")}]`;
        if (options.normalize.includes(key))
          type = `[${__("string")}]`;
        if (options.array.includes(key))
          type = `[${__("array")}]`;
        if (options.number.includes(key))
          type = `[${__("number")}]`;
        const deprecatedExtra = (deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`;
        const extra = [
          key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
          type,
          key in demandedOptions ? `[${__("required")}]` : null,
          options.choices && options.choices[key] ? `[${__("choices:")} ${self2.stringifiedValues(options.choices[key])}]` : null,
          defaultString(options.default[key], options.defaultDescription[key])
        ].filter(Boolean).join(" ");
        ui2.span({
          text: getText(kswitch),
          padding: [0, 2, 0, 2 + getIndentation(kswitch)],
          width: maxWidth(switches, theWrap) + 4
        }, desc);
        const shouldHideOptionExtras = yargs.getInternalMethods().getUsageConfiguration()["hide-types"] === true;
        if (extra && !shouldHideOptionExtras)
          ui2.div({ text: extra, padding: [0, 0, 0, 2], align: "right" });
        else
          ui2.div();
      });
      ui2.div();
    });
    if (examples.length) {
      ui2.div(__("Examples:"));
      examples.forEach((example) => {
        example[0] = example[0].replace(/\$0/g, base$0);
      });
      examples.forEach((example) => {
        if (example[1] === "") {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2]
          });
        } else {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2],
            width: maxWidth(examples, theWrap) + 4
          }, {
            text: example[1]
          });
        }
      });
      ui2.div();
    }
    if (epilogs.length > 0) {
      const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
      ui2.div(`${e}\n`);
    }
    return ui2.toString().replace(/\s*$/, "");
  };
  function maxWidth(table, theWrap, modifier) {
    let width = 0;
    if (!Array.isArray(table)) {
      table = Object.values(table).map((v) => [v]);
    }
    table.forEach((v) => {
      width = Math.max(shim2.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
    });
    if (theWrap)
      width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
    return width;
  }
  function normalizeAliases() {
    const demandedOptions = yargs.getDemandedOptions();
    const options = yargs.getOptions();
    (Object.keys(options.alias) || []).forEach((key) => {
      options.alias[key].forEach((alias) => {
        if (descriptions[alias])
          self2.describe(key, descriptions[alias]);
        if (alias in demandedOptions)
          yargs.demandOption(key, demandedOptions[alias]);
        if (options.boolean.includes(alias))
          yargs.boolean(key);
        if (options.count.includes(alias))
          yargs.count(key);
        if (options.string.includes(alias))
          yargs.string(key);
        if (options.normalize.includes(alias))
          yargs.normalize(key);
        if (options.array.includes(alias))
          yargs.array(key);
        if (options.number.includes(alias))
          yargs.number(key);
      });
    });
  }
  let cachedHelpMessage;
  self2.cacheHelpMessage = function() {
    cachedHelpMessage = this.help();
  };
  self2.clearCachedHelpMessage = function() {
    cachedHelpMessage = undefined;
  };
  self2.hasCachedHelpMessage = function() {
    return !!cachedHelpMessage;
  };
  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
    let groupedKeys = [];
    let toCheck = null;
    Object.keys(groups).forEach((group) => {
      groupedKeys = groupedKeys.concat(groups[group]);
    });
    keys.forEach((key) => {
      toCheck = [key].concat(aliases[key]);
      if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
        groups[defaultGroup].push(key);
      }
    });
    return groupedKeys;
  }
  function filterHiddenOptions(key) {
    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
  }
  self2.showHelp = (level) => {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level)
      level = "error";
    const emit = typeof level === "function" ? level : logger[level];
    emit(self2.help());
  };
  self2.functionDescription = (fn) => {
    const description = fn.name ? shim2.Parser.decamelize(fn.name, "-") : __("generated-value");
    return ["(", description, ")"].join("");
  };
  self2.stringifiedValues = function stringifiedValues(values, separator) {
    let string = "";
    const sep = separator || ", ";
    const array = [].concat(values);
    if (!values || !array.length)
      return string;
    array.forEach((value) => {
      if (string.length)
        string += sep;
      string += JSON.stringify(value);
    });
    return string;
  };
  function defaultString(value, defaultDescription) {
    let string = `[${__("default:")} `;
    if (value === undefined && !defaultDescription)
      return null;
    if (defaultDescription) {
      string += defaultDescription;
    } else {
      switch (typeof value) {
        case "string":
          string += `"${value}"`;
          break;
        case "object":
          string += JSON.stringify(value);
          break;
        default:
          string += value;
      }
    }
    return `${string}]`;
  }
  function windowWidth() {
    const maxWidth2 = 80;
    if (shim2.process.stdColumns) {
      return Math.min(maxWidth2, shim2.process.stdColumns);
    } else {
      return maxWidth2;
    }
  }
  let version = null;
  self2.version = (ver) => {
    version = ver;
  };
  self2.showVersion = (level) => {
    const logger = yargs.getInternalMethods().getLoggerInstance();
    if (!level)
      level = "error";
    const emit = typeof level === "function" ? level : logger[level];
    emit(version);
  };
  self2.reset = function reset(localLookup) {
    failMessage = null;
    failureOutput = false;
    usages = [];
    usageDisabled = false;
    epilogs = [];
    examples = [];
    commands = [];
    descriptions = objFilter(descriptions, (k) => !localLookup[k]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      failMessage,
      failureOutput,
      usages,
      usageDisabled,
      epilogs,
      examples,
      commands,
      descriptions
    });
  };
  self2.unfreeze = function unfreeze(defaultCommand = false) {
    const frozen = frozens.pop();
    if (!frozen)
      return;
    if (defaultCommand) {
      descriptions = { ...frozen.descriptions, ...descriptions };
      commands = [...frozen.commands, ...commands];
      usages = [...frozen.usages, ...usages];
      examples = [...frozen.examples, ...examples];
      epilogs = [...frozen.epilogs, ...epilogs];
    } else {
      ({
        failMessage,
        failureOutput,
        usages,
        usageDisabled,
        epilogs,
        examples,
        commands,
        descriptions
      } = frozen);
    }
  };
  return self2;
}
var isIndentedText = function(text) {
  return typeof text === "object";
};
var addIndentation = function(text, indent) {
  return isIndentedText(text) ? { text: text.text, indentation: text.indentation + indent } : { text, indentation: indent };
};
var getIndentation = function(text) {
  return isIndentedText(text) ? text.indentation : 0;
};
var getText = function(text) {
  return isIndentedText(text) ? text.text : text;
};

// node_modules/yargs/build/lib/completion-templates.js
var completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
var completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;

// node_modules/yargs/build/lib/completion.js
function completion(yargs, usage2, command3, shim2) {
  return new Completion(yargs, usage2, command3, shim2);
}
var isSyncCompletionFunction = function(completionFunction) {
  return completionFunction.length < 3;
};
var isFallbackCompletionFunction = function(completionFunction) {
  return completionFunction.length > 3;
};

class Completion {
  constructor(yargs, usage2, command3, shim2) {
    var _a2, _b2, _c2;
    this.yargs = yargs;
    this.usage = usage2;
    this.command = command3;
    this.shim = shim2;
    this.completionKey = "get-yargs-completions";
    this.aliases = null;
    this.customCompletionFunction = null;
    this.indexAfterLastReset = 0;
    this.zshShell = (_c2 = ((_a2 = this.shim.getEnv("SHELL")) === null || _a2 === undefined ? undefined : _a2.includes("zsh")) || ((_b2 = this.shim.getEnv("ZSH_NAME")) === null || _b2 === undefined ? undefined : _b2.includes("zsh"))) !== null && _c2 !== undefined ? _c2 : false;
  }
  defaultCompletion(args, argv, current, done) {
    const handlers = this.command.getCommandHandlers();
    for (let i = 0, ii = args.length;i < ii; ++i) {
      if (handlers[args[i]] && handlers[args[i]].builder) {
        const builder = handlers[args[i]].builder;
        if (isCommandBuilderCallback(builder)) {
          this.indexAfterLastReset = i + 1;
          const y = this.yargs.getInternalMethods().reset();
          builder(y, true);
          return y.argv;
        }
      }
    }
    const completions = [];
    this.commandCompletions(completions, args, current);
    this.optionCompletions(completions, args, argv, current);
    this.choicesFromOptionsCompletions(completions, args, argv, current);
    this.choicesFromPositionalsCompletions(completions, args, argv, current);
    done(null, completions);
  }
  commandCompletions(completions, args, current) {
    const parentCommands = this.yargs.getInternalMethods().getContext().commands;
    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current && !this.previousArgHasChoices(args)) {
      this.usage.getCommands().forEach((usageCommand) => {
        const commandName = parseCommand(usageCommand[0]).cmd;
        if (args.indexOf(commandName) === -1) {
          if (!this.zshShell) {
            completions.push(commandName);
          } else {
            const desc = usageCommand[1] || "";
            completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
          }
        }
      });
    }
  }
  optionCompletions(completions, args, argv, current) {
    if ((current.match(/^-/) || current === "" && completions.length === 0) && !this.previousArgHasChoices(args)) {
      const options = this.yargs.getOptions();
      const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
      Object.keys(options.key).forEach((key) => {
        const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
        const isPositionalKey = positionalKeys.includes(key);
        if (!isPositionalKey && !options.hiddenOptions.includes(key) && !this.argsContainKey(args, key, negable)) {
          this.completeOptionKey(key, completions, current, negable && !!options.default[key]);
        }
      });
    }
  }
  choicesFromOptionsCompletions(completions, args, argv, current) {
    if (this.previousArgHasChoices(args)) {
      const choices = this.getPreviousArgChoices(args);
      if (choices && choices.length > 0) {
        completions.push(...choices.map((c) => c.replace(/:/g, "\\:")));
      }
    }
  }
  choicesFromPositionalsCompletions(completions, args, argv, current) {
    if (current === "" && completions.length > 0 && this.previousArgHasChoices(args)) {
      return;
    }
    const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
    const offset = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1);
    const positionalKey = positionalKeys[argv._.length - offset - 1];
    if (!positionalKey) {
      return;
    }
    const choices = this.yargs.getOptions().choices[positionalKey] || [];
    for (const choice of choices) {
      if (choice.startsWith(current)) {
        completions.push(choice.replace(/:/g, "\\:"));
      }
    }
  }
  getPreviousArgChoices(args) {
    if (args.length < 1)
      return;
    let previousArg = args[args.length - 1];
    let filter = "";
    if (!previousArg.startsWith("-") && args.length > 1) {
      filter = previousArg;
      previousArg = args[args.length - 2];
    }
    if (!previousArg.startsWith("-"))
      return;
    const previousArgKey = previousArg.replace(/^-+/, "");
    const options = this.yargs.getOptions();
    const possibleAliases = [
      previousArgKey,
      ...this.yargs.getAliases()[previousArgKey] || []
    ];
    let choices;
    for (const possibleAlias of possibleAliases) {
      if (Object.prototype.hasOwnProperty.call(options.key, possibleAlias) && Array.isArray(options.choices[possibleAlias])) {
        choices = options.choices[possibleAlias];
        break;
      }
    }
    if (choices) {
      return choices.filter((choice) => !filter || choice.startsWith(filter));
    }
  }
  previousArgHasChoices(args) {
    const choices = this.getPreviousArgChoices(args);
    return choices !== undefined && choices.length > 0;
  }
  argsContainKey(args, key, negable) {
    const argsContains = (s) => args.indexOf((/^[^0-9]$/.test(s) ? "-" : "--") + s) !== -1;
    if (argsContains(key))
      return true;
    if (negable && argsContains(`no-${key}`))
      return true;
    if (this.aliases) {
      for (const alias of this.aliases[key]) {
        if (argsContains(alias))
          return true;
      }
    }
    return false;
  }
  completeOptionKey(key, completions, current, negable) {
    var _a2, _b2, _c2, _d;
    let keyWithDesc = key;
    if (this.zshShell) {
      const descs = this.usage.getDescriptions();
      const aliasKey = (_b2 = (_a2 = this === null || this === undefined ? undefined : this.aliases) === null || _a2 === undefined ? undefined : _a2[key]) === null || _b2 === undefined ? undefined : _b2.find((alias) => {
        const desc2 = descs[alias];
        return typeof desc2 === "string" && desc2.length > 0;
      });
      const descFromAlias = aliasKey ? descs[aliasKey] : undefined;
      const desc = (_d = (_c2 = descs[key]) !== null && _c2 !== undefined ? _c2 : descFromAlias) !== null && _d !== undefined ? _d : "";
      keyWithDesc = `${key.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
    }
    const startsByTwoDashes = (s) => /^--/.test(s);
    const isShortOption = (s) => /^[^0-9]$/.test(s);
    const dashes = !startsByTwoDashes(current) && isShortOption(key) ? "-" : "--";
    completions.push(dashes + keyWithDesc);
    if (negable) {
      completions.push(dashes + "no-" + keyWithDesc);
    }
  }
  customCompletion(args, argv, current, done) {
    assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
    if (isSyncCompletionFunction(this.customCompletionFunction)) {
      const result = this.customCompletionFunction(current, argv);
      if (isPromise(result)) {
        return result.then((list) => {
          this.shim.process.nextTick(() => {
            done(null, list);
          });
        }).catch((err) => {
          this.shim.process.nextTick(() => {
            done(err, undefined);
          });
        });
      }
      return done(null, result);
    } else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
      return this.customCompletionFunction(current, argv, (onCompleted = done) => this.defaultCompletion(args, argv, current, onCompleted), (completions) => {
        done(null, completions);
      });
    } else {
      return this.customCompletionFunction(current, argv, (completions) => {
        done(null, completions);
      });
    }
  }
  getCompletion(args, done) {
    const current = args.length ? args[args.length - 1] : "";
    const argv = this.yargs.parse(args, true);
    const completionFunction = this.customCompletionFunction ? (argv2) => this.customCompletion(args, argv2, current, done) : (argv2) => this.defaultCompletion(args, argv2, current, done);
    return isPromise(argv) ? argv.then(completionFunction) : completionFunction(argv);
  }
  generateCompletionScript($0, cmd) {
    let script = this.zshShell ? completionZshTemplate : completionShTemplate;
    const name = this.shim.path.basename($0);
    if ($0.match(/\.js$/))
      $0 = `./${$0}`;
    script = script.replace(/{{app_name}}/g, name);
    script = script.replace(/{{completion_command}}/g, cmd);
    return script.replace(/{{app_path}}/g, $0);
  }
  registerFunction(fn) {
    this.customCompletionFunction = fn;
  }
  setParsed(parsed) {
    this.aliases = parsed.aliases;
  }
}

// node_modules/yargs/build/lib/utils/levenshtein.js
function levenshtein(a, b) {
  if (a.length === 0)
    return b.length;
  if (b.length === 0)
    return a.length;
  const matrix = [];
  let i;
  for (i = 0;i <= b.length; i++) {
    matrix[i] = [i];
  }
  let j;
  for (j = 0;j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (i = 1;i <= b.length; i++) {
    for (j = 1;j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        if (i > 1 && j > 1 && b.charAt(i - 2) === a.charAt(j - 1) && b.charAt(i - 1) === a.charAt(j - 2)) {
          matrix[i][j] = matrix[i - 2][j - 2] + 1;
        } else {
          matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
        }
      }
    }
  }
  return matrix[b.length][a.length];
}

// node_modules/yargs/build/lib/validation.js
function validation(yargs, usage2, shim2) {
  const __ = shim2.y18n.__;
  const __n = shim2.y18n.__n;
  const self2 = {};
  self2.nonOptionCount = function nonOptionCount(argv) {
    const demandedCommands = yargs.getDemandedCommands();
    const positionalCount = argv._.length + (argv["--"] ? argv["--"].length : 0);
    const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== undefined) {
          usage2.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
        } else {
          usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s.toString(), demandedCommands._.min.toString()));
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== undefined) {
          usage2.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
        } else {
          usage2.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s.toString(), demandedCommands._.max.toString()));
        }
      }
    }
  };
  self2.positionalCount = function positionalCount(required, observed) {
    if (observed < required) {
      usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed + "", required + ""));
    }
  };
  self2.requiredArguments = function requiredArguments(argv, demandedOptions) {
    let missing = null;
    for (const key of Object.keys(demandedOptions)) {
      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === "undefined") {
        missing = missing || {};
        missing[key] = demandedOptions[key];
      }
    }
    if (missing) {
      const customMsgs = [];
      for (const key of Object.keys(missing)) {
        const msg = missing[key];
        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg);
        }
      }
      const customMsg = customMsgs.length ? `\n${customMsgs.join("\n")}` : "";
      usage2.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
    }
  };
  self2.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
    var _a2;
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    Object.keys(argv).forEach((key) => {
      if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self2.isValidAndSomeAliasIsNotNew(key, aliases)) {
        unknown.push(key);
      }
    });
    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (checkPositionals) {
      const demandedCommands = yargs.getDemandedCommands();
      const maxNonOptDemanded = ((_a2 = demandedCommands._) === null || _a2 === undefined ? undefined : _a2.max) || 0;
      const expected = currentContext.commands.length + maxNonOptDemanded;
      if (expected < argv._.length) {
        argv._.slice(expected).forEach((key) => {
          key = String(key);
          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
            unknown.push(key);
          }
        });
      }
    }
    if (unknown.length) {
      usage2.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.map((s) => s.trim() ? s : `"${s}"`).join(", ")));
    }
  };
  self2.unknownCommands = function unknownCommands(argv) {
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    if (currentContext.commands.length > 0 || commandKeys.length > 0) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (unknown.length > 0) {
      usage2.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
      return true;
    } else {
      return false;
    }
  };
  self2.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
      return false;
    }
    const newAliases = yargs.parsed.newAliases;
    return [key, ...aliases[key]].some((a) => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
  };
  self2.limitedChoices = function limitedChoices(argv) {
    const options = yargs.getOptions();
    const invalid = {};
    if (!Object.keys(options.choices).length)
      return;
    Object.keys(argv).forEach((key) => {
      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
        [].concat(argv[key]).forEach((value) => {
          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {
            invalid[key] = (invalid[key] || []).concat(value);
          }
        });
      }
    });
    const invalidKeys = Object.keys(invalid);
    if (!invalidKeys.length)
      return;
    let msg = __("Invalid values:");
    invalidKeys.forEach((key) => {
      msg += `\n  ${__("Argument: %s, Given: %s, Choices: %s", key, usage2.stringifiedValues(invalid[key]), usage2.stringifiedValues(options.choices[key]))}`;
    });
    usage2.fail(msg);
  };
  let implied = {};
  self2.implies = function implies(key, value) {
    argsert("<string|object> [array|number|string]", [key, value], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        self2.implies(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!implied[key]) {
        implied[key] = [];
      }
      if (Array.isArray(value)) {
        value.forEach((i) => self2.implies(key, i));
      } else {
        assertNotStrictEqual(value, undefined, shim2);
        implied[key].push(value);
      }
    }
  };
  self2.getImplied = function getImplied() {
    return implied;
  };
  function keyExists(argv, val) {
    const num = Number(val);
    val = isNaN(num) ? val : num;
    if (typeof val === "number") {
      val = argv._.length >= val;
    } else if (val.match(/^--no-.+/)) {
      val = val.match(/^--no-(.+)/)[1];
      val = !Object.prototype.hasOwnProperty.call(argv, val);
    } else {
      val = Object.prototype.hasOwnProperty.call(argv, val);
    }
    return val;
  }
  self2.implications = function implications(argv) {
    const implyFail = [];
    Object.keys(implied).forEach((key) => {
      const origKey = key;
      (implied[key] || []).forEach((value) => {
        let key2 = origKey;
        const origValue = value;
        key2 = keyExists(argv, key2);
        value = keyExists(argv, value);
        if (key2 && !value) {
          implyFail.push(` ${origKey} -> ${origValue}`);
        }
      });
    });
    if (implyFail.length) {
      let msg = `${__("Implications failed:")}\n`;
      implyFail.forEach((value) => {
        msg += value;
      });
      usage2.fail(msg);
    }
  };
  let conflicting = {};
  self2.conflicts = function conflicts(key, value) {
    argsert("<string|object> [array|string]", [key, value], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        self2.conflicts(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!conflicting[key]) {
        conflicting[key] = [];
      }
      if (Array.isArray(value)) {
        value.forEach((i) => self2.conflicts(key, i));
      } else {
        conflicting[key].push(value);
      }
    }
  };
  self2.getConflicting = () => conflicting;
  self2.conflicting = function conflictingFn(argv) {
    Object.keys(argv).forEach((key) => {
      if (conflicting[key]) {
        conflicting[key].forEach((value) => {
          if (value && argv[key] !== undefined && argv[value] !== undefined) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value));
          }
        });
      }
    });
    if (yargs.getInternalMethods().getParserConfiguration()["strip-dashed"]) {
      Object.keys(conflicting).forEach((key) => {
        conflicting[key].forEach((value) => {
          if (value && argv[shim2.Parser.camelCase(key)] !== undefined && argv[shim2.Parser.camelCase(value)] !== undefined) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value));
          }
        });
      });
    }
  };
  self2.recommendCommands = function recommendCommands(cmd, potentialCommands) {
    const threshold = 3;
    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
    let recommended = null;
    let bestDistance = Infinity;
    for (let i = 0, candidate;(candidate = potentialCommands[i]) !== undefined; i++) {
      const d = levenshtein(cmd, candidate);
      if (d <= threshold && d < bestDistance) {
        bestDistance = d;
        recommended = candidate;
      }
    }
    if (recommended)
      usage2.fail(__("Did you mean %s?", recommended));
  };
  self2.reset = function reset(localLookup) {
    implied = objFilter(implied, (k) => !localLookup[k]);
    conflicting = objFilter(conflicting, (k) => !localLookup[k]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      implied,
      conflicting
    });
  };
  self2.unfreeze = function unfreeze() {
    const frozen = frozens.pop();
    assertNotStrictEqual(frozen, undefined, shim2);
    ({ implied, conflicting } = frozen);
  };
  return self2;
}
var specialKeys = ["$0", "--", "_"];

// node_modules/yargs/build/lib/utils/apply-extends.js
function applyExtends(config, cwd, mergeExtends, _shim) {
  shim2 = _shim;
  let defaultConfig = {};
  if (Object.prototype.hasOwnProperty.call(config, "extends")) {
    if (typeof config.extends !== "string")
      return defaultConfig;
    const isPath = /\.json|\..*rc$/.test(config.extends);
    let pathToDefault = null;
    if (!isPath) {
      try {
        pathToDefault = require.resolve(config.extends);
      } catch (_err) {
        return config;
      }
    } else {
      pathToDefault = getPathToDefaultConfig(cwd, config.extends);
    }
    checkForCircularExtends(pathToDefault);
    previouslyVisitedConfigs.push(pathToDefault);
    defaultConfig = isPath ? JSON.parse(shim2.readFileSync(pathToDefault, "utf8")) : import.meta.require(config.extends);
    delete config.extends;
    defaultConfig = applyExtends(defaultConfig, shim2.path.dirname(pathToDefault), mergeExtends, shim2);
  }
  previouslyVisitedConfigs = [];
  return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
}
var checkForCircularExtends = function(cfgPath) {
  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
    throw new YError(`Circular extended configurations: '${cfgPath}'.`);
  }
};
var getPathToDefaultConfig = function(cwd, pathToExtend) {
  return shim2.path.resolve(cwd, pathToExtend);
};
var mergeDeep = function(config1, config2) {
  const target = {};
  function isObject(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
  }
  Object.assign(target, config1);
  for (const key of Object.keys(config2)) {
    if (isObject(config2[key]) && isObject(target[key])) {
      target[key] = mergeDeep(config1[key], config2[key]);
    } else {
      target[key] = config2[key];
    }
  }
  return target;
};
var previouslyVisitedConfigs = [];
var shim2;

// node_modules/yargs/build/lib/yargs-factory.js
function YargsFactory(_shim) {
  return (processArgs = [], cwd = _shim.process.cwd(), parentRequire) => {
    const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
    Object.defineProperty(yargs, "argv", {
      get: () => {
        return yargs.parse();
      },
      enumerable: true
    });
    yargs.help();
    yargs.version();
    return yargs;
  };
}
function isYargsInstance(y) {
  return !!y && typeof y.getInternalMethods === "function";
}
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _YargsInstance_command;
var _YargsInstance_cwd;
var _YargsInstance_context;
var _YargsInstance_completion;
var _YargsInstance_completionCommand;
var _YargsInstance_defaultShowHiddenOpt;
var _YargsInstance_exitError;
var _YargsInstance_detectLocale;
var _YargsInstance_emittedWarnings;
var _YargsInstance_exitProcess;
var _YargsInstance_frozens;
var _YargsInstance_globalMiddleware;
var _YargsInstance_groups;
var _YargsInstance_hasOutput;
var _YargsInstance_helpOpt;
var _YargsInstance_isGlobalContext;
var _YargsInstance_logger;
var _YargsInstance_output;
var _YargsInstance_options;
var _YargsInstance_parentRequire;
var _YargsInstance_parserConfig;
var _YargsInstance_parseFn;
var _YargsInstance_parseContext;
var _YargsInstance_pkgs;
var _YargsInstance_preservedGroups;
var _YargsInstance_processArgs;
var _YargsInstance_recommendCommands;
var _YargsInstance_shim;
var _YargsInstance_strict;
var _YargsInstance_strictCommands;
var _YargsInstance_strictOptions;
var _YargsInstance_usage;
var _YargsInstance_usageConfig;
var _YargsInstance_versionOpt;
var _YargsInstance_validation;
var kCopyDoubleDash = Symbol("copyDoubleDash");
var kCreateLogger = Symbol("copyDoubleDash");
var kDeleteFromParserHintObject = Symbol("deleteFromParserHintObject");
var kEmitWarning = Symbol("emitWarning");
var kFreeze = Symbol("freeze");
var kGetDollarZero = Symbol("getDollarZero");
var kGetParserConfiguration = Symbol("getParserConfiguration");
var kGetUsageConfiguration = Symbol("getUsageConfiguration");
var kGuessLocale = Symbol("guessLocale");
var kGuessVersion = Symbol("guessVersion");
var kParsePositionalNumbers = Symbol("parsePositionalNumbers");
var kPkgUp = Symbol("pkgUp");
var kPopulateParserHintArray = Symbol("populateParserHintArray");
var kPopulateParserHintSingleValueDictionary = Symbol("populateParserHintSingleValueDictionary");
var kPopulateParserHintArrayDictionary = Symbol("populateParserHintArrayDictionary");
var kPopulateParserHintDictionary = Symbol("populateParserHintDictionary");
var kSanitizeKey = Symbol("sanitizeKey");
var kSetKey = Symbol("setKey");
var kUnfreeze = Symbol("unfreeze");
var kValidateAsync = Symbol("validateAsync");
var kGetCommandInstance = Symbol("getCommandInstance");
var kGetContext = Symbol("getContext");
var kGetHasOutput = Symbol("getHasOutput");
var kGetLoggerInstance = Symbol("getLoggerInstance");
var kGetParseContext = Symbol("getParseContext");
var kGetUsageInstance = Symbol("getUsageInstance");
var kGetValidationInstance = Symbol("getValidationInstance");
var kHasParseCallback = Symbol("hasParseCallback");
var kIsGlobalContext = Symbol("isGlobalContext");
var kPostProcess = Symbol("postProcess");
var kRebase = Symbol("rebase");
var kReset = Symbol("reset");
var kRunYargsParserAndExecuteCommands = Symbol("runYargsParserAndExecuteCommands");
var kRunValidation = Symbol("runValidation");
var kSetHasOutput = Symbol("setHasOutput");
var kTrackManuallySetKeys = Symbol("kTrackManuallySetKeys");

class YargsInstance {
  constructor(processArgs = [], cwd, parentRequire, shim3) {
    this.customScriptName = false;
    this.parsed = false;
    _YargsInstance_command.set(this, undefined);
    _YargsInstance_cwd.set(this, undefined);
    _YargsInstance_context.set(this, { commands: [], fullCommands: [] });
    _YargsInstance_completion.set(this, null);
    _YargsInstance_completionCommand.set(this, null);
    _YargsInstance_defaultShowHiddenOpt.set(this, "show-hidden");
    _YargsInstance_exitError.set(this, null);
    _YargsInstance_detectLocale.set(this, true);
    _YargsInstance_emittedWarnings.set(this, {});
    _YargsInstance_exitProcess.set(this, true);
    _YargsInstance_frozens.set(this, []);
    _YargsInstance_globalMiddleware.set(this, undefined);
    _YargsInstance_groups.set(this, {});
    _YargsInstance_hasOutput.set(this, false);
    _YargsInstance_helpOpt.set(this, null);
    _YargsInstance_isGlobalContext.set(this, true);
    _YargsInstance_logger.set(this, undefined);
    _YargsInstance_output.set(this, "");
    _YargsInstance_options.set(this, undefined);
    _YargsInstance_parentRequire.set(this, undefined);
    _YargsInstance_parserConfig.set(this, {});
    _YargsInstance_parseFn.set(this, null);
    _YargsInstance_parseContext.set(this, null);
    _YargsInstance_pkgs.set(this, {});
    _YargsInstance_preservedGroups.set(this, {});
    _YargsInstance_processArgs.set(this, undefined);
    _YargsInstance_recommendCommands.set(this, false);
    _YargsInstance_shim.set(this, undefined);
    _YargsInstance_strict.set(this, false);
    _YargsInstance_strictCommands.set(this, false);
    _YargsInstance_strictOptions.set(this, false);
    _YargsInstance_usage.set(this, undefined);
    _YargsInstance_usageConfig.set(this, {});
    _YargsInstance_versionOpt.set(this, null);
    _YargsInstance_validation.set(this, undefined);
    __classPrivateFieldSet(this, _YargsInstance_shim, shim3, "f");
    __classPrivateFieldSet(this, _YargsInstance_processArgs, processArgs, "f");
    __classPrivateFieldSet(this, _YargsInstance_cwd, cwd, "f");
    __classPrivateFieldSet(this, _YargsInstance_parentRequire, parentRequire, "f");
    __classPrivateFieldSet(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
    this.$0 = this[kGetDollarZero]();
    this[kReset]();
    __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f"), "f");
    __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f"), "f");
    __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
    __classPrivateFieldSet(this, _YargsInstance_logger, this[kCreateLogger](), "f");
  }
  addHelpOpt(opt, msg) {
    const defaultHelpOpt = "help";
    argsert("[string|boolean] [string]", [opt, msg], arguments.length);
    if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
      __classPrivateFieldSet(this, _YargsInstance_helpOpt, null, "f");
    }
    if (opt === false && msg === undefined)
      return this;
    __classPrivateFieldSet(this, _YargsInstance_helpOpt, typeof opt === "string" ? opt : defaultHelpOpt, "f");
    this.boolean(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
    this.describe(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show help"));
    return this;
  }
  help(opt, msg) {
    return this.addHelpOpt(opt, msg);
  }
  addShowHiddenOpt(opt, msg) {
    argsert("[string|boolean] [string]", [opt, msg], arguments.length);
    if (opt === false && msg === undefined)
      return this;
    const showHiddenOpt = typeof opt === "string" ? opt : __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
    this.boolean(showHiddenOpt);
    this.describe(showHiddenOpt, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show hidden options"));
    __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
    return this;
  }
  showHidden(opt, msg) {
    return this.addShowHiddenOpt(opt, msg);
  }
  alias(key, value) {
    argsert("<object|string|array> [string|array]", [key, value], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.alias.bind(this), "alias", key, value);
    return this;
  }
  array(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("array", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  boolean(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("boolean", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  check(f, global2) {
    argsert("<function> [boolean]", [f, global2], arguments.length);
    this.middleware((argv, _yargs) => {
      return maybeAsyncResult(() => {
        return f(argv, _yargs.getOptions());
      }, (result) => {
        if (!result) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__("Argument check failed: %s", f.toString()));
        } else if (typeof result === "string" || result instanceof Error) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(result.toString(), result);
        }
        return argv;
      }, (err) => {
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
        return argv;
      });
    }, false, global2);
    return this;
  }
  choices(key, value) {
    argsert("<object|string|array> [string|array]", [key, value], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.choices.bind(this), "choices", key, value);
    return this;
  }
  coerce(keys, value) {
    argsert("<object|string|array> [function]", [keys, value], arguments.length);
    if (Array.isArray(keys)) {
      if (!value) {
        throw new YError("coerce callback must be provided");
      }
      for (const key of keys) {
        this.coerce(key, value);
      }
      return this;
    } else if (typeof keys === "object") {
      for (const key of Object.keys(keys)) {
        this.coerce(key, keys[key]);
      }
      return this;
    }
    if (!value) {
      throw new YError("coerce callback must be provided");
    }
    __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv, yargs) => {
      let aliases;
      const shouldCoerce = Object.prototype.hasOwnProperty.call(argv, keys);
      if (!shouldCoerce) {
        return argv;
      }
      return maybeAsyncResult(() => {
        aliases = yargs.getAliases();
        return value(argv[keys]);
      }, (result) => {
        argv[keys] = result;
        const stripAliased = yargs.getInternalMethods().getParserConfiguration()["strip-aliased"];
        if (aliases[keys] && stripAliased !== true) {
          for (const alias of aliases[keys]) {
            argv[alias] = result;
          }
        }
        return argv;
      }, (err) => {
        throw new YError(err.message);
      });
    }, keys);
    return this;
  }
  conflicts(key1, key2) {
    argsert("<string|object> [string|array]", [key1, key2], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicts(key1, key2);
    return this;
  }
  config(key = "config", msg, parseFn) {
    argsert("[object|string] [string|function] [function]", [key, msg, parseFn], arguments.length);
    if (typeof key === "object" && !Array.isArray(key)) {
      key = applyExtends(key, __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(key);
      return this;
    }
    if (typeof msg === "function") {
      parseFn = msg;
      msg = undefined;
    }
    this.describe(key, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Path to JSON config file"));
    (Array.isArray(key) ? key : [key]).forEach((k) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").config[k] = parseFn || true;
    });
    return this;
  }
  completion(cmd, desc, fn) {
    argsert("[string] [string|boolean|function] [function]", [cmd, desc, fn], arguments.length);
    if (typeof desc === "function") {
      fn = desc;
      desc = undefined;
    }
    __classPrivateFieldSet(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion", "f");
    if (!desc && desc !== false) {
      desc = "generate completion script";
    }
    this.command(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"), desc);
    if (fn)
      __classPrivateFieldGet(this, _YargsInstance_completion, "f").registerFunction(fn);
    return this;
  }
  command(cmd, description, builder, handler, middlewares, deprecated) {
    argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
    return this;
  }
  commands(cmd, description, builder, handler, middlewares, deprecated) {
    return this.command(cmd, description, builder, handler, middlewares, deprecated);
  }
  commandDir(dir, opts) {
    argsert("<string> [object]", [dir, opts], arguments.length);
    const req = __classPrivateFieldGet(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").require;
    __classPrivateFieldGet(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet(this, _YargsInstance_shim, "f").getCallerFile(), opts);
    return this;
  }
  count(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("count", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  default(key, value, defaultDescription) {
    argsert("<object|string|array> [*] [string]", [key, value, defaultDescription], arguments.length);
    if (defaultDescription) {
      assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
    }
    if (typeof value === "function") {
      assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key])
        __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = __classPrivateFieldGet(this, _YargsInstance_usage, "f").functionDescription(value);
      value = value.call();
    }
    this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), "default", key, value);
    return this;
  }
  defaults(key, value, defaultDescription) {
    return this.default(key, value, defaultDescription);
  }
  demandCommand(min = 1, max, minMsg, maxMsg) {
    argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [min, max, minMsg, maxMsg], arguments.length);
    if (typeof max !== "number") {
      minMsg = max;
      max = Infinity;
    }
    this.global("_", false);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands._ = {
      min,
      max,
      minMsg,
      maxMsg
    };
    return this;
  }
  demand(keys, max, msg) {
    if (Array.isArray(max)) {
      max.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        this.demandOption(key, msg);
      });
      max = Infinity;
    } else if (typeof max !== "number") {
      msg = max;
      max = Infinity;
    }
    if (typeof keys === "number") {
      assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      this.demandCommand(keys, max, msg, msg);
    } else if (Array.isArray(keys)) {
      keys.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        this.demandOption(key, msg);
      });
    } else {
      if (typeof msg === "string") {
        this.demandOption(keys, msg);
      } else if (msg === true || typeof msg === "undefined") {
        this.demandOption(keys);
      }
    }
    return this;
  }
  demandOption(keys, msg) {
    argsert("<object|string|array> [string]", [keys, msg], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), "demandedOptions", keys, msg);
    return this;
  }
  deprecateOption(option, message) {
    argsert("<string> [string|boolean]", [option, message], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
    return this;
  }
  describe(keys, description) {
    argsert("<object|string|array> [string]", [keys, description], arguments.length);
    this[kSetKey](keys, true);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").describe(keys, description);
    return this;
  }
  detectLocale(detect) {
    argsert("<boolean>", [detect], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, detect, "f");
    return this;
  }
  env(prefix) {
    argsert("[string|boolean]", [prefix], arguments.length);
    if (prefix === false)
      delete __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
    else
      __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix = prefix || "";
    return this;
  }
  epilogue(msg) {
    argsert("<string>", [msg], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").epilog(msg);
    return this;
  }
  epilog(msg) {
    return this.epilogue(msg);
  }
  example(cmd, description) {
    argsert("<string|array> [string]", [cmd, description], arguments.length);
    if (Array.isArray(cmd)) {
      cmd.forEach((exampleParams) => this.example(...exampleParams));
    } else {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").example(cmd, description);
    }
    return this;
  }
  exit(code, err) {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    __classPrivateFieldSet(this, _YargsInstance_exitError, err, "f");
    if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
      __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.exit(code);
  }
  exitProcess(enabled = true) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_exitProcess, enabled, "f");
    return this;
  }
  fail(f) {
    argsert("<function|boolean>", [f], arguments.length);
    if (typeof f === "boolean" && f !== false) {
      throw new YError("Invalid first argument. Expected function or boolean 'false'");
    }
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").failFn(f);
    return this;
  }
  getAliases() {
    return this.parsed ? this.parsed.aliases : {};
  }
  async getCompletion(args, done) {
    argsert("<array> [function]", [args, done], arguments.length);
    if (!done) {
      return new Promise((resolve5, reject) => {
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions) => {
          if (err)
            reject(err);
          else
            resolve5(completions);
        });
      });
    } else {
      return __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, done);
    }
  }
  getDemandedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedOptions;
  }
  getDemandedCommands() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands;
  }
  getDeprecatedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions;
  }
  getDetectLocale() {
    return __classPrivateFieldGet(this, _YargsInstance_detectLocale, "f");
  }
  getExitProcess() {
    return __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f");
  }
  getGroups() {
    return Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_groups, "f"), __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"));
  }
  getHelp() {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
        if (isPromise(parse)) {
          return parse.then(() => {
            return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
          });
        }
      }
      const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        return builderResponse.then(() => {
          return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
        });
      }
    }
    return Promise.resolve(__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
  }
  getOptions() {
    return __classPrivateFieldGet(this, _YargsInstance_options, "f");
  }
  getStrict() {
    return __classPrivateFieldGet(this, _YargsInstance_strict, "f");
  }
  getStrictCommands() {
    return __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f");
  }
  getStrictOptions() {
    return __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f");
  }
  global(globals, global2) {
    argsert("<string|array> [boolean]", [globals, global2], arguments.length);
    globals = [].concat(globals);
    if (global2 !== false) {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local.filter((l) => globals.indexOf(l) === -1);
    } else {
      globals.forEach((g) => {
        if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").local.includes(g))
          __classPrivateFieldGet(this, _YargsInstance_options, "f").local.push(g);
      });
    }
    return this;
  }
  group(opts, groupName) {
    argsert("<string|array> <string>", [opts, groupName], arguments.length);
    const existing = __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName];
    if (__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName]) {
      delete __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName];
    }
    const seen = {};
    __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter((key) => {
      if (seen[key])
        return false;
      return seen[key] = true;
    });
    return this;
  }
  hide(key) {
    argsert("<string>", [key], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_options, "f").hiddenOptions.push(key);
    return this;
  }
  implies(key, value) {
    argsert("<string|object> [number|string|array]", [key, value], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").implies(key, value);
    return this;
  }
  locale(locale) {
    argsert("[string]", [locale], arguments.length);
    if (locale === undefined) {
      this[kGuessLocale]();
      return __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.getLocale();
    }
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
    __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
    return this;
  }
  middleware(callback, applyBeforeValidation, global2) {
    return __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global2);
  }
  nargs(key, value) {
    argsert("<string|object|array> [number]", [key, value], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), "narg", key, value);
    return this;
  }
  normalize(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("normalize", keys);
    return this;
  }
  number(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("number", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  option(key, opt) {
    argsert("<string|object> [object]", [key, opt], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        this.options(k, key[k]);
      });
    } else {
      if (typeof opt !== "object") {
        opt = {};
      }
      this[kTrackManuallySetKeys](key);
      if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && (key === "version" || (opt === null || opt === undefined ? undefined : opt.alias) === "version")) {
        this[kEmitWarning]([
          '"version" is a reserved word.',
          "Please do one of the following:",
          '- Disable version with `yargs.version(false)` if using "version" as an option',
          "- Use the built-in `yargs.version` method instead (if applicable)",
          "- Use a different option key",
          "https://yargs.js.org/docs/#api-reference-version"
        ].join("\n"), undefined, "versionWarning");
      }
      __classPrivateFieldGet(this, _YargsInstance_options, "f").key[key] = true;
      if (opt.alias)
        this.alias(key, opt.alias);
      const deprecate = opt.deprecate || opt.deprecated;
      if (deprecate) {
        this.deprecateOption(key, deprecate);
      }
      const demand = opt.demand || opt.required || opt.require;
      if (demand) {
        this.demand(key, demand);
      }
      if (opt.demandOption) {
        this.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : undefined);
      }
      if (opt.conflicts) {
        this.conflicts(key, opt.conflicts);
      }
      if ("default" in opt) {
        this.default(key, opt.default);
      }
      if (opt.implies !== undefined) {
        this.implies(key, opt.implies);
      }
      if (opt.nargs !== undefined) {
        this.nargs(key, opt.nargs);
      }
      if (opt.config) {
        this.config(key, opt.configParser);
      }
      if (opt.normalize) {
        this.normalize(key);
      }
      if (opt.choices) {
        this.choices(key, opt.choices);
      }
      if (opt.coerce) {
        this.coerce(key, opt.coerce);
      }
      if (opt.group) {
        this.group(key, opt.group);
      }
      if (opt.boolean || opt.type === "boolean") {
        this.boolean(key);
        if (opt.alias)
          this.boolean(opt.alias);
      }
      if (opt.array || opt.type === "array") {
        this.array(key);
        if (opt.alias)
          this.array(opt.alias);
      }
      if (opt.number || opt.type === "number") {
        this.number(key);
        if (opt.alias)
          this.number(opt.alias);
      }
      if (opt.string || opt.type === "string") {
        this.string(key);
        if (opt.alias)
          this.string(opt.alias);
      }
      if (opt.count || opt.type === "count") {
        this.count(key);
      }
      if (typeof opt.global === "boolean") {
        this.global(key, opt.global);
      }
      if (opt.defaultDescription) {
        __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
      }
      if (opt.skipValidation) {
        this.skipValidation(key);
      }
      const desc = opt.describe || opt.description || opt.desc;
      const descriptions = __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions();
      if (!Object.prototype.hasOwnProperty.call(descriptions, key) || typeof desc === "string") {
        this.describe(key, desc);
      }
      if (opt.hidden) {
        this.hide(key);
      }
      if (opt.requiresArg) {
        this.requiresArg(key);
      }
    }
    return this;
  }
  options(key, opt) {
    return this.option(key, opt);
  }
  parse(args, shortCircuit, _parseFn) {
    argsert("[string|array] [function|boolean|object] [function]", [args, shortCircuit, _parseFn], arguments.length);
    this[kFreeze]();
    if (typeof args === "undefined") {
      args = __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
    }
    if (typeof shortCircuit === "object") {
      __classPrivateFieldSet(this, _YargsInstance_parseContext, shortCircuit, "f");
      shortCircuit = _parseFn;
    }
    if (typeof shortCircuit === "function") {
      __classPrivateFieldSet(this, _YargsInstance_parseFn, shortCircuit, "f");
      shortCircuit = false;
    }
    if (!shortCircuit)
      __classPrivateFieldSet(this, _YargsInstance_processArgs, args, "f");
    if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
      __classPrivateFieldSet(this, _YargsInstance_exitProcess, false, "f");
    const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
    const tmpParsed = this.parsed;
    __classPrivateFieldGet(this, _YargsInstance_completion, "f").setParsed(this.parsed);
    if (isPromise(parsed)) {
      return parsed.then((argv) => {
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
          __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
        return argv;
      }).catch((err) => {
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) {
          __classPrivateFieldGet(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
        }
        throw err;
      }).finally(() => {
        this[kUnfreeze]();
        this.parsed = tmpParsed;
      });
    } else {
      if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f"))
        __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
      this[kUnfreeze]();
      this.parsed = tmpParsed;
    }
    return parsed;
  }
  parseAsync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    return !isPromise(maybePromise) ? Promise.resolve(maybePromise) : maybePromise;
  }
  parseSync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    if (isPromise(maybePromise)) {
      throw new YError(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
    }
    return maybePromise;
  }
  parserConfiguration(config) {
    argsert("<object>", [config], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_parserConfig, config, "f");
    return this;
  }
  pkgConf(key, rootPath) {
    argsert("<string> [string]", [key, rootPath], arguments.length);
    let conf = null;
    const obj = this[kPkgUp](rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"));
    if (obj[key] && typeof obj[key] === "object") {
      conf = applyExtends(obj[key], rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
    }
    return this;
  }
  positional(key, opts) {
    argsert("<string> <object>", [key, opts], arguments.length);
    const supportedOpts = [
      "default",
      "defaultDescription",
      "implies",
      "normalize",
      "choices",
      "conflicts",
      "coerce",
      "type",
      "describe",
      "desc",
      "description",
      "alias"
    ];
    opts = objFilter(opts, (k, v) => {
      if (k === "type" && !["string", "number", "boolean"].includes(v))
        return false;
      return supportedOpts.includes(k);
    });
    const fullCommand = __classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands.length - 1];
    const parseOptions = fullCommand ? __classPrivateFieldGet(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand) : {
      array: [],
      alias: {},
      default: {},
      demand: {}
    };
    objectKeys(parseOptions).forEach((pk) => {
      const parseOption = parseOptions[pk];
      if (Array.isArray(parseOption)) {
        if (parseOption.indexOf(key) !== -1)
          opts[pk] = true;
      } else {
        if (parseOption[key] && !(pk in opts))
          opts[pk] = parseOption[key];
      }
    });
    this.group(key, __classPrivateFieldGet(this, _YargsInstance_usage, "f").getPositionalGroupName());
    return this.option(key, opts);
  }
  recommendCommands(recommend = true) {
    argsert("[boolean]", [recommend], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_recommendCommands, recommend, "f");
    return this;
  }
  required(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  require(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  requiresArg(keys) {
    argsert("<array|string|object> [number]", [keys], arguments.length);
    if (typeof keys === "string" && __classPrivateFieldGet(this, _YargsInstance_options, "f").narg[keys]) {
      return this;
    } else {
      this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), "narg", keys, NaN);
    }
    return this;
  }
  showCompletionScript($0, cmd) {
    argsert("[string] [string]", [$0, cmd], arguments.length);
    $0 = $0 || this.$0;
    __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion"));
    return this;
  }
  showHelp(level) {
    argsert("[string|function]", [level], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
        if (isPromise(parse)) {
          parse.then(() => {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
          });
          return this;
        }
      }
      const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        builderResponse.then(() => {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
        });
        return this;
      }
    }
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
    return this;
  }
  scriptName(scriptName) {
    this.customScriptName = true;
    this.$0 = scriptName;
    return this;
  }
  showHelpOnFail(enabled, message) {
    argsert("[boolean|string] [string]", [enabled, message], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
    return this;
  }
  showVersion(level) {
    argsert("[string|function]", [level], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion(level);
    return this;
  }
  skipValidation(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("skipValidation", keys);
    return this;
  }
  strict(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strict, enabled !== false, "f");
    return this;
  }
  strictCommands(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strictCommands, enabled !== false, "f");
    return this;
  }
  strictOptions(enabled) {
    argsert("[boolean]", [enabled], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_strictOptions, enabled !== false, "f");
    return this;
  }
  string(keys) {
    argsert("<array|string>", [keys], arguments.length);
    this[kPopulateParserHintArray]("string", keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  terminalWidth() {
    argsert([], 0);
    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.stdColumns;
  }
  updateLocale(obj) {
    return this.updateStrings(obj);
  }
  updateStrings(obj) {
    argsert("<object>", [obj], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
    __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
    return this;
  }
  usage(msg, description, builder, handler) {
    argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [msg, description, builder, handler], arguments.length);
    if (description !== undefined) {
      assertNotStrictEqual(msg, null, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      if ((msg || "").match(/^\$0( |$)/)) {
        return this.command(msg, description, builder, handler);
      } else {
        throw new YError(".usage() description must start with $0 if being used as alias for .command()");
      }
    } else {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").usage(msg);
      return this;
    }
  }
  usageConfiguration(config) {
    argsert("<object>", [config], arguments.length);
    __classPrivateFieldSet(this, _YargsInstance_usageConfig, config, "f");
    return this;
  }
  version(opt, msg, ver) {
    const defaultVersionOpt = "version";
    argsert("[boolean|string] [string] [string]", [opt, msg, ver], arguments.length);
    if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f")) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(undefined);
      __classPrivateFieldSet(this, _YargsInstance_versionOpt, null, "f");
    }
    if (arguments.length === 0) {
      ver = this[kGuessVersion]();
      opt = defaultVersionOpt;
    } else if (arguments.length === 1) {
      if (opt === false) {
        return this;
      }
      ver = opt;
      opt = defaultVersionOpt;
    } else if (arguments.length === 2) {
      ver = msg;
      msg = undefined;
    }
    __classPrivateFieldSet(this, _YargsInstance_versionOpt, typeof opt === "string" ? opt : defaultVersionOpt, "f");
    msg = msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show version number");
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(ver || undefined);
    this.boolean(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
    this.describe(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"), msg);
    return this;
  }
  wrap(cols) {
    argsert("<number|null|undefined>", [cols], arguments.length);
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").wrap(cols);
    return this;
  }
  [(_YargsInstance_command = new WeakMap, _YargsInstance_cwd = new WeakMap, _YargsInstance_context = new WeakMap, _YargsInstance_completion = new WeakMap, _YargsInstance_completionCommand = new WeakMap, _YargsInstance_defaultShowHiddenOpt = new WeakMap, _YargsInstance_exitError = new WeakMap, _YargsInstance_detectLocale = new WeakMap, _YargsInstance_emittedWarnings = new WeakMap, _YargsInstance_exitProcess = new WeakMap, _YargsInstance_frozens = new WeakMap, _YargsInstance_globalMiddleware = new WeakMap, _YargsInstance_groups = new WeakMap, _YargsInstance_hasOutput = new WeakMap, _YargsInstance_helpOpt = new WeakMap, _YargsInstance_isGlobalContext = new WeakMap, _YargsInstance_logger = new WeakMap, _YargsInstance_output = new WeakMap, _YargsInstance_options = new WeakMap, _YargsInstance_parentRequire = new WeakMap, _YargsInstance_parserConfig = new WeakMap, _YargsInstance_parseFn = new WeakMap, _YargsInstance_parseContext = new WeakMap, _YargsInstance_pkgs = new WeakMap, _YargsInstance_preservedGroups = new WeakMap, _YargsInstance_processArgs = new WeakMap, _YargsInstance_recommendCommands = new WeakMap, _YargsInstance_shim = new WeakMap, _YargsInstance_strict = new WeakMap, _YargsInstance_strictCommands = new WeakMap, _YargsInstance_strictOptions = new WeakMap, _YargsInstance_usage = new WeakMap, _YargsInstance_usageConfig = new WeakMap, _YargsInstance_versionOpt = new WeakMap, _YargsInstance_validation = new WeakMap, kCopyDoubleDash)](argv) {
    if (!argv._ || !argv["--"])
      return argv;
    argv._.push.apply(argv._, argv["--"]);
    try {
      delete argv["--"];
    } catch (_err) {
    }
    return argv;
  }
  [kCreateLogger]() {
    return {
      log: (...args) => {
        if (!this[kHasParseCallback]())
          console.log(...args);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length)
          __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
      },
      error: (...args) => {
        if (!this[kHasParseCallback]())
          console.error(...args);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length)
          __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
      }
    };
  }
  [kDeleteFromParserHintObject](optionKey) {
    objectKeys(__classPrivateFieldGet(this, _YargsInstance_options, "f")).forEach((hintKey) => {
      if (((key) => key === "configObjects")(hintKey))
        return;
      const hint = __classPrivateFieldGet(this, _YargsInstance_options, "f")[hintKey];
      if (Array.isArray(hint)) {
        if (hint.includes(optionKey))
          hint.splice(hint.indexOf(optionKey), 1);
      } else if (typeof hint === "object") {
        delete hint[optionKey];
      }
    });
    delete __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
  }
  [kEmitWarning](warning, type, deduplicationId) {
    if (!__classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
      __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
      __classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
    }
  }
  [kFreeze]() {
    __classPrivateFieldGet(this, _YargsInstance_frozens, "f").push({
      options: __classPrivateFieldGet(this, _YargsInstance_options, "f"),
      configObjects: __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects.slice(0),
      exitProcess: __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"),
      groups: __classPrivateFieldGet(this, _YargsInstance_groups, "f"),
      strict: __classPrivateFieldGet(this, _YargsInstance_strict, "f"),
      strictCommands: __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f"),
      strictOptions: __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f"),
      completionCommand: __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"),
      output: __classPrivateFieldGet(this, _YargsInstance_output, "f"),
      exitError: __classPrivateFieldGet(this, _YargsInstance_exitError, "f"),
      hasOutput: __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f"),
      parsed: this.parsed,
      parseFn: __classPrivateFieldGet(this, _YargsInstance_parseFn, "f"),
      parseContext: __classPrivateFieldGet(this, _YargsInstance_parseContext, "f")
    });
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_command, "f").freeze();
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").freeze();
  }
  [kGetDollarZero]() {
    let $0 = "";
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv()[0])) {
      default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(1, 2);
    } else {
      default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
    }
    $0 = default$0.map((x) => {
      const b = this[kRebase](__classPrivateFieldGet(this, _YargsInstance_cwd, "f"), x);
      return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
    }).join(" ").trim();
    if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_") && __classPrivateFieldGet(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_")) {
      $0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_").replace(`${__classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.execPath())}/`, "");
    }
    return $0;
  }
  [kGetParserConfiguration]() {
    return __classPrivateFieldGet(this, _YargsInstance_parserConfig, "f");
  }
  [kGetUsageConfiguration]() {
    return __classPrivateFieldGet(this, _YargsInstance_usageConfig, "f");
  }
  [kGuessLocale]() {
    if (!__classPrivateFieldGet(this, _YargsInstance_detectLocale, "f"))
      return;
    const locale = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_ALL") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_MESSAGES") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANG") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANGUAGE") || "en_US";
    this.locale(locale.replace(/[.:].*/, ""));
  }
  [kGuessVersion]() {
    const obj = this[kPkgUp]();
    return obj.version || "unknown";
  }
  [kParsePositionalNumbers](argv) {
    const args = argv["--"] ? argv["--"] : argv._;
    for (let i = 0, arg;(arg = args[i]) !== undefined; i++) {
      if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
        args[i] = Number(arg);
      }
    }
    return argv;
  }
  [kPkgUp](rootPath) {
    const npath = rootPath || "*";
    if (__classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath])
      return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
    let obj = {};
    try {
      let startDir = rootPath || __classPrivateFieldGet(this, _YargsInstance_shim, "f").mainFilename;
      if (!rootPath && __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.extname(startDir)) {
        startDir = __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(startDir);
      }
      const pkgJsonPath = __classPrivateFieldGet(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names) => {
        if (names.includes("package.json")) {
          return "package.json";
        } else {
          return;
        }
      });
      assertNotStrictEqual(pkgJsonPath, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
      obj = JSON.parse(__classPrivateFieldGet(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, "utf8"));
    } catch (_noop) {
    }
    __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath] = obj || {};
    return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
  }
  [kPopulateParserHintArray](type, keys) {
    keys = [].concat(keys);
    keys.forEach((key) => {
      key = this[kSanitizeKey](key);
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type].push(key);
    });
  }
  [kPopulateParserHintSingleValueDictionary](builder, type, key, value) {
    this[kPopulateParserHintDictionary](builder, type, key, value, (type2, key2, value2) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = value2;
    });
  }
  [kPopulateParserHintArrayDictionary](builder, type, key, value) {
    this[kPopulateParserHintDictionary](builder, type, key, value, (type2, key2, value2) => {
      __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] || []).concat(value2);
    });
  }
  [kPopulateParserHintDictionary](builder, type, key, value, singleKeyHandler) {
    if (Array.isArray(key)) {
      key.forEach((k) => {
        builder(k, value);
      });
    } else if (((key2) => typeof key2 === "object")(key)) {
      for (const k of objectKeys(key)) {
        builder(k, key[k]);
      }
    } else {
      singleKeyHandler(type, this[kSanitizeKey](key), value);
    }
  }
  [kSanitizeKey](key) {
    if (key === "__proto__")
      return "___proto___";
    return key;
  }
  [kSetKey](key, set) {
    this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), "key", key, set);
    return this;
  }
  [kUnfreeze]() {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const frozen = __classPrivateFieldGet(this, _YargsInstance_frozens, "f").pop();
    assertNotStrictEqual(frozen, undefined, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
    let configObjects;
    _a2 = this, _b2 = this, _c2 = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, {
      options: { set value(_o) {
        __classPrivateFieldSet(_a2, _YargsInstance_options, _o, "f");
      } }.value,
      configObjects,
      exitProcess: { set value(_o) {
        __classPrivateFieldSet(_b2, _YargsInstance_exitProcess, _o, "f");
      } }.value,
      groups: { set value(_o) {
        __classPrivateFieldSet(_c2, _YargsInstance_groups, _o, "f");
      } }.value,
      output: { set value(_o) {
        __classPrivateFieldSet(_d, _YargsInstance_output, _o, "f");
      } }.value,
      exitError: { set value(_o) {
        __classPrivateFieldSet(_e, _YargsInstance_exitError, _o, "f");
      } }.value,
      hasOutput: { set value(_o) {
        __classPrivateFieldSet(_f, _YargsInstance_hasOutput, _o, "f");
      } }.value,
      parsed: this.parsed,
      strict: { set value(_o) {
        __classPrivateFieldSet(_g, _YargsInstance_strict, _o, "f");
      } }.value,
      strictCommands: { set value(_o) {
        __classPrivateFieldSet(_h, _YargsInstance_strictCommands, _o, "f");
      } }.value,
      strictOptions: { set value(_o) {
        __classPrivateFieldSet(_j, _YargsInstance_strictOptions, _o, "f");
      } }.value,
      completionCommand: { set value(_o) {
        __classPrivateFieldSet(_k, _YargsInstance_completionCommand, _o, "f");
      } }.value,
      parseFn: { set value(_o) {
        __classPrivateFieldSet(_l, _YargsInstance_parseFn, _o, "f");
      } }.value,
      parseContext: { set value(_o) {
        __classPrivateFieldSet(_m, _YargsInstance_parseContext, _o, "f");
      } }.value
    } = frozen;
    __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = configObjects;
    __classPrivateFieldGet(this, _YargsInstance_usage, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_validation, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_command, "f").unfreeze();
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").unfreeze();
  }
  [kValidateAsync](validation3, argv) {
    return maybeAsyncResult(argv, (result) => {
      validation3(result);
      return result;
    });
  }
  getInternalMethods() {
    return {
      getCommandInstance: this[kGetCommandInstance].bind(this),
      getContext: this[kGetContext].bind(this),
      getHasOutput: this[kGetHasOutput].bind(this),
      getLoggerInstance: this[kGetLoggerInstance].bind(this),
      getParseContext: this[kGetParseContext].bind(this),
      getParserConfiguration: this[kGetParserConfiguration].bind(this),
      getUsageConfiguration: this[kGetUsageConfiguration].bind(this),
      getUsageInstance: this[kGetUsageInstance].bind(this),
      getValidationInstance: this[kGetValidationInstance].bind(this),
      hasParseCallback: this[kHasParseCallback].bind(this),
      isGlobalContext: this[kIsGlobalContext].bind(this),
      postProcess: this[kPostProcess].bind(this),
      reset: this[kReset].bind(this),
      runValidation: this[kRunValidation].bind(this),
      runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
      setHasOutput: this[kSetHasOutput].bind(this)
    };
  }
  [kGetCommandInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_command, "f");
  }
  [kGetContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_context, "f");
  }
  [kGetHasOutput]() {
    return __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f");
  }
  [kGetLoggerInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_logger, "f");
  }
  [kGetParseContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_parseContext, "f") || {};
  }
  [kGetUsageInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_usage, "f");
  }
  [kGetValidationInstance]() {
    return __classPrivateFieldGet(this, _YargsInstance_validation, "f");
  }
  [kHasParseCallback]() {
    return !!__classPrivateFieldGet(this, _YargsInstance_parseFn, "f");
  }
  [kIsGlobalContext]() {
    return __classPrivateFieldGet(this, _YargsInstance_isGlobalContext, "f");
  }
  [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
    if (calledFromCommand)
      return argv;
    if (isPromise(argv))
      return argv;
    if (!populateDoubleDash) {
      argv = this[kCopyDoubleDash](argv);
    }
    const parsePositionalNumbers = this[kGetParserConfiguration]()["parse-positional-numbers"] || this[kGetParserConfiguration]()["parse-positional-numbers"] === undefined;
    if (parsePositionalNumbers) {
      argv = this[kParsePositionalNumbers](argv);
    }
    if (runGlobalMiddleware) {
      argv = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
    }
    return argv;
  }
  [kReset](aliases = {}) {
    __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f") || {}, "f");
    const tmpOptions = {};
    tmpOptions.local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local || [];
    tmpOptions.configObjects = __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || [];
    const localLookup = {};
    tmpOptions.local.forEach((l) => {
      localLookup[l] = true;
      (aliases[l] || []).forEach((a) => {
        localLookup[a] = true;
      });
    });
    Object.assign(__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet(this, _YargsInstance_groups, "f")).reduce((acc, groupName) => {
      const keys = __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName].filter((key) => !(key in localLookup));
      if (keys.length > 0) {
        acc[groupName] = keys;
      }
      return acc;
    }, {}));
    __classPrivateFieldSet(this, _YargsInstance_groups, {}, "f");
    const arrayOptions = [
      "array",
      "boolean",
      "string",
      "skipValidation",
      "count",
      "normalize",
      "number",
      "hiddenOptions"
    ];
    const objectOptions = [
      "narg",
      "key",
      "alias",
      "default",
      "defaultDescription",
      "config",
      "choices",
      "demandedOptions",
      "demandedCommands",
      "deprecatedOptions"
    ];
    arrayOptions.forEach((k) => {
      tmpOptions[k] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[k] || []).filter((k2) => !localLookup[k2]);
    });
    objectOptions.forEach((k) => {
      tmpOptions[k] = objFilter(__classPrivateFieldGet(this, _YargsInstance_options, "f")[k], (k2) => !localLookup[k2]);
    });
    tmpOptions.envPrefix = __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
    __classPrivateFieldSet(this, _YargsInstance_options, tmpOptions, "f");
    __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f") ? __classPrivateFieldGet(this, _YargsInstance_usage, "f").reset(localLookup) : usage(this, __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f") ? __classPrivateFieldGet(this, _YargsInstance_validation, "f").reset(localLookup) : validation(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f") ? __classPrivateFieldGet(this, _YargsInstance_command, "f").reset() : command(__classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_validation, "f"), __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    if (!__classPrivateFieldGet(this, _YargsInstance_completion, "f"))
      __classPrivateFieldSet(this, _YargsInstance_completion, completion(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_command, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
    __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").reset();
    __classPrivateFieldSet(this, _YargsInstance_completionCommand, null, "f");
    __classPrivateFieldSet(this, _YargsInstance_output, "", "f");
    __classPrivateFieldSet(this, _YargsInstance_exitError, null, "f");
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, false, "f");
    this.parsed = false;
    return this;
  }
  [kRebase](base, dir) {
    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.relative(base, dir);
  }
  [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
    let skipValidation = !!calledFromCommand || helpOnly;
    args = args || __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
    __classPrivateFieldGet(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__;
    __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
    const populateDoubleDash = !!__classPrivateFieldGet(this, _YargsInstance_options, "f").configuration["populate--"];
    const config = Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration, {
      "populate--": true
    });
    const parsed = __classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f"), {
      configuration: { "parse-positional-numbers": false, ...config }
    }));
    const argv = Object.assign(parsed.argv, __classPrivateFieldGet(this, _YargsInstance_parseContext, "f"));
    let argvPromise = undefined;
    const aliases = parsed.aliases;
    let helpOptSet = false;
    let versionOptSet = false;
    Object.keys(argv).forEach((key) => {
      if (key === __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f") && argv[key]) {
        helpOptSet = true;
      } else if (key === __classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && argv[key]) {
        versionOptSet = true;
      }
    });
    argv.$0 = this.$0;
    this.parsed = parsed;
    if (commandIndex === 0) {
      __classPrivateFieldGet(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
    }
    try {
      this[kGuessLocale]();
      if (shortCircuit) {
        return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
        const helpCmds = [__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")].concat(aliases[__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")] || []).filter((k) => k.length > 1);
        if (helpCmds.includes("" + argv._[argv._.length - 1])) {
          argv._.pop();
          helpOptSet = true;
        }
      }
      __classPrivateFieldSet(this, _YargsInstance_isGlobalContext, false, "f");
      const handlerKeys = __classPrivateFieldGet(this, _YargsInstance_command, "f").getCommands();
      const requestCompletions = __classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey in argv;
      const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
      if (argv._.length) {
        if (handlerKeys.length) {
          let firstUnknownCommand;
          for (let i = commandIndex || 0, cmd;argv._[i] !== undefined; i++) {
            cmd = String(argv._[i]);
            if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
              const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
              return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
            } else if (!firstUnknownCommand && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
              firstUnknownCommand = cmd;
              break;
            }
          }
          if (!__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && __classPrivateFieldGet(this, _YargsInstance_recommendCommands, "f") && firstUnknownCommand && !skipRecommendation) {
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
          }
        }
        if (__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") && argv._.includes(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) && !requestCompletions) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          this.showCompletionScript();
          this.exit(0);
        }
      }
      if (__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
        const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
        return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (requestCompletions) {
        if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
          setBlocking(true);
        args = [].concat(args);
        const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey}`) + 1);
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions) => {
          if (err)
            throw new YError(err.message);
          (completions || []).forEach((completion3) => {
            __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(completion3);
          });
          this.exit(0);
        });
        return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
      }
      if (!__classPrivateFieldGet(this, _YargsInstance_hasOutput, "f")) {
        if (helpOptSet) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          skipValidation = true;
          this.showHelp("log");
          this.exit(0);
        } else if (versionOptSet) {
          if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"))
            setBlocking(true);
          skipValidation = true;
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion("log");
          this.exit(0);
        }
      }
      if (!skipValidation && __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.length > 0) {
        skipValidation = Object.keys(argv).some((key) => __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && argv[key] === true);
      }
      if (!skipValidation) {
        if (parsed.error)
          throw new YError(parsed.error.message);
        if (!requestCompletions) {
          const validation3 = this[kRunValidation](aliases, {}, parsed.error);
          if (!calledFromCommand) {
            argvPromise = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
          }
          argvPromise = this[kValidateAsync](validation3, argvPromise !== null && argvPromise !== undefined ? argvPromise : argv);
          if (isPromise(argvPromise) && !calledFromCommand) {
            argvPromise = argvPromise.then(() => {
              return applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
            });
          }
        }
      }
    } catch (err) {
      if (err instanceof YError)
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message, err);
      else
        throw err;
    }
    return this[kPostProcess](argvPromise !== null && argvPromise !== undefined ? argvPromise : argv, populateDoubleDash, !!calledFromCommand, true);
  }
  [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
    const demandedOptions = { ...this.getDemandedOptions() };
    return (argv) => {
      if (parseErrors)
        throw new YError(parseErrors.message);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").nonOptionCount(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").requiredArguments(argv, demandedOptions);
      let failedStrictCommands = false;
      if (__classPrivateFieldGet(this, _YargsInstance_strictCommands, "f")) {
        failedStrictCommands = __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownCommands(argv);
      }
      if (__classPrivateFieldGet(this, _YargsInstance_strict, "f") && !failedStrictCommands) {
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, positionalMap, !!isDefaultCommand);
      } else if (__classPrivateFieldGet(this, _YargsInstance_strictOptions, "f")) {
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, {}, false, false);
      }
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").limitedChoices(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").implications(argv);
      __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicting(argv);
    };
  }
  [kSetHasOutput]() {
    __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
  }
  [kTrackManuallySetKeys](keys) {
    if (typeof keys === "string") {
      __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
    } else {
      for (const k of keys) {
        __classPrivateFieldGet(this, _YargsInstance_options, "f").key[k] = true;
      }
    }
  }
}

// node_modules/yargs/index.mjs
var Yargs = YargsFactory(esm_default);
var yargs_default = Yargs;

// run.ts
var main = function() {
  async function setupChatForWaku() {
    const Waku = (await Promise.resolve().then(() => __toESM(require_waku(), 1))).default;
    const waku = await new Waku().init();
    const ChatForWaku = (await Promise.resolve().then(() => __toESM(require_chatForWaku(), 1))).default;
    let name = "P" + argv.party;
    chat = new ChatForWaku(waku, name);
    console.log("chat set up --- waku");
  }
  setupChatForWaku();
};
var argv = yargs_default(hideBin(process.argv)).option("party", {
  alias: "p",
  description: "Party name",
  type: "string",
  default: "1",
  choices: ["1", "2"]
}).option("runKeygen", {
  alias: "k",
  description: "Run keygen",
  type: "boolean",
  default: true
}).option("runSign", {
  alias: "s",
  description: "Run sign",
  type: "boolean",
  default: false
}).option("repeatSign", {
  alias: "r",
  description: "re-start listening for sign if acting as party2 flag",
  type: "boolean",
  default: false
}).help().alias("help", "h").parseSync();
console.log("Arguments:", argv);
var chat = null;
main();
